% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig linefig xverbatim

\documentclass[11pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{11pt}


\usepackage{myconfig}
\usepackage{mytitle}


\begin{document}
\frontmatter

\titlea{The-Qt4-Book}
\author{Jasmin B., Mark S.}
\authorinfo{作者全名：Jasmin Blanchette, Mark Summerfield。本文代码来自\href{http://www.qtrac.eu/marksummerfield.html}{这个网站}。原中文翻译：闫锋欣，曾泉人，张志强；原中文审校：周莉娜，赵延兵。}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：德山书生，湖南常德人氏。我负责整理排版工作。本项目Github网站在\href{https://github.com/a358003542/The-Qt4-Book}{这里}。有意见请反馈。}
\version{0.01}
\titleLA

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
为什么会是Qt？为什么像我这样的程序员会选择Qt？这个问题的答案显而易见：Qt单一源程序的兼容性、丰富的特性、C++方面的性能、源代码的可用性、它的文档、高质量的技术支持，以及在奇趣科技公司那些精美的营销材料中所涉及的其他优势等。这些答案看起来确实都不错，但是遗漏了最为重要的一点：Qt的成功缘于程序员们对它的喜欢。

那么，是什么让程序员喜欢某种技术而放弃另外一种呢？就我而言，我认为软件工程师们喜欢某种技术，是因为他们觉得这种技术是合适的，但是这也会让他们讨厌所有那些他们觉得不合适的其他技术。除此之外，我们还能解释下面的这些情况吗？例如，一些最出众的程序员需要在帮助之下才能编写出一个录像机程序，或者又比如，似乎大多数工程师在操作本公司的电话系统时总会遇到麻烦。我虽然善于记住随机数字和指令的序列，但是如果将其比作用于控制我的应答系统所需要的条件来说，则可能一条也不具备。在奇趣科技公司，我们的电话系统要求在拨打其他人的分机号码前，一定要按住"*"键2秒后才允许开始拨号。如果忘记了这样做而是直接拨打分机号码，那么就不得不再重新拨一遍全部的号码。为什么是"*"键而不是"\#{}"键、"1"键或者"5"键？或者为什么不是20个电话键盘中的其他任何一个呢？又为什么是2秒，而不是1秒、3秒或者1.5秒呢？问题到底出在哪里？我发现电话很气人，所以我尽可能不去使用它。没有人喜欢总是去做一些不得不做的随机事情，特别是当这些随机事情显然只出现在同样随机的情况下的时候，真希望自己从来都没有听到过它。

编程很像我们正在使用的电话系统，并且要比它还糟糕。而这正是Qt所要解决的问题。Qt与众不同。一方面，Qt很有意义；另一方面，Qt颇具趣味性。Qt可以让您把精力集中在您的任务上。当Qt的首席体系结构设计师面对一个问题的时候，他们不是寻求一个好的、快速的或者最简便的解决方案，而是在寻求一个恰当的解决方案，然后将其记录在案。应当承认，他们犯下了一些错误，并且还要承认的是，他们的一些设计决策没有通过时间的检验，但是他们确实做出了很多正确的设计，并且那些错误的设计应当而且也是能够进行改正的。看一看最初设计用于构建Windows 95和UNIX Motif之间的桥梁系统，到后来演变为跨越Windows Vista、Mac OS X和
GNU/Linux以及那些诸如移动电话等小型设备在内的统一的现代桌面系统，这些事实就足以证明这一点。

早在Qt大受欢迎并且被广泛使用很久以前，正是Qt的开发人员为寻求恰当的解决方案所做出的贡献才使Qt变得与众不同。其贡献之大，至今仍然影响着每一个对Qt进行开发和维护的人。对我们而言，研发Qt是一种使命和殊荣。能够使您的职业生涯和开源生活变得更为轻松和更加有趣，这让我们倍感自豪。

人们乐于使用Qt的诸多原因之一是它的在线帮助文档，但是该帮助文档的主要目的是集中介绍个别的类，而很少讲述应当如何构建现实世界中那些复杂的应用程序。这本好书填补了这一缺憾，它展示了Qt所提供的东西，如何使用“Qt的方式”进行Qt编程，以及如何充分地利用Qt。本书将指导C++、Java或者C\#{}程序员进行Qt编程，并且提供了丰富详实的资料来使他们成长为老练的Qt程序员。这本书包含了很多很好的例子、建议和说明——并且，该书也是我们对那些新加入公司的程序员们进行培训的入门教材。

如今，已有大量的商业或者免费的Qt应用程序可以购买或者下载，其中的一些专门用于特殊的高端市场，其他一些则面向大众市场。看到如此多的应用程序都是基于Qt构建而成的，这使我们充满了自豪感，并且还激励我们要让Qt变得更好。相信在这本书的帮助下，将会前所未有地出现更多的、质量更高的Qt应用程序。

{\hfill Matthias Ettrich}

{\hfill 德国，柏林}

{\hfill 2007年11月}

\section*{序言}
Qt使用“一次编写，随处编译”的方式为开发跨平台的图形用户界面应用程序提供了一个完整的C++应用程序开发框架。Qt允许程序开发人员使用应用程序的单一源码树来构建可以运行在不同平台下的应用程序的不同版本；这些平台包括从Windows 98到Vista、MacOS X、Linux、Solaris、HP-UX以及其他很多基于X11的Unix。许多Qt库和工具也都是Qt/Embedded Linux的组成部分。Qt/Embedded Linux是一个可以在嵌入式Linux上提供窗口系统的产品。

本书的目标就是教您如何使用Qt4来编写图形用户界面程序。本书从"Hello Qt"开始，然后很快地转移到更高级的话题中，如自定义窗口部件的创建和拖放功能的提供等。通过本书的\href{http://www.informit.com/store/c-plus-plus-gui-programming-with-qt4-9780132354165}{互联网站点}，您可以下载到一些作为本书文字补充材料的示例程序。附录A说明了如何下载和安装这些软件，其中包括一个用于Windows的C++免费编译器。

本书分为四部分。第一部分涵盖了在使用Qt编写图形用户界面应用程序时所必需的全部基本概念和练习。仅掌握这一部分中所蕴含的知识就足以写出实用的图形用户界面应用程序。第二部分进一步深入介绍了Qt的一些重要主题，第三部分则提供了更为专业和高级的材料。您可以按任意顺序阅读第二部分和第三部分中的章节，但这是建立在您对第一部分中的内容非常熟悉的基础之上的。第四部分包括数个附录，附录B说明了如何构建Qt应用程序，附录C则介绍了Qt Jambi，它是Java版的Qt。

本书的第一版建立在Qt 3版本的基础上，尽管已通过全书修订来反映那些很好的Qt4编程技术，但本书还是根据Qt4的模型，视图结构、新的插件框架、使用Qt/Embedded Linux进行嵌入式编程等内容而引入了一些新的章节和一个新的附录。作为第二版，本书充分利用了Qt 4.2和Qt 4.3中引入的新特性对其进行了彻底更新，并包含“自定义外观”和“应用程序脚本”两个新的章以及两个新的附录。原有的“图形”一章已经拆分为“二维”和“三维”两章，在它们中间，涵盖了新的图形视图类和QPainter的OpenGL后端实现。此外，在数据库、XML和嵌入式编程等几章中，还添加了许多新内容。

与本书的前两版一样，这一版的重点放在如何进行Qt编程的说明和许多真实例子的提供上，而不是对丰富的Qt在线文档的简单拼凑和总结。因为本书纯粹讲授的是Qt 4编程中的原理和实践知识，因而读者能够轻松学会将要出现在Qt 4.4、Qt 4.5以及Qt 4.x等后续版本中的15个Qt新模块。如果您正在使用的Qt版本恰好是这些后续版本中的一个，那么当然要阅读一下参考文档中的"What's New in Qt 4.x"一章，以便可以对那些可用的新特性有一个总体把握。

在写作本书的时候，是假定您已经具备了C++、Java或者C\#{}的基本知识。本书中的例子代码使用的是C++中的一个子集，从而避免了很多在Qt编程中极少使用的C++特性。在某些不可避免而必须使用C++高级结构的地方，会在使用时对其做出必要的解释。如果您对Java或者C\#{}已经非常熟悉但是对C++还知之不多甚至一无所知，那么建议您先阅读附录D。附录D提供了对C++较为充分的介绍，从而能够让您具有使用本书所必备的C++知识。对于C++中的面向对象编程更为全面的介绍，建议您阅读由P. J. Deitel和H. M. Deitel编著的"C++ How to Program"(Prentice Hall , 2007)，以及由Stanley B. Lippman , Josée Lajoie和Barhara E. Moo编著的"C++ Primer"(Addison-Wesley , 2005)这两本书。

\section*{Qt简史}
Qt框架首度为公众可用是在1995年5月。它最初由Haavard Nord（奇趣科技公司的CEO）和Eirik Chambe-Eng（公司总裁）开发而成。Haavard和Eirik在位于挪威特隆赫姆的挪威科技学院相识，在那里，他们都获得了计算机科学的硕士学位。

Haavard对C++图形用户界面开发的兴趣始于1988年，当时一家瑞典公司委托他开发一套C++图形用户界面框架。几年后，在1990年的夏天，Haavard和Eirik因为一个超声波图像方面的C++数据库应用程序而在一起工作。这个系统需要一个能够在UNIX、Macintosh和Windows上都能运行的图形用户界面。在那个夏天中的某天，Haavard和Eirik一起出去散步，享受阳光，当他们坐在公园的一条长椅上时，Haavard说：“我们需要一个面向对象的显示系统。”由此引发的讨论，为他们即将创建的面向对象的、跨平台的图形用户界面框架奠定了智力基础。

1991年，Haavard和Eirik开始一起合作设计、编写最终成为Qt的那些类。在随后的一年中，Eirik提出了“信号和槽”的设想——一个简单并且有效的强大的图形用户界面编程规范，而现在，它已经可以被多个工具包实现。Haavard实践了这一想法，并且据此创建了一个手写代码的实现系统。到1993年，Haavard和Eirik已经开发出了Qt的第一套图形内核程序，并且能够利用它实现他们自己的一些窗口部件。同年末，为了创建“世界上最好的C++图形用户界面框架”，Haavard提议一起进军商业领域。

1994年成为两位年轻程序员不幸的一年，他们没有客户，没有资金，只有一个未完成的产品，但是他们希望能够闯进一个稳定的市场。幸运的是，他们的妻子都有工作并且愿意为他们的丈夫提供支持。在这两年里，Haavard和Eirik认为，他们需要继续开发产品并且从中赚得收益。

之所以选择字母“Q”作为类的前缀，是因为该字母在Haavard的Emacs字体中看起来非常漂亮。随后添加的字母"t"代表“工具包”(toolkit)，这是从"Xt"——一个X工具包的命名方式中获得的灵感。公司于1994年3月4日成立，最初的名字是"Quasar Technologies"，随后更名为"Troll Tech"，而公司今天的名字则是"Trolltech"。

1995年4月，通过Haavard就读过的大学的一位教授的联系，挪威的Metis公司与他们签订了一份基于Qt进行软件开发的合同。大约在同一时间，公司雇佣了Arnt Gulbrandsen，在公司工作的6年时间里，他设计并实现了一套独具特色的文档系统，并且对Qt的代码也做出了不少贡献。

1995年5月20日，Qt 0.90被上传到sunsite.unc.edu。6天后，在\\ comp.os.linux.announce上发布。这是Qt的第一个公开发行版本。Qt既可以用于Windows上的程序开发，又可以用于UNIX上的程序开发，而且在这两种平台上，都提供了相同的应用程序编程接口。从第一天起，Qt就提供了两个版本的软件许可协议：一个是进行商业开发所需的商业许可协议版，另一个则是适用于开源开发的自由软件许可协议版。Metis的合同确保了公司的发展，然而，在随后长达10个月的时间内，再没有任何人购买Qt的商业许可协议。

1996年3月，欧洲航天局(European Space Agency)购买了10份Qt的商业许可协议，它成了第二位Qt客户。凭着坚定的信念，Eirik和Haavard又雇佣了另外一名开发人员。Qt 0.97在同年5月底正式发布，随后在1996年9月24日，Qt1.0正式面世。到了这一年的年底，Qt的版本已经发展到了1.1，共有来自8个不同国家的客户购买了18份Qt的商业许可协议。也就是在这一年，在Matthias Ettrich的带领下，创立了KDE项目。

Qt 1.2于1997年4月发布。Matthias Ettrich利用Qt建立KDE的决定，使Qt成为Linux环境下开发C++图形用户界面的事实标准。Qt 1.3于1997年9月发布。

Matthias在1998年加入公司，并且在当年9月，发布了Qt 1系列的最后一个版本——V 1.40。1999年6月，Qt 2.0发布，该版本拥有一个新的开源许可协议——Q公共许可协议(QPL，Q Public License)，它与开源的定义一致。1999年8月，Qt赢得了LinuxWorld的最佳库/工具奖。大约在这个时候，Trolltech Pty Ltd（澳大利亚）成立了。

2000年，公司发布了Qt/Embedded Linux，它用于Linux嵌入式设备。Qt/Em-bedded Linux提供了自己的窗口系统，并且可以作为X11的轻量级替代产品。现在，Qt/X11和Qt/Embedded Linux除了提供商业许可协议之外，还提供了广为使用的GNU通用公共许可协议（GPL: General Public License）。2000年底，成立了Trolltech Inc.（美国），并发布了Qtopia的第一版，它是一个用于移动电话和掌上电脑(PDA)的环境平台。Qt/Embedded Linux在2001年和2002年两次获得了LinuxWorld的"Best Embedded Linux Solution"奖，Qtopia Phone也在2004年获得了同样的荣誉。

2001年，Qt 3.0发布。现在，Qt已经可用于Windows、Mac OS X、UNIX和Linux（桌面和嵌入式）平台。Qt 3提供了42个新类和超过500 000行的代码。Qt 3是自Qt 2以来前进历程中最为重要的一步，它主要在诸多方面进行了众多改良，包括本地化和统一字符编码标准的支持、全新的文本查看和编辑窗口部件，以及一个类似于Perl正则表达式的类等。2002年，Qt 3赢得了Software Development Times的"Jolt Productivity Award"\footnote{Jolt大奖素有“软件业界的奥斯卡”之美誉，共设通用类图书、技术类图书、语言和开发环境、框架库和组件、开发者网站等十余个分类，每个分类设有一个“震撼奖”(Jolt Award)和三个“生产力奖”(Productivity Award)。一项技术产品只有在获得了Jolt奖之后才能真正成为行业的主流，一本技术书籍只有在获得了Jolt奖之后才能真正奠定其作为经典的地位。虽然Jolt奖项并不起决定作用，但它代表了某种技术趋势与潮流——译者注。}。

2005年夏，Qt 4.0发布，它大约有500个类和9000多个函数，Qt 4比以往的任何一个版本都要全面和丰富，并且它已经裂变成多个函数库，从而使开发人员可以根据自己的需要只连接所需要的Qt部分。相对于以前的所有Qt版本，Qt 4的进步是巨大的，它不仅彻底地对高效易用的模板容器、高级的模型/视图功能、快速而灵活的二维绘图框架和强大的统一字符编码标准的文本查看和编辑类进行了大量改进，就更不必说对那些贯穿整个Qt类中的成千上万个小的改良了。现如今，Qt 4具有如此广泛的特性，以至于Qt已经超越了作为图形用户界面工具包的界限，逐渐成长为一个成熟的应用程序开发框架。Qt 4也是第一个能够在其所有可支持的平台上既可用于商业开发
又可用于开源开发的Qt版本。  

同样在2005年，公司在北京开设了一家办事处，以便为中国及其销售区域内的用户提供服务和培训，并且为Qt/Embedded Linux和Qtopia提供技术支持。

通过获取一些非官方的语言绑定件(language bmdings)，非C++程序员也已早就开始使用Qt，特别是用于Python程序员的PyQt语言绑定件。2007年，公司发布了用于C\#{}程序员的非官方语言绑定件Qyoto。同一年，Qt Jambi投放市场，它是一个官方支持的Java版Qt应用程序编程接口。附录C提供了对Qt Jambi的介绍。

自奇趣科技公司诞生以来，Qt的声望经久不衰，而且至今依旧持续高涨。取得这样的成绩不但说明了Qt的质量，而且也说明了人们都喜欢使用它。在过去的10年中，Qt已经从一个只被少数专业人士所熟悉的“秘密”产品，发展了到如今遍及全世界拥有数以千计的客户和数以万计的开源开发人员的产品。


\section*{编者的话}
感谢作者，感谢原中文翻译者，感谢原中文审校者。

书名修改不是想标新立异，实在是github和本地文档编译方便，不支持空格。

感谢汉王OCR技术支持，感谢\XeLaTeX 。




%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter


\part{Qt基础}
\chapter{Qt入门}
这一章介绍了如何把基本的C++知识与Qt所提供的功能组合起来创建一些简单的图形用户界面（Graphical User Interface，GUI）应用程序。在这一章中，还引入了Qt中的两个重要概念：一个是“信号和槽”，另外一个是“布局”。第2章还将对它们做进一步的阐述，而第3章将着手创建一个具有真正意义的应用程序。  

如果你已经熟知Java或C\#{}，但对C++的编程经验还有些欠缺的话，那么在开始阅读本书之前，可能需要先阅读附录D，它对C++做了简要介绍。

\section{Hello Qt}
我们先从一个非常简单的Qt程序开始。首先一行一行地研究这个程序，然后将会看到如何编译并运行它。

\begin{cppinput}{qt4-book/chap01/hello/hello.cpp}
\end{cppinput}


第1行和第2行包含了类QApplication和QLabel的定义。对于每个Qt类，都有一个与该类同名（且大写）的头文件，在这个头文件中包括了对该类的定义。

第6行创建了一个QApplication对象，用来管理整个应用程序所用到的资源。这个QApplication构造函数需要两个参数，分别是argc和argv，因为Qt支持它自己的一些命令行参数。

第7行创建了一个显示“Hello Qt!”的QLabel窗口部件(widget)。在Qt和UNIX的术语(tenninology)中，窗口部件就是用户界面中的一个可视化元素。该词起源于“window gadget”（窗口配件）这两个词，它相当于Windows系统术语中的“控件”(control)和“容器”(container)。按钮、菜单、滚动条和框架都是窗口部件。窗口部件也可以包含其他窗口部件，例如，应用程序的窗口通常就是一个包含了一个QMenuBar、一些QToolBar、一个QStatusBar以及一些其他窗口部件的窗口部件。绝大多数应用程序都会使用一个QMainWindow或者一个QDialog来作为它的窗口，但Qt是如此灵活，以至于任意窗口部件都可以用作窗口。在本例中，就是用窗口部件QLabel作为应用程序的窗口的。   

第8行使QLabel标签(label)可见。在创建窗口部件的时候，标签通常都是隐藏的，这就允许我们可以先对其进行设置然后再显示它们，从而避免了窗口部件的闪烁现象。

第9行将应用程序的控制权传递给Qt。此时，程序会进入事件循环状态，这是一种等待模式，程序会等候用户的动作，例如鼠标单击和按键等操作。用户的动作会让可以产生响应的程序生成一些事件（event，也称为“消息”），这里的响应通常就是执行一个或者多个函数。例如，当用户单击窗口部件时，就会产生一个“鼠标按下”事件和一个“鼠标松开”事件。在这方面，图形用户界面应用程序和常规的批处理程序完全不同，后者通常可以在没有人为干预的情况下自行处理输入、生成结果和终止。

为简单起见，我们没有过多关注在main()函数末尾处对QLabel对象的delete操作调用。在如此短小的程序内，这样一点内存泄漏(memory  leak)问题无关大局，因为在程序结束时，这部分内存是可以由操作系统重新回收的。
\begin{fig}{helloqt}
\caption{Linux上的Hello程序}
\label{fig:Linux上的Hello程序}
\end{fig}

现在是在机器上测试这个程序的时候了，看起来它应该会如图1.1所示。首先需要安装Qt 4.3.2（或是其后的其他Qt 4新发行版），附录A对这一安装过程进行了说明。从现在开始，假定你已经正确地安装了Qt 4的一个副本，并且假定已经在PATH环境变量中对Qt的bin目录进行了设置。（在Windows操作系统中，这些操作会由Qt的安装程序自动完成。）还需要将该程序的源代码保存到hello.cpp文件，并把它放进一个名为hello的目录中。

现在在命令提示符下，进入hello目录，输入如下命令，生成一个与平台无关的项目文件hello.pro：
\begin{Verbatim}
qmake -project
\end{Verbatim}

然后，输入如下命令，从这个项目文件生成一个与平台相关的makefile文件：

\begin{Verbatim}
qmake hello.pro
\end{Verbatim}

键入make命令就可以构建该程序。（在附录B中，会给出qmake工具更为详细的说明。）要运行该程序，在Windows下可以输入\verb+hello+，在UNIX下可以输入\verb+./hello+，在Mac OS X下可以输入\verb+open hello.app+。要结束该程序，可直接单击窗口标题栏上的关闭按钮。

如果使用的是Windows系统，并且已经安装了Qt的开源版和MinGW编译器，那么将会看到一个指向MS-DOS提示符窗口的快捷键，其中已经正确地创建了使用Qt时所需的全部环境变量。如果启动了这个窗口，那么就可以在里面像上面所讲述的那样使用qmake命令和make命令编译Qt应用程序。而由此产生的可执行文件将会保存在应用程序所在目录的debug或release文件夹中。

如果使用的是Microsoft Visual C++和商业版的Qt，则需要用nmake命令代替make命令。除了这一方法外，还可以通过hello.pro文件创建一个Visual Studio的工程文件，此时需要输入命令：

\begin{Verbatim}
qmake -tp vc hello.pro
\end{Verbatim}

然后就可以在Visual Studio中编译这个程序了。如果使用的是Mac OS X系统中的Xcode，那么可以使用如下命令来生成一个Xcode工程文件：
\begin{Verbatim}
qmake -spec macx-xcode hello.pro
\end{Verbatim}

在开始进入下一个例子之前，我们一起来做一件有意思的事情：将代码行
\begin{Verbatim}
QLabel *label = new QLabel("Hello Qt!");
\end{Verbatim}

替换为
\begin{Verbatim}
QLabel *label = new QLabel("<h2><i>Hello</i> "
                           "<font color=red>Qt!</font></h2>");
\end{Verbatim}

然后重新编译该程序。运行程序时，看起来应当是图1.2的样子。正如该例子所显示的那样，通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变得更为丰富多彩。
\begin{fig}{helloqt2}
\caption{具有简单HTML样式的标签}
\label{fig:helloqt2}
\end{fig}

\section{建立连接}
第二个例子要说明的是如何响应用户的动作。这个应用程序由一个按钮构成，用户可以单击这个按钮退出程序。除了应用程序的主窗口部件使用的是QPushButton而不是QLabel之外，这个应用程序的源代码和Hello程序的源代码非常相似。同时，我们还会将用户的一个动作（单击按钮）与一段代码连接起来。

这个应用程序的源代码位于本书的例子文件中，文件名是qt4-book/chap01/qu-it/quit.cpp。程序的运行效果如图1.3所示。以下是该文件所包含的内容：
\begin{cppinput}{qt4-book/chap01/quit/quit.cpp}
\end{cppinput}

\begin{fig}{quit}
\caption{Quit应用程序}
\label{fig:quit}
\end{fig}

Qt的窗口部件通过发射信号(signal)来表明一个用户动作已经发生了或者是一个状态已经改变了\footnote{Qt的信号和UNIX的信号并不相关，本书中所讨论的信号仅指Qt信号。}。例如，当用户单击QPushButton时；该按钮就会发射一个clicked()信号。信号可以与函数（在这里称为槽，slot）相连接，以便在发射信号时，槽可以得到自动执行。在这个例子中，我们把这个按钮的clicked()信号与QApplication对象的quit()槽连接起来。宏SIGNAL()和SLOT()是Qt语法中的一部分。

现在来构建这个应用程序。假设已经创建了一个包含quit.cpp文件的quit目录。在quit目录中，首先运行qmake命令生成它的工程文件，然后再次运行该命令来生成一个makefile文件，这两项操作的命令如下：
\begin{Verbatim}
qmake -project
qmake quit.pro
\end{Verbatim}

现在，就可以编译并运行这个应用程序了。如果单击Quit按钮，或者按下了空格键（这样也会按下Quit按钮），那么将会退出应用程序。


\section{窗口部件的布局}
这一节将创建一个简单的例子程序，以说明如何用布局(layout)来管理窗口中窗口部件的几何形状，还要说明如何利用信号和槽来同步窗口部件。这个应用程序的运行效果如图1-4所示，它可以用来询问用户的年龄，而用户可以通过操纵微调框(spin box)或者滑块(slider)来完成年龄的输入。
\begin{fig}{ageapplication}
\caption{Age应用程序}
\label{fig:ageapplication}
\end{fig}

这个应用程序由三个窗口部件组成：一个QSpinBox，一个QSlider和一个QWidget。QWidget是这个应用程序的主窗口。QSpinBox和QSlider会显示在QWidget中，它们都是QWidget窗口部件的子对象。换言之，QWidget窗口部件是QSpinBox和QSlider的父对象。QWidget窗口部件自己则没有父对象，因为程序是把它当作顶层窗口的。QWidget的构造函数以及它的所有子类都会带一个参数QWidget *，以用来说明谁是它们的父窗口部件。

以下是本应用程序的源代码：
\begin{cppinput}{qt4-book/chap01/age/age.cpp}
\end{cppinput}

第10行和第11行创建了QWidget对象，并把它作为应用程序的主窗口。我们通过调用setWindowTitle()函数来设置显示在窗口标题栏上的文字。

第13行和第14行分别创建了一个QSpinBox和一个QSlider，并分别在第15行和第16行设置了它们的有效范围。我们可以放心地假定用户的最大年龄不会超过130岁。本应把这个窗口传递给QSpinBox和QSlider的构造函数，以说明这两个窗口部件的父对象都是这个窗口，但在这里没有这个必要，因为布局系统将会自行得出这一结果并自动把该窗口设置为微调框和滑块的父对象，下面将会很快看到这一点。

从第18行到第21行，调用了两次QObject::connect()，这是为了确保能够让微调框和滑块同步，以便它们两个总是可以显示相同的数值。一旦有一个窗口部件的值发生了改变，那么就会发射它的valueChanged(int)信号，而另一个窗口部件就会用这个新值调用它的setValue(int)槽。

第22行将微调框的值设置为35。当发生这种情况时，QSpinBox就会发射valueChanged(int)信号，其中，int参数的值是35。这个参数会被传递给QSlider的setValue(int)槽，它会把这个滑块的值设置为35。于是，滑块就会发射valueChanged(int)信号，因为它的值发生了变化，这样就触发了微调框的setValue(int)槽。但在这一点上，setValue(int)并不会再发射任何信号，因为微调框的值已经是35了。这样就可以避免无限循环的发生。图1.5对这种情况进行了图示概述。
\begin{fig}[0.8]{ageapplication2}
\caption{改变一个窗口部件的值会使两个窗口部件都发生变化}
\label{fig:ageapplication2}
\end{fig}


\begin{framed}
\vspace{-\parskip}
\begin{center}
\textbf{窗口部件的风格}
\end{center}

到目前为止，我们看到的这些屏幕截图都来自于Linux，但是Qt应用程序在每一个所支持的平台上都可以看起来像本地程序一样（见图1.6）。Qt是通过所模拟平台的视觉外观来实现这一点的，而不是对某个特殊平台的封装或者一个工具包中的窗口部件集。

\begin{linefig}[0.9]{appstyle}
\caption{一些预定义风格}
\label{fig:appstyle}
\end{linefig}

运行于KDE下的Qt/X11应用程序的默认风格是Plastique，而运行于GNOME下的应用程序的默认风格是Cleanlooks。这些风格使用了渐变和抗锯齿效果，以用来提供一种时尚的外观。运行Qt应用程序的用户可以通过使用命令行参数-style覆盖原有的默认风格。例如，在X11下，要想使用Motif风格来运行Age应用程序，只需简单输入以下命令即可：
\begin{Verbatim}
./age -style motif
\end{Verbatim}

与其他风格不同，Windows XP、Windows Vista和Mac的风格只能在它们的本地平台上有效，因为它们需要依赖平台的主题引擎。

还有另外一种风格QtDotNet，它来自于Qt Solutions模块。创建自定义风格也是可能的，这会在第19章中加以阐述。
\end{framed}

在源程序的第24行到第27行，使用了一个布局管理器对微调框和滑块进行布局处理。布局管理器(layout manager)就是一个能够对其所负责窗口部件的尺寸大小和位置进行设置的对象。Qt有三个主要的布局管理器类：
\begin{itemize}
\item QHBoxLayout。在水平方向上排列窗口部件，从左到右（在某些文化中则是从右向左）。
\item QVBoxLayout。在竖直方向上排列窗口部件，从上到下。
\item QGridLayout。把各个窗口部件排列在一个网格中。
\end{itemize}

第27行的QWidget::setlayout()函数调用会在窗口上安装该布局管理器（见图1.7）。从软件的底层实现来说，QSpinBox和QSlider会自动“重定义父对象”，它们会成为这个安装了布局的窗口部件的子对象。也正是基于这个原因，当创建一个需要放进某个布局中的窗口部件时，就没有必要为其显式地指定父对象了。

\begin{linefig}[0.8]{agelayout}
\caption{Age应用程序中的窗口部件和布局}
\label{fig:agelayout}
\end{linefig}

尽管没有明确地设置任何一个窗口部件的位置或大小，但QSpinBox和QSlider还是能够非常好看地一个挨着一个显示出来。这是因为QHBoxLayout可根据所负责的子对象的需要为它们分配所需的位置和大小。布局管理器使我们从应用程序的各种屏幕位置关系指定的繁杂纷扰中解脱出来，并且它还可以确保窗口尺寸大小发生改变时的平稳性。

Qt中构建用户接口的方法很容易理解并且非常灵活。Qt程序员最常使用的方式是先声明所需的窗口部件，然后再设置它们所应具备的属性。程序员把这些窗体部件添加到布局中，布局会自动设置它们的位置和大小。利用Qt的信号－槽机制，并通过窗口部件之间的连接就可以管理用户的交互行为。


\section{使用参考文档}
由于Qt的参考文档涉及了Qt中的每一个类和函数，所以对任何一名Qt开发人员来说，它都是一个基本工具。本书讲述了Qt的许多类和函数，但是也并不能完全覆盖到Qt中所有的类和函数，同时也无法对书中所涉及的每个类和函数都提供全部的细节。如果想尽可能多地从Qt获益，那么就应当尽快地达到对Qt参考文档了如指掌的程度。

在Qt的doc/html目录下可以找到HTML格式的参考文档，并且可以使用任何一种Web浏览器来阅读它。也可以使用Qt的帮助浏览器Qt Assistant，它具有强大的查询和索引功能，使用时能够比Web浏览器更加快速和容易。

要运行Qt Assistant，在Windows下，可单击“开始”菜单中的"Qt by Trolltech v4.x.y | Assistant"(见图1.8)；在UNIX下，可在命令行终端中输入assistant命令；在Mac  OS X Finder中，只需双击assistant即可，在主页的"API Reference"小节中的链接提供了浏览Qt类的几种不同方式，"All Classes"页面列表会列出Qt API中的每一个类，而"Main Classes"页面列表只会列出Qt中那些最为常用的类。作为练习，你或许可以去试着查询一下这一章中所使用过的那些类和函数。
\begin{linefig}[0.8]{qtassistant}
\caption{Windows Vista 下Qt Assistant中的Qt参考文档}
\label{fig:qtassistant}
\end{linefig}

需要注意的是，通过继承而得到的函数的文档会显示在它的基类中，例如，QPushButton就没有它自己的show()函数，因为它是从QWidget那里继承的函数。图1.9给出了到目前为止我们所见过的各个类之间的关系。
\begin{linefig}[0.8]{classtree}
\caption{目前为止我们所见过的那些Qt类的继承树}
\label{fig:classtree}
\end{linefig}

可以从\href{http://doc.trolltech.com}{http://doc.trolltech.com}中获取Qt的当前版和一些早期版本的在线参考文档。这个网站也选摘了Qt季刊(Qt Quarterly)中的一些文章。Qt季刊是Qt程序员的时事通讯，会发送给所有
获得Qt商业许可协议的人员。

本章介绍了一些重要概念：信号－槽连接和布局，也逐步展示了Qt的兼容性和Qt完全面向对象的构建方法和窗口部件的使用。如果你浏览了一遍Qt的参考文档，那么将会发现一种如何学习使用新窗口部件的统一方法，并且也将发现Qt对函数、参数、枚举等变量选名的严谨性，以及在使用Qt编程时令人叹服的愉悦感和舒适性。

本书第一部分的随后几章，都建立在本章的基础之上，它们演示了如何创建一个完整的GUI应用程序——拥有菜单、工具栏、文档窗口、状态条和对话框，还有与之相应的用于阅读、处理和输出文件的底层功能函数。



\chapter{创建对话框}
这一章讲解如何使用Qt创建对话框。对话框为用户提供了许多选项和多种选择，允许用户把选项设置为他们喜欢的变量值并从中做出选择。之所以把它们称为对话框，或者简称为“对话”，是因为它们为用户和应用程序之间提供了一种可以相互“交谈”的交互方式。

绝大多数图形用户界面应用程序都带有一个由菜单栏、工具栏构成的主窗口以及几十个对主窗口进行补充的对话框。当然，也可以创建对话框应用程序，它可以通过执行合适的动作来直接响应用户的选择（例如，一个计算器应用程序）。

本章将首先完全用手写代码的方式创建第一个对话框，以便能够说明是如何完成这项工程的。然后将使用Qt的可视化界面设计工具Qt设计师(Qt Designer)。使用Qt设计师比手写代码要快得多，并且可以使不同的设计测试工作以及稍后对设计的修改工作变得异常轻松。


\section{子类化QDialog}
第一个例子是完全使用C++编写的一个Find(查找)对话框，它的运行效果如图2.1所示，这将实现一个拥有自主权的对话框。通过这一过程，就可以让对话框拥有自己的信号和槽，成为一个独立的、完备的控件。

\begin{fig}{finddialog}
\caption{Find对话框}
\label{fig:finddialog}
\end{fig}

源代码分别保存在finddialog.h和finddialog.cpp文件中。首先从finddialog.h文件说起：
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{1}{9}
\end{cppline}


第1、2行（以及后面的第27行，见下页）能够防止对这个头文件的多重包含。第4行包含了QDialog的定义，它是Qt中对话框的基类。QDialog从QWidget类中派生出来。第6行到第9行前置声明了一些用于这个对话框实现中的Qt类。前置声明(forward declaration)会告诉C++编译程序类的存在，而不用提供类定义中的所有细节(通常放在它自己的头文件中)。关于这一点，将会再简单地多讲一些。

接下来定义FindDialog，并让它成为QDialog的子类：
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{11}{16}
\end{cppline}


对于所有定义了信号和槽的类，在类定义开始处的Q\_{}OBJECT宏都是必需的。

FindDialog的构造函数就是一个典型的Qt窗口部件类的定义方式。parent参数指定了它的父窗口部件。该参数的默认值是一个空指针，意味着该对话框没有父对象。
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{18}{20}
\end{cppline}

signals部分声明了当用户单击Find按钮时对话框所发射的两个信号。如果向前查询(search backward)选项生效，对话框就发射findPrevious()信号，否则它就发射findNext()信号。

signals关键字实际上是一个宏。C++预处理器会在编译程序找到它之前把它转换成标准C++代码。Qt::CaseSensitivity足一个枚举类型，它有\\ Qt::CaseSensitive和Qt::CaseInsensitive两个取值。
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{22}{0}
\end{cppline}

在这个类的private段声明了两个槽。为了实现这两个槽，几乎需要访问这个对话框的所有子窗口部件，所以也保留了指向它们的指针。关键字slots就像signals一样也是一个宏，也可以扩展成C++编译程序可以处理的一种结构形式。

对于这些私有变量，我们使用了它们的类前置声明。这是可行的，因为它们都是指针，而且没有必要在头文件中就去访问它们，因而编译程序就无须这些类的完整定义。我们没有包含与这几个类相关的头文件（<QCheckBox>、<QLabel>，等等），而是使用了一些前置声明。这可以使编译过程更快一些。

现在看一下finddialog.cpp，其中包含了对FindDialog类的实现：
\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{1}{3}
\end{cppline}

首先，需要包含<QtGui>，该头文件包含了Qt Gui类的定义。Qt由数个模块构成，每个模块都有自己的类库。最为重要的模块有QtCore、QtGui、QtNetwork、QtOpenGL、QtScript、QtSql、QtSvg和QtXml。其中，在<QtGui>头文件中为构成QtCore和QtGui组成部分的所有类进行了定义。在程序中包含这个头文件，就能够使我们省去在每个类中分别包含的麻烦。

在filedialog.h文件中，本可以仅简单地添加一个<QtGui>包含即可，而不用包含<QDialog>和使用QCheckBox、QLabel、QLineEdit和QPushButton的前置声明。然而，在一个头文件中再包含一个那么大的头文件着实不是一种好的编程风格，尤其对于比较大的工程项目更是如此。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{5}{19}
\end{cppline}

在第6行，把parent参数传递给了基类的构造函数。然后，创建了子窗口部件。在字符串周围的tr()函数调用是把它们翻译成其他语言的标记。在每个QObject对象以及包含有Q\_{}OBJECT宏的子类中都有这个函数的声明。尽管也许并没有将你的应用程序立刻翻译成其他语言的打算，但是在每一个用户可见的字符串周围使用tr()函数还是一个很不错的习惯。在第18章中将对翻译Qt应用程序进行详细讲述。

在这些字符串中，使用了表示“与”操作的符号"\&{}"来表示快捷键。例如，笫15行创建了一个Find按钮，用户可在那些支持快捷键的平台下通过按下Alt+F快捷键来激活它。符号"\&{}"可以用来控制焦点：在第8行创建了一个带有快捷键(Alt+W)的标签，而在第10行设置了行编辑器作为标签的伙伴。所谓“伙伴”(buddy)就是一个窗口部件，它可以在按下标签的快捷键时接收焦点(focus)。所以当用户按下Alt+W（该标签的快捷键）时，焦点就会移动到这个行编辑器（该标签的伙伴）上。

在第16行，通过调用setDefault(true)让Find按钮成为对话框的默认按钮。默认按钮(default button)就是当用户按下Enter键时能够按下对应的按钮。在第17行，禁用了Find按钮。当禁用一个窗口部件时，它通常会显示为灰色，并且不能和用户发生交互操作。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{21}{26}
\end{cppline}

只要行编辑器中的文本发生变化，就会调用私有槽enableFindButton(const QString \& )。当用户单击Find按钮时，会调用findClicked()私有槽。而当用户单击Close时，对话框会关闭。close()槽是从QWidget中继承而来的，并且它的默认行为就是把窗口部件从用户的视野中、隐藏起来（而无须将其删除）。稍后将会看到enableFindButton()槽和findClicked()槽的代码。

由于QObject是FindDialog的父对象之一，所以可以省略connect()函数前面的QObject::前缀。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{28}{45}
\end{cppline}

接下来，使用布局管理器摆放这些子窗口部件。布局中既可以包含多个窗口部件，也可以包含其他子布局。通过QHBoxLayout、QVBoxLayout和QGridLayout这三个布局的不同嵌套组合，就可能构建出相当复杂的对话框。

如图2.2所示，对于Find对话框，使用了两个QHBoxLayout布局和两个QVBoxLayout布局。外面的布局是主布局，通过第45行代码将其安装在FindDialog中，并且由其负责对话框的整个区域。其他三个布局则作为子布局。图2.2中右下角的小“弹簧”是一个分隔符（或者称为“伸展器”）。用它来占据Find按钮和Close按钮所余下的空白区域，这样可以确保这些按钮完全占用它们所在布局的上部空间。

\begin{linefig}[0.8]{finddialoglayout}
\caption{Find对话框的布局}
\label{fig:finddialoglayout}
\end{linefig}

布局管理器类的一个精妙之处在于它们不是窗口部件。相反，它们派生自QLayout，因而也就是进一步派生自QObject，在图2.2中，窗口部件用实线轮廓来表示，布局用点线来表示，这样就能够很好地区分窗口部件和布局。在一个运行的应用程序中，布局是不可见的。

当将子布局对象添加到父布局对象中时（第33、43和44行），子布局对象就会自动重定义自己的父对象。也就是说，当将主布局装到对话框中去时（第45行），它就会成为对话框的子对象了，于是它的所有子窗口部件都会重定义自己的父对象，从而变成对话框中的子对象。图2.3给出了父子层次关系的最终结果。

\begin{fig}[0.8]{finddialogrelation}
\caption{Find对话框中的父子关系}
\label{fig:finddialogrelation}
\end{fig}

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{47}{49}
\end{cppline}

最后，设置了显示在对话框标题栏上的标题的内容，并让窗口具有一个固定的高度，这是因为在对话框的垂直方向上再没有其他窗口部件可以去占用所多出的空间了。QWidget::sizeHint()函数可以返回一个窗口部件所“理想”的尺寸大小。

这样，就完成了对FindDialog对话框构造函数的分析。由于在创建这个对话框中的窗口部件和布局时使用的是new，所以需要写一个能够调用delete的析构函数，以便可以删除所创建的每一个窗口部件和布局。但是这样做并不是必需的，因为Qt会在删除父对象的时候自动删除其所属的所有子对象，也就会删除FindDialog中作为其子孙的所有子窗口部件和子布局。

现在来看一下这个对话框中所用到的槽：

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{51}{0}
\end{cppline}

当用户单击Find按钮时，就会调用findClicked()槽。而该槽将会发射findPrevious()或findNext()信号，这取决于Search backward选项的取值。emit是Qt中的关键字，像其他Qt扩展一样，它也会被C++预处理器转换成标准的C++代码。

只要用户改变了行编辑器中的文本，就会调用enableFindButton()槽。如果在行编辑器中有文本，该槽就会启用Find按钮，否则它就会禁用Find按钮。

利用这两个槽就完成了这个对话框的功能。现在，可以创建一个main.cpp文件来测试一下这个FindDialog窗口部件。

\begin{cppinput}{qt4-book/chap02/find/main.cpp}
\end{cppinput}

为了编译这个程序，还像以前一样运行qmake。由于FindDialog类的定义包含Q\_{}OBJECT宏，因而由qmake生成的makefile将会自动包含一些运行moc的规则，moc就是指Qt的元对象编译器，即meta-object compiler。（会在下一节介绍Qt的元对象系统。）

为了使moc能够正常运行，必须把类定义从实现文件中分离出来并放到头文件中。由moc生成的代码会包含这个头文件，并且会添加一些特殊的C++代码。

必须对使用了Q\_{}OBJECT宏的类运行moc。因为qmake会自动在makefile中添加这些必要的规则，所以这并不成问题。但是如果忘记了使用qmake重新生成makefile文件，并且也没有重新运行moc，那么连接程序就会报错，指出你声明了一些函数但是却没有实现它们。这些信息可能是相当不明确的。GCC会生成像这样的出错信息：
\begin{Verbatim}
finddialog.o: In function `FindDialog::tr(char const*, char const*)':
/usr/lib/qt/src/corelib/global/qglobal.h:1430: undefined reference to
`FindDialog::staticMetaObject'
\end{Verbatim}

Visual C++输出的出错信息可能是这样的：
\begin{Verbatim}
finddialog.obj : error LNK2001: unresolved external symbol
"public:~virtual int __thiscall MyClass::qt_metacall(enum QMetaObject
::Call,int,void * *)"
\end{Verbatim}

如果曾经遇到过这种情况，那么请重新运行qmake以生成新的makefile文件，然后再重新构建该应用程序。

现在来运行该程序。如果在你的系统上能够显示快捷键，那么可以检验一下快捷键Alt+w、Alt+C、Alt+B和Alt+F是不是触发了正确的行为。可以通过敲击键盎上的Tab键来遍历这些窗口部件。默认的Tab键顺序就是创建窗口部件时的顺序。要改变这个键顺序，可以使用QWidget::setTabOrder()函数。

提供一种合理的Tab键顺序和键盘快捷键可以确保不愿（或者不能）使用鼠标的用户能够充分享受应用程序所提供的全部功能。完全通过键盘控制应用程序也深受快速输入人员的赞赏。

在第3章，将在一个真实的应用程序中使用Find对话框，并且将会把findPrevious()信号和findNext()信号与一些槽连接到一起。


\section{深入介绍信号和槽}
信号和槽机制是Qt编程的基础。它可以让应用程序编程人员把这些互不了解的对象绑定在一起。前面，已经把一些信号和槽连接在了一起，也声明了自己的信号和槽，还实现了自己的槽，并且还发射了自己的信号。让我们再花一点时间，来进一步深入地了解这个机制。

槽和普通的C++成员函数几乎是一样的——可以是虚函数；可以被重载；可以是公有的、保护的或者私有的，并且也可以被其他C++成员函数直接调用；还有，它们的参数可以是任意类型。唯一的不同是：槽还可以和信号连接在一起，在这种情况下，每当发射这个信号的时候，就会自动调用这个槽。

connect()语句看起来会是如下的样子：
\begin{Verbatim}
connect(sender, SIGNAL(signal), receiver, SLOT(slot));
\end{Verbatim}

这里的\textit{sender}和\textit{receiver}是指向QObject的指针，\textit{signal}和\textit{slot}是不带参数的函数名。实际上，SIGNAL()宏和SLOT()宏会把它们的参数转换成相应的字符串。

到目前为止，在已经看到的实例中，我们已经把不同的信号和不同的槽连接在了一起。但这里还需要考虑一些其他的可能性。

\begin{itemize}
\item \textbf{一个信号可以连接多个槽}：

\begin{Verbatim}
connect(slider, SIGNAL(valueChanged(int)),
        spinBox, SLOT(setValue(int)));
connect(slider, SIGNAL(valueChanged(int)),
        this, SLOT(updateStatusBarIndicator(int)));
\end{Verbatim}

在发射这个信号的时候，会以不确定的顺序一个接一个地调用这些槽。

\item \textbf{多个信号可以连接同一个槽}：
\begin{Verbatim}
connect(lcd, SIGNAL(overflow()),
        this, SLOT(handleMathError()));
connect(calculator, SIGNAL(divisionByZero()),
        this, SLOT(handleMathError()));
\end{Verbatim}

无论发射的是哪一个信号，都会调用这个槽。

\item \textbf{一个信号可以与另外一个信号相连接}：

\begin{Verbatim}
connect(lineEdit, SIGNAL(textChanged(const QString &)),
        this, SIGNAL(updateRecord(const QString &)));
\end{Verbatim}

当发射个信号时，也会发射第二个信号。除此之外，信号与信号之间的连接和信号与槽之间的连接是难以区分的。

\item \textbf{连接可以被移除}：
\begin{Verbatim}
disconnect(lcd, SIGNAL(overflow()),
        this, SLOT(handleMathError()));
\end{Verbatim}

这种情况较少用到，因为当删除对象时，Qt会自动移除和这个对象相关的所有连接。
\end{itemize}

要把信号成功连接到槽（或者连接到另外一个信号），它们的参数必须具有相同的顺序和相同的类型：
\begin{Verbatim}
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(processReply(int, const QString &)));
\end{Verbatim}

例外地，如果信号的参数比它所连接的槽的参数多，那么多余的参数将会被简单地忽略掉：
\begin{Verbatim}
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(checkErrorCode(int)));
\end{Verbatim}

如果参数类型不匹配，或者如果信号或槽不存在，则当应用程序使用调试模式构建后，Qt会在运行时发出警告。与之相类似的是，如果在信号和槽的名字中包含了参数名，Qt也会发出警告。

到现在为止，我们仅仅在窗口部件之间使用了信号和槽。但是这种机制本身是在QObject中实现的，并不只局限于图形用户界面编程中。这种机制可以用于任何QObject的子类中：

\begin{Verbatim}
class Employee : public QObject
{
    Q_OBJECT
public:
    Employee() { mySalary = 0; }
    int salary() const { return mySalary; }
public slots:
    void setSalary(int newSalary);
signals:
    void salaryChanged(int newSalary);
private:
    int mySalary;
};
void Employee::setSalary(int newSalary)
{
    if (newSalary != mySalary) {
        mySalary = newSalary;
        emit salaryChanged(mySalary);
    }
}
\end{Verbatim}

注意一下setSalary()槽是如何工作的。只有在newSalary != mySalary的时候，才发射salaryChanged()信号。这样可以确保循环连接不会导致无限循环。

\begin{framed}
\vspace{-\parskip}
\begin{center}
\textbf{Qt的元对象系统}
\end{center}

Qt的主要成就之一就是使用了一种机制对C++进行了扩展，并且使用这种机制创建了独立的软件组件。这些组件可以绑定在一起，但任何一个组件对于它所要连接的组件的情况事先都一无所知。

这种机制称为元对象系统(meta-object system)，它提供了关键的两项技术：信号－槽以及内省(introspection)。内省功能对于实现信号和槽是必需的，并且允许应用程序的开发人员在运行时获得有关QObject子类的“元信息”(meta-information)，包括一个含有对象的类名以及它所支持的信号和槽的列表。这一机制也支持属性（广泛用于Qt设计师中）和文本翻译（用于国际化），并且它也为QtScript模块奠定了基础。从Qt 4.2开始，可以动态添加属性，这一特性将会在第19章和第22章中付诸实施。

标准C++没有对Qt的元对象系统所需要的动态元信息提供支持。Qt通过提供一个独立的moc工具解决了这个问题，moc解析Q\_{}OBJECT类的定义并且通过C++函数来提供可供使用的信息。由于moc使用纯C++来实现它的所有功能，所以Qt的元对象系统可以在任意C++编译器上工作。

这一机制是这样工作的：
\begin{itemize}
\item Q\_{}OBJECT宏声明了在每一个QObject子类中必须实现的一些内省函数：metaObject()、tr()、qt\_{}metacall()，以及其他一些函数。
\item Qt的moc工具生成了用于由Q\_{}OBJECT声明的所有函数和所有信号的实现。
\item 像connect()和disconnect()这样的QObject的成员函数使用这些内省函数来完成它们的工作。
\end{itemize}

由于所有这些工作都是由qmake、moc和QObject自动处理的，所以很少需要再去考虑这些事情。但是如果你对此充满好奇心的话，那么也可以阅读一下有关QMetaObject类的文档和由moc生成的C++源代码文件，可以从中看出这些实现工作是如何进行的。
\end{framed}


\section{快速设计对话框}
Qt的设计初衷就是为了能够直观并且友好地进行手工编码，并且对于程序员来说，纯粹通过编写C++源代码来开发整个Qt应用程序并不稀奇。尽管如此，许多程序员还是喜欢使用可视化的方法来设计窗体，因为他们发现使用可视化方式会比手工编码显得更自然、更快速，并且也希望能够通过可视化方法，对那些手工编码所设计的窗体，进行更快速、更容易的测试和修改。

Qt设计师(Qt Designer)为程序员们提供了可供使用的新选择，它提供一种可视化的设计能力。Qt设计师可用于开发应用程序中的所有或部分窗体。使用Qt设计师所创建的窗体最终仍旧是C++代码，因此，可把Qt设计师看作是一个传统的工具集，并且不会对编译器强加其他特殊要求。

\begin{fig}{gotocell}
\caption{Go to Cell对话框}
\label{fig:gotocell}
\end{fig}

在这一节，将使用Qt设计师来创建如图2.4所示的Go to Cell对话框。并且无论是使用手工编码还是使用Qt设计师，在创建对话框时总是要包含以下这几个相同的基本步骤：

\begin{enumerate}
\item 创建并初始化子窗口部件。
\item 把子窗口部件放到布局中。
\item 设置Tab键顺序。
\item 建立信号－槽之间的连接。
\item 实现对话框中的自定义槽。
\end{enumerate}

要启动Qt设计师，在Windows下，可单击“开始”菜单中的Qt by Trolltech v4.x.y→Designer；在UNIX下，在命令行中输入"designer"；在Mac OS X Finder中，直接双击designer。当Qt设计师开始运行后，它会弹出一个多种模板的列表。单击Widget模板，然后再单击Create。（"Dialog with Buttons Bottom"模板看起来可能更具诱惑力，但是对于这个例子来说，为了能够看到是如何完成OK和Cancel按钮的，所以需要采用手工方式来创建它们。）现在应该会看到一个名为"Untitled"的窗口。

默认情况下，Qt设计师的用户界面由多个顶级窗口构成。如果你更喜欢像图2.5所示的那种多文档(MDI)界面风格，即只有一个顶级窗口和多个子窗口构成的界面，则可以单击Edit→Preferences，然后将用户界面模式设置为Docked Window（停靠窗口）即可。
\begin{linefig}[0.8]{designer}
\caption{Windows Vista中显示为停靠窗口模式的Qt设计师}
\label{fig:designer}
\end{linefig}

第一步是创建子窗口部件并且把它们放置到窗体中。创建一个标签、一个行编辑器、一个水平分隔符和两个按钮。对于这里的每一项，可先从Qt设计师的窗口部件工具箱中拖拽其名字或者图标并将其放到窗体中的大概位罩。在Qt设计师中，分隔符会显示为一个蓝色的弹簧，但在最终结果的窗体中它是不可见的。

现在，向上拖动窗体的底部使它变短一些，这样将会产生一个类似于图2.6的窗体。不要在窗体上为确定这些项的位置而花费太多的时间，会在稍后使用Qt的布局管理器，它可以把这些项摆放得恰到好处。
\begin{fig}[0.7]{designer2-6}
\caption{带一些窗口部件的窗体}
\label{fig:designer2-6}
\end{fig}

使用Qt设计师的属性编辑器可以设置每一个窗口部件中的属性：
\begin{enumerate}
\item 单击文本标签。确保此时objectName的属性是"label"，那么就可以将它的text属性设置成"\&{}Cell Location:"。
\item 单击行编辑器。确保objectName属性是"lineEdit"。
\item 单击第一个按钮。将它的objectName属性设置成"okButton"，将它的enabled属性设置成"false"，将它的text属性设置成"OK"，并且把它的default属性设置成"true"。
\item 单击第二个按钮。将它的objectName属性设置成"cancelButton"，并且将它的text属性设置成"Cancel"。
\item 单击这个窗体中空白的地方，选中窗体本身。将objectName属性设置成"GoToCellDialog"，并且将它的windowTitle属性设置成"Go to Cell"。
\end{enumerate}

现在，除了文本标签，所有的窗口部件看起来都很不错，文本标签仍显示为"\&{}Cell Location:"。单击Edit→Edit Buddies进入一种允许设置窗口部件伙伴(buddy)的特殊模式。然后，单击这个标签并把红色箭头拖到行编辑器上，释放鼠标按键。现在标签看起来应该显示为"\uline{C}ell Location:"，如图2.7所示，同时，它还会把行编辑器看成是自己的伙伴。单击Edit→Edit Widgets离开伙伴设置模式。

\begin{fig}[0.7]{designer2-7}
\caption{带属性设置的窗体}
\label{fig:designer2-7}
\end{fig}

下一步是在窗体中摆放这些窗口部件，步骤如下：
\begin{enumerate}
\item 单击"\uline{C}ell Location:"标签并且当单击与之相邻的行编辑器时按下Shift键，这样就可以同时选择它们。单击Form→Lay Out Horizontally。
\item 单击分隔符，然后在单击窗体的OK按钮和Cancel按钮时一直按下Shift键。单击Form→Lay Out Horizontally。
\item 单击窗体中的空白，取消对所有已选中项的选择，然后单击Form→Lay Out Vertically。
\item 单击Form→Adjust Size，重新把窗体的大小定义为最佳形式。
\end{enumerate}

在窗体上出现的红线就是已经创建的布局，如图2.8所示。但是在窗体运行的时候，它们是绝不会出现的。
\begin{fig}[0.7]{designer2-8}
\caption{带布局的窗体}
\label{fig:designer2-8}
\end{fig}

现在，单击Edit→Edit Tab Order。在每一个可以接受焦点的窗口部件上，都会出现一个带蓝色矩形的数字，如图2.9所示。按照你所希望的接受焦点的顺序单击每一个窗口部件，然后单击Edit→Edit Widget，离开Tab键顺序设置模式。

\begin{fig}[0.7]{designer2-9}
\caption{设置窗体的Tab键顺序}
\label{fig:designer2-9}
\end{fig}

要预览这个对话框，可单击Form→Preview菜单选项。通过重复按下Tab键来检查对话框Tab键的顺序。使用窗体标题栏上的Close按钮，可以关闭对话框。

把对话框保存到gotocell目录下，另存为gotocelldialog.ui，然后使用一个纯文本编辑器在同一目录下创建一个main.cpp文件，内容如下：
\begin{cppinput}{qt4-book/chap02/gotocell1/main.cpp}
\end{cppinput}

现在运行qmake，生成一个.pro文件和一个makefile文件（命令分别是：qmake-project; qmake gotocell.pro）。qmake工具非常智能，它可以自动检测到用户界面文件gotocelldialog.ui并且可以生成适当的makefile规则来调用Qt的用户界面编译器(user interface compiler , uic)。uic工具会将gotocelldialog.ui文件转换成C++并且将转换结果存储在ui\_{}gotocelldialog.h文件中。

所生成的ui\_{}tocelldialog.h文件中包含了类Ui::GoToCellDialog的定义，该类是一个与gotocelldialog.ui文件等价的C++文件。这个类声明了一些成员变量，它们存储着窗体中的子窗口部件和子布局，以及用于初始化窗体的setupUi()函数。生成的类看起来如下所示：
\begin{Verbatim}
class Ui::GoToCellDialog
{
public:
    QLabel *label;
    QLineEdit *lineEdit;
    QSpacerItem *spacerItem;
    QPushButton *okButton;
    QPushButton *cancelButton;
    ...
    void setupUi(QWidget *widget) {
    ...
    }
};
\end{Verbatim}

生成的类没有任何基类。当在main.cpp文件中使用该窗体时，可以创建一个QDialog对象，然后把它传递给setupUi()函数。

如果现在运行该程序，对话框也可以工作，但它并没有正确地实现所想要的那些功能：    
\begin{itemize}
\item OK按钮总是失效的。
\item Cancel按钮什么也做不了。
\item 行编辑器可以接受任何文本，而不是只能接受有效的单元格位置坐标。
\end{itemize}

通过写一些代码，就可以让对话框具有适当的功能。最为简捷的做法是创建一个新类，让该类同时从QDialog和Ui::GoToCellDialog中继承出来，并且由它来实现那些缺失的功能（从而也证明了这句话：通过简单地增加另外一个间接层就可以解决软件的任何问题）。命名惯例是：将该类与uic所生成的类具有相同的名字，只是没有Ui::前缀而已。

使用文本编辑器，创建一个名为gotocelldialog.h的文件，其中所包含的代码如下所示：
\begin{cppinput}{qt4-book/chap02/gotocell2/gotocelldialog.h}
\end{cppinput}


在这里，使用了public继承，这是因为我们想在该对话框的外面访问该对话框的窗口部件。包含在gotocelldialog.cpp文件中的实现代码如下所示：
\begin{cppinput}{qt4-book/chap02/gotocell2/gotocelldialog.cpp}
\end{cppinput}

在构造函数中，调用setupUi()函数来初始化窗体。正是由于使用了多重继承关系，可以直接访问Ui::GoToCellDialog中的成员。创建了用户接口后，setupUi()函数还会自动将那些符合on\_{}objectName\_{}signalName()命名惯例的任意槽与相应的objectName的signalName()信号连接到一起。在这个例子中，这就意味着setupUi函数将建立如下所示的信号－槽连接关系：
\begin{Verbatim}
connect(lineEdit, SIGNAL(textChanged(const QString &)),
        this, SLOT(on_lineEdit_textChanged()));
\end{Verbatim}

同样还是在构造函数中，设置了一个检验器来限制输入的范围。Qt提供了三个内置检验器类：QIntValidator、QDoubleValidator和QRegExpValidator。在这里使用检验器类QRegExpValidator，让它
带一个正则表达式\\ \verb+"[A-Za-z][1-9][0-9]{0,2}"+，它的意思是：允许一个大写或者小写的字母，后面
跟着一个范围为1～9的数字，后面再跟0个、1个或2个0～9的数字。（对于正则表达式的介绍，请查看参考文档中的QRegExp类。）

通过把this传递给QRegExpValidator的构造函数，使它成为GoToCellDialog对象的一个子对象。这样，以后就不用担心有关删除QRegExpValidator的事情了：当删除它的父对象时，它也会被自动删除。

Qt的父－子对象机制是在QOject中实现的。当利用一个父对象创建一个子对象（一个窗口部件，一个检验器，或是任意的其他类型）时，父对象会把这个子对象添加到自己的子对象列表中。当删除这个父对象时，它会遍历子对象列表并且删除每一个子对象。然后，这些子对象再去删除它们自己所包含的每个子对象。如此反复递归调用，直至清空所有子对象为止。这种父－子对象机制可在很大程度上简化内存管理工作，降低内存泄漏的风险。需要明确删除的对象是那些使用new创建的并且没有父对象的对象。并且，如果在删除一个父对象之前先删除了它的子对象，Qt会自动地从它的父对象的子对象列表中将其移除。

对于窗口部件，父对象还有另外一层含义：子窗口部件会显示在它的父对象所在的区域中。当删除这个父窗口部件时，不仅子对象会从内存中消失，而且它也会在屏幕上消失。

在构造函数的最后部分，我们将OK按钮连接到QDialog的accept()槽，将Cancel按钮连接到reject()槽。这两个槽都可以关闭对话框，但accept()槽可以将对话框返回的结果变量设置为QDialog::Accepted（其值等于1），而reject()槽会把对话框的值设置为QDialog::Rejected（其值等于0）。当使用这个对话框的时候，可以利用这个结果变量判断用户是否单击了OK按钮，从而执行相应的动作。

根据行编辑器中是否包含了有效的单元格位置坐标，on\_{}lineEdit\_{}textChang\linebreak ed()槽可以启用或者禁用OK按钮。QLineEdit::hasAcceptableInput()会使用在构造函数中设置的检验器来判断行编辑器中内容的有效性。

这样，就完成了这个对话框。现在可以通过重写main.cpp文件来使用这个对话框：
\begin{cppinput}{qt4-book/chap02/gotocell3/main.cpp}
\end{cppinput}

使用qmake -project命令重新生成gotocell.pro文件（因为已经在工程中添加了源文件），使用qmake gotocell.pro命令更新makefile文件，然后再次构建并运行应用程序。在行编辑器中输入"A12"，这时可以注意到OK按钮已经变为启用了。尝试输入一些随机文本来看看检验器是如何完成它的工作的。单击Cancel按钮关闭对话框。

这个对话框工作得很好，但对于Mac OS X用户，这些按钮却显得不够圆润。在前面采用了单独添加每个按钮的方法，这是为了可以让我们看出是如何完成这些步骤的，但我们本来的确是应当使用QDialogButtonBox的，它是一个可以容纳给定的按钮的窗口部件，可以让那些按钮以正确方式呈现在应用程序所运行的平台上，如图2.10所示。
\begin{fig}[0.7]{designer2-10}
\caption{Windows Vista和Mac OS X上的Go to Cell对话框}
\label{fig:designer2-10}
\end{fig}

要使用QDialogButtonBox来制作这个对话框，必须同时修改设计过程和上述代码。在Qt设计师中，一共需要4步：
\begin{enumerate}
\item 单击窗体（不是任何窗口部件或者布局），然后单击Form→Break Layout。
\item 单击并删除OK按钮、Cancel按钮、水平分隔符以及（现在为空的）水平布局。
\item 在窗体上拖放一个“按钮盒”(Button Box)，放在标签和行编辑器单元的下方。
\item 单击窗体，然后单击Form →Lay Out Vertically。
\end{enumerate}

如果只打算修改设计，比如修改对话框的布局和窗口部件的属性等，那么只要重新构建应用程序即可。但在这里是移除了一些窗口部件并且添加了一个新的窗口部件，所以在这种情况下，通常还必须对代码进行修改。

我们所必须做的修改都在gotocelldialog.cpp文件中。这里给出的是其构造函数的新版本：
\begin{cppline}{qt4-book/chap02/gotocell3/gotocelldialog.cpp}{5}{16}
\end{cppline}

在前一版本中，一开始在Qt设计师中禁用了OK按钮。但是在使用QDialogButtonBox之后就不能那样做了，因而可以在代码中调用setupUi()之后，再立即禁用OK按钮，这样也可以达到同样的效果。类QDialogButtonBox有一组标准按钮的枚举值，并且可以利用这一点来访问这些特殊的按钮，本例就是访问OK按钮。

非常方便的是Qt设计师对于QDialogButtonBox的默认名称就是buttonBox。双方的连接会从按钮盒而不是从按钮自己创建出来。在单击一个带AcceptRole的按钮时，就会发射accepted()信号，这一点与单击一个带RejectRole的按钮会发射rejected()信号的情况相似。默认情况下，标准的QDialogButtonBox::Ok按钮具有AcceptRole属性，而标准的QDialogButtonBox::Cancel按钮具有RejectRole属性。

还需要在\verb+on_lineEdit_textChanged+槽中做一处修改：
\begin{cppline}{qt4-book/chap02/gotocell3/gotocelldialog.cpp}{18}{22}
\end{cppline}

与之前的唯一不同之处在于不是对存储为成员变量的特殊按钮进行引用，而是直接去访问按钮盒中的OK按钮。

使用Qt设计师的一个好处就在于它为程序员在修改自己设计的窗体时提供了很大的自由，并且不必再强迫自己去修改源代码。当完全通过手写C++代码开发窗体时，对窗体设计的修改将会相当耗时。利用Qt设计师，由于uic会自动为那些发生了改变的窗体重新生成源代码，所以就不会再浪费时间了。对话框的用户交互界面会被保存为.ui文件（一种基于XML的文件格式），而通过对uic所生成的类进行子类化，就可以实现自定义的函数功能。

\section{改变形状的对话框}
我们已经看到了如何创建对话框，无论何时使用它们，这些对话框永远只会显示出一些相同的窗口部件。在某些情况下，人们非常希望能够提供一些可以改变形状的对话框。最常见的可改变形状的对话框有两种：扩展对话框(extension dialog)和多页对话框(multi-page dialog)。在Qt中，不论是纯粹使用代码还是使用Qt设计师，都可以实现这两种对话框。

扩展对话框通常只显示简单的外观，但是它还有一个切换按钮(toggle button)，可以让用户在对话框的简单外观和扩展外观之间来回切换。扩展对话框通常用于试图同时满足普通用户和高级用户需要的应用程序中，这种应用程序通常会隐藏那些高级选项，除非用户明确要求看到它们。在这一节中，将使用Qt设计师来创建如图2.11所示的扩展对话框。
\begin{linefig}[0.8]{sortdialog}
\caption{具有简单外观和扩展外观的Sort对话框}
\label{fig:sortdialog}
\end{linefig}

这个对话框是一个用于电子制表软件应用程序的排序对话框（Sort对话框），在这个对话框中，用户可以选择一列或多列进行排序。在这个简单外观中，允许用户输入一个单一的排序键，而在扩展外观下，还额外提供了两个排序键。More按钮允许用户在简单外观和扩展外观之间切换。

我们将在Qt设计师中创建这个对话框的扩展外观，并且在运行时根据需要隐藏排序的第二键和第三键。这个窗口部件看起来有些复杂，但在Qt设计师中可以轻而易举地完成它。简单的诀窍是首先完成主键部分，然后再复制并且粘贴两次就可以获得第二键和第三键所需的内容。

\begin{enumerate}
\item 单击File→New Form，并选择"Dialog without Buttons"模板。
\item 创建OK按钮并把它拖放到窗体的右上角。将它的objectName修改为"okButton"，并将它的default属性设置为"true"。
\item 创建Cancel按钮并把它拖放到OK按钮的下方。将它的objectName修改为"cancelButton"。
\item 创建一个垂直分隔符并把它拖放到Cancel按钮的下方，然后再创建一个More按钮。并将它放在垂直分隔符的下方。将More按钮的objectName修改为"moreButton"，text属性设置成"\&{}More"，checkable属性设置为"true"。
\item 单击OK按钮，按下Shift键后再单击Cancel按钮、垂直分隔符和More按钮，然后单击Form→Lay Out Vertically。
\item 创建一个群组框、两个标签、两个组合框以及一个水平分隔符，然后把它们放到窗体上的任意位置。
\item 拖动群组框的右下角使它变大一些。然后，把其他窗口部件移到群组框中，并且按照如图2.12(a)所示的那样把它们放置到适当位置。
\item 拖动第二个组合框的右边缘，使它的宽度大约为第一个组合框的两倍。
\item 将群组框的title属性设置为"\&{}Primary Key"，第一个标签的text属性设置为"Column:"，第二个标签的text属性设置为"Order:"。
\item 右键单击第一个组合框。从Qt设计师弹出的上下文菜单的组合框编辑器中选择EditItems。用文本"None"创建一个项。
\item 右键单击第二个组合框并且同样选择Edit Items。创建一个"Ascending"项和一个"Descending"项。
\item 单击群组框，然后单击Form-Lay Out in a Grid。再次单击群组框，并且单击Form→Adjust Size。此时将会产生一个如图2.12(b)所示的布局。
\end{enumerate}

\begin{linefig}[0.8]{sortlayout}
\caption{将群组框的子对象摆放到网格中}
\label{fig:sortlayout}
\end{linefig}

如果没能生成你所希望的那种布局效果，或者是不小心做错了，那么总是可以随时先通过单击Edit→Undo或Form→Break Layout，然后再重新放置这些要摆放的窗口部件，最后再试着对它们重新布局，直到满意为止。

现在来添加其他两个群组框：Secondary Key和Tertiary Key：
\begin{enumerate}
\item 让对话框窗口足够高，以便可以容纳另外两个部分。
\item 按下Ctrl键（在Mac中按下Alt键），然后单击并拖动Primary Key群组框，这样就可以在原群组框（以及它所包含的所有组件）的上方复制出一个新的群组框。仍旧按下Ctrl键（或Alt键），把复制的这个群组框拖动到原群组框的下方。重复以上步骤，就可以生成第三个群组框，然后把它拖动到第二个群组框的下方。
\item 将它们的title属性分别修改为"\&{}Secondary Key"和"\&{}Tertiary Key"。
\item 创建一个垂直分隔符，并且把它放到Primary Key群组框和Secondary Key群组框的中间。
\item 把这些窗口部件按图2.13(a)所示的那样排列成网格状。

\begin{linefig}[0.8]{sort2-13}
\caption{把窗体的各个子对象摆放到网格中}
\label{fig:sort2-13}
\end{linefig}

\item 单击窗体，取消对任意选中窗口部件的选择，然后单击Form→Lay Out in a Grid。现在，向上和向左拖动窗体的右下角，以便让窗体变得尽可能地小。现在，窗体应该和图2.13(b)中显示的一样了。
\item 把两个垂直分隔符的sizeHint属性设置为[20,0]。
\end{enumerate}

最终的网格布局是4行2列，一共有8个单元格。Primary Key群组框、最左边的垂直分隔符、Secondary Key群组框和Tertiary Key群组框各占一个单独的单元格。包含OK、Cancel和More按钮的垂直布局占用了两个单元格。最后，会在对话框的右下角剩下两个空白单元格。如果你做出来的对话框不是这样，那么请撤销布局，重新放置窗口部件的位置，然后再重新试试。

把这个窗体重命名为"SortDialog"，并且把它的标题修改为"Sort"。根据图2.14修改各个子窗口部件的名称。
\begin{linefig}[0.8]{sort2-14}
\caption{重新命名窗体中的各个窗口部件}
\label{fig:sort2-14}
\end{linefig}
  
单击Edit→Edit Tab Order，从窗体的最上面到最下面依次单击每个组合框，然后单击窗体右侧的OK、Cancel和More按钮。单击Edit→Edit Widgets离开Tab键顺序设置模式。

现在，窗体已经设计完成，可以开始着手设置一些信号－槽的连接来实现窗体的功能了。Qt设计师允许我们
在构成同一窗体的不同部分内的窗口部件之间建立连接。我们需要建立两个连接。

单击Edit→Edit Signals/Slots，进入Qt设计师的设置连接模式。窗体中各个窗口部件之间的连接用蓝色箭头表
示，如图2.15所示，并且它们也会同时在Qt设计师的signal/slot编辑器窗口中显示出来。要在两个窗口部件之间
建立连接，可以单击作为发射器的窗口部件并且拖动所产生的红色箭头线到作为接收器的窗口部件上，然后松开鼠标按键。这时会弹出一个对话框，可以从中选择建立连接的信号和槽。

\begin{fig}{sort2-15}
\caption{连接窗体的各个部件}
\label{fig:sort2-15}
\end{fig}

要建立的第一个连接位于okButton按钮和窗体的accept()槽之间。把从okButton按钮开始的红色箭头线拖动
到窗体的空白区域，然后松开按键，这样会弹出如图2.16所示的设置连接对话框(Configure Connection dialog)。从该对话框中选择clicked()作为信号，选择accept()作为槽，然后单击OK按钮。

对于第二个连接，把从cancelButton按钮开始的红色箭头线拖动到窗体的空白区域，然后在设置连接对话框中连接按钮的clicked()信号和窗体的reject()槽。

要建立的第三个连接位于moreButton按钮和secondayGroupBox群组框之间。在这两个窗口部件之间拖动红色箭头线，然后选择toggled(bool)作为信号，选择setVisible(bool)作为槽。默认情况下，setVisible(bool)槽不会显示在Qt设计师的槽列表中，但如果选中了"Show all signals and slots"选项，就可以看到这个槽了。

\begin{linefig}[0.8]{sort2-16}
\caption{Qt设计师的连接编辑器}
\label{fig:sort2-16}
\end{linefig}

第四个也是最后一个要建立的连接是moreButton按钮的toggled(bool)信号和tertiaryGroupBox群组框的setVisible(bool)槽之间的连接。这些连接一旦完成，就可以单击Edit→Edit Widgets而离开创建连接模式。

将这个对话框保存在sort目录中，文件名为sortdialog.ui。要给这个窗体添加代码，同样将使用在前一节的Go to Cell对话框设计中已经用过的多重继承的方法。

首先，用如下内容创建一个sortdialog.h文件：
\begin{cppinput}{qt4-book/chap02/sort/sortdialog.h}
\end{cppinput}

然后再创建sortdialog.cpp文件 :
\begin{cppinput}{qt4-book/chap02/sort/sortdialog.cpp}
\end{cppinput}

构造函数隐藏了对话框的第二键和第三键这两个部分。它也把有关窗体布局的sizeConstraint属性设置为QLayout::SetFixedSize，这样会使用户不能再重新修改这个对话框窗体的大小。这样一来，布局就会负责对话框重新定义大小的职责，并且也会在显示或者隐藏子窗口部件的时候自动重新定义这个对话框的大小，从而可以确保对话框总是能以最佳的尺寸显示出来。

setColumnRange()槽根据电子制表软件中选择的列初始化了这些组合框的内容。在（可选的）第二键和第三键的组合框选项中插入了一个"None"选项。

第26行和第27行给出了布局中的一个特殊习惯用语。QWidget::sizeHint()函数可以返回布局系统试图认同的“理想”大小。这也解释了为什么不同的窗口部件或者具有不同内容的类似窗口部件通常会被布局系统分配给不同的尺寸大小。对于这些组合框，这里指的是第二键组合框和第三键组合框，由于它们包含了一个"None"选项，所以它们要比只包含了一个单字符项目的主键组合框显得宽一些。为了避免这种不一致性，需要把主键组合框的最小大小设置成第二键组合框的理想大小。

这里是一个用于测试效果的main()函数，它首先设置了列的范围为从"C"到"F"，然后再显示这个对话框：
\begin{cppinput}{qt4-book/chap02/sort/main.cpp}
\end{cppinput}

这样就完成了这个扩展对话框。就像这个实例所显示的那样，设计一个扩展对话框并不比设计一个简单对话框难：所需要的就是一个切换按钮、一些信号－槽连接以及一个不可以改变尺寸大小的布局。在实际的应用程序中，控制扩展对话框的按钮通常会在只显示了基本对话框时显示为Advanced>>>，而在显示了扩展对话框时才显示为Advanced<<<。这在Qt中实现起来非常容易，只需在单击这个按钮时调用QPushButton中的setText()函数即可完成这一功能。

在Qt中，无论是使用手工编码的方式还是使用Qt设计师，都可以轻松地创建另一种常用的可以改变形状的对话框：多页对话框。可以通过多种不同的方式创建这种对话框：
\begin{itemize}
\item QTabWidget的用法就像它自己的名字一样。它提供了一个可以控制内置QStackedWidge的Tab栏。
\item QListWidget和QStackedWidget可以一起使用，将QListWidget::curre-ntRowChanged()信号与QStackedWidget::setCurrentIndex()槽连接，然后再利用QListWidget的当前项就可以确定应该显示QStackedWidget中的哪一页。
\item 与上述QListWidget的用法相似，也可以将QTreeWidget和QStackedWidget一起使用。
\end{itemize}

第6章将讲解QStackedWidget类。

\section{动态对话框}
动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件创建而来的那些对话框。动态对话框不需要通过uic把.ui文件转换成C++代码，相反，它是在程序运行的时候使用QUiLoader类载入该文件的，就像下面这种方式：
\begin{Verbatim}
QUiLoader uiLoader;
QFile file("sortdialog.ui");
QWidget *sortDialog = uiLoader.load(&file);
if (sortDialog) {
    ...
}
\end{Verbatim}

可以使用QObject::findChild<T>()来访问这个窗体中的各个子窗口部件：
\begin{Verbatim}
QComboBox *primaryColumnCombo =
    sortDialog->findChild<QComboBox *>("primaryColumnCombo");
if (primaryColumnCombo) {
    ...
}
\end{Verbatim}

这里的findChild<T>()函数是一个模板成员函数，它可以返回与给定的名字和类型相匹配的子对象。由于受编译器的制约，还不能在MSVC 6中使用该函数。如果需要使用MSVC 6编译器，那么可以通过调用全局函数qFindChild<T>()来代替该函数，这个全局函数同样也可以完全相同的方式工作。

QUiLoader类放在一个独立的库中。为了在Qt应用程序中使用QUiLoader，必须在这个应用程序的.pro文件中加入这一行内容：
\begin{Verbatim}
CONFIG += uitools
\end{Verbatim}

动态对话框使不重新编译应用程序而可以改变窗体布局的做法成为可能。动态对话框也同样可用于创建小型终端应用程序，这些程序只有一个内置的前端窗体，并且只是在需要的时候才会去创建所有的其他窗体。


\section{内置的窗口部件类和对话框类}
Qt提供了一整套内置的窗口部件和常用对话框，这可以满足绝大多数情况。在这一节，几乎给出了它们所有的屏幕截图。会在稍后提供那些少量的特殊窗口部件：第3章会讲到用于主窗口的那些窗口部件，如QMenuBar、QToolBar和QStatusBar等；第6章会讲到与布局相关的那些窗口部件，如QSplitter和QScrollArea等。在本书提供的实例中将会用到绝大多数内置窗口部件和对话框。所有这些窗口部件都会使用Plastique风格显示在从图2.17到图2.26的屏幕截图中。

如图2.17所示，Qt提供了4种类型的按钮：QPushButton、QToolButton、QCheckBox和QRadioButton。最常使用的就是QPushButton和QToolButton，当单击时，它们就能够发起一个动作，但它们也可以具有像切换按钮（按钮单击一次被按下，再单击一次会还原）一样的行为。复选框QCheckBox可用于打开/关闭单独的那些选项，而单选按钮QRadioButton通常用于需要互斥条件的地方。
\begin{linefig}[0.8]{widget2-17}
\caption{Qt的按钮窗口部件}
\label{fig:widget2-17}
\end{linefig}

Qt的容器窗口部件是一种可以包含其他窗口部件的窗口部件。图2.18和图2.19给出了这些容器窗口部件。QFrame也可用于它自身，这只是为了绘制一些直线，它也可以用作许多其他窗口部件的基类，如QToolBox和QLabel等。
\begin{linefig}[0.8]{widget2-18}
\caption{Qt的单页容器窗口部件}
\label{fig:widget2-18}
\end{linefig}

QTabWidget和QToolBox是多页窗口部件。在多页窗口部件中，每一页都是一个子窗口部件，并从0开始编号这些页。对于一个QTabWidget，它的每个Tab标签的形状和位置都可以进行设置。如图2.20所示，为处理较大的数据量，这些项视图已经进行了优化，并且会经常使用它们的滚动条(scroll bar)。滚动条机制是在QAbstractScrollArea中实现的，它是所有项视图和其他类型的可滚动窗口部件的基类。 

\begin{linefig}[0.8]{widget2-19}
\caption{Qt的多页容器窗口部件}
\label{fig:widget2-19}
\end{linefig}


Qt库含有一个富文本引擎(rich text engine)，它可用于格式化文本的显示和编辑。该引擎支持字体规范、文本对齐、列表、表格、图片和超文本链接等。可以通过编程的方式一个元素一个元素地生成富文本文档，或者也可以通过所提供的HTML格式的文本来生成富文本文档。至于该引擎所支持的HTML标记和CSS属性的详细说明，请参见\href{http://doc.trolltech.com/4.3/richtext-html-subset.html}{文档}。

\begin{linefig}[0.8]{widget2-20}
\caption{Qt的项视图窗口部件}
\label{fig:widget2-20}
\end{linefig}

如图2.21所示，Qt提供了一些纯粹用于显示信息的窗口部件。QLabel是这些窗口部件中最重要的一个，并且它也可以用来显示普通文本、HTML和图片。

\begin{linefig}[0.8]{widget2-21}
\caption{Qt的显示窗口部件}
\label{fig:widget2-21}
\end{linefig}

QTextBrowser是一个只读型QTextEdit子类，它可以显示带格式的文本。对于大型格式化文本文档的处理优先使用这个类而不是QLabel，因为它与QLabel不同，它会在必要时自动提供滚动条，同时还提供了键盘和鼠标导航的广泛支持。Qt 4.3助手就是使用QTextBrowser来为用户呈现文档的。

Qt提供了数个用于数据输入的窗口部件，如图2.22所示。QLineEdit可以使用一个输入掩码、一个检验器或者同时使用两者对它的输入进行限定。QTextEdit是QAbstractScrollArea的子类，具有处理大量文本的能力。一个QTextEdit可设置用于编辑普通文本或者富文本。在编辑富文本的时候，它可以显示Qt富文本引擎所支持的所有元素。QLineEdit和QTextEdit两者都对剪贴板提供完美支持。

\begin{linefig}[0.8]{widget2-22}
\caption{Qt的输入窗口部件}
\label{fig:widget2-22}
\end{linefig}

如图2.23所示，Qt提供了一个通用消息框和一个可以记住它所显示的消息内容的错误对话框。可以使用QProgressDialog或者使用图2.21中显示的QProgressBar来对那些非常耗时的操作进度进行指示。当用户只需要输入一行文本或者一个数字的时候，使用QInputDialog会显得非常方便。

\begin{linefig}[0.8]{widget2-23}
\caption{Qt的反馈对话框}
\label{fig:widget2-23}
\end{linefig}

Qt提供了一套标准的通用对话框，这样可以让用户很容易地选择颜色、字体、文件或者文档打印。图2.24和图2.25显示了这些对话框。
\begin{linefig}[0.8]{widget2-24}
\caption{Qt的颜色对话框和字体对话框}
\label{fig:widget2-24}
\end{linefig}

\begin{linefig}[0.8]{widget2-25}
\caption{Qt的文件对话框和打印对话框}
\label{fig:widget2-25}
\end{linefig}

在Windows和Mac OS X上，Qt有可能会使用本地系统的对话框，而不是它自己的通用对话框。颜色的选取也可以使用Qt Solutions的某个颜色选择窗口部件来完成，而字体也可以使用内置的QFontComboBox来选择。

最后，QWizard为生成向导（wizard，在Mac OS X上也称为助手）提供了一个基本框架。对于那些用户可能会难于理解的复杂或者不常见的工作，向导会非常有用。图2.26给出了使用向导的一个例子。

\begin{linefig}[0.8]{widget2-26}
\caption{Qt的QWizard对话框}
\label{fig:widget2-26}
\end{linefig}

内置窗口部件和常用对话框为用户提供了很多可以直接使用的功能。通过设置窗口部件的属性，或者是通过把信号和槽连接起来并在槽里实现自定义的行为，通常就可以满足许多更为复杂的需求。

如果Qt所提供的窗口部件或者常用对话框没有一个合适，那么可以从Qt Solutions，或者从商业或非商业的第三方软件中找到一个可用的。Qt Solutions提供了许多额外的窗口部件，包括各种颜色选择器、一个手轮控制器、许多饼状图菜单以及属性浏览器等，还有一个复制对话框。

在某些情况下，你可能希望手动创建一个自定义窗口部件。Qt使这种工作变得很简单，并且自定义窗口部件也可以像Qt的内置窗口部件一样获得与平台无关的所有相同绘制功能。自定义窗口部件甚至可以集成到Qt设计师中，这样就可以像使用Qt的内置窗口部件一样来使用它们。第5章将讲述如何创建自定义窗口部件。


\chapter{创建主窗口}
这一章讲解如何使用Qt创建主窗口。在本章的最后部分，你将能够创建一个应用程序的完整用户界面，包括菜单、工具栏、状态栏以及应用程序所需的足够多的对话框。

应用程序的主窗口提供了用于构建应用程序用户界面的框架。如图3.1所示的Spreadsheet（电子制表）应用程序的主窗口将构成本章的基础。这个Spreadsheet应用程序使用了在第2章中创建的三个对话框：Find、Go to Cell和Sort。
\begin{linefig}[0.9]{spreadsheet}
\caption{Spreadsheet应用程序}
\label{fig:spreadsheet}
\end{linefig}

在绝大多数图形用户界面应用程序的后台，都有一套提供底层功能的代码——例如，用于读写文件或者用于处理用户界面中的数据的代码。在第4章，将会再次把Spreadsheet应用程序当作实例，看看如何实现这些功能。

\section{子类化QMainWindow}
通过子类化QMainWindow，可以创建一个应用程序的主窗口。由于QDialog和QMainWindow都派生自QWidget，所以在第2章中看到的许多创建对话框的技术，对于创建主窗口也同样适用。

可以使用Qt设计师创建应用程序的主窗口，但是在这一章，将使用代码来完成所有的功能，以便可以说明它们是如何完成的。如果你更喜欢可视化的方式，可以参考Qt设计师在线手册中的"Creating a Main Window Application"一章。

Spreadsheet应用程序主窗口的源代码分别放在mainwindow.h和mainwindow.cpp中。先从头文件开始分析：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{1}{19}
\end{cppline}

我们将MainWindow类定义为QMainWindow类的子类。由于类MainWindow提供了自己的信号和槽所以它包含了Q\_{}OBJECT宏。

closeEvent()函数是QWidget类中的一个虚函数，当用户关闭窗口时，这个函数会被自动调用。类MainWindow中重新实现了它，这样就可以向用户询问一个标准问题"Do you want to save your changes?"，并且可以把用户的一些偏好设置保存到磁盘中。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{21}{29}
\end{cppline}

像File→New和Help→About这样的菜单项，在MainWindow中会被实现为私有槽。除了save()槽和saveAs()槽返回一个bool值以外，绝大多数的槽都把void作为它们的返回值。当槽作为一个信号的响应函数而被执行时，就会忽略这个返回值；但是当把槽作为函数来调用时，其返回值对我们的作用就和调用任何一个普通的C++函数时的作用是相同的。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{30}{47}
\end{cppline}

为了能够对用户界面提供支持，主窗口需要更多的私有槽以及数个私有函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{49}{0}
\end{cppline}

除了它自己的私有槽和私有函数以外，MainWindow类还有很多私有变量。当用到这些私有槽和私有函数时，将再对它们进行解释。

现在来看看实现文件：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{1}{7}
\end{cppline}

我们包含了<QtGui>头文件，其中包含了在子类中所要用到的所有Qt类的定义。我们也包含了一些自定义头文件，特别是来自第2章的finddialog.h、gotocelldialog.h和sortdialog.h三个头文件。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{9}{26}
\end{cppline}

在这个构造函数中，先从创建一个Spreadsheet窗口部件并且把它设置为这个主窗口的中央窗口部件开始。中央窗口部件会占用主窗口的中央区域部分（如图3.2所示）。Spreadsheet类是QTableWidget类的一个子类，并且也具有一些电子制表软件的功能，如对电子制表软件公式的支持等。将会在第4章中实现这一功能。

私有函数createActions()、createMenus()、createContextMenu()、createToolBars()和createStatusBar()创
建主窗口中的其余部分，readSettings()则读取这个应用程序存储的一些设置。
\begin{linefig}[0.8]{spreadsheet3-2}
\caption{QMainWindow中的区域分配}
\label{fig:spreadsheet3-2}
\end{linefig}

我们把findDialog指针初始化为空(null)指针。在第一次调用MainWindow::find()函数时，将会创建该FindDialog对象。

在构造函数的最后部分，把窗口的图标设置为icon.png，它是一个PNG格式的文件。Qt支持很多图像格式，包括BMP、GIF、JPEG、PNG、PNM、SVG、TIFF、XBM和XPM。调用QWidget::setWindowIcon()函数可以设置显示在窗口左上角的图标。遗憾的是，还没有一种与平台无关的可在桌面上显示应用程序图标的设置方法。与平台相关的桌面图标设置方法在\href{http://doc.trolltech.com/4.3/appicon.html}{这个网页}中进行了阐述。


图形用户界面(GUI)应用程序通常会使用很多图片。为应用程序提供图片的方法有多种，如下是一些最常用的方法：
\begin{itemize}
\item 把图片保存到文件中，并且在运行时载入它们。
\item 把XPM文件包含在源代码中。（这一方法之所以可行，是因为XPM文件也是有效的C++文件。）
\item 使用Qt的资源机制(resource mechanism)。
\end{itemize}

这里，使用了Qt的资源机制法，因为它比运行时载入文件的方法更方便，并且该方法适用于所支持的任意文件格式。我们将选中的图片存放在源代码树中名为images的子目录下。

为了利用Qt的资源系统(resource system)，必须创建一个资源文件(resource file)，并且在识别该资源文件的.pro文件中添加一行代码。在这个例子中，已经将资源文件命名为spreadsheet.qrc，因此只需在.pro文件中添加如下一行代码：
\begin{Verbatim}
RESOURCES = spreadsheet.qrc
\end{Verbatim}

资源文件自身使用了一种简单的XML文件格式。这里给出的是从已经使用的资源文件中摘录的部分内容：
\begin{Verbatim}
<RCC>
<qresource>
    <file>images/icon.png</file>
    ...
    <file>images/gotocell.png</file>
</qresource>
</RCC>
\end{Verbatim}

所有资源文件都会被编译到应用程序的可执行文件中，因此并不会弄丢它们。当引用这些资源时，需要使用带路径前缀\verb+:/+（冒号斜线）的形式，这就是为什么会将图标表示成:/images/icon.png的形式。资源可以是任意类型的文件（并非只是一些图像），并且可以在Qt需要文件名的大多数地方使用它们。第12章将对此做进一步说明。  

\section{创建菜单和工具栏}
绝大多数现代图形用户界面应用程序都会提供一些菜单、上下文菜单和工具栏。菜单可以让用户浏览应用程序并且可以学会如何处理一些新的事情，上下文菜单和工具栏则提供了对那些经常使用的功能进行快速访问的方法。图3.3展示的是Spreadsheet应用程序的菜单。
\begin{linefig}[0.9]{spreadsheet3-3}
\caption{Spreadsheet应用程序中的菜单}
\label{fig:spreadsheet3-3}
\end{linefig}

Qt通过“动作”的概念简化了有关菜单和工具栏的编程。一个动作(action)就是一个可以添加到任意数量的菜单和工具栏上的项。在Qt中，创建菜单和工具栏包括以下这些步骤：
\begin{itemize}
\item 创建并且设置动作。
\item 创建菜单并且把动作添加到菜单上。
\item 创建工具栏并且把动作添加到工具栏上。
\end{itemize}

在这个Spreadsheet应用程序中，动作是在createActions()函数中创建的：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{163}{169}
\end{cppline}

动作New有一个加速键(\uline{N}ew)、一个父对象（主窗口）、一个图标、一个快捷键和一个状态提示。大多数窗口系统都有用于特定动作的标准化的键盘快捷键。例如，在Windows、KDE和GNOME中，这个New动作就有一个快捷键Ctrl+N，而在Mac OS X中则是Command+N。通过使用适当的QKeySequence::StandardKey枚举值，就可以确保Qt能够为应用程序在其运行的平台上提供正确的快捷键。

把这个动作的triggered()信号连接到主窗口的私有槽newFile()——将会在下一节实现它。这个连接可以确保在用户选择File→New菜单项、选择工具栏上的New按钮或者按下Ctrl+N时，都可以调用newFile()槽。

由于菜单中的Open、Save和Save As动作与New动作非常相似，所以将会直接跳到File菜单中的"recently opened files"（最近打开的文件）的部分。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{188}{193}
\end{cppline}

我们为recentFileActions数组添加动作。每个动作都是隐式的，并且会被连接到openRencentFile()槽。稍后，将会看到如何读这些最新文件中的动作变得可见并且可用。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{195}{198}
\end{cppline}

这个Exit动作与目前为止所看到的那些动作稍微有些不同。由于没有用于终止应用程序的标准化键序列，所以需要在这里明确指定键序列。另外一个不同之处是我们连接的是窗口的close()槽，而它是由Qt提供的。

现在，可以跳到Select All动作中：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{241}{246}
\end{cppline}

由于槽selectAll()是由QTabelWidget的父类之一的QAbstractItemView提供的，所以就没有必要再去亲自实现它。

现在，不妨进一步跳到Options菜单中的Show Grid动作中去：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{273}{279}
\end{cppline}

Show Grid是一个复选(checkable)动作。复选动作在菜单中显示时会带一个复选标记，并且在工具栏中它可以实现成切换(toggle)按钮。当启用这个动作时，Spreadsheet组件就会显示一个网格。我们用Spreadsheet组件的默认值来初始化这个动作，这样它们就可以从一开始就同步起来。然后，把Show Grid动作的toggled(bool)信号和Spreadsheet组件的setShowGrid(bool)槽连接起来，这个槽继承自QTableWidget。一旦把这个动作添加到菜单或者工具栏中，用户就可以对网格的显示与否进行切换了。

Show Grid动作和Auto-Recalculate动作是相互独立的两个复选动作。通过QActionGroup类的支持，Qt也可以支持相互排斥的动作。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{298}{301}
\end{cppline}

对于About Qt动作，通过访问qApp全局变量，我们可以使用QApplication对象的aboutQt()槽。这个动作会弹出一个如图3.4所示的对话框。
\begin{linefig}[0.8]{spreadsheet3-4}
\caption{About Qt对话框}
\label{fig:spreadsheet3-4}
\end{linefig}

现在已经创建了这些动作，还可以继续构建一个包含这些动作的菜单系统：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{303}{314}
\end{cppline}

在Qt中，菜单都是QMenu的实例。addMenu()函数可以用给定的文本创建一个QMenu窗口部件，并且会把它添加到菜单栏中。QMainWindow::menuBar()函数返回一个指向QMenuBar的指针。菜单栏会在第一次调用menuBar()函数的时候就创建出来。

从创建File菜单开始，然后再把New、Open、Save、Save As动作添加进去。插入一个间隔器(separator)，可以从视觉上把关系密切的这些项放在一起。使用一个for循环从recentFileActions数组中添加一些动作（最初是隐藏起来的），然后在最后添加一个exitAction动作。

我们已经让一个指针指向了这些间隔器中的某一个。这样就可以允许隐藏（如果没有最近文件的话）或者显示那个间隔器，因为不希望出现在两个间隔器之间什么都没有的情况。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{316}{329}
\end{cppline}

现在来创建Edit菜单，就像在File菜单中所做的那样使用QMenu::addMenu\linebreak ()函数添加各个动作，并且在希望出现子菜单的地方使用QMenu::addMenu()函数添加子菜单。一个子菜单与它所属的菜单一样，也是一个QMenu。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{331}{344}
\end{cppline}

通过类似的方式创建Tools、Options和Help菜单。在Options菜单和Help菜单之间插入一个间隔器。对于Motif和CDE风格，这个间隔器会把Help菜单放到菜单栏的最右端；对于其他的风格，则将会忽略这个间隔器。图3.5是这两种情况的示意图。

\begin{linefig}[0.8]{spreadsheet3-5}
\caption{Motif和Windows风格下的菜单栏}
\label{fig:spreadsheet3-5}
\end{linefig}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{346}{352}
\end{cppline}

任何Qt窗口部件都可以有一个与之相关联的QActions列表。要为该应用程序提供一个上下文菜单，可以将所需要的动作添加到Spreadsheet窗口部件中，并且将那个窗口部件的上下文菜单策略(context menu policy)设置为一个显示这些动作的上下文菜单。当用户在一个窗口部件上单击鼠标右键，或者是在键盘上按下一个与平台相关的按键时，就可以激活这些上下文菜单。Spreadsheet中的上下文菜单如图3.6所示。
\begin{fig}[0.6]{spreadsheet3-6.png}
\caption{Spreadsheet应用程序中的上下文菜单}
\label{fig:spreadsheet3-6.png}
\end{fig}

一种更为高级的提供上下文菜单方法是重新实现QWidget::contextMenuEve-nt()函数，创建一个QMenu窗口部件，在其中添加所期望的那些动作，并且再对该窗口部件调用exec()函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{354}{368}
\end{cppline}

创建工具栏与创建菜单的过程很相似，我们据此创建一个File工具栏和一个Edit工具栏。就像菜单一样，工具栏也可以有多个间隔器，如图3.7所示。
\begin{linefig}[0.6]{spreadsheet3-7.png}
\caption{Spreadsheet应用程序的工具栏}
\label{fig:spreadsheet3-7.png}
\end{linefig}


\section{设置状态栏}
随着菜单和工具栏的完成，已经为设置Spreadsheet应用程序的状态栏做好了准备。在程序的普通模式下，状态栏包括两个状态指示器：当前单元格的位置和当前单元格中的公式。状态栏也用于显示状态提示和其他一些临时消息。图3.8给出了各种情况下的状态栏。
\begin{linefig}[0.7]{spreadsheet3-8.png}
\caption{Spreadsheet应用程序的状态栏}
\label{fig:spreadsheet3-8.png}
\end{linefig}

MainWindow的构造函数会调用createStatusBar()来设置状态栏。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{370}{388}
\end{cppline}

QMainWindow::statusBar()函数返回一个指向状态栏的指针。\footnote{在第一次调用statusBar()函数的时候会创建状态栏。}状态栏指示器是一些简单的QLabel，可以在任何需要的时候改变它们的文本。已经在formulaLabel中添加了一个缩进格式，以便让那些在它里面显示的文本能够与它的左侧边有一个小的偏移量。当把这些QLabel添加到状态栏的时候，它们会自动被重定义父对象，以便让它们成为状态栏的子对象。

图3.8所示的两个标签都有不同的空间需求。单元格定位指示器只需要非常小的空间，并且在重新定义窗口大小时，任何多余的空间都会分配给位于右侧的单元格公式指示器。这是通过在公式标签的QStatusBar::addWidget()调用中指定一个伸展因子$ 1 $而实现的。位置指示器的默认伸展因子为$ 0 $，这也就意味着它不喜欢被伸展。

当QStatusBar摆放这些指示器窗口部件时，它会尽量考虑由QWidget::size-Hint()提供的每一个窗口部件的理想大小，然后再对那些可伸展的任意窗口部件进行伸展以填满全部可用空间。一个窗口部件的理想大小取决于这个窗口部件的内容以及改变内容时的变化大小。为了避免对定位指示器连续不断地重定义大小，设置它的最小尺寸大小为它所能包含的最大字符数("W999")和一些空格的总大小。还把它的对齐方式设置为Qt::AlignHCenter，以便可以在水平方向上居中对齐它的文本。

在函数结尾的附近，把Spreadsheet的两个信号和MainWindow的两个槽，updateStatusBar()和spreadsheetModified()，连接了起来。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{151}{155}
\end{cppline}

updateStatusBar()槽可以更新单元格定位指示器和单元格公式指示器。只要用户把单元格光标移动到一个新的单元格，这个槽就会得到调用。该槽也可以作为一个普通函数而在createStatusBar()的最后用于初始化这些指示器。因为Spreadsheet不会在一开始的时候就发射currentCellChanged()小心，所以还必须这样做。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{157}{161}
\end{cppline}

spreadsheetModified()槽把windowModified属性设置为true，用以更新标题栏。这个函数也会更新位置和公式指示器，以便可以让它们反映事件的当前状态。

\section{实现File菜单}
在这一节中，将实现那些能够让File菜单项正常工作并且能够对最近打开文件进行管理的槽函数和私有函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{38}{44}
\end{cppline}

当用户点击File→New菜单项或者单击工具栏上的New按钮时，就会调用newFile()槽。如果存在还没有被保存的信息，okToContinue()私有函数就会弹出如图3.9所示的对话框："Do you want to save your changes?"。如果用户选择Yes或者No（保存文档应该选择Yes），这个函数会返回true；如果用户选择Cancel，它就返回false。Spreadsheet::clear()函数会清空电子制表软件中的全部单元格和公式。setCurrentFile()私有函数会更新窗口的标题，以说明正在编辑的是一个没有标题的文档，它还会设置curFile私有变量并且更新最近打开文件的列表。  
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{416}{431}
\end{cppline}

在okToContinue()函数中，会检测windowModified属性的状态。如果该属性的值是true，就显示一个如图3.9所示的消息框。这个消息框包含一个Yes按钮、一个No按钮和一个Cancel按钮。
\begin{linefig}[0.8]{spreadsheet3-9}
\caption{"Do you want to save your changes?"消息框}
\label{fig:spreadsheet3-9}
\end{linefig}

QMessageBox提供了许多标准按钮，并且会自动尝试着让其中的一个成为默认的确认按钮（在用户按下Enter键时会得到激活），一个成为默认的退出按钮（在用户按下Esc时会得到激活）。选择一些特殊的按钮作为默认的确认按钮和退出按钮也是有可能的，用户还可以自定义按钮中将要显示的文本内容。

当首次看到warning()函数调用时，可能会觉得它有点复杂，但这种常用语法实际上是相当简单的：
\begin{Verbatim}
QMessageBox::warning(parent, title, message, buttons);
\end{Verbatim}

除了warning()之外，QMessageBox还提供了information()、question()和critical()函数，它们每一个都有自己特定的图标，这些图标如图3.10所示。
\begin{linefig}[0.8]{spreadsheet3-10.png}
\caption{Windows风格下的消息框图标}
\label{fig:spreadsheet3-10.png}
\end{linefig}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{46}{55}
\end{cppline}

open()槽对File→Open做出响应。就像newFile()一样，它首先调用okToContinue()函数来处理任何没有被保存的变化。然后它使用方便的QFileDialog::getOpenFileName()静态函数从用户那里获得一个新的文件名。这个函数会弹出一个文件对话框，让用户选择一个文件，并且返回这个文件名——或者，如果用户单击了Cancel按钮，则返回一个空字符串。

传递给QFileDialog::getOpenFileName()函数的第一个参数是它的父窗口部件。用于对话框和其他窗口部件的这种父子对象关系意义并不相同。对话框通常都拥有自主权，但是如果它有父对象，那么在默认情况下，它就会居中放到父对象上。一个子对话框也会共用它的父对象的任务栏。

第二个参数是这个对话框应当使用的标题。第三个参数告诉它应当从哪一级目录开始，在这个例子中就是当前目录。

第四个参数指定了文件过滤器。文件过滤器(filter)由一个描述文本和一个通配符组成。如果除了要支持Spreadsheet本地文件格式以外，还需要支持采用逗号分隔的数据文件和Lotus 1-2-3文件，就应当使用如下的文件过滤器：
\begin{Verbatim}
tr("Spreadsheet files (*.sp)\n"
"Comma-separated values files (*.csv)\n"
"Lotus 1-2-3 files (*.wk1 *.wks)")
\end{Verbatim}

loadFile()私有函数是在open()中得到调用的，它用来载入文件。我们让它成为一个独立的函数，是因为会在载入最近打开的文件中使用同样的功能。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{433}{443}
\end{cppline}

我们使用Spreadsheet::readFile()函数从磁盘中读取文件。如果载入成功，会调用setCurrentFile()函数来更新这个窗口的标题；否则，Spreadsheet::readFile()将会通过一个消息框把遇到的问题通知给用户。在通常情况下，让底层组件来报告错误消息是一个不错的习惯，这是因为它们可以提供准确的错误细节信息。

在上述两种情况下，都会在状态栏中显示一个消息2秒（2000毫秒），这样可以通知用户应用程序正在做什么。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{57}{64}
\end{cppline}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{445}{455}
\end{cppline}

save()槽对File→Save做出响应。如果因为这个文件是之前打开的文件或者它是一个已经保存过的文件，这样已经有了一个名字，那么save()函数就会用这个名字调用saveFile()函数；否则，它只是简单地调用saveAs()函数。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{66}{75}
\end{cppline}

saveAs()槽对File→Save As做出响应。调用QFileDialog::getSaveFileName()函数来从用户那里得到一个文件名。如果用户单击了Cancel，则返回false，这将会使这个结果向上传递给它的调用者[save()或者okToContinue()]。

如果给定的文件已经存在，getSaveFileName()函数将会要求用户确认是否需要覆盖该文件。但通过给getSaveFileName()函数传递一个QFileDialog::DontConfirmOverwrite附加参数，则可以改变这一行为。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{28}{36}
\end{cppline}

当用户单击File→Exit或者单击窗口标题栏中的关闭按钮时，将会调用QWidget::close()槽。该槽会给窗口部件发射一个“close”事件。通过重新实现QWidget::closeEvent()函数，就可以中途截取对这个主窗口的关闭操作，并且可以确定到底是不是真的要关闭这个窗口。

如果存在未保存的更改并且用户选择了Cancel，就会“忽略”这个关闭事件并且让这个窗口不受该操作的影响。一般情况下，我们会接受这个事件，这会让Qt隐藏该窗口。也可以调用私有函数writeSettings()来保存这个应用程序的当前设置。

当最后一个窗口关闭后，这个应用程序就结束了。如果需要，通过把QApplication的quitOnLastWindowClosed属性设置为false，可以禁用这种行为。在这种情况下，该应用程序将会持续保持
运行，直到调用QApplication::quit()函数，程序才会结束。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{457}{472}
\end{cppline}
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{497}{500}
\end{cppline}


在setCurrentFile()中，对保存正在编辑的文件名的curFile私有变量进行了设置。在把这个文件名显示在标题栏中之前，需要使用strippedName()函数移除文件名中的路径字符，这样可以使文件名看起来更友好一些。   

每个QWidget都有一个windowModified属性，如果该窗口的文档存在没有保存的变化，则应当把它设置为true，否则应当将其设置为false。在Mac OS X下，未保存的文档是通过窗口标题栏上关闭按钮中的一个点来表示的；在其他平台下，则是通过文件名字后跟一个星号来表示的。Qt会自动处理这一行为，只要始终让windowModified属性保持为当前最新状态，并且当需要显示星号的时候，把"[*]"标记放在窗口的标题栏上即可。

传递给setWindowTitle()函数的文本是：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{470}{471}
\end{cppline}





%附录
\appendix

\part{附录}
\chapter{面向Java和C\#{}程序员的C++简介}
这个附录为已经熟知Java或者C\#{}的开发人员提供一个关于C++的简短介绍。这里假定你已经熟悉了面向对象中的那些概念，如继承和多态，并且认为你也的确是想学习C++。为了不让本书变成一部厚达1500页的涵盖全部C++入门知识的不实用的“大部头”，所以要把这个附录仅仅限定在基本知识的范围内：只给出用来理解本书其他部分所示例子的基本知识和方法，但这些知识也足以使用Qt开发跨平台的C++图形用户界面应用程序。

在编写这本书的时候，C++是开发跨平台、高性能、面向对象的图形用户界面应用程序的唯一现实选择。而一些别有用心的批评者也可能会指出，Java或者C\#{}具有更好的可用性，而C++则降低了C的兼容性。实际上，作为C++发明人的Bjarne Stroustrup，他在"The Design and Evolution of C++"(Addison-Wesley，1994)一书中早就指出：“即使有C++，还可以找出更小、更简洁的语言”。

幸运的是，在使用Qt进行编程的时候，我们通常只关注于C++的子类，这非常接近于Stroustrup所设想的“乌托邦”式的编程语言，从而能够让我们集中精力去解决手头的问题。此外，通过Qt独创性的“信号和槽”机制、对统一字符编码标准的支持以及foreach关键字，Qt也在多个方面扩展了C++。

在这个附录的第一节中，将会看到如何使用C++的源文件产生一个可执行程序。这将可以引导我们探索C++的一些核心概念，如编译单元、头文件、目标文件、库等，并且也可以让我们逐步熟悉C++的预处理器、编译器和连接器。

然后，会转到对C++、Java和C\#{}这些主要语言不同点的说明上：如何定义类，如何使用指针和引用，如何重载运算符，如何使用预处理器，等等。尽管C++语法从表面上看与Java或者C\#{}的语法很相似，但从深层意义上来讲，这些概念却稍微显得不尽相同。同时，作为Java和C\#{}的创意之源，C++语言也与这两种语言有着诸多相同之处，包括相似的数据类型，同样的数学运算符，以及同样的基本控制流语句等。

最后一节专门用于说明标准C++库，该库提供了可用于任意C++程序中的完善功能。这个库是30多年来演化的结果，并且因此提供了涵盖程序、面向对象、函数编程风格以及宏和模板等方面的诸多方法。与Java和C\#{}提供的库相比，标准C++库的范围显得有些窄。比如，标准C++库不支持图形用户界面程序设计、多线程、数据库、国际化、网络、XML或者统一字符编码标准。要在这些领域进行开发，C++程序员则可能要使用各种各样（通常是与平台相关的）的库。

这就是为什么说Qt可以节约时间的原因。Qt首先作为跨平台的图形用户界面工具包（一个让编写可移植图形用户界面应用程序成为可能的类的集合）而起步，但很快发展成为一个成熟的程序开发框架，它对标准C++库进行了部分扩展和部分替换。尽管本书使用的是Qt，但是如果能够知道标准C++库到底提供了哪些功能也是很有用的，因为你有可能需要去处理一些使用了那些功能的代码。

\section{C++入门}
一个C++程序由一个或者多个编译单元(compilation unit)构成。每个编译单元都是一个独立的源代码文件，通常是一个带.cpp扩展名（其他常用的扩展名还有.cc和.cxx）的文件，编译器每次可以处理一个这样的文件。对于每一个编译单元，编译器都会产生一个目标文件，它的扩展名是.obj（在Windows中）或者.o（在UNIX和Mac OS X中）。这个目标文件是一个二进制文件，其中包含了系统架构方面的机器代码，而程序则要运行在此基础之上。  

一旦所有的.cpp文件都已编译完成，那么我们就可以使用一个称为连接器的特殊程序，把这些目标文件连接在一起，生成一个可执行程序。连接器会连接这些目标文件，并且会解析函数和编译单元中引用到的其他符号的内存地址。

在构建一个程序时，必须确保其中的某个编译单元包含一个main()函数，它是程序入口的标志。这个函数不属于任何类，它是一个全局函数(global function)。图D.1给出了这一过程的原理图。
\begin{fig}[0.8]{c++compilation}
\caption{C++的编译过程（在Windows中）}
\label{fig:c++compilation}
\end{fig}

不像Java的每一个源文件都必须严格包含一个类那样，C++可以按我们想要的形式组织各个编译单元。我们可以在同一个.cpp文件中实现多个类，或者也可以把一个类的实现分散到多个.cpp文件中，并且还可以把这些源文件命名为我们所喜欢的任意名字。当在某一个特殊的.cpp文件中进行修改时，只需要重新编译那个文件，然后再重新连接这个应用程序就可以生成一个新的可执行程序。

在进一步深入学习之前，让我们快速看一个C++小程序的源代码，该程序可以计算一个整数的平方。这个程序由两个编译单元构成：main.cpp和square.cpp。

这是square.cpp文件中的内容：
\begin{cppinput}{qt4-book/appendixD/square/square.cpp}
\end{cppinput}

这个文件只简单包含了一个称为square()的全局函数，它可以返回所带参数的平方值。

这里是main.cpp文件中的内容：
\begin{cppinput}{qt4-book/appendixD/square/main.cpp}
\end{cppinput}

源文件main.cpp包含了main()函数的定义。在C++中，这个函数的参数是一个int和一个char * 数组（一个字符串数组）。可以从argv[0]中获取程序的名字，命令行参数则分别放在argv[1]、argv[2]、$\cdots$、argv[argc-1]中。把参数命名为argc（argument count，参数个数）和argv（argument values，参数值）是一种习惯性的做法。如果这个程序不能使用命令行参数，那么可以把main()定义成不带参数的形式。
 
 这个main()函数使用标准C++库中的strtod()（即“string转换到double”)、cout（c++的标准输出流），和cerr（c++的标准错误信息输出流），把命令行参数转换成double，并且以文本的形式打印到终端控制台。字符串、数字和行尾标记符(endl)都是使用<<操作符的输出流，该操作符也用于移位操作(bit-shifting)中。为了可以使用这一标准功能，我们需要在第1行和第2行中加入\verb+#inlcude+指示符。



%这里空一行

\end{common-format}
\end{document}



QString：：喵()函数将会使用自己的参数替换最小数字的“%n”参数，并且会用它的参数返回
结果“%n”字符和最终的结果字符串。在本例中，喵()被用于两个“%n”参教中。第一个arg()调
用会替换参数“%1”，第二个arg(．)调用则会替换参数‘t%2”。如果文件名是budget,。p并且没有载
人翻译文件，那么结果字符串将是“budget.sp[*]-
    _    ’
但使用arg()函数可以为翻译人员提供更多的灵活性。
    如果存在文件名，就需要更新应用程序的最近打开文件列表recentFile。。可以调用removeAll()
从列表中移除任何已经出现过的文件名‘；从而避免该文件名的重复。然后，可以调用prepend()把
这个文件名作为文件列表的第一项添加进去。在更新了文件列表之后，可以调用私有函数upda

使用一个风格的迭代器，可以移除任何不再存在的文件。一些文件或许已经在前面的会
话中使用过，但在此之前还没被删除掉。recentFiles交量的类型是QStringU。t（QString型列表）。第
11章会详细说明一些像QStringJjst -样的容器类，其中将会说明它们与C++标准模板库（Standard
Template LibraIy，STL)之间的关系，也会说明Qt的Java风格迭代器类的用法。
    然后，再遍历一次文件列表，这_次使用数组风格的索引形式。对于每一个文件，创建一个由
一个与操作符、一位数字（j斗1）、一个空格和该文件名（不带路径）组成的字符串。我们要为使用这
种文本设置相应的动作。例如，如果第一个文件是C：那么第一个动作的文
本将会是“&1

    每一个动作都可以带一个与之相关的QVariant型data项。QVanaHt类型可以保存许多C++和
Qt型变量，第11章将说明这一点。这里，将文件的全名保存在动作的data项中，以便随后可以方
便地找到它。还要将这个动作设置为可见。 
    如果有比最新文件更多的文件动作；那么只需隐藏那些多余的动作即可。‘最后，如果至少还
存在一个最近打开的文件，那么就应该把间隔器设置为可见：

    当用户选择了一个最近打开的文件，就会调用oper，RecentFile()槽。只要有任何未保存的变
化，就会调用okToContinue()西数，并且假定用户没有取消，还可以使用QObject：：sende。()查出是哪
    ？    ‘
个特有动作调用了这个槽。   
    qobject_cast <T>()函数可在Qt的moc(meta-object compiler，元对象编译器)所生成的元信息基
础上执行动态类型强制转换(dynamid cast)。它返回一个指向所需QObject子类的指针，或者是在
该对象不能被转换成所需的那种类型时返回0。与标准C++的：dynamic．．cast <T>()不同，Qt的
qobject_cast<D()可正确地跨越动态库边界。在例子中，使用qobject_cast：：<D()把一个QObject指
针转换成QAction指针。如果这个转换是成功的（应当是这样的），就可：以利用从动作的data项中
所提取的文件全名来调用loadFile()函数。
    顺便值得一提的是，由于知道这个发射器是一个QAcdon，如果使用static. cast乏D()或者传统
的C风格的数据类型强制转换代替原有的数据转换方式，这个程序应当仍然是可以运行的。请参
见附录D中“类型转换”一节对不同C++数据类型强制转换的概述。


使用对话框
一节将说明如何在Qt中使用对话框——如何创建：初始化以及运行它们，并且对用户交互
择做出响应。本节将会使用在第2章中创建的Find、Go to Cell和Sort对话框，也会创建一


们从如图3.12所示的Find对话框开始。’由于希望用户能够在Spreadsheet窗口和Find对话

框之间进行切换，所以Find对话框必须
中对于任何其他窗口都独童数宣旦一
。非模态窗口就是运行在应用程序

    Find对话框是一个可以让用户在电子制表软件中搜索文本的窗口。当用户单击Edit—Find
时，就会调用find()槽来弹出Find对话框。这时，就可能出现下列几种情形：
  ●这是用户第一次调用Find对话框。
  ●以前曾经调用过Find对话框，但用户关闭了它。
  。以前曾经调用过Find对话框，并且现在它还是可见的。
  ．  如果Find对话框还不曾存在过，就可以创建它并且把它的findNext()信号和findPrevious()信号
  与Spreadsheet中相对应的那些槽连接起来嗵迥嘤盛啦噔道垫宝剑蕉这个对话框，
  但是推迟对话框的创建过程将可哒德堡壁釜囊鬓茎磊蓑篓还d如果从-hr使用到这不对话

se()和ac曲ateWindow()来确保窗口位于其他寥且之占羞县墨酉见的和激
活的。只调用sh6w(．)就足以让一个隐藏窗口变为可见的、位于最上方并且是激活的，但是也有可
1粒是在Find对话框窗口已经是可见的时候又再次调用了它，在这种情况下，。how()调用可能什么
也不做，那么就必须调用raise()和acdvateWindow()让窗口成为顶层窗口和激活状态。还有另外一
种方法，本可以写成：

但这样的程序就好像明明在穿越单行道却又同时去看这条单行道的两个方向一样，显得多余。
    现在看一下如图3.13所示的Go to Cell对话框。我们希望用户可以弹出、使用和关闭它，但是
却不希望让这个窗白能够与应用程序中的其他窗口相互切换。也就是说，Go to Cell对话框窗口必
须是邀蓥垫狮da】咖由。模态窗口就是一个在得到调用可以弹出并可以匾藿西南疆再诵蔺面]夫而会
从调用发生开始起妨碍其他的任意处理或者交互操作，直到关闭该窗口为止。前面使用的文件对
话框和消息框就是模态的。    。
    图3.13 Spreadsheet应用程序的G0 to CeU对话框
桌对话框是通过show()调用的，那么它就是非模态对话框[除非此后又调甩：setModal()，芨会一
让它变为模态对话框]。但是，如果它是通过e）【ec()调用的，那么该对话框就会是模态X适k

    如果对话框被接受，函数QDialog：：exec()可返回一个true值（QDi抛：：Accep州），否则就会返
回一个脚se值(QDialog：：Rejected)。可以回想一下，当初在第2章利用q．设计师创建Go to Cen对
话框时，就曾经把0K连接到accept()，把Cancel连接到rej面t()。如果用户选择OK，就把当前单元
格的值设置成行编辑器中的值。
    Q铀le：：setCu玎entCeu()函数需要两个参数：一个行索引和一个列索引。在Spr睨dsheet应用程
序中，单元格Al就是单元格(0，0)，单元格B27就是单元格(26，1)。为了从函数Q‰eE拙：：text()
返回的QStriIlg中获得行索引，可以使用QS嘧唱：：rnid()来提取行号（这个函数将返回一个从字符串
的开始直到末尾位置的子字符串），然后使用QS嘧唱：：toh()把它转换成一个整数值，并且把该值
再减去l。对于列号，则可以用这个字符串中第～个字符的大写数值减去字符‘A’的数值而得到。
我们知道，该字符串将具有正确的格式，因为为对话框创建了一食J坚凄粤翌些dator检验器，只有
道星二全主煎遁堕亘曼跟至多三位数字格式的字符串才能让o墅缝鲤起生蟹凰———、～——————～
    g汛cen()函数写画斋看蓟萌旃看砭羁郡有些不同j因为它在堆栈中创建了一个作为变量的窗
口部件（一个GoTOCeuDialog）。虽然多使用了一行代码，但是换来了使用new和delete的简便：：
  由于在使用完一个对话框（或者菜单）后，通常就不再需要它了，所以在堆栈，中创建对话框（和
    f：
上下文菜单）是一种常见的编程模式。并且对话框会在作用域结束后自动销毁掉。
热现在转到Sort对话框上。Sort对ia:攥是-.个模态对话框，它允许用户在当前的选定区域中使

用给定的列进行排序。图3 .14给出了-个排序的实例，用列，B作为排序的主键，列A作为排序的
第二键（两个都采用升序）。
(a)排序前

sort()函数中的代码使用了一种和goToCell()豳数中用到的类似模式：

。在堆栈中创建对话框并且对其进行初始化。
。使用.exec()弹出对话框。．
o如果用户单击0
setColuiwnRange()调用将那些可用于排序的列变量设置为选定的列。例如，使用图
的选择，range .leftColumn(')将返回值
曛，即，并且
range. rightColunu/()将返回

compare对象储存了主键、第二键和第三键以及它们的排序顺序。（将会在下一章中看到
SpreadsheetCompare类的定义。）这个对象会由
Spreadsheet:：sort()使用，用于两行的比较。keys数组
存储了这些键的列号。例如，如果选择区域是从
C2扩展到F5，那么列C的位置就是0。ascendirig厂

    数组中按bool格式存储了和每一个键相关的顺序。QComlioBox:：currentlndex()返回当前选定项的
    索引值，该值是一个从0开始的数。对于第二键和第三键，考虑到“None”项，我们从当前项减去1。
·    sort()函数会完成这项工作，但是它显得稍有不足。它认为Sorr对话框是按照一种特定的方
    式来实现的，也就是像上面那样来处理组合框和“None”项。这就意味着，如果重新设计了Sort对
    话框，也许就需要重新编写这些代码。如果对话框只会从一个地方调用，那么这样的方式应该是
    足够了，但是如果对话框可能会在几个地方调用到，那么这种处理方式就等于打开了维护工作的
 一种更为稳健的方法是让SortDialog类具有自适应性|=建寄圾通过让它自甚创建二个Spread -
    sheetCompare对象，然后使这个对象只能被它的调用者使用来做到这’七点。这样就可以有效地简7

这种方法可产生松散的耦合组件，并且当从多个地方调用该对话框对，它几乎总可以做出正

一种更为极端的方式是在初始化SonDialog对象的时候就为其传递一个指向Spreadsheet对象
的指针，并且允许对话框直接对Spreadsheet进行操作。这样做会使SortDialog少一些通用性，因为
它仅能适用于一种类型的窗口部件，但是通过去除SortDialog:：setColumnRange()函数，它的确是进
一步简化了程序代码。于是，现在的MainWindow:：sort()函数将变成如下所示的样子：
  -相比而言，第一种方法中调用者需要知道与这个对话框相关的暗示信息，而第二种方法中的
对话框需要知道由调用者所提供的与数捃结构相关的暗示信息。在对话框需要作用于现场变化
的地方，这种方法显得更为有用些。但是就像第一种方法中调用者的代码功能不足一样，如果数
据结构发生了变化，则第三种方法也会失效。
    一些开发者只会选用一种对话框处理方法并对其持之以恒。这有一个好处，就是能够精通和
简练处理方法，因为所有的对话框都使用的是同一种处理模式，但是这也会失去对调用对话框时
没有用到的那些其他有益处理方法。理想情况下，应根据每一个对话框的自身来选择应当使用的
对话框处理方法。
    我们将用About对话框来圆满结束这一节。可以创建一个像Find或Go to Cell．对话框那样的
自定义对话框来显示应用程序的有关信息，但是因为绝大多数About对话框都具有较为固定的格
式，所以Qt提供了一种更为简单的解决方案。

通过调用一个方便的静态函数QMessageBox：：about()，就可以获得About对话框。这个函数和
QMessageBox:：waming()．J形式非常相似，只是它使用了父窗口的图标，而不是标准的“警告”图标。
这个对话框的最终结果显示在图3.15中。
图3.15 Spreadsheet的About对话框
    到现在为止，已经使用了由QMessageBox和QFileDialog提供的多个方便的静态函数。这些函
数可以创建二个对话框，初始化它，并且可以对它调用exec()。当然，也可以像创建其他任意窗口
部件一样创建QMessageBox或者QFileDialog窗口部件，然后再明确地对它调用exec()，或者甚至是
show()，尽管这样的处理方式会显得有些不大方便。
3.6稃储设置1 7    ．
    在MainWindow的构造函数中，调用了readSettings()来载入应用程序存储的那些设置。与之相
似的是，在closeEvent()中，调用writeSettings()来保存这些设置。这两个函数是最后两个需要实现
的MainWindow成员函数。

writeSettings()函数保存了主窗口的几何形状（位置和尺寸大小）、最近打开文件列表以及Show
Grid和Auto-Recalculate逸项的设置值。    ‘
    默认情况下，QSettings会存储应用程序中与特定平台相关的一些设置信息。在Windows系统
中，它使用的是系统注册表；在UNIX系统中，它会把设置信息存储在文本文件中；在Mac OS X中，
它会使用Core Foundation. Preferences的应用程序编程接口。
    构造函数的参数说明了组织的名字和应用程序的名字。采用与平台相关的方式，可以利用这
一信息查找这些设置所在的位置。
    QSettings把设置信息存储为键值对(key-value paJr)的形式。键(key)与文件系统的路径很相，，
    ；
第3章创建主窗口
似。可以使用路径形式的语法(例如，findDialog/matchCase)来指定子键(subkey)的值，或者也可以使
用beginGroup()和endGroup()的形式：    ，

value)可以是一个int、bool、double、QString、QStringList或者是QVariant所支持的其他任意类
型，包括那些已经注册过的自定义类型。


readSettings()卤数可以载入之前使用writeSettings()函数所保存的那些设置。value()函数中的
第二个参数可以在没有可用设置的情况下指定所需的默认值。在应用程序第一次运行时，使用的
就是这些默认值。由于没有为形状或者最近打开文件列表指定第二个参数，所以在第一次运行
时，窗口会使用任意但是却合理的大小和位置，而最近文件列表会是一个空表。
    在readSettings()和xvriteSettins()中使用与QSettings楣关的全部代码为MainWindow所选择的布
置方案，都只是许多可用方案中的一种而已。可以在应用程序执行期间韵任何时候和程序代码中
的任何地方，随时随地创建一个QSettings对象，用它查询或者修改一些设置。    ，，
    现在已经完成了对Spreadsheet的MainWindow的实现。在后续的几节中，将会讨论如何修改
Spreadsheet应用程序来让它可以处理多文档以及如何实现一个程序启动画面(sp.lash screen)。将会
在下一章中完成它的功能，包括公式和排序的处理。
3.7多文档
现在，已经为编写Spreadsheet应用程序的main()函数的代码做好了准备：


  这个main()函数和以前曾经写过的那些函数稍微有点不同：以变量的形式在堆栈里创建

MainWindow实例，而不是使用new来创建它。当函数结束时，MainWindow实例会自动销毁。
就像上面ma/n()函数所显示的那样，Spreadsheet应甫程序页疆篌亍二个单一王雷曰，并且在同
。气  一时间只能处理一个文档。如果想让它在同一时间具有处理多个文档的能力，就需要同时启动多


个Spreadsheet应用程序：实例。，但是这对于用户来讲是很不方便的，用户需要的是一个可以处理多
个文档的单一应用程序实例，就像在_个网页浏览器实例中可以同时提供多个浏览器窗口一样。+
    下面将修改Spreadsheet应用程序，以使它可以处理多个文档。首
先，需要对File菜单做一些简单改动：
    ●利用File—New创建一个空文档主窗口，而不是再次使用已经存
    在的主窗口。
    ●利用r<le—Oose关闭当前主窗口。
    ●利用File—Exit关闭所有窗口。
    在File菜单的最初版本中，并没有aose选项’i这只是因为当时它
还和Exit -样具有相同的功能j+新的File菜单如图3.16所示。一

‘新的'main()函数为：
图3.16新的File菜单

 具有多窗口功能后，现在就需要使用菜单中的new来创建MainWindow。考虑到节省内存，可

以在工作塞垦骞垣堡塑壁塑te操(~删除主窗口。


。我们只创建了一个新的MainWindow实例。这看起来有些奇怪；因为没有保留指向这个新窗
口的任何    }际上这鲞丕星仕么闽题，因趁Q笠逐塑堕的窗口耋箜跟踪。  ’    一t


    槽QApplicaUon：：closeAllWindow弓()会关闭所有应用程序的窗口，除非其中一个应用程序拒绝
了这个关闭事件。这正是在此所需的行为。我佃不用再考虑那些有关是否保存的事情，因为就算
关闭一个窗口，都会在MainWindow:：closeEvent()中处理这些情况。    ，

    看起来好像已经完成了应用程序对多窗口处理能力的工作。遗憾的是，这里还隐藏着一个潜在
的问题：如果用户一直仓il建著且关JJ主窗口、-那么这台机器早晚会耗尽它的全部内存。这是因为我们
，一
第3章创建主窗口
保存了newFile()中创建的MamWindow窗口部件，但是从没有删除它们。当用户关闭一个主窗口时，
默认行为是隐藏它，所以它还会保留在内存中。对于如此多的主窗口：的确会造成一定的问题。
    解决办法是在构造函数中对Qt:：WA_DeleteOnClose的属性进行设置、：

  这样做就会告诉Qt在关闭窗口时将其删除。Qt：：WA_DeleteOnOose;属性是可以在QWidget上
进行设置并用来影响这个窗口部件的行为的诸多标记之一。‘  ：

    内存泄漏并不是必须处理的唯一问题。最初的应用程序设计包含了一个隐含的假设，也就是
它仅有一个主窗口。对于多窗口，每一个主窗·口都有它自己的最近打开文件列表和它自己的一些
  选项。很明显，最近打开文件列表对于整个应用程序来说应该是全局的
  声明为静态鸾藿。可以相当容易地解决这个问题，这样对王墼仝应用程序
  丐鼯露萌亘旦堡随后必须礴傈丽廷专适壑塑丽鄙盯≤j：磊磊鬲n堪阻eActio璐()

  必须是在所有的这是实现这一做法的代码：
。通过把recentFiles变量

函数来更新File菜单，都

这段代码使用了Qt的for朗ch结构体（将在第11章中对其进行说明）来遍历这个应用程序的
所有窗口，并且对所有类型为Mai水晰ndow的窗口部件调用updateRecen娟le如tions(．)。，可以使用类
似的代码来同步Show G谢和Auto—Recalculate选项，或者用于确保同一个文件不会被加载两次。
    在每一个主窗口中只提供一个文档的应用程序称为单文档界面（si时e docur孟nc interf如e，SDI）
应用程序。在Wind0、vS系统下，一种常用的替代方法是多文档界面(mul邱le docurnent inte出ce，
MDI)，这种应用程序只有一个单一的主窟口：，但可以对主窗口中央区域的多个文档窗口进行管理。
Qt可以在它支持的所有平台上创建SDI和MDI应用程序。图3；．17给出了使用这两种方法的
Spreadsheet应用程序。第6章将对肋I进行说明。
 
    图3.17单文档界面和多文档界面    ．
许多应用程序都会在启动的时候显示一个程序启动画面（splash screen），图3118给出的就是这

样的一个实例。一些程序员使用程序启动画面对缓慢的启动过程进行掩饰，而另外一些人则是用
于满足市场部门的要求。使用QSplashScreen类，可以非常容易地为Qt应用程序添加一个程序启
动画面。    
图3.18程序启动画面
    类QSplashScreen会在应用程序的主窗口出现之前显示一个图片。它也可以在这个图片上显
示一些消息，用来通知用户有关应用程序初始化的过程。通常，程序启动画面的代码会放在main()函
数中，位于QApplication：：exec()调用之前。
    下面给出了一个main()函数的例子，在应用程序中，它使用QSplashScreen显示的程序启动画
面表示启动时载入的一些模块和网络连接的建立。

    刭此为止，我们已经创建了Spreadsheet应用程序的用户界面。在下一章中，将会通过实现电
子制表软件的核心功能来完成这个应用程序。
    第4章  实现应用程序的功能

前两章说明了如何创建Spreadsheet应用程序的用户界面。在这一章中；将通过编写它的底层
功能函数来完成这个程序。此外，还将看到如何载人鸭保存文件，女哜旺莓内存中存储数据，如何实
现剪贴板操作，以及如何向QTableWidget中舔加对电子制表软件公式的支持等功能。

中央窗口部件 
    QMainWindow的中央区域可以被任意种类的窗口部件所占用。下面给出的是x所有可能情形
的概述。
1．使用一个标准的Qt窗口部件
    像QTableWidget或者QTextEdit这样的标准窗口部件可以用作中央窗口部件。在这种情况下，
这个应用程序的功能，如文件的载人和保存，必须在其他地方实现（例如，在QMainWindow的子
2．使用一个自定义窗口部件
    特殊的应用程序通常需要在自定义窗口部件中显示数据。例如，一个图标编辑器程序就应当
使用一个IconEditor窗口部件作为自己的中央窗口部件。第5章将会说明如何在’Qt中编写自定义
窗口部件。    ’
3．使用一个带布局管理器的普通QWidget
    有时，应用程序的中央区域会被许多窗口部件所占用。这时可以遁过使用一个作为所有这些
其他窗口部件父对象的QWidget，以及通过使用布局管理器管理这些子窗口部件的大小和位置来
完成这一特殊情况。
4．使用切分窗口(splitter)
    多个窗口部件一起使用的另．种方法是使用QSplitter。QSplitter会在水平方向或者竖直方向
上排列它的子窗口部件，用户可以利用切分条(splitter handle)控制它们的尺寸大小。切分窗口可
以包含所有类型的窗口部件，包括其他切分窗口。
5．使用多文档界面工作空间
    如果应用程序使用的是多文档界面，那么它的中央区域就会被QMdiArea窗口部件所占据，并
且每个多文档界面窗口都是它的一个子窗口部件。
    布局、切分窗口和多文档界面工作空间都可以与标准的Qt窗口部件或者自定义窗口部件组
合使用。第6章将会进一步深入地讲解这些类。
    对于Spreadsheet应用程序，会使用一个QTableWidget子类作为它的中央窗口部件。类QTable-
Widget已经提供了我们所需要的绝大多数电子制表软件的功能，但是它还不支持剪贴板操作，并
且也不能理解诸如“= A1+A2+A3”这样的电子制表软件公式的意义。我们将会在Spreads heet类中
窦现这些缺少的功能。


    类Spreadsheet派生自QTableWidget，如图4.1所示。 
    eView
QTableWidget是一纽格子，可以非常有效地用来表达二维  oT86下vj
稀疏数组。它可以在规定的维数内显示用户滚动到的任'iLQTableWidget    QTabLeWidgetltem i
    l    I
一单元格。当用户在一个空单元格内输入一些文本的时  Spreadsheet    Cell
候，QTableWidget会自动创建二个用莱存储遂些文笨酌S    。
    ，  图4.1类Spreadsheet和Cell的继承树
QTableWidgedtem。    _
    QTableWidget派生自QTableView，它是模型／视图类之一，我们将在第10章进一步了解它。对
于另外一个表QicsTable，它有更多的非常规功能，可以从http：//www.ics. com/中获取：
    让我们一起来实现Spreadsheet，首先从它的头文件歼始：    ‘    ．

头文件是从Cell和SpreadsheetCompare类的前置声明开始的。

    QTableWidget单元格的属性，比如它的文本和对齐方式等，都存储在QTableWjdgeⅡtem中。与
QTableWidget不同的是，QTableWidgedtem不是一个窗口部件类，而是一个纯粹的数据类：Cell类派
生自QTableWidgeⅡtem，会在本章的最后一节对这个Cell类进行解释。


乏所以把autoRecalculate()函数实现为内联函数，是因为无论自动重新计算的标识符生效与
它都必须要有返回值。
在第3章中，当实现MainWindow时，我们依赖于S
中的一些公有函数。例如，我们从
MainWindow:：newFile()中调用clear()来重置电子制表软件。也使用了一些从QTableWidget中继承
而来的函数，，特别是setCurrentCell()和setShowGrid()。

    Spreadsheet提供了许多实现Edit、’rools和Options菜单中的动作酌槽：并且它也提供了一个
modified()信号，用来告知用户，可能已经发生的任何变化。

还定义了一个由Spreadsheet类内部使用的私有槽： 

在这个类的私有段中，声明了3伞常量、4个函数和1个变量。

    在这个头文件的最后，给出了SpreadsheetCompare类的定义。当查看1Spre。dsheet：。：。orf()时，会
解释这个类。
现在来看一下它的实现文件：

通常情况下，当用户在一个空单元格中输入一些文本的时候，QTableWidget将会自动创建一个
  QTableWidgetltem来保存这些文本。在电子制表软件中，我们想利用将要创建的Cell项来代替
  QTableWidgedtem。这可以通过在构造函数中调用sedtemPrototype()来完成。实际上，QTableWidget
  会在每次需要新项的时候把所传递的项以原型的形式克隆出来。
    同样是在构造函数中，我们将选择模式设置为QAbstracdtemView：：ConUguousSelection，从而可以
  允许简单矩形选择框方法。我们把表格窗口部件的ite．nChanged()信号连接到私有槽s


Changed()上，这可以确保在用户编辑一个单元格的时候，somethingChanged()槽可以得到调用。最
后，调用clear()来重新调整表格的尺寸大小并且设置列标题。

clear()函数是从Spreadsheet构造函数中得到调用的，用来初始化电子制表软件。它也会在
Ma/nWindow:：newFile()中得到调用。  
    我们原本使用qLableWidget：：clear()来清空所有项和任意选择，但是那样儆的话，这些标题将会
以当前大小的尺寸而被留下。相反的是，我们要把表格向下调整为Ox0。这样就可以完全清空整个
表格，包括这些标题。然后，，重新调整表的大小为ColumnCount×RowCount(26×999)，并且把QIable-
Widgetltem水平方向上的标题修改为列名“A'’，“B”，…，“Z”。不需要设置垂直标题的标签，因为这些
标签的默认值是“1”，“2”，…，“999'’。最后，’把单元格光标移动到单元格Al处。
    qlCableWidget由多个子窗口部件构成。在它的顶部有一个水平的QHeaderView，左侧有一个垂
直的QHeaderView，还有两个QScrollBar。在它的中间区域被一个名为视口(viewport)的特殊窗口部
件所占用，’QTableWidget可以在它上面绘制单元格。通过从QTableView和QAbstractScroⅡArea中继
承的一些函数，可以访问这些不同的子窗口部件(参见图4.2)。‘QAbstractScrollArea提供了一个可
以滚动的视口，和两个可以打开或关闭的滚动条。第6章将讲述QScrollArea子类。．  ’


  。cell()私有函数可以根据给定的行和列返回一个Cell对象。它几乎和QTableWidget:：item()函
数的作用一样，只不过它返回的是一个Cell指针，而不是一个QTableWidgetltem指针。

    text()私有函数可以返回给定单元格中的文本。如果cell()返回的是一个空指针，则表示该单
元格是空的，因而返回一个空字符串。

    formula()函数返回给定单元格中的公式。在很多情况下，公式和文本是相同的。例如，公式
“Hello”等价于字符串“Hello”，所以如果用户在单元格中输入“Hello”并且按下回车键浔眵么该单元
格就会显示文本“Hello”。但是还有一些例外的情况：：    j
    ·如果公式是一个数字，那么它就会被认为是一个数字。，例如，公式“1.50”等价于双精度实数
    ( double)的1.5，它在电子制表软件中会被豆示为右对齐的“1.5:’。
    ·如果公式以单引号开始．那么公式的剩余部分将会被认为是文本。例如，公式'12345”等价
    。    ：
    于字符串“12345”。    ，

●如果公式以等号开始，那么公式将会被认为是一个算术公式。例如，如果单元格．A1包含
    “12”并且单元格A2包含“6”，那么公式“= A1+A2”就会等于18。    。
    把公式转换成值的任务是由Cell类完成的。这时，要记住的事情是显示在单元格内的/cAs:i是
公式的结果，而不是公式本身。

setFormula()私有函数可以设置用于给定单元格的公式。如果该单元格已经有一个Cell对象，
那么我们就重新使用它。否则，可以创建一个新的Cell对象并且调用QTableWidget:：setltem()把它
插入到表中。最后，调用该单元格自己的setFormula(>函数，但如果这个单元格已经显示在屏幕上．
那么就重新绘制它。我们不需要担心随后对这个.Cell对象的迥l瞧操绦。因为7．凹ableWidget会得到
这个单元格的所有权，并且会在正确的时候自动将其删除。

    currentLocation()函数返回当前单元格的位置，它是按照电子制表软件的通常格式，也就是一个

列字母后跟上行号的形式来表示这个位置的值。MainWindow：：updateStatusBar()使用它把这个单元
格的位置显示在状态栏上。

currentFonnula()函数返回当前单元格的公式。它是从MainWindow:：updateStatusBar()中得到调
用的。

如果启用了“引ito-recalculate”（自动重新计算），那么somethingChanged()私有槽就会重新计算整
个电子制表软件。它也会发射modified()信号。
4.3载入和保存
  现在，我们将使用一种自定义的二进制数格式来实现Spreadsheet文件的载人和保存。将使用
QFile和QDaLaStream来完成这一工作．由它们共同提供与平台无关的二进制数输入，输出接口。
    首先从一个Spreadsheet文件的输出开始：    +．

第4章实现应用程序的功能


从MainWindow:：saveFile()中调用的writeFile()函数把文件输出到二磁盘中。如果输出成功，它
会返回true；如果出现错误，则返回false。    ‘
    我们使用给定的文件名创建一个QFile对象，并且调用open()打开这个用于输出的文件。我
们也会创建一个QDataStream财象，由它操作这个QFile对象并且使用该对象输出数据。
    在输出数据之前，我们把这个应用程序的光标修改为标准的等待光标（通常是●个沙漏），并
且一旦所有的数据输出完毕，就需要把这个应用程序的光标重新恢复为普通光标。在函数的最
后，文件会由QFile对象的析构函数自动关闭。    。一    ．  ．：  。，◆  ．
    QDataStream既可以支持C++基本类型，也可以支持多种Qt类型。该语法模仿了标准C++的
<iostream>中的那些类的语法。例如：

会把变量x、y和z输出到一个流中，而：

会从流中读出它们。因为C++的基本类型在不同平台上可能会有不同的大小，所以把这些变量
强制转换成qint8、quint8、qint16、quint16、qint32、quint32、qint64以及quint64中的一个是最安全的做
法，这样做可以确保它们能够获得应有的大小（按位计算）。  。  。    ‘
    ：、
    Spreadsheet应用程序的文件格式是相当简单的。一个Spreadsheet文件以一个32位数字作为
文件的开始，由它确定文件的格式（MagicNu．nber，茌spreadsheet．hf中定义为Ox7F51C883，它是一个
任意的随机数）。然后是连续的数据块，每一数据块都包含了用于一个单元格中的行、列和公式。
为了节省空间，我们没有输出空白单元格。该文件格式如图4.3所示。    ”    ，
图4.3 Spreadsheet'的文件格式
    关于这些数据类型的二进制数确切表示方法则是由QDataStream决定的。例如，一个quint16
  按照高字节在后的顺序存储为两个字节，而一个QString则被存储为字符串的长度后跟Unicode字
  ．符的形式。
    关于Qt数据类型的二进制数确切表示方法，自Qtl.0以来已经发生了许多变化。而且在未来的
．。Qt发行版中，为了能够与现存的数据类型和将来允许出现的新的Qt类型保持一致，这样的表示方法
。还可能会继续变化下去。默认情况下，QDataStrea/n会使用最近版本的二进制数格式（在Qt 4.3中
C.++ GUI Qt 4编程（第二版）
的版本是第9版），但是可以设置它，使它可以读取那些1日的数据版本。如果以后有可能使用新的
Qt发行版来重新编译这个应用程序，那么为了避免出现任何可能的兼容性问题，需要明确告诉
QDataStream应该使用的是第9版，从而无需再考虑要使用的Qt版本。（QDataStreanl-：Qt_4_3是一
个方便的常量，它就等于乡。）
    QDataStream的功能非常齐全。既可以把它用于QFile中，也可以把它用于QBuffer、QProcess、
QTcpSocket、QUdpSocket或者QSslSocket中。在读取和输出文本文件时，Qt也提供了一个QText-
Sueam类，可以使用它代替QDataStream类。第12章将深入地讲解这些类，并且也会讲述处理不同
的QDataStream版本时所使用的各种方法。


readFile()函数与writeFile()函数非常相似。我们使用QFile读取一个文件，但这一次使用的是
QIODevice.:：ReadOnly标记，而不是QIODevice：：WriteOnly标记。1然后，把'QDataStream的版本设置为
9。用于读取文件的格式必须总是与输出文件的格式相同。
    如果该文件在开始处具有正确的幻数(magic nur—iber)，那么可以调用clear()来清空电子制表软
件中的所有单元格，并且读人单元格中的数据。由于该文件中只包含那些非空单元格的数据，并
且也不大可能重置电子制表软件中的每个单元格，所以必须确保在读人数据之前已经清空了所有
的单元格。
4:4实现Edit菜单
    现在，我们已经为实现响应应用程序Edit菜单中的各个槽做好了准备。Spreadsheet应用程序
中的'Edit菜单如图4.4所示。    

    cut()槽可以对Edit_+ Cut菜单做出响应。由于Cut的执行效果与Copy之后再加上一个Delete
的执行效果相同，所以其实现代码很简单。    、

copy()槽能够对Edit_+C叩y做出响应。它会遍历当前选择（如果没有明确的选择，那么就认为
选择的只是当前单元格）。每一个选中单元格的公式都会被添加到一个QStri坞中，行与衍之间利
用换行符“＼n”分隔，列与列之间则以制表符“＼t”来分隔。图4.5给出了这一实现方法的示意图。
    图4.4 Spreadsheet应用程序的Edit菜单    图4.5’把选择复制到剪贴板中
    在Qt中，通过调用QApplication：：clipboard()静态函数可以使用系统的剪贴板。通过调用
QClipboard：：setText()，就既可以在本应用程序中又可以在其他应用程序中使用放在剪贴板上的这
些文本。这种使用制表符“＼t”和换行符“＼n”作为文件分隔符的形式可以被包括微软Excel在内的
许多应用程序所支持。    ．    ’    ．
    函数QTableWidget：：selectedRanges()返回一个选择范围列表j1我fl]知道；由于在构造函数中已
经将选择模式设置为QAbstracdtemView：：ContiguousSelection，所以选择范围不可能再超过Vl。为方
便起见，我们定义了一个selectedRange()函数来返回这个选择范围。、  “


如果只有．个选择，则只需简单地返回第一个（并且也只有这一个）选择即可。没有选择的。隋

况应该永远不会发生，因为ContiguousSelection模式至少可以把当前单元格当作是已经选中的选
择。但是，为了避免使程序出现缺陷的可能性，还是需要对这种当前没有选中单元格的情况进行
单独处理。    。

paste()槽对Edit—Paste菜单选项做出响应。我们从剪贴板中取回文本，并且调甩静态函数
制表符“"字符的个数再加上1。如果只选中了一个单元格，‘就把这个单元格作为粘贴区域放在
左上角；否则，就把当前选择作为要粘贴的区域。
为了执行粘贴操作，我们遍历所有行并且再次使用
QString:：spht()把它们分隔到每一个单元
格中，但是这一次要把制表符当作分隔符。图4.6给出了这一过程中所使用的步骤。

:rDelete菜单选项做出响应。7如果有选’中的项，那么该函数就会ff/l.l除它们并且
调用gmethingChanged(:)函数。，对选择中的每一个CeR对象使用.delete足以清空所有这些单元格j
当删除QTableWidget的QTableWidgetlte蹬的时候，凹abKWidget就会注意到这一情况的发生，而如果
这些项中有可见的任意项，QTableWidget将会自动对自己进行重绘。如果在一个已经删除过thj单
元格位置上又调用了cell()，那么该函数将会返回。个空指针。

项做出响应。这些实现分别依赖于QTableWidget的selJectRow()和selectColumn()函数。+我们不必再
去实现Edit  Select- All菜单选项的功能，因为该功能可以由QTableWidget从QAbstiactItemView：：
selectAll()的函数中继承过来。

findNext()槽会遍历单元格一遍，它从当前光标右侧的单元格开始逋冼到这一行的最后一列，
然后再从下一行的第一个单元格开始继续遍历，如此反复，直到找到所要鲞找的文本，或者是直到
最后一个单元格为止。例如，如果当前的单元格是C24，那么就会搜索D24、E24、…、224，然后再去
搜索A25、B25、C25、-？，≮225;等等，一直遍历到2999为止。如果找到才々个匹配项，那么就清空当
前选择，把单元格光标移动到那个匹配的单元格上，并且让包含．Spreads~et的窗日变成激潘状态。
如果没能找到匹配的单元格，那么就让应用程序发出，哔’’'( beep)盼一声来表明搜索已经结束i匹配
没有成功。

findPrevious()槽与findNext()槽相似，区别之处是它会向相反的方向遍历并且会在单元格Al
处停下来。
4.5实现其他菜单
    现在，我们将要实现那些对Tools和Options菜单做出响应的槽。这些菜单项如图4.7所示。
recalculate()槽能够对Tools—Recalculate莱单选项做出响应。当必要时，它也会被Spreadsheet
自动调用。  
    我们遍历每一个单元格，并且对每一个单元格调用setDirty()把它们标记为需要重新计算。为
了在电子制表软件中显示一个Cell对象的值，QTableWidget会再次对该对象调用text()以获得其
值，从而使该值重新计算一次。
    然后，对这个视口调用update()来重新绘制整个电子制表软件。QTableWidget中的重绘代码就
又会对每一个可见单元格调用text()来获得它们中要显示的值。因为在每一个单元格上都调用了
setDiIy.()，所以这些对text()的调用将会使用重新计算过的值。该计算可能需要重新计算那些不
可见的单元格，这就会造成一个级联计算，直到每一个需要被重新计算的单元格能够在刚才刷新
过的视口中重新得到计算，从而使它们也能够显示正确的文本。这一计算是由Cell类执行的。

    setAutoRecalculate()槽对OpUons—Auto-Reealculate菜单选项做出响应。如果启用了这个特性，则
会立即重新计算整个电子制表软件以确保它是最新的，然后，recalculate()会自动在something-
Changed()中得到调用。
    因为QTableWidget已经提供了一个从QTableView中继承而来的setShowCrid()槽，所以不需要
再对OpUons—ShowGI-id菜单选项编写任何代码。所有要保留的东西就是Spreadsheet：：sort()，它会
在MainWindow:：soit()中得到调用：
 
 徘序操作会对当前的选择进行，并且会根据存储在compare对象中的排序键和排序顺序重新
排列这些行。我们使用一个QStringList来重新表示每一行数据，并且把该选择存储在一个行列表
中。我们使用Qt的qStableSort()算法，并且根据公式而不是根据值来进行简单排序。这一过程如
图4.8和图4.9所示。第11章中会讲述Qt的标准算法和数据结构。

图4.9排序后把数据放回表中
    qStable,Sort()函数可以接受一个开始迭代器、二个终止迭代器和一个比较函数。这个比较函数
是一个带两个参数(两个QStringList)的函数，并且如果第一个参数“小于”第二个参数，它就返回

true，否则返回false。传递的作为比较函数的这个compare对象并不是一个真正的函数，但是它可
以用作一个函数，将会很快看到这一点。  j
    在执行完qStableSmt()之后，我们把数据移回到这个表中，接着清空这一选择，并且调用。ome-
thingChanged()函数。

Sp”eadsheetCompare类有些特殊，因为它实现了一个“()”操作符。这样就允许把这个类像函数
一样使用。把这样的类称为函数对象(function object)，或者称为仿函数(fun。to。)o为了理解仿函数
是如何工作的，首先从一个简单的例子开始：

    Square粪提供了一个函数，operator() (int)函数，它返回其参数的平方值。通过把这个函数命名
为operator() (int)，而不是将其命名为compute(int)之类的函数，就可以把一个类型为Square的对象
当作一个函数。

使用compare对象就像使用一个普通的con．pare()函数一样。另外，它的实现可以访问所有存
储为成员变量的排序键和排序顺序。  ，    ，，    ：。、，：
    与此方案相同的另一种方法是，把这些排序键和排序顺序存储在全局成员变量中，并且使用
一个普通的c优npare()函数。然而，在全局成员变量之间通信是一种并不提侣的做法，并且可能会
产生一些莫名其妙的问题。作为像qStableSort()这样的模板函数的接口，仿函数是一种更为常用
的做法。
这里给出的是对电子制表软件中的两个行进行比较的函数实现：

    如果第1行小于第2行，该仿函数就返回true；否则，就返回false。qStableSort()函数会使用这
个函数的结果来执行排序操作。
    SpreadsheetCompare对象的key与ascending数组和MainWindow：；sort()函数（已经在第2章中给
出过）一起配合使用。每个键都保存一个列索引，或者-1（为“None”时）。
    我们按键顺序比较两行中相应的单元格条目。一旦发现有不同之处，就返回一个适当的true或
者false值。如果所有的比较关系都证明两者是相等的，就返回false。qStableSort()函数会使用这里给
出etjJ顷序来解决这种平局情形。如果一开始的时候rowl在row2之前，并且它们都苯“小于”对方，
那么，在结果中rowl还在row2前面。这就是qStableSort()与它很葙似酌非稳定版本的qSort()函数
之间的区别。    ‘    ‘
    现在已经宪成了这个Spreadsheet类。在下一节中，将分析Cell类的代码。这个类用作保存单
元格的公式，并且它还重新实现了QTableWidgetltem：：data()函数，Spreadsheet可以通过QTabl．-Wid-
getltem:：text()间接调用该函数，用它显示单元格公式的计算结果。
4.6  子类化QTableWidgetltem
    Cell类派生自QTableWidgetltem类。这个类被设计用于和Spreadsheet' -起工作，但是它对类
QTableWidgetltem没有任何特殊的依赖关系，所以在理论上讲，它也可以用于任意的QTableWidget
类中。这里给出的是Cell类的头文件：

遁过增加两个私有变量，Cell类对QTableWidgetltem进行了扩展：

●cachedValue把单元格的值缓存为QV撕ant。
．如果缓存的值不是最新的，那么就把cacheIsDirty设置为true。
之所以使用QVanant，是因为有些单元格是double型值，另外一些单元格则是QString型值。
    在声明cachedValue和cacheIsDirt.y变量时使用了C++的mutable关键字，这样就可以在const
函数中修改这些变量。或者，在每次调用text()时，本应当重新计算这个值，但是这样做是不必要
的，因为它的效率非常低下。  ？
    我们注意到，在该类的定义中并没有使用Q- OBJECT宏。这是因为，Cell是-个普通的C’++
类，它没有使用任何信号或者槽。实际上，因为QTableWidgetltem不是从QObject派生而来的，所以
就不能让Cell拥有信号和槽。为了使QL‘的项(item)类的开销降到最低，它们就不是从QObject派
生的。如果需要信号和槽，可以在包含项的窗口部件中实现它们，或者在特殊情况下，可以通过对
QObject进行多重继承的方式来实现它们。    ．    ．
在构造函数中，只需要将缓存设置为dirty。没有必要传递父对象，当用setltem()把单元格插
人到一个QTableWidget中的时候，QTableWidget将会自动对其拥有所有权。
    每个QTableWidgetltem都可以保存一些数据，最多可以为每个数据“角鸟”分配一个QV矗aIlt变
量。最常用的角色是Qt:：Ed/tRole和Qt:：DisplayRole。编辑角色用在那些需要编辑的数据上，而显
示角色用在那些需要显示的数据上。通常情况下，用于两者的数据是一样的，但在Cell类中，．编辑
角色对应于单元格的公式，而显示角色对应于单元格的值（对公式求值后的结果）。．

  一当QTableWidget需要创建一个新的单元格时，例如，当用户在一个以前没有使用过的空白单元
格中开始输入数据时，它就会调用clone()函数。传递给QTableWidget:：setItemPrototype()中的实例
就是需要克隆的项。曲于对于Cell来讲，成员级的复制已经足以满足需要，所以在clone()函数中，
只需依靠由C++自动创建的默认复制构造函数就可以创建新的Cell实例了。
setFormula()函数用来设置单元格中的公式。它只是一个对编辑角色调用setData()的简便函
数。也可以从Spreadsheet:：setFonnula()中调用它。

    formula()函数会从Spreadsheet:：fonnula()中得到调用。就像setFormula() -样，它也是一个简
便函数，这次是重新获得该项的Ed/tRole数据。

    如果有一个新的公式，就可以把cacheIsDirty设置为true，以确保在下一次调用text()的时候可
以重新计算该单元格。
    尽管对Cell实例中的SpreAdsheet:：text()调用了text()，但在Cen中没有定义text()函数。这个
text()函数是一个由QTableWidgetltem提供的简便函数。这相当于调用data(
    调用setDnty()函数可以用来对该单元格的值强制进行重新计算。它只是简单地把cachels -
Dirty设置为true，也就意味着cachedValue不再是最新值了。除非有必要，否则不会执行这个重新
计算操作。
data()豳数是从QTableWidgetltem中重新实现的。如果使用Qt:：DiBplayRole调用这个函数，那
么它返回在电子制表软件中应该显示的文本；如果使用Qt:：EditRole调用这个函数，那么它返回该
单元格中的公式；如果使用Qt:：TextAlignmentRole调用这个函数，那么它返回一个合适的对齐方
式。在使用DisplayRole的情况下，它依靠value()未计算单元格的值。如果该值是无效的（由于这
个公式是错误的），则返回“辑#样”。    ，  ‘
。在data()中使用的这个CeⅡ:：value()函数可以返回一个QVariant值。QVariant可以存储不同
类型的值，比如double和QString，并且提供了把变量转换为其他类型变量的一些函数。例如，对一
个保存了double值的变量调用toString()，可以产生一个表示这个double值的字符串。使用默认构
造函数构造的QVariant是一个“无效”变量。    ：

value()私有函数返回这个单元格的值。如果cacheIsDirty是true，就需要重新计算这个值。
    如果公式是由单引号开始的（例如，“’12345”），那么这个单引号就会占用位置0，而值就是从
位置1直到最后位置的一个字符串。    ‘’
    如果公式是由等号开始的，那么会使用从位置1开始的字符串．并且将它可能包含的任意空
格全部移除。然后，调用evalExpression()来计算这个表达式的值。这里的参数pos是通过引用(ref-
erence)方式传递的，由它来说明需要从哪里开始解析字符的位置。在调用evalExpression()之后，如
果表达式解析成功，那么在位置pos处的字符应当是我们添加上的QChar:：Null字符。如果在表达
式结束之前解析失败了，那么可以把cachedValue设置为Invalid。
    如果公式不是由单引号或者等号开始的，那么可以使用toDouble()试着把它转换为浮点数。
如果转换正常，就把cachedValue设置为结果数字；否则，把cachedValue设置为字符串公式。例如，
公式“1.50”会导致toDouble()把ok设置为true并且返回i.5，而公式“World Population”则会导致
toDouble()把ok设置为false并且返回0.0。
    通过给toDouble()-个bool指针，可以区分字符串转换中表示的是数字0.0还是表示的是转
换错误(此时，仍旧会返回一个0.0，但是同时会把这个bool设置为~alse)。有时候，对于转换矢败
所返回的0值可能正是我们所需要的。在这种情况下，就没有必要再麻烦地传递一个bool指针
了。考虑到程序的性能和移植性因素，Qt从来不使用C++异常(exception)机制来报告错误。但
是，如果你的编译器支持C++异常，那么这也不会妨碍你在自己的Qt程序中使用它们。
    value()函数声明为const函数。，我们不得不把cachedValue和cacheIsValid声明为mutable变量，
以便编译器可以让我们在．const。函数中修改它们。当然，如果能够把value()声明为一个非const函
数并且移除mutable哭键掌可能会更吸引火些，但是这将会导致无法编译，因为是从一个const函数
的data()函数中调用value()的。
    除了要解析这些公式之外：现在已经完成了整个Spreadsheet应用程序。这一节的剩余部分将
说明evalExpression()以及evalTerm()和evalFactor()这两个帮助函数。这些代码有一些复杂，但是把
它们放在这里是为了能够让整个应用程序显得更完善些。由于这些代码和图形用户界面编程无
关，所以你可以非常放心地略过这一部分，从第5章继缤阅读下去。
    evalExpression()函数返回一个电子制表软件表达式的值。表达式可以定义为：一个或者多个
通过许多“+”或者“一”操作符分隔而成的项。这些项自身可以定义为：由“*”或者“／”操作符分
隔而成的一个或者多个因子( factor)。通过把表达式分解成项，再把项分解成因子，就可以确保以
正确的顺序来使用这些操作符了。
    例如，“2*C5+D6”就是一个表达式，它由作为第一项的j'2*G5”和作为第二项的“D6”构成。项
“2 x-C5”是由作为第一个因子的“2”和作为第二个因子的“C5”组成的，而项“D6”则由一个单一的因
子“D6”组成。一个因子可以是一个数(“2”)、一个单元格位置(‘！c5”)，或者是一个在圆括号内的表
达式，在它们的前面可以有负号。
    在图4.10中，定义了电子制表软件表达式的语法。对于语法（表达式、项和因子）中的每一个
符号，都对应一个解析它的成员函数，并且函数的结构严格遵循语法。通过这种方式写出的解析
器称为递归渐降解析器( recursive-descent parser)。
首先，调用evalTerm()得到第一项的值j如果它后面紧跟的字符是“+，”或者“二”，那么就继续
第二次调用evalTerm()；否则，表达式就只包含一个单一项’，并且把它的值作为墼个表达式的值而
返回。在得到前两项的值之后，根据操作符计算出这一一操作的结果o=如果两项都求出一个doubl。
值，就把计算出的结果当作一个double值；否则，把结果设置为Invalid。。一  ，  ，    ：
    像前面那样继续操作，直到再没有更多的项为止。，这样做可以正确地进行．；因为加法和减法
都是左相关(left:associative)的；也就是说，“1-2-3”的意思是‘j(1÷2)，3”，而不evalTerm()函数是处理乘法和除法这一点不同之外，它和evalExpression()都很相似。在
)中唯二的不同就是必须要避免除零，因为在_些处理器中这将是一个错误。尽管测试
浮点数值是否相等通常并不明智，因为其中存在取舍问题，但是在这个防止除零的问题上，这样做
相等性测试已经足够了。

    evalFactor()函数比evalExpression()和evalTerm()函数都要复杂一些。它先从计算因子是否为负
开始。然后，判断它是否是从左圆括号开始的。如果是，就先把圆括号内的内容作为表达式并通过调
用evalExpression()来处理它。当解析到带圆括号的表达式时，evalExpression()调用evalTerm()，eval-
Term()调用evalFactor()，evalFactor()贝U会再次调f evalExpression()。这就是在解析器中出现递归调用
的地方。
    如果该因子不是一个嵌套表达式，就提取下一个记号，它应当是一个单元格的位置，或者也可
能是一个数字。如果这个记号匹配QRegExp．就把它认为是一个单元格引用并且对给定位置处的
单元格调用value()。该单元格可能在电子制表软件中的任何一个地方，并且它可能会依赖于其他
的单元格。这种依赖不是什么问题，它们只会简单地触发更多的value()调用和（对于那些“_diry”
单元格）更多的解析处理，直到所有相关的单元格的值都得到计算为止。如果记号不是一个单元
格的位置，那么就把它看作是一个数字。    ．
    如果单元格Al包含公式“=A1”时会发生什么呢？或者如果单元格A1包含公式“=A2”并且
单元格A2包含公式“=A1”时又会发生什么呢？尽管还没有编写任何特定代码来检测这种循环依
赖关系，但解析器可以通过返回一个无效的QVariant来完美地处理这一情况。之所以可以正常工
作，是因为在调用evalExpr；ession()之前，我们会在value()中把cacheIsDirty设置为false，把
cachedValue设置为Invalid。如果evalExpression()对同一个单元格循环调用value()，，它就会立即返
回Invahd，并且这样就会使整个表达式等于Invalid。
    现在，我们已经完成了公式解析器。通过扩展因子的语法定叉，公式解析器可以非常方便地处
理那些在电子制表软件中像“sum()”和“a．vg()”一样的某些预定义函数。而另外一种比较容易的扩展
方式是将“+”操作符实现为字符串连接（就像串联一样），这样就无需再对这个语法进行修改了。


第5章  创建自定义窗口部件
    这一章讲解如何使用Qt开发自定义窗口部件。通过对一个已经存在的Qt窗口部件进行子类
化或者直接对QWidget进行子类化，就可以创建自定义窗口部件。本章将示范这两种方式，并且也
会说明如何把自定义窗口部件集成到Qt设计师中，这样就可以像使用内置的Qt窗口部件一样来
使用它们了。最后，将通过展示一个使用了双缓冲技术（一种用于快速绘制的强大技术）的自定义
窗白部件来结束这一章的内容。

5.1  自定义t窗口部件
  ’在某些情况下，我们发现Qt窗口部件需要更多的自定义定制，这些定制可能要比它在Qt设计
师里可设置的属性或者对它调用的那些函数更多一些。一个简单而直接的解决方法就是对相关
的窗口部件类进行子类化并且使它能够满足我们的需要。
    这一节将开发一个如图5.1所示的十六进制微调框，以说明是如
何完成这一工作的。QSpinBox -般只支持十进制整数，但是通过子类
化方法，可以让它非常容易地接受并且显示十六进制数值。

    HexSpinBox从QSpmBox中继承了它的绝大多数功能，它提供了一个典型的构造函数，并且重
新实现了QSpinBox中的三个虚函数。    ，
我们设置的默认范围是从0到255(即从Ox00到OxFF)。对于十六进制微调框来说，这样的设
置比QSpinBox的默认设置值范围(从0到99)更为合适些。
    用户可以通过单击微调框的向上和向下箭头或者在它的行编辑器中输人数值来修改微调框
的当前值。在后一种情况中，我们想要严格控制用户输入的数据必须是合法的十六进制数字。为
了实现这一点，我们使用一个QRegExpValidator，它可以接受1到8个字符，所有这些字符都必须是

    这个函数由QSpinBox调用，用来检查目前为止用户输入文本的合法性。有三种结果可能会出
现：Invalid(无效，输入的文本与常规表达式不匹配)、Intennediate（部分有效部分无效，输入的文本是
～个有效值中似是而非的一部分）以及Acceptable(可以接受，输入的文本合法有效)。QR。gExpVali-
dator有一个合适的validate()函数，因此只需返回对其调用后的最终结果即可。理论上，应当为位
于微调框范围之外的那些值返回Invalid或者Intennediate，但是QSpinBox具有很好的自适应性，它
可以在没有任何帮助的情况下检测出那种情况。    ：  ’
    textFromValue()函数把一个整数值转换成一个字符串。当用户按下微调框的向上或者向下箭
头时，QSpinBox会调用它来更新微调框的编辑器部分。我们使用静态函数QString．：：numbe，()，将其
第二个参数设置为16，把该值转换为小写格式的十六进制字符串，并且对结果调用QString：：
toUpper()，使其成为大写格式的结果。
    valueFromText()函数执行从字符串到整数值的逆向转换。当用户在微调框的编辑器部分输入
一介值并且按下Enter时，QSpinBox就会调用它。我们使用QString：：tolnt()试着把当前文本转换成
一个整数值，当然还是使用16作为基数。如果这个字符串不是有效的十六进制数习5么就把ok设
置为false，并且由tolnt()返回一个0。在这里，不需要考虑这种可能出现的情况，因为此处的验证
器只允许输入有效的十六进制字符串。我们希望能够给tolnt()的第一个参数传递的是一个空指
针，而不是传递一个虚拟变量(ok)的地址。
    现在已经完成了这个十六进制微调框。自定义其他Qt窗口部件也可以遵循相同的模式：选
择一个合适的Qt窗口部件，对它进行子类化，并且通过重新实现一些虚函数来改变它的行为即
可。如果我们想做的全部就是对一个已经存在的窗口部件的外观进行自定义设置，那么只需对其
应用一个样式表或者重新实现一种自定义风格即可，而不必对其进行子类化，就像第19章中说明
的那样。  
5.2子类化QWidget
    许多自定义窗口部件都是对现有窗口部件的简单组合，不论它们是内置的Qt窗口部件，
其他一些像HexSpinBox这样的自定义窗口部件。通过对现有窗口部件的组合构建而成的自定义
，窗口部件通常都可以在Qt设计师中开发出来：
    ●使用“Widget”模板创建一个新窗体。
    ●把一些必需的窗口部件添加到这个窗体上，并且对它们进行摆放。
    ●设置一些信号和槽的连接。
    ●如果通过信号和槽不能获得所需的行为，则只需在类中添加一些必要的代码即可——这个
    类需要同时从QWidget类和IUC生成的类中派生出来。
    当然，要对这些现有窗口部件进行组合，也完全可以通过手写代码方式来加以实现。但无论
使用的是哪种方式，最终生成的类都会是QWidget类的一个子类。
    如果窗口部件本身没有任何信号和槽，并且它也没有重新实现任何虚函数，那么我们甚至还
是有可能通过对现有窗口部件的组合而不是通过子类化的方式来生成这样的窗口部件。这就是
在第1章创建Age应用程序时所使用的方法，其中用到了一个QWidget、一个QSpinBox以及一个
QSLde。。虽然如此，也还是可以很容易地通过子类化QWidget，并且在它的子类构造函数中创建
QSpinBox郓QSlider．的方式来做到这一点。
    当手里没有任何一个Qt窗口部件能够满足任务要求，并且也没有办法通过组合现有窗口部
件来满足所需的期望结果时，仍1日可以创建出我们想要的窗口部件来。要实现这一点，只需通过
子类化QWidget，并且通过重新实现一些用来绘制窗口部件和响应鼠标点击的事件处理器即可。
这一方法给了我们定义并且控制自己的窗口部件的外观和行为的完全自由。Qt的一些内置窗口
部件，像QiLabel、QPushButton和QTableWidget，都是通过这种方法得以重新实现的。如果它们没有
在Qt中存在，那么还是完全有可能以与平台无关的方式使用QWidget所提供的公有函数来创建
它们。
    为了说明如何使用这种方法编写一个自定义窗口部件，
我们将会创建一个如图5.2所示的IconEditor窗口部件。这个
IconEditor本来是一个用于图标编辑器程序中的窗口部件。
    实际上，在我们开始潜心研究和创建一个自定义窗口部
件之前，还是很有必要先去检查一下是否已经有了可用的相
关窗口部件，无论是在Qt Solu【ion(http://wwW.trolltech.com/
products/qt/addon/soluUons/catalog/4/)申还是在商业或者非商业
第三方(http：//www．trolltech．com/products/qt/3 rdparty/)那里都
行，因为这样将很有可能会节省许多时间和精力。在本例中，
假设没有可用的合适窗口部件，因而需要创建我们自己的窗口部件。
    让我们先从它的头文件开始看起：

    类IconEciitor使用Q_PROPERTY()宏声明了三个自定义属性：penColor<iconlmage和zoomFacto，。
每一个属性都有一个数据类型、一个“读”函数和一个作为可选项的“写”函数。例如，penColor属性
的类型是QColor，并且可以使用penColor()和setPenColor()函数对它进行读写。
    当我们在Qt设计师中使用这个窗口部件时，在Qt设计师属性编辑器里，那些继承于QWidget
的属牲下面，将会显示这些自定义属性。这些属性可以是由QVant所支持的任何类型。对于定
义属性的类：Q_OBJECT宏是必需的。    ，．
IconEditor重新实现了QWidget中的三个保护函数，并且也拥有一些自己的私有函数和私有变
量。这三个私有变量保存这三个属性的值。
    实现文件是从IconEditor的构造函数开始的。

    枸造函数有一些巧妙的地方，比如这里的Qt：：WA StaticContents属性和setSizePolicy()调用。
我们将简单地讨论一下它们。
    画笔的颜色被设置为黑色。缩放因子(zoom factor)被设置为8，也就是说，图标中的每一个像
素都将会显示成一个8x8的正方形。
    图标数据会保存在image成员变量中，并且可以通过sedconlmage()和iconlmage()函数对它们
进行访问。当用户打开一个图标文件时，图标编辑器程序通常会调用sedconlmage()函数；当用户
C++ GUI Qt 4编程（第二版）
想保存这个图标时．，它就会调用iconlmage()来重新得到这个图标。Image变量的类型是QImage。
我们把它初始化为16×16的像素大小和32位的ARGB颜色格式，这种颜色格式可以支持半透明
效果。通过填充一种透明的颜色，就可以清空image中的数据。
    QImage类使用一种与硬件无关的方式来存储图像。可以把它设置成使用1位、8位或者32位
色深。一个具有32位色深的图像分别对每一个像素各使用8位来存储它的红、绿、蓝分量。剩余
的8位存储这个像素的alpha分量（即不透明度）。例如，一个纯红颜色的红、绿、蓝和alpha分量的
值分别是255、0、0和255。在Qt中，这种颜色可以通过如下形式给定：
    QRgb red=qRgba(255,0.7..f255);
或者，由于该颜色是不透明的，所以可以表示为：
    QRgb red i qRgbT255,0,’0);    ‘    ’、    ，
，  QRgb只是unsigned int类型的一个typedef(类型别名)，并且qRgb()和'qRgba()都是用来把它们
的参数组合成一个32位ARGB整数值的内联函数。也可能写成这样的形式：
    QRgb red=OxFFFFOOOO；
    这里的第1个FF对应于alpha分量，第2个FF对应于红色分量。在IconEditor的构造函数中，
我们通过使用0作为alpha分量而构成的透明色来填充这个QImage。
    Qt提供了两种存储颜色的类型：QRgb和QColor。虽然QRgb仅仅是一个用在QImage中存储
32位像素数据的类型别名，但QColor则是一个具有许多有用函数并且在q中广泛用于存储颜色
的类。在QIconEditor窗口部件中，只有在处理QImage时，我们才使用QRgb，而对于其他任意东西，
包括这里的penColor属性，我们都只使用QColor。

sizeHmt()函数是从QWidget中重新实现的，并且可以返回二个窗口部件的理想大小。在这里，
我们用缩放因子乘以图像的尺寸大小作为这个窗口部件的理想大小，但如果缩放因子是3或者更
大，那么在每一个方向上需要再额外增加一个像素，以便可以容纳一个网格绂。（如果缩放因子是
2或者1，就不必再显示网格线，因为这些网格线将几乎不能再给图标的像素留下任何空间。）
    在和布局联合使用时，窗口部件的大小提示非常有用。当Qt的布局管理器摆放一个窗体的
子窗口部件时，它会尽可能多地考虑这些窗口部件的大小提示。为了能够让IconEditor成为一个
具有良好布局的窗口部件，它必须报告一个可靠的大小提示。
    除了大小提示，窗口部件还有一个大小策略，它会告诉布局系统是否可以对这个窗口部件进行
拉长或者缩短。通过在构造函数中调用以QSizePolicy：：MiniⅡnⅡn为水平和垂直大小策略的setSize-
Policy(.)，会告诉负责管理这个窗口部件的任意布局管理器，这个窗口部件的大小提示就是它的最小
尺寸大小。换句话说，如果需要的话，可‘以拉长这个窗口部件，但是决不允许把它缩短到比它的大
小提示还要小的尺寸。在Qt设计师中，通过设置这个窗口部件的sizePolicy属性也可以实现这一
特性。第6~章将会解释各式各样韵大小策略。    ‘．

    函数sedconlmage()会设置需要编辑的图像。‘如果这个图像还不是我们正在编辑的图像，则会
调用convertToFormat()把它变成一个带alpha缓冲的32位图像。在其他代码中，将假设图像数据是
存储在32位的ARGB值中的。
    在设置完iⅡiage变量后，调用QWidget：：update()，它会使用新的图像强制重绘这个窗口部件。
接下来，调用QWidget：：updateGeometry()，告诉包含这个窗口部件的任意布局，这个窗口部件的大
心提示已经发生改变了。于是，该布局将会自动适应这个新的大小提示。
setZoomFactor()函数设置图像的缩放因子。为了避免在其他地方被0除，应纠正任何小于I的
  值。之后，会再次调用update()和updateGeometry()来重新绘制该窗口部件，以便可以把大小提示
  的变化通知给其他任何一个负责管理它的布局。    ，
    ．    一，r
    在头文件中，我们把penColor()、iconlmage()和zoomFactor()函数都实现成了内联函数。
    现在查看pa/ntEvent()函数的代码。这个函数是IconEditor最为重要的函数。只要需要重新绘
  制窗口部件，就会调用它。它在QWidget中的默认实现什么都不做，这样就留下了，个空白的窗口

    就像在第3章中碰到的closeEvent()函数一样，paintEvent()也是一个事件处理器。Qt还有很多
  其他的事件处理器，每一个都对应一种不同类型的事件。第7章将会进一步深入介绍事件的
  处理。
    当产生～个绘制事件并且调用pa/ntEverit()函数的时候，会出现如下几种情况：
    ●在窗口部件第一次显示时，系统会自动产生一个绘制事件，从而强制绘制这个窗口部件

    ●当重新调整窗口部件大小的时候，系统也会产生一个绘制事件。
    ·当窗口部件被其他窗口部件遮挡，然后又再次显示出来的时候，就会对那些隐藏的区域产
    生一个绘制事件（除非这个窗口系统存储了整个区域）。
    也可以通过调用QWidget：：update()或者QWidget.：：repaint(')来强制产生一个绘制事件。这两
  个函数之间的区别是：repaint()函数会强制产生一个即时的重绘事件；而update'()函数则只是在Qt
  下一次处理事件时才简单地调用一个绘制事件。（如果窗口部件在屏幕上是不可见的，那么这两
  个函数会什么也不做。）如果多次调用update()，Qt就会把连续多次的绘制事件压缩成一个单一的
-绘制事件，这样就可以避免闪烁现象。在IconEditor中，我们总是使用update()函数。

第5章创建自定义窗口部件
    一个窗口部件的调色板由三个颜色组构成：激活组( Active)、非激活组(Inactive)和不可用组
( Disabled)。应该使用哪一个颜色组取决于该窗口部件的当前状态：
    ●Active颜色组可用于当前激活窗口中的那些窗口部件。
    ●Inactive颜色组可用于其他窗口中的那些窗口部件。
    ●Disabled颜色组可用于任意窗口中的那些不可用窗口部件。
    QWidget:：palette()函数可以返回窗口部件的调色板，它是一个QPalette型对象。颜色组给定
为QPalette：：ColoICroup型枚举变量值。
    如果我们希望获得一个用于绘制的适当的画笔或者颜色，正确的方法就是使用当前调色板。它
可以通过QWidget：：palette()而获得，并且也可以使用所需的角色，例如，QPalette:：foreground()。每个
角色函数都可以返回一个画笔，它通常就正是我们所想要的东西，但如果我们只需要颜色的话，则
可以将其从画笔中提取出来，就像paintEvent()中所做的那样。默认情况下，返回的那些画笔都是
能够适用于窗口部件的状态的，因而就没有必要再去给定颜色组。
    以图像自舟的绘制作为paintEvent()函数的结尾。对IconEditor:：pixelRect()的调用会返回一个
QRect，其中定义了需要重新绘制的区域。（图5.4说明了矩形是如何绘制的。）作为简单的优化处
理方法，我们没有对落在这个区域之外的像素进行重新绘制。
    (width() -1,height() -1)
图5.4使用QPainter绘制一个矩形
    我们调用QPainter:：fllRect()来绘制一个缩放后的像素。QPainter:：fiⅡRect()带一个QRect和
一个QBrush。通过传递一个用作画笔的QColor，我们获得了一个实心填充图案。如果该颜色并非
完全不透明(它的‘alpha通道小于255)，就会先绘制出一个白色的背景来。

    pixelRect()函数返回一个适用于QPainter:：fmRect()酌QRect。这里的参数i和j是QJmage的
像素坐标，而不是窗口部件中的坐标。如果缩放因子是1，那么这两个坐标系就可以恰好一致了。
    QRect构造函数具有QRect(菇，，，，wtath，height)的语法形式，这里的（菇，，，）是这个矩形左上角的
位置坐标，而widt..h×height就是矩形的尺寸大小。如果缩放因子是3或者更大，则可以在矩形的
水平和竖直方向大小上都减去一个像素，以便在填充时不会覆盖那些网格线。
当用户按下鼠标按钮时，系统就会产生一个“鼠标按下”事件。通过重新实现QWidget：：mou。e．
PrI粥sEvent()，就可以响应这一事件，并且可以对鼠标光标下的图像像素进行设置或者清空。
    女口果用户按下了鼠标左键，则使用true作为调用私有函数setImagePix。l1()的第二个参数，告诉
它要把这个像素设茸成当前画笔的颜色：如果用户按下了鼠标右键，也会调用。etImagePixel()，但
这一次是通过传递false来清空这个像素。
mouseMoveEvent()赴理“鼠标移动”事件。默认情况下，只有当用户按住一个键不放的时候，才
会产生这些事件。通过调用QWidget：：setMouseTracking()则有可能改变这一行为，但是在这个例子
中不需要这样做。。
    就像按下鼠标左键或者右键可以设置或者清空一个像素一样，把按键按下不放并且悬停在另
一个像素上也足可以设置或者清空一个像素。由于有可能会同时按下多个键，所以最终结果实际
是QMouseEvent：：buttons()的返回值与鼠标的按键按照按位“或：！(|oR)运算之后的结果。可以使用
“&”操作符来测试某个特定键是否按下了，并且如果是这样的话，就调用setImagePixel()
    setImagePixel()西数是从mousePressEvent()和mouseMoveEvent()中得到调用的，用来设置或者清
空一个像素。pos参数是鼠标在窗口部件中的位置。
    第一步是把鼠标的位置从窗口部件的坐标转换到图像的坐标。这可以通过使用鼠标的x()．和
y()分量除以缩放因子完成。接下来，检查该点是否位于正确的范围之内。使用QImage：：re。t()和
QRect：：contains()可以很容易地完成这一检查过程。这样就可以高效地检查出i是不是在0和unt-
age.width() -1之间，j是否位t于0和'l/nage .height() -1之间。
    根据opaque参数，我们可．以设置或者清空图像中的像素。清空一个像素，实际就是把它设置
成透明。我们必须把画笔的QColor转换为一个用于调用QImaue：：setPixel()的32位ARGB值。最
后，对需要重新绘制的区域调用带QRect的update()。
    现在已经查看了各个成员函数，下面将回刭构造函数中使用的。Q：：WA_StaticContent。属性上。
这个属性告诉Qt，当重新改变窗口部件的大小时，这个窗口部件的内容并没有发生变化，而且它的
    第5章创建自定义窗口部件    89

内容仍旧保留从窗口部件左上角开始的特性。当重新定义窗口部件的大小时，通过使用这个信
息，Qt就可以避免对已经显示区域的重新绘制。图5.5图示了这一情形。

    图5.5重新改变Qt:：WA_StaticContents窗口部件的大小
    ’’
    通常情况下，当重新定义一个窗口部件的大小时，Qt会为窗口部件的整个可见区域生成一个
绘制事件。但是如果该窗口部件在创建时使用了Qc：：WA_ Stat/cContents属性，那么绘制事件的区
域就会被严格限定在之前没有被显示的像素部分上。这也就意味着，如果重新把窗口部件改变为
比原来还要小的尺寸，那么就根本不会产生任何绘制事件。
。  IconEditor窗口部件现在就完成了。．通过使用前几章中的知识和例子，我们编写代码，把
IconEditor作为一个独立的窗口，或者作为QMainWindow．申舶一个中央窗口部件、布局中的．个子
窗口部件以及QScrollArea(参见6.4节)中的一个子窗口部件。在下一节中，我们将会看到如何把
在Qt设计师中使用自定义窗口部件之前，我们必须让Qt设计师先察觉到它们的存在。有两
种方法可以完成这一任务：改进法( promot/on)和插件法(plugin)。    ：    ．。    ．
    改进法是最为快捷和简单的方法。这种方法包括：选择一个内置的Qt窗口部件t，但该窗口部
件要和我们自定义的窗口部件具有相类似的应用程序编程接口，并在Qt设计师的自定义窗口部
件对话框（如图5.6所示）中填写一些与这个窗口部件相关的信息。然后，这个自定义窗口部件就
可用于由Qt设计师开发的窗体中，尽管在编辑或者预览该窗体时它有可能仍旧显示为与之相关
的内置Qt窗口部件的形式。
。    ．    。。
图5.6 q设计师中的自定义窗口部件对话框
90
C++ GL11 Qt 4编程（第二版）
以下给出了如何使用这种方法在窗体中插入一个HexSpinBox窗口部件的步骤：    一
1．从Qt设计师的窗口部件工具盒中拖动一个QSpinBox到窗体中，由此创建一个QSpinBox。
2．右键单击这个微调框，并且从上下文菜单中选择“Promote to Custom Widget”（改进成自定义
  窗口部件）。
3．在弹出的对话框中，填入“HexSpinBox”作为类的名字，填入“hexspinbox．∥作为头文件的
  名字。
    这三步就足够了。由uic生成的代码将会包含hexspinbox．h，而不是<QSpinBox>，并且会生成
一个HexSpinBox的实例。在Qt设计师中，将会用QSpinBox的图标来代表HexSpinBox窗口部件，从
而允许我们设置QSpinBox的所有属性（例如，它的作用范围和当前值）。
    改进法的缺点是：在Qt设计师中，无法对自定义窗口部件中的那些特定属性进行访问，并且
也无法对这个窗口部件自身进行绘制。所有这两个问题都可以通过使用插件法得到解决。
    插件法需要创建一个插件库，Qt设计师可以在运行时加载这个库，并且可以利用该库创建窗
口部件的实例。在对宙体进行编辑或者用于窗体预览时，Qt设计师就会用到这个真正的窗口部
件，这要归功于Qt的元对象系统iQt设计师才可以动态获取它的这些属性的列表。’为了说明它是
如何工作的，我们将把前一小节中的IconEditor集成为一个插件。
    首先，必须对QDesigneICustomWidgetlnterface进行子类化，并且需要重新实现一些虚函数。假
定插件的源代码放在一个名为iconeditorplugin的目录中，并且IconEditor的源代码放在与iconeditor-
plugin目录同级的iconeditor目录中。
    以下是类的定义：    。
群include <QDesignerCustomWidgetlnterface>

    IconEditorPlugin予类是一个封装了这个IconEditor窗口部件的工厂(factoIy)类。它从QObject和
QDesigneICustomWidgetlter~ace中派生而来，并且使用Q_IRTERFACES()宏通知moc：这里的第二个基
类是一个插件接口。q设计师会使用这些函数创建这个类的各个实例并且获取相关信息。

构造函数非常简单。


第5章创建自定义窗口部件    91
name()函数返回由该插件提供的这个窗口部件的名字。
    includeFile()函数返回由该插件封装的特定窗口部件的头文件的名称。这个头文件会包含在
由LUC工具所生成的代码中。

    group()函数返回自定义窗口部件所应属于的窗口部件工具箱群组的名字。但如果以这个名
字命名的窗口部件工具箱群组还没有使用到，那么Qt设计师将会为这个窗口部件创建一个新
群组。

 icon()函数返回一个图标，可以在Qt设计师窗口部件工具箱中用它来代表自定义窗口部件。
这里，我们假定IconEditorPlugin有一个与之相关联的Qt资源文件(resource file)，其中有适当的一项
可作为图标编辑器图像。

toolTip()圈数返回一个工具提示信息，可在鼠标悬停在Qt设计师窗口部件工具箱中的自定义
窗口部件上时显示该信息。
whatsThis()函数返回用于Qt设计师“What's Tlus?”中显示的文本。

如果该窗口部件还可以包含其他窗口部件，isContainer()函数就返回true；否则；它就返回false。
例如，QFrame就是一个可以包含其他窗口部件的窗口部件。一般情况下，任何窗口部件都可以再

包含其他窗口部件，但是当isContainer()返回false时，Qt设计师则不会允许它再包含其他的窗口
部件。

Qt设计师会调用createWidget()函数，利用给定的父对彖创建该窗口部件类的一个实例。


    在实现该插件类的源文件的末尾，必须使用Q—EXPORT_PLUGIN2()宏，从而可以在Qt设计师
中使用这个插件。第一个参数是希望给插件的名字，第二个参数是实现该插件类的名字。
    用于构建该插件的．pro文件看起来如下所示：

qmake构建工具已经构建了一些预定义变量。．就是它们当中的一
个，它保存了指向Qt安装目录中plugins目录所在的路径。当键人make或者nmake来构建该插件
时，它就会自动把自己安装到Qt设计师的plugins/designer目录中。插件二旦构建宪毕，在Qt设计
师中就可以像使用其他内置的Qt窗口部件一样来使用IconEditor窗口部件。
    如果想在Qt设计师中集成多个自定义窗口部件，则既可以为每个窗口部件创建一个插件，也
可以通过从QDesigneICustomWidgetCollectionlnterface中派生的方式把它们组合成一个单一插件。
’  5.4双缓冲
    双缓冲(double buffering)是一种图形用户界面编程技术，它包括把一个窗口部件渲染到一个脱
屏像素映射( off-screen pixmap)中以及把这个像素映射复制到显示器上。在Qt的早期版本中，这种
技术通常用于消除屏幕的闪烁以及为用户提供一个漂亮的用户界面。
    在Qt 4中，QWidget会自动处理这些情况，所以我们很少需要考虑窗口部件的闪烁问题。尽管
如此，但如果窗口部件的绘制非常复杂并且需要连续不断地重复绘制时，明确指定使用双缓冲则
是非常有用的事情。于是就可以把这个窗口部件固定不变地存储成一个像素映射，这样就总可以
为下一个绘制事件做好准备，并且一旦收到绘制事件，就可以把这个像素映射复制到窗口部件上。
当我们想做一些小的修改时，比如一个橡皮筋选择框的绘制，此时并不需要对整个宙口部件进行
重复绘制和计算，从而就会显得特别有用。
    本章将通过回顾在图5.7和图5.9中显示的Plotter自定义窗口部件来结束。这个窗口部件使
用了双缓冲技术，并且也对Qt编程中的一些其他方面的知识进行了示范，包括像键盘事件处理、
手动布局和坐标系统等。

    第5章创建自定义窗口部件    93
    对于需要具有一个图形处理或者图形测绘窗口部件的真正应用程序来说，最好还是使用那些
可以获取的第三方窗口部件，而不是像这里所做的那样，去创建一个自定义窗口部件。例如，我们

Plotter窗口部件可以按照给定的矢量坐标绘制一条或者多条曲线。用户可以在图像中拖拽一
条橡皮筋选择框，并且Plotter将会对由这个橡皮筋选择框选定的区域进行放大。用户通过单击图
上的一个点、按住鼠标左键并且把鼠标拖动到另外一个位置，就可以拖拽出一个橡皮筋选择框，然
后就可以松开鼠标按键。Qt为绘制橡皮筋选择框提供了类，但这里通过我们自己来绘制它，以提
供更好的视觉控制效果，并且藉此说明双缓冲技术。．，    ，
    通过多次拖拽出橡皮筋选择框，可以重复进行放大操作。使用Zoom Out按钮可以进行缩小操
作，而使用Zoom In按钮又可以再放大回来。Zoom In和Zoom Out按钮在第一次出现的时候就处于
启用扶态。这样的话，如果用户没有对这个曲线图进行缩放，它们也不会弄乱图形的显示效果。
    Plotter窗口部件可以保存任意条曲线的数据。它还维护着一个PlotSett/ngs堆栈对象，而这每
一个堆栈对象都对应一个特定的缩放级别。
    让我们来查看一下这个类，先从plotter.h开始：
 苜先关注plotter头文件中包含的相应的Qt类头文件。在零件肇琴女譬聱劈jj还箭置声明了一些

在Plotter类中，提供三个公有函数来用于创建绘图区(：plot)，并且用薅个公有槽来响应图形的
放大和缩小操作。还重新实现了QWidget中的minimumS;izeHint(-和SrzeHint()两个函数。我们把曲
线的顶点存储为QVector <QPointF>t这里的？QPointF是二个其希浮j举数形式的QPomt。  ．

声明了一些用于绘制这个窗口部件的函数、一个常量和几个成员变量。
Margin帝量可以为图形区域的周围提供一些空间。
    在这些成员变量中，pixmap变量的类型为QPixmap。这个变量对整个窗口部件的绘制数据的
进行了复制保存，这和屏幕上显示的图形是相同的。绘图区总是先在脱屏像素映射上绘制图形。
然后，才把这一像素映射复制到窗口部件中。

    PlotSeffings类给定了x轴和y轴的范围，以及在这些轴上刻度标记符的数量。图5.8给出了一
个PlotSettings对象和一个Plotter窗口部件之间的对应关系。
    依照惯例，，把r/umXI'iCks和numYTicks部会减去1。如果numXI'icks是5，那么Plotter实际会在
x轴上绘制6个刻度标记符。这样可以简化后续运算。
    现在让我们查看一下它的实现文件：

setBackgroundRole()调用告诉QWidget使用调色板中的
“暗”分量作为重绘窗口部件的颜色，而不是使用“背景色”分
量。这样就可以为Qt设置一种默认颜色，当把这个窗口部件
重新改变成一个更大的尺寸时，甚至有可能是在paintEvent()
事件绘制那些新近显示的任意像素之前，就可以使用这种默
认颜色来填充这些新的像素。我们也需要调用se tAutoFill-
Background( true)来启用这一机制。（默认情况下，子窗口部件
会从它们的父窗口部件那里继承相应的背景色。）
    setSizePolicy()调用可以把这个窗口部件的大小策略设置
为在两个方向上都是QSizePolicy：：Expanding。这样就会告诉
图5.8 PlotSe/tings.的成员变量
负责这个窗口布局的任意布局管理器，这个窗口部件可以放大，也可以缩小，这对于那些要占用
很多屏幕空间的窗口部件来说，通常是一种比较典型的设置方法。在两个方向上，默认设置都是
QSizePoliqr：：Preferred，它的意思是指这个窗口部件的合适大小就是大小提示所给出的大小，但是如
果有必要，也可以无限放大它，或者也可以一直把它缩小到大小提示给出的最小大小。
    setFoucusPolicy(Qt：：StrongFocus)调用可以让窗口部件通过单击或者通过按下Tab键而输入焦
点。当Plotter获得焦点时，它将会接收由按键而产生的事件。Plotte。窗口部件可以处理一一些按键：
“+，，用来放大图形，“一”用来缩小图形，以及还可以使用四个方向键来上、下、左、右地滚动图形。
图5.9滚动Plotter窗口部件
    同样还是在构造函数中，创建了两个QToolButton，二者都有一个图标。允许用户通过这些按
钮进行缩小和放大操作。这些按钮的图标存储在一个资源文件中，因此任何使用Plotte，窗口部件
的应用程序都需要在它们的．pro文件中加入这一条代码：
资源文件与我们在Spreadsheet应用程序中曾经使用过的形式类似：

在这些按钮上调用的adjustSize()，可以把它们的大小设置成大小提示所给定的大小。这些按
钮没有放在布局中舛目反，我们将自己动手把它们放在Plotter的重定义大小事件中。由于没有使
用任何布局，所以必须通过对QPushButton的构造函数传递一个this指针来明确指定这些按钮所在
的父对象。    ．  ，  ．    。．
    最后，通过对setPlotSettings()的调用就完成了初始化工作：

setPlotSettings()豳数用于指定显示绘图区时所用到的PlotSettings。它可以被Plotter的构造函数
调用，也可以被使用这个类的用户调用。绘图区开始时使用它的默认缩放级。用户每放大一次，
都会创建一个新的PlotSettings实例，并且会将其放进缩放堆栈中。这个缩放堆栈由两个成员变量
来表示：
    ·类型为QVector <PlotSettings>的zoomStack保存不同的缩放级设置值。
    ·curZoom在这个zoomStack中保存PlotSettings的当前索引值。
    对setPlotSettings()进行调用之后，该缩放堆栈会只包含-项，并且Zoom In和Zoom Out按钮也
是隐藏的。只有当我们在zoomJn()和zoomOut()槽中对它们调用show()的时候，才会把这些按钮显
示出来。(一般情况下，在顶层窗口部件中调用show()足以显示所有的子窗口部件。但是，。当明确
地对子窗口部件调用hide()时，除非再次对它调用show()，否则它就．直会处于隐藏状态。）
    为了更新显示，refreshPixmlp()调用是很有必要t0'o通常情况下，本可以调用update()：但是这
里的傲法将会稍微有些不同，因为我们想让QPixmap在任意时刻都处于最新状态。在重新生成像
素映射之后，refreshPixmap()会调用update()。，会把像素映射复制到窗口部件中。一

图形放大后，可以使用这个zoomOut()槽进行缩小。它可以减小当前的缩放级数，并且可以根
据这个图形是否还允许缩得更小来设置Zoom Out按钮是否生效j Zoom In按钮会设置为生效并且
显示出来；而通过调用refreshPixmap()可以更新当前的显示结果a    ．

如果用户在此之前已经放大过图形并且又缩小了图形，那么用于下一缩放级数的PlotSettings将
会放在这个缩放堆栈中，因而就可以放大图形j（此外，还有可能通过橡皮筋选择框来放大图形。）  ：
    这个槽可以把curZoom移动到缩放堆栈中更深的位置上，它会根据是否允许把这个图形放得
更大来决定Zoom In按钮是生效还是无效，并且会启用和显示Zoom Out按钮。此外，会再次调用
refreshPixmap()，以便让这个绘图区能够使用到最新的缩放设置值。
setCurveData()函数设置了用于给定曲线ID中的数据。如果一条曲线的ID与girveMap中已经
存在的ID相同，那么将会用新的曲线数据替换原有的那些数据；否则，只是简单地插入新的曲线。
curveMap成员变量的类型为QMap <mt，QVector <QPointD>，    ，，

clearCurve()函数可以从curveMap中移除一条给定的曲线。

m/nimumSheHint()函数与sizeHint()函数相似。就像sizeHint()函数可以指定二个窗口部件的
理想大小一样，m/nimumSizeHint()可以指定一个窗口部件理想的最小大小。布局决不会把一个窗
口部件的大小修改为比它的最小大小提示还要小的大小。    二    ‘
    我们返回的这个值是300x 200(因为Margin= 5.0)，这可以在4条边上留出÷些空白区域，也可
以为图形本身留出一些空间。如果小于这个大小，那么该绘图区就会显得太小了，，也就没有什么

    茌sizeHint()中，我们返回一个和边白常量Mar~jn成比例的“理想”大小，它们会形成合适的3：2
比例，就像min/mumSizeHint()中用到的比例一样。    ’  。    ，。
    至此，就完成了对Plotter公有函数和公有槽的回顾。现在，来看一下处于protected段中的事件

    通常情况下，paintEvent()是执行所有绘制任务的地方。但这里，图形区的所有绘制任务都在
之前的refreshPixmap()中完成了，所以只需简单地通过把该像素映射复制到窗口部件的(O，O)位置
处来完成整个图形的绘制工作。
    如果橡皮筋选择框可见，则可以把它绘制在图形区的顶部。我们从窗口部件的当前颜色组中
选择“亮”分量作为画笔的颜色，这样可以确保绘制出的橡皮筋选择框能够与“暗”背景形成很好的
反差。需要注意的是，我们是直接在窗口部件上绘制的，而并未改变脱屏像素映射。使用QRect：：
nonnalized()可以确保这个矩形橡皮筋选择框的宽度和高度（如有必要，可以对换坐标）郡是正值，
并且adjusted()可以把矩形的大小减去1个像素，以允许它具有1像素宽的轮廓。
    如果Plotter拥有焦点，就会使用窗口部件风格的drawPrimitive()函数绘制这个焦点选择框(fo-
cus rectanle)，并使用QStyle:：PE_FrameFocusRect作为函数的第一个参数，使用QStyleOptionFocusRect
对象作为函数的第二个参数。焦点选择框各个绘制选项的初始化会基于Plotter窗口部件[通过调
用initFrom()]。背景颜色需要明确给定。
    当希望使用当前风格进行绘制时，则可以直接调用QStyle函数，例如：
也可以使用QStylePainter代替常用的QPainter，就像Plotter中所做的那样，并且使用QStylePa/nter会
使绘制工作显得更加方便些。
    QWiclget:：style()函数返回绘制窗口部件时应当使用的风格。在Qt中。窗口部件风格是QSt}le
的一个子类。内置的风格类型包括QWindowsStyle.QWindowsXPStyle、QWindowsVistaStyle、QMotifStyle、
QCDEStyle、QMacStyle~QPlastiqueStyle以及QCleanlooksStyle。每一种风格都重新实现了QSt}le中的
一些虚函数，它们会以该风格所模拟平台的正确方式来执行绘制操作。QStylePainter的drawPrimi-
tive()函数调用与QStyle中函数同名的函数，这样就可以用来绘制像面板、按钮和焦点选择框这样
的一些“基本元素”(primit/ve element)。在一个应用程序中，所有窗口部件的风格(QApplication：：
style())通常都是相同的，但是也可以在每个窗口部件的基础上使用QWidget：：setStyle()对它们的
风格进行重新定义。
  ：通过子类化QStyle，就有可能定义一种新的自定义风格。这样就可以为一个或者一组应用程
序设置一种与众不同的外观，就像第19章中将看到的那样。通常情况下，尽管我们认为使用目标
平台所提供的本地化外观是一种明智的选择，但如果你乐于探索的话，Qt还是为你提供了很大的
自由度。
    Qt的内置窗口部件几乎都只依赖于QSt}le来绘制自身。这就是为什么在'Qt支持的所有平台
上，它们看起来都像原有平台上的窗口部件一样。要获得与风格楣关的自定义窗口部件，既可以
通过使用QSt}le绘制它们自身的方式，也可以通过把Qt的内置窗口部件作为子窗口部件的方式。
对于Plotter，则使用这两种方式的组合：使用QSt}le(借助QStylePainter)绘制焦点选择框，而Zoom In
和Zoom Out按钮则使用Qt的内置窗口部件来完成。
第5章创建自定义窗口部件

只要一改变Plotter窗口部件的大小，Qt就会产生一个“重定义大小”事件。这里重新实现了
resizeEvent()，它把Zoom In和Zoom Out按钮放置在Plotter窗日部件的右上角。  ‘    ，
    我们把Zoom In和Zoom Out按钮一个挨一个地放好，它们之间有5个像素的间隔，并且距离它
们的父窗口部件的上边缘和右边缘各有5个像素。
    如果想把这些按钮总是放在图形的左上角，其坐标是(o，o)，那么只需在Plotte。的构造函数中
简单修改一下就可以了。但是，如果想追踪的是图形的右上角，那么此处的坐标就取决于窗口部
件的大小。正是因为这一点，重新实现resizeEvent()井且把这些按钮的位置放在那里就显得很有
必要了。    。二
    在Plotter的构造函数中，没有为按钮设置任何位置。但这不并是什么问题，因为‘在一个窗口
部件第一次显示之前，Qt总是会自动产生一个重定义大小事件。。。    一．二-
    除了通过重新实现resizeEvent()并且手动摆放这些子窗口部件这一方法之外，还有可能使用
的另外一种方法是使用布局管理器(例如，QCriidLayout)。使用布局可能会稍微有些麻烦，并且可能
会消耗更多的资源。另一方面，能够按照从右到左的方式来处理布局可能会显得更漂亮些，而且
这对于像阿拉伯语和希伯来语的那些语言来说也是很有必要的。    ：。j。√
    最后，调用refreshPixmap()，以按照新的尺寸大小重新绘制像素映射。  ‘  ：‘、

    驾用户按下鼠标左键，就开始显示一个橡皮筋选择框。这样会产生一系列事件，像把rubber-
BandIsShown设置为true，以当前鼠标指针所在的位置初始化rubberBandRect，调用—个绘制该橡皮
筋选择框的绘制事件以及把鼠标光标修改成十字形光标等。
    rubbcrBandRect变量的类型是QRect。QPLect既可以通过．4个分量（菇1，y，wulth，height）定义——
这里的（菇，，，）是它的左上角的点的位置坐标，width.×height是这个矩形的大小，也可以使用一个左
上角和一个右下角两个点而形成的一个坐标对来定义。这里使用的表示方法就是坐标对表示法。
我们把用户点击的点既当作橡皮筋选择框的左上角坐标又把它当作右下角坐标。然后，调周up-
dateRubberBandRcgion()来对橡皮筋选择框所覆盖的（最小）区域进行强制重绘。
    Qt提供了两种用于控制鼠标光标形状的机制：
-当鼠标悬停在某个特殊的窗口部件上时，QWidget：：setCursor()可以设置它所使用的光标形
100
C++'GUI Qt 4:编程（第二版）
状。如果没有为窗口部件专门设置光标，那么就会使用它的父窗口部件中的光标。顶层窗
，口部件的默认光标是箭头光标：‘  L    ’
·对于整个应用程序7中所使用的光标形状，可以通过QApplicaUoni：setOverrideCursor()进行设
置，它会把不同窗口部件中的光标形状全部覆盖掉，直到调用restoreOverrideCursor()。
    在第4章中，就调用了以Qt:：WaitCurosr为参数的QApplicaUon:：setOverrideCursor()，它把应用
程序的光标变成了标准的等待光标(wait cursor)。

当用户按下鼠标左键并移动鼠标光标的时候，会首先调用updateRubberBandRegion()未预约一
个绘制事件，由其对橡皮筋选择框所在的区域进行重新绘制。然后，重新计算rubberBandRect来说
明这次鼠标移动的距离。最后，调用updateRubberBandRegion()再一次对绘制橡皮筋选择框已经移
动到的区域进行重新计算。这样做，可以有效地擦除橡皮筋选择框，并且可以在新的坐标系中重
新绘制它。    、    ‘
  如果用户向上或者向左移动鼠标，那么rubberBandRect名义上的右下角看起来就好像跑到了
左上角的上面或者左面了。如果发生这种情况，那么这个QRect就会具有一个负的宽度或者高度
值。因此在paintEvent()中使用QRect：：nonnalized()，从而可以对它的左上角和右下角坐标进行调
整，以确保能够获得非负的宽度值或者高度值。

  驾用户释放鼠标左键时，会擦除这个橡皮筋选择框，并且把光标恢复成标准的箭头光标。如
果橡皮筋选择框不小于4x4，那么就执行缩放操作。如果橡皮筋选择框小于4x4，看来应当是用
户错误地点击了窗口部件，或者仅仅是为了让窗口部件获得焦点，所以就什么也不做。
  这段执行缩放的代码稍微有一点复杂。这是因为需要同时处理窗口部件坐标系和绘图区坐
    ·    J
第5章创建自定义窗口部件
101
标系。这里所做的绝大多数工作都是为了把rubberBandRect的坐标从窗口部件坐标系转换成绘图
    L    ．    ．
区坐标系。这一转换过程一旦完成，就可以调用PlotSetUngs：：ajust()圆整这些数据，并且为每根坐
    _    L
标轴找出一个合适的刻度标记符个数。图5.10和图5.11描述了这一处理过程。
(0，0)
图5.10把橡皮筋选择框的坐标从窗口部件坐标系转换成绘图区坐标系
图5.11调整绘图区坐标系并且放大橡皮筋选择框。
  然后，执行缩放操作。这一缩放工作的实现是通过把刚刚计算过的PlotSefUngs放到缩放堆栈
的顶端并且调用zoomln()来完成的。    …。

  。当用户按下_个键并且Plotter窟口部件拥有焦点时，就会调用keyPressEyent()函数。在这里，
我们重新实现该函数以响应6个按键：+、一以及向上-、向下、向左和向右4个方向键。如果用户
按下的是一个无法处理的键，那么就调用基类的实现。为简便起见，我们忽略了Shift、Cul和Alt这
些修饰键，可以通过QKeyEvent:：modifiers()来获得它们的状态。
 wheel)时，就会产生滚轮事件。绝大多数鼠标只提供一个垂直滚轮，但是也
有一些鼠标还提侠了另外一个水平滚轮。对这两种滚轮Qt都可以支持。滚轮事件会到达那些拥
有焦点的窗口部件。delta()函数可以返回一个距离，它等于滚轮旋转角度的8倍。，鼠标通常都以
15度作为步长。这里，通过修改缩放堆栈上最顶端的元素来改变所需的标记符的数量，并且使用
refreshPixmap()更新显示。    、
    鼠标滚轮最为常见的用法是用它来滚动一个滚动条。当使用QScronArea（将会在第6章中讲
到）来提供一些滚动条的时候，QScronArea会自动处理鼠标的滚动事件，所以不需要重新实现
wheemvent()。
    这样就完成了对事件处理器的实现。现在来看一下私有函数。


到调用，用来擦除或者重新绘制橡皮筋选择框。这个函数由4个update()调用组成，它们为橡皮筋
选择框（由两条垂直线和两条水平线构成）所覆盖的4个小矩形区域调用一个绘制事件。
    refreshPinnap()函数把绘图区重新绘制到脱屏像素映射上，并且对显示加以更新。我们把像素
映射的大小调整为与窗口部件的大小一样，并且使用窗口部件的擦除颜色来填充该像素映射。这
个颜色就是调色板中的“暗”分量，因为是在Plotter的构造函数中调用setBack&ounidRole()的。如果
背景色是一个非实心画笔，QPixmap:：fll()就需要知道窗口部件中的偏移量，像素映射需要在那里
恰好与画笔图案相对齐。这里，像素映射与整个窗口部件相对应，所以就指定位置(O，O)。

    然后，创建一个QPainter在这个像素映射上进行绘制。initFrom()调用可以设置painter所使用的
画笔、背景色和字体，这些都与Plotter窗口部件中的一样。接下来，调用drawGrid()和drawCLuves()来
执行绘制。最后，调用update()，从而为整个窗口部件预约一个绘制事件。在97页的paintEvent()
函数中，已经将把这个像素映射复制到窗口部件中。，

    drawCrid()卤数绘制曲线和坐标轴后面的网格。绘制网格的区域是通过rect给定的。如果窗
口部件不够大，不能容纳下这个图形，就立即返回。
    第1个for循环绘制了网格的垂直线和沿x轴方向上的标记符。第2个for循环绘制了网格的
水平线和沿y轴方向上的标记符。最后，沿空白区域绘制一个长方形。drawText()函数用于绘制两
个坐标轴上与记号相对应的那些数字。
    对于drawText()的调用遵循下面的语法形式：
定义了一个矩形，alignmenL是在这个矩形中文本的位置，而text就是要
绘制的文本。在本例中，已经人工计算出了用于绘制文本的矩形。另外一种具有更好适应性的方
法或许应当是使用QFontMetrics，其中包含了文本边界框的计算。  ，
drawCurves()函数在网格上绘制这些曲线。我们从调用setClipRect()开始，它为包含这些曲线
（边白和包围绘图区的框架除外）的矩形设置QPainter剪辑区。‘然后，QPainter将会忽略在这个区域
之外的像素绘制操作。
    一旦已经将_条曲线全部点的坐标都转换成了窗口部件中的坐标，就可以为用于这条曲线的画笔
设置颜色(使用预定义的颜色集之-)，并直调用dr?wPolyline(．)绘制F条经过该曲线上所有点的直线。
’  这就是完整的Plotter类。毋在只剩下PlotSettinE;s中aj:_些函数了。
 scroll()函数使用两个记号之间的距离乘以j个给定数字的方式来增加（或者减少）lninX、
maxX、minY和maxY的值。这个函数在Plotter:：keyPressEvent()中用来实现滚动功能。

    从mouseReleaseEvent()中调用的adjust()函数，用来把minX、maxX、minY和maxY圆整成“合适
的”数值，并且用于决定每一个坐标轴上应当使用的标记符个数。私有函数adjustAx/s()每次可以
处理一个坐标轴。

。adjustAxis()函数把它的nun和max参数转换成“合适的”数值，并且在给定的【nun，max]范围内
计算出合适的标记符个数，然后把它的numTicks参数设置成该值。因为、需要对变量
（minX、Ⅱ，axX、nurnXI'ick,s，等等）进行实际修改而不仅仅只是复制，所落《的i
adjustAxis()中的绝大多数代码都只是简单地试图确定两个记号之间适当距离的合适数值（这
里就是“步长”）。为了沿每一根轴都可以获禧这样的合适数值，必须小心地选择这爷步篝。侈jI如，
一个步长为3.8的数值会导致这根轴的长度应当是3.8的若干倍，但是这样的数值很难使人认同
它。+对于以十进制为标记的轴，“合适的”步长值应该具有像10“、2×10“或者5×10n这样的数值
形式。    1
    一开始，我们先计算“总步长”，它是该步长最大僮的一种形式。然后，找到一个小于或等于这
个总步长并且形式为10“的对应值。对它进行以10为基数的对数运算，然后对它取整，再以10为
底、以前面取整所得的整数为指数，从而形成幂的形式。例如，如果总步长为236，则计算．log 236：
2.-37291．．‘。然后，对它取整得到整数2，这样就可以得到l02= 100，也就是具有形式为lOn的一个
候选步长值。    ，j  i：  j．,'?    。，：    ’
    一旦获得了第一个步长候选值，就可以使用它计算另外两种形式的候选值：2×10”和5×
10“。根据前面的计算示例，这另外的两个候选值分别为200j和5010。而500比总步长要大，所以不
能使用它。200则比236要小，所以在这个例子中，我们使用200’作为步长值。
    利用这个步长值，就可以很容易地推算出numTicks、nun和max的值。新的nun值是小于初始
m/n值的最近的步长倍数值，而新的max值大于初始max的最近的步长倍数值。新的nurnTicks是
取整后的nuii和max之间的距离个数。例如，如果在这个函数中输入的nun为240并且rnax为
1184，那么新的范围就变为[200，1200]，有5个标记符。

这种算法在有些情况下给出的并不是最佳结果。发表在“Graphics Gems”(Morgan Kaufinann，
1990)上Paul S．Heckbert的文章“Nice Numbers for Graph Labels”中，描述了一个复杂的算法。
    通过这一章，就结束了本书的第一部分。这一章解释了如何对已经存在的Qt窗口部件进行
自定义，并且说明了如何使用QWidget作为基类来构建窗口部件的方法。第2章讲解了如何使用
已有的窗口部件来组建新的窗口部件，而在第6章还会对这一主题做进一步探索。
    到此为止，我们利用Qt已经足以编写出完整的图形用户界面应用程序。在第二部分和第三
部分，将会更进一步探索Qt，以使我们能够更为充分地利用Qt的强大功能。