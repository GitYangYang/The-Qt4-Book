% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig linefig xverbatim

\documentclass[11pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{11pt}


\usepackage{myconfig}
\usepackage{mytitle}


\begin{document}
\frontmatter

\titlea{The-Qt4-Book}
\author{Jasmin B., Mark S.}
\authorinfo{作者全名：Jasmin Blanchette, Mark Summerfield。本文代码来自\href{http://www.qtrac.eu/marksummerfield.html}{这个网站}。原中文翻译：闫锋欣，曾泉人，张志强；原中文审校：周莉娜，赵延兵。}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：德山书生，湖南常德人氏。我负责整理排版工作。本项目Github网站在\href{https://github.com/a358003542/The-Qt4-Book}{这里}。有意见请反馈。}
\version{0.01}
\titleLA

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
为什么会是Qt？为什么像我这样的程序员会选择Qt？这个问题的答案显而易见：Qt单一源程序的兼容性、丰富的特性、C++方面的性能、源代码的可用性、它的文档、高质量的技术支持，以及在奇趣科技公司那些精美的营销材料中所涉及的其他优势等。这些答案看起来确实都不错，但是遗漏了最为重要的一点：Qt的成功缘于程序员们对它的喜欢。

那么，是什么让程序员喜欢某种技术而放弃另外一种呢？就我而言，我认为软件工程师们喜欢某种技术，是因为他们觉得这种技术是合适的，但是这也会让他们讨厌所有那些他们觉得不合适的其他技术。除此之外，我们还能解释下面的这些情况吗？例如，一些最出众的程序员需要在帮助之下才能编写出一个录像机程序，或者又比如，似乎大多数工程师在操作本公司的电话系统时总会遇到麻烦。我虽然善于记住随机数字和指令的序列，但是如果将其比作用于控制我的应答系统所需要的条件来说，则可能一条也不具备。在奇趣科技公司，我们的电话系统要求在拨打其他人的分机号码前，一定要按住"*"键2秒后才允许开始拨号。如果忘记了这样做而是直接拨打分机号码，那么就不得不再重新拨一遍全部的号码。为什么是"*"键而不是"\#{}"键、"1"键或者"5"键？或者为什么不是20个电话键盘中的其他任何一个呢？又为什么是2秒，而不是1秒、3秒或者1.5秒呢？问题到底出在哪里？我发现电话很气人，所以我尽可能不去使用它。没有人喜欢总是去做一些不得不做的随机事情，特别是当这些随机事情显然只出现在同样随机的情况下的时候，真希望自己从来都没有听到过它。

编程很像我们正在使用的电话系统，并且要比它还糟糕。而这正是Qt所要解决的问题。Qt与众不同。一方面，Qt很有意义；另一方面，Qt颇具趣味性。Qt可以让您把精力集中在您的任务上。当Qt的首席体系结构设计师面对一个问题的时候，他们不是寻求一个好的、快速的或者最简便的解决方案，而是在寻求一个恰当的解决方案，然后将其记录在案。应当承认，他们犯下了一些错误，并且还要承认的是，他们的一些设计决策没有通过时间的检验，但是他们确实做出了很多正确的设计，并且那些错误的设计应当而且也是能够进行改正的。看一看最初设计用于构建Windows 95和UNIX Motif之间的桥梁系统，到后来演变为跨越Windows Vista、Mac OS X和
GNU/Linux以及那些诸如移动电话等小型设备在内的统一的现代桌面系统，这些事实就足以证明这一点。

早在Qt大受欢迎并且被广泛使用很久以前，正是Qt的开发人员为寻求恰当的解决方案所做出的贡献才使Qt变得与众不同。其贡献之大，至今仍然影响着每一个对Qt进行开发和维护的人。对我们而言，研发Qt是一种使命和殊荣。能够使您的职业生涯和开源生活变得更为轻松和更加有趣，这让我们倍感自豪。

人们乐于使用Qt的诸多原因之一是它的在线帮助文档，但是该帮助文档的主要目的是集中介绍个别的类，而很少讲述应当如何构建现实世界中那些复杂的应用程序。这本好书填补了这一缺憾，它展示了Qt所提供的东西，如何使用“Qt的方式”进行Qt编程，以及如何充分地利用Qt。本书将指导C++、Java或者C\#{}程序员进行Qt编程，并且提供了丰富详实的资料来使他们成长为老练的Qt程序员。这本书包含了很多很好的例子、建议和说明——并且，该书也是我们对那些新加入公司的程序员们进行培训的入门教材。

如今，已有大量的商业或者免费的Qt应用程序可以购买或者下载，其中的一些专门用于特殊的高端市场，其他一些则面向大众市场。看到如此多的应用程序都是基于Qt构建而成的，这使我们充满了自豪感，并且还激励我们要让Qt变得更好。相信在这本书的帮助下，将会前所未有地出现更多的、质量更高的Qt应用程序。

{\hfill Matthias Ettrich}

{\hfill 德国，柏林}

{\hfill 2007年11月}

\section*{序言}
Qt使用“一次编写，随处编译”的方式为开发跨平台的图形用户界面应用程序提供了一个完整的C++应用程序开发框架。Qt允许程序开发人员使用应用程序的单一源码树来构建可以运行在不同平台下的应用程序的不同版本；这些平台包括从Windows 98到Vista、MacOS X、Linux、Solaris、HP-UX以及其他很多基于X11的Unix。许多Qt库和工具也都是Qt/Embedded Linux的组成部分。Qt/Embedded Linux是一个可以在嵌入式Linux上提供窗口系统的产品。

本书的目标就是教您如何使用Qt4来编写图形用户界面程序。本书从"Hello Qt"开始，然后很快地转移到更高级的话题中，如自定义窗口部件的创建和拖放功能的提供等。通过本书的\href{http://www.informit.com/store/c-plus-plus-gui-programming-with-qt4-9780132354165}{互联网站点}，您可以下载到一些作为本书文字补充材料的示例程序。附录A说明了如何下载和安装这些软件，其中包括一个用于Windows的C++免费编译器。

本书分为四部分。第一部分涵盖了在使用Qt编写图形用户界面应用程序时所必需的全部基本概念和练习。仅掌握这一部分中所蕴含的知识就足以写出实用的图形用户界面应用程序。第二部分进一步深入介绍了Qt的一些重要主题，第三部分则提供了更为专业和高级的材料。您可以按任意顺序阅读第二部分和第三部分中的章节，但这是建立在您对第一部分中的内容非常熟悉的基础之上的。第四部分包括数个附录，附录B说明了如何构建Qt应用程序，附录C则介绍了Qt Jambi，它是Java版的Qt。

本书的第一版建立在Qt 3版本的基础上，尽管已通过全书修订来反映那些很好的Qt4编程技术，但本书还是根据Qt4的模型，视图结构、新的插件框架、使用Qt/Embedded Linux进行嵌入式编程等内容而引入了一些新的章节和一个新的附录。作为第二版，本书充分利用了Qt 4.2和Qt 4.3中引入的新特性对其进行了彻底更新，并包含“自定义外观”和“应用程序脚本”两个新的章以及两个新的附录。原有的“图形”一章已经拆分为“二维”和“三维”两章，在它们中间，涵盖了新的图形视图类和QPainter的OpenGL后端实现。此外，在数据库、XML和嵌入式编程等几章中，还添加了许多新内容。

与本书的前两版一样，这一版的重点放在如何进行Qt编程的说明和许多真实例子的提供上，而不是对丰富的Qt在线文档的简单拼凑和总结。因为本书纯粹讲授的是Qt 4编程中的原理和实践知识，因而读者能够轻松学会将要出现在Qt 4.4、Qt 4.5以及Qt 4.x等后续版本中的15个Qt新模块。如果您正在使用的Qt版本恰好是这些后续版本中的一个，那么当然要阅读一下参考文档中的"What's New in Qt 4.x"一章，以便可以对那些可用的新特性有一个总体把握。

在写作本书的时候，是假定您已经具备了C++、Java或者C\#{}的基本知识。本书中的例子代码使用的是C++中的一个子集，从而避免了很多在Qt编程中极少使用的C++特性。在某些不可避免而必须使用C++高级结构的地方，会在使用时对其做出必要的解释。如果您对Java或者C\#{}已经非常熟悉但是对C++还知之不多甚至一无所知，那么建议您先阅读附录D。附录D提供了对C++较为充分的介绍，从而能够让您具有使用本书所必备的C++知识。对于C++中的面向对象编程更为全面的介绍，建议您阅读由P. J. Deitel和H. M. Deitel编著的"C++ How to Program"(Prentice Hall , 2007)，以及由Stanley B. Lippman , Josée Lajoie和Barhara E. Moo编著的"C++ Primer"(Addison-Wesley , 2005)这两本书。

\section*{Qt简史}
Qt框架首度为公众可用是在1995年5月。它最初由Haavard Nord（奇趣科技公司的CEO）和Eirik Chambe-Eng（公司总裁）开发而成。Haavard和Eirik在位于挪威特隆赫姆的挪威科技学院相识，在那里，他们都获得了计算机科学的硕士学位。

Haavard对C++图形用户界面开发的兴趣始于1988年，当时一家瑞典公司委托他开发一套C++图形用户界面框架。几年后，在1990年的夏天，Haavard和Eirik因为一个超声波图像方面的C++数据库应用程序而在一起工作。这个系统需要一个能够在UNIX、Macintosh和Windows上都能运行的图形用户界面。在那个夏天中的某天，Haavard和Eirik一起出去散步，享受阳光，当他们坐在公园的一条长椅上时，Haavard说：“我们需要一个面向对象的显示系统。”由此引发的讨论，为他们即将创建的面向对象的、跨平台的图形用户界面框架奠定了智力基础。

1991年，Haavard和Eirik开始一起合作设计、编写最终成为Qt的那些类。在随后的一年中，Eirik提出了“信号和槽”的设想——一个简单并且有效的强大的图形用户界面编程规范，而现在，它已经可以被多个工具包实现。Haavard实践了这一想法，并且据此创建了一个手写代码的实现系统。到1993年，Haavard和Eirik已经开发出了Qt的第一套图形内核程序，并且能够利用它实现他们自己的一些窗口部件。同年末，为了创建“世界上最好的C++图形用户界面框架”，Haavard提议一起进军商业领域。

1994年成为两位年轻程序员不幸的一年，他们没有客户，没有资金，只有一个未完成的产品，但是他们希望能够闯进一个稳定的市场。幸运的是，他们的妻子都有工作并且愿意为他们的丈夫提供支持。在这两年里，Haavard和Eirik认为，他们需要继续开发产品并且从中赚得收益。

之所以选择字母“Q”作为类的前缀，是因为该字母在Haavard的Emacs字体中看起来非常漂亮。随后添加的字母"t"代表“工具包”(toolkit)，这是从"Xt"——一个X工具包的命名方式中获得的灵感。公司于1994年3月4日成立，最初的名字是"Quasar Technologies"，随后更名为"Troll Tech"，而公司今天的名字则是"Trolltech"。

1995年4月，通过Haavard就读过的大学的一位教授的联系，挪威的Metis公司与他们签订了一份基于Qt进行软件开发的合同。大约在同一时间，公司雇佣了Arnt Gulbrandsen，在公司工作的6年时间里，他设计并实现了一套独具特色的文档系统，并且对Qt的代码也做出了不少贡献。

1995年5月20日，Qt 0.90被上传到sunsite.unc.edu。6天后，在\\ comp.os.linux.announce上发布。这是Qt的第一个公开发行版本。Qt既可以用于Windows上的程序开发，又可以用于UNIX上的程序开发，而且在这两种平台上，都提供了相同的应用程序编程接口。从第一天起，Qt就提供了两个版本的软件许可协议：一个是进行商业开发所需的商业许可协议版，另一个则是适用于开源开发的自由软件许可协议版。Metis的合同确保了公司的发展，然而，在随后长达10个月的时间内，再没有任何人购买Qt的商业许可协议。

1996年3月，欧洲航天局(European Space Agency)购买了10份Qt的商业许可协议，它成了第二位Qt客户。凭着坚定的信念，Eirik和Haavard又雇佣了另外一名开发人员。Qt 0.97在同年5月底正式发布，随后在1996年9月24日，Qt1.0正式面世。到了这一年的年底，Qt的版本已经发展到了1.1，共有来自8个不同国家的客户购买了18份Qt的商业许可协议。也就是在这一年，在Matthias Ettrich的带领下，创立了KDE项目。

Qt 1.2于1997年4月发布。Matthias Ettrich利用Qt建立KDE的决定，使Qt成为Linux环境下开发C++图形用户界面的事实标准。Qt 1.3于1997年9月发布。

Matthias在1998年加入公司，并且在当年9月，发布了Qt 1系列的最后一个版本——V 1.40。1999年6月，Qt 2.0发布，该版本拥有一个新的开源许可协议——Q公共许可协议(QPL，Q Public License)，它与开源的定义一致。1999年8月，Qt赢得了LinuxWorld的最佳库/工具奖。大约在这个时候，Trolltech Pty Ltd（澳大利亚）成立了。

2000年，公司发布了Qt/Embedded Linux，它用于Linux嵌入式设备。Qt/Em-bedded Linux提供了自己的窗口系统，并且可以作为X11的轻量级替代产品。现在，Qt/X11和Qt/Embedded Linux除了提供商业许可协议之外，还提供了广为使用的GNU通用公共许可协议（GPL: General Public License）。2000年底，成立了Trolltech Inc.（美国），并发布了Qtopia的第一版，它是一个用于移动电话和掌上电脑(PDA)的环境平台。Qt/Embedded Linux在2001年和2002年两次获得了LinuxWorld的"Best Embedded Linux Solution"奖，Qtopia Phone也在2004年获得了同样的荣誉。

2001年，Qt 3.0发布。现在，Qt已经可用于Windows、Mac OS X、UNIX和Linux（桌面和嵌入式）平台。Qt 3提供了42个新类和超过500 000行的代码。Qt 3是自Qt 2以来前进历程中最为重要的一步，它主要在诸多方面进行了众多改良，包括本地化和统一字符编码标准的支持、全新的文本查看和编辑窗口部件，以及一个类似于Perl正则表达式的类等。2002年，Qt 3赢得了Software Development Times的"Jolt Productivity Award"\footnote{Jolt大奖素有“软件业界的奥斯卡”之美誉，共设通用类图书、技术类图书、语言和开发环境、框架库和组件、开发者网站等十余个分类，每个分类设有一个“震撼奖”(Jolt Award)和三个“生产力奖”(Productivity Award)。一项技术产品只有在获得了Jolt奖之后才能真正成为行业的主流，一本技术书籍只有在获得了Jolt奖之后才能真正奠定其作为经典的地位。虽然Jolt奖项并不起决定作用，但它代表了某种技术趋势与潮流——译者注。}。

2005年夏，Qt 4.0发布，它大约有500个类和9000多个函数，Qt 4比以往的任何一个版本都要全面和丰富，并且它已经裂变成多个函数库，从而使开发人员可以根据自己的需要只连接所需要的Qt部分。相对于以前的所有Qt版本，Qt 4的进步是巨大的，它不仅彻底地对高效易用的模板容器、高级的模型/视图功能、快速而灵活的二维绘图框架和强大的统一字符编码标准的文本查看和编辑类进行了大量改进，就更不必说对那些贯穿整个Qt类中的成千上万个小的改良了。现如今，Qt 4具有如此广泛的特性，以至于Qt已经超越了作为图形用户界面工具包的界限，逐渐成长为一个成熟的应用程序开发框架。Qt 4也是第一个能够在其所有可支持的平台上既可用于商业开发
又可用于开源开发的Qt版本。  

同样在2005年，公司在北京开设了一家办事处，以便为中国及其销售区域内的用户提供服务和培训，并且为Qt/Embedded Linux和Qtopia提供技术支持。

通过获取一些非官方的语言绑定件(language bmdings)，非C++程序员也已早就开始使用Qt，特别是用于Python程序员的PyQt语言绑定件。2007年，公司发布了用于C\#{}程序员的非官方语言绑定件Qyoto。同一年，Qt Jambi投放市场，它是一个官方支持的Java版Qt应用程序编程接口。附录C提供了对Qt Jambi的介绍。

自奇趣科技公司诞生以来，Qt的声望经久不衰，而且至今依旧持续高涨。取得这样的成绩不但说明了Qt的质量，而且也说明了人们都喜欢使用它。在过去的10年中，Qt已经从一个只被少数专业人士所熟悉的“秘密”产品，发展了到如今遍及全世界拥有数以千计的客户和数以万计的开源开发人员的产品。


\section*{编者的话}
感谢作者，感谢原中文翻译者，感谢原中文审校者。

书名修改不是想标新立异，实在是github和本地文档编译方便，不支持空格。

感谢汉王OCR技术支持，感谢\XeLaTeX 。




%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter


\part{Qt基础}
\chapter{Qt入门}
这一章介绍了如何把基本的C++知识与Qt所提供的功能组合起来创建一些简单的图形用户界面（Graphical User Interface，GUI）应用程序。在这一章中，还引入了Qt中的两个重要概念：一个是“信号和槽”，另外一个是“布局”。第2章还将对它们做进一步的阐述，而第3章将着手创建一个具有真正意义的应用程序。  

如果你已经熟知Java或C\#{}，但对C++的编程经验还有些欠缺的话，那么在开始阅读本书之前，可能需要先阅读附录D，它对C++做了简要介绍。

\section{Hello Qt}
我们先从一个非常简单的Qt程序开始。首先一行一行地研究这个程序，然后将会看到如何编译并运行它。

\begin{cppinput}{qt4-book/chap01/hello/hello.cpp}
\end{cppinput}


第1行和第2行包含了类QApplication和QLabel的定义。对于每个Qt类，都有一个与该类同名（且大写）的头文件，在这个头文件中包括了对该类的定义。

第6行创建了一个QApplication对象，用来管理整个应用程序所用到的资源。这个QApplication构造函数需要两个参数，分别是argc和argv，因为Qt支持它自己的一些命令行参数。

第7行创建了一个显示“Hello Qt!”的QLabel窗口部件(widget)。在Qt和UNIX的术语(tenninology)中，窗口部件就是用户界面中的一个可视化元素。该词起源于“window gadget”（窗口配件）这两个词，它相当于Windows系统术语中的“控件”(control)和“容器”(container)。按钮、菜单、滚动条和框架都是窗口部件。窗口部件也可以包含其他窗口部件，例如，应用程序的窗口通常就是一个包含了一个QMenuBar、一些QToolBar、一个QStatusBar以及一些其他窗口部件的窗口部件。绝大多数应用程序都会使用一个QMainWindow或者一个QDialog来作为它的窗口，但Qt是如此灵活，以至于任意窗口部件都可以用作窗口。在本例中，就是用窗口部件QLabel作为应用程序的窗口的。   

第8行使QLabel标签(label)可见。在创建窗口部件的时候，标签通常都是隐藏的，这就允许我们可以先对其进行设置然后再显示它们，从而避免了窗口部件的闪烁现象。

第9行将应用程序的控制权传递给Qt。此时，程序会进入事件循环状态，这是一种等待模式，程序会等候用户的动作，例如鼠标单击和按键等操作。用户的动作会让可以产生响应的程序生成一些事件（event，也称为“消息”），这里的响应通常就是执行一个或者多个函数。例如，当用户单击窗口部件时，就会产生一个“鼠标按下”事件和一个“鼠标松开”事件。在这方面，图形用户界面应用程序和常规的批处理程序完全不同，后者通常可以在没有人为干预的情况下自行处理输入、生成结果和终止。

为简单起见，我们没有过多关注在main()函数末尾处对QLabel对象的delete操作调用。在如此短小的程序内，这样一点内存泄漏(memory  leak)问题无关大局，因为在程序结束时，这部分内存是可以由操作系统重新回收的。
\begin{fig}{helloqt}
\caption{Linux上的Hello程序}
\label{fig:Linux上的Hello程序}
\end{fig}

现在是在机器上测试这个程序的时候了，看起来它应该会如图1.1所示。首先需要安装Qt 4.3.2（或是其后的其他Qt 4新发行版），附录A对这一安装过程进行了说明。从现在开始，假定你已经正确地安装了Qt 4的一个副本，并且假定已经在PATH环境变量中对Qt的bin目录进行了设置。（在Windows操作系统中，这些操作会由Qt的安装程序自动完成。）还需要将该程序的源代码保存到hello.cpp文件，并把它放进一个名为hello的目录中。

现在在命令提示符下，进入hello目录，输入如下命令，生成一个与平台无关的项目文件hello.pro：
\begin{Verbatim}
qmake -project
\end{Verbatim}

然后，输入如下命令，从这个项目文件生成一个与平台相关的makefile文件：

\begin{Verbatim}
qmake hello.pro
\end{Verbatim}

键入make命令就可以构建该程序。（在附录B中，会给出qmake工具更为详细的说明。）要运行该程序，在Windows下可以输入\verb+hello+，在UNIX下可以输入\verb+./hello+，在Mac OS X下可以输入\verb+open hello.app+。要结束该程序，可直接单击窗口标题栏上的关闭按钮。

如果使用的是Windows系统，并且已经安装了Qt的开源版和MinGW编译器，那么将会看到一个指向MS-DOS提示符窗口的快捷键，其中已经正确地创建了使用Qt时所需的全部环境变量。如果启动了这个窗口，那么就可以在里面像上面所讲述的那样使用qmake命令和make命令编译Qt应用程序。而由此产生的可执行文件将会保存在应用程序所在目录的debug或release文件夹中。

如果使用的是Microsoft Visual C++和商业版的Qt，则需要用nmake命令代替make命令。除了这一方法外，还可以通过hello.pro文件创建一个Visual Studio的工程文件，此时需要输入命令：

\begin{Verbatim}
qmake -tp vc hello.pro
\end{Verbatim}

然后就可以在Visual Studio中编译这个程序了。如果使用的是Mac OS X系统中的Xcode，那么可以使用如下命令来生成一个Xcode工程文件：
\begin{Verbatim}
qmake -spec macx-xcode hello.pro
\end{Verbatim}

在开始进入下一个例子之前，我们一起来做一件有意思的事情：将代码行
\begin{Verbatim}
QLabel *label = new QLabel("Hello Qt!");
\end{Verbatim}

替换为
\begin{Verbatim}
QLabel *label = new QLabel("<h2><i>Hello</i> "
                           "<font color=red>Qt!</font></h2>");
\end{Verbatim}

然后重新编译该程序。运行程序时，看起来应当是图1.2的样子。正如该例子所显示的那样，通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变得更为丰富多彩。
\begin{fig}{helloqt2}
\caption{具有简单HTML样式的标签}
\label{fig:helloqt2}
\end{fig}

\section{建立连接}
第二个例子要说明的是如何响应用户的动作。这个应用程序由一个按钮构成，用户可以单击这个按钮退出程序。除了应用程序的主窗口部件使用的是QPushButton而不是QLabel之外，这个应用程序的源代码和Hello程序的源代码非常相似。同时，我们还会将用户的一个动作（单击按钮）与一段代码连接起来。

这个应用程序的源代码位于本书的例子文件中，文件名是qt4-book/chap01/qu-it/quit.cpp。程序的运行效果如图1.3所示。以下是该文件所包含的内容：
\begin{cppinput}{qt4-book/chap01/quit/quit.cpp}
\end{cppinput}

\begin{fig}{quit}
\caption{Quit应用程序}
\label{fig:quit}
\end{fig}

Qt的窗口部件通过发射信号(signal)来表明一个用户动作已经发生了或者是一个状态已经改变了\footnote{Qt的信号和UNIX的信号并不相关，本书中所讨论的信号仅指Qt信号。}。例如，当用户单击QPushButton时；该按钮就会发射一个clicked()信号。信号可以与函数（在这里称为槽，slot）相连接，以便在发射信号时，槽可以得到自动执行。在这个例子中，我们把这个按钮的clicked()信号与QApplication对象的quit()槽连接起来。宏SIGNAL()和SLOT()是Qt语法中的一部分。

现在来构建这个应用程序。假设已经创建了一个包含quit.cpp文件的quit目录。在quit目录中，首先运行qmake命令生成它的工程文件，然后再次运行该命令来生成一个makefile文件，这两项操作的命令如下：
\begin{Verbatim}
qmake -project
qmake quit.pro
\end{Verbatim}

现在，就可以编译并运行这个应用程序了。如果单击Quit按钮，或者按下了空格键（这样也会按下Quit按钮），那么将会退出应用程序。


\section{窗口部件的布局}
这一节将创建一个简单的例子程序，以说明如何用布局(layout)来管理窗口中窗口部件的几何形状，还要说明如何利用信号和槽来同步窗口部件。这个应用程序的运行效果如图1.4所示，它可以用来询问用户的年龄，而用户可以通过操纵微调框(spin box)或者滑块(slider)来完成年龄的输入。
\begin{fig}{ageapplication}
\caption{Age应用程序}
\label{fig:ageapplication}
\end{fig}

这个应用程序由三个窗口部件组成：一个QSpinBox，一个QSlider和一个QWidget。QWidget是这个应用程序的主窗口。QSpinBox和QSlider会显示在QWidget中，它们都是QWidget窗口部件的子对象。换言之，QWidget窗口部件是QSpinBox和QSlider的父对象。QWidget窗口部件自己则没有父对象，因为程序是把它当作顶层窗口的。QWidget的构造函数以及它的所有子类都会带一个参数QWidget *，以用来说明谁是它们的父窗口部件。

以下是本应用程序的源代码：
\begin{cppinput}{qt4-book/chap01/age/age.cpp}
\end{cppinput}

第10行和第11行创建了QWidget对象，并把它作为应用程序的主窗口。我们通过调用setWindowTitle()函数来设置显示在窗口标题栏上的文字。

第13行和第14行分别创建了一个QSpinBox和一个QSlider，并分别在第15行和第16行设置了它们的有效范围。我们可以放心地假定用户的最大年龄不会超过130岁。本应把这个窗口传递给QSpinBox和QSlider的构造函数，以说明这两个窗口部件的父对象都是这个窗口，但在这里没有这个必要，因为布局系统将会自行得出这一结果并自动把该窗口设置为微调框和滑块的父对象，下面将会很快看到这一点。

从第18行到第21行，调用了两次QObject::connect()，这是为了确保能够让微调框和滑块同步，以便它们两个总是可以显示相同的数值。一旦有一个窗口部件的值发生了改变，那么就会发射它的valueChanged(int)信号，而另一个窗口部件就会用这个新值调用它的setValue(int)槽。

第22行将微调框的值设置为35。当发生这种情况时，QSpinBox就会发射valueChanged(int)信号，其中，int参数的值是35。这个参数会被传递给QSlider的setValue(int)槽，它会把这个滑块的值设置为35。于是，滑块就会发射valueChanged(int)信号，因为它的值发生了变化，这样就触发了微调框的setValue(int)槽。但在这一点上，setValue(int)并不会再发射任何信号，因为微调框的值已经是35了。这样就可以避免无限循环的发生。图1.5对这种情况进行了图示概述。
\begin{fig}[0.8]{ageapplication2}
\caption{改变一个窗口部件的值会使两个窗口部件都发生变化}
\label{fig:ageapplication2}
\end{fig}


\begin{framed}
\vspace{-\parskip}
\begin{center}
\textbf{窗口部件的风格}
\end{center}

到目前为止，我们看到的这些屏幕截图都来自于Linux，但是Qt应用程序在每一个所支持的平台上都可以看起来像本地程序一样（见图1.6）。Qt是通过所模拟平台的视觉外观来实现这一点的，而不是对某个特殊平台的封装或者一个工具包中的窗口部件集。

\begin{linefig}[0.9]{appstyle}
\caption{一些预定义风格}
\label{fig:appstyle}
\end{linefig}

运行于KDE下的Qt/X11应用程序的默认风格是Plastique，而运行于GNOME下的应用程序的默认风格是Cleanlooks。这些风格使用了渐变和抗锯齿效果，以用来提供一种时尚的外观。运行Qt应用程序的用户可以通过使用命令行参数-style覆盖原有的默认风格。例如，在X11下，要想使用Motif风格来运行Age应用程序，只需简单输入以下命令即可：
\begin{Verbatim}
./age -style motif
\end{Verbatim}

与其他风格不同，Windows XP、Windows Vista和Mac的风格只能在它们的本地平台上有效，因为它们需要依赖平台的主题引擎。

还有另外一种风格QtDotNet，它来自于Qt Solutions模块。创建自定义风格也是可能的，这会在第19章中加以阐述。
\end{framed}

在源程序的第24行到第27行，使用了一个布局管理器对微调框和滑块进行布局处理。布局管理器(layout manager)就是一个能够对其所负责窗口部件的尺寸大小和位置进行设置的对象。Qt有三个主要的布局管理器类：
\begin{itemize}
\item QHBoxLayout。在水平方向上排列窗口部件，从左到右（在某些文化中则是从右向左）。
\item QVBoxLayout。在竖直方向上排列窗口部件，从上到下。
\item QGridLayout。把各个窗口部件排列在一个网格中。
\end{itemize}

第27行的QWidget::setlayout()函数调用会在窗口上安装该布局管理器（见图1.7）。从软件的底层实现来说，QSpinBox和QSlider会自动“重定义父对象”，它们会成为这个安装了布局的窗口部件的子对象。也正是基于这个原因，当创建一个需要放进某个布局中的窗口部件时，就没有必要为其显式地指定父对象了。

\begin{linefig}[0.8]{agelayout}
\caption{Age应用程序中的窗口部件和布局}
\label{fig:agelayout}
\end{linefig}

尽管没有明确地设置任何一个窗口部件的位置或大小，但QSpinBox和QSlider还是能够非常好看地一个挨着一个显示出来。这是因为QHBoxLayout可根据所负责的子对象的需要为它们分配所需的位置和大小。布局管理器使我们从应用程序的各种屏幕位置关系指定的繁杂纷扰中解脱出来，并且它还可以确保窗口尺寸大小发生改变时的平稳性。

Qt中构建用户接口的方法很容易理解并且非常灵活。Qt程序员最常使用的方式是先声明所需的窗口部件，然后再设置它们所应具备的属性。程序员把这些窗体部件添加到布局中，布局会自动设置它们的位置和大小。利用Qt的信号－槽机制，并通过窗口部件之间的连接就可以管理用户的交互行为。


\section{使用参考文档}
由于Qt的参考文档涉及了Qt中的每一个类和函数，所以对任何一名Qt开发人员来说，它都是一个基本工具。本书讲述了Qt的许多类和函数，但是也并不能完全覆盖到Qt中所有的类和函数，同时也无法对书中所涉及的每个类和函数都提供全部的细节。如果想尽可能多地从Qt获益，那么就应当尽快地达到对Qt参考文档了如指掌的程度。

在Qt的doc/html目录下可以找到HTML格式的参考文档，并且可以使用任何一种Web浏览器来阅读它。也可以使用Qt的帮助浏览器Qt Assistant，它具有强大的查询和索引功能，使用时能够比Web浏览器更加快速和容易。

要运行Qt Assistant，在Windows下，可单击“开始”菜单中的"Qt by Trolltech v4.x.y | Assistant"(见图1.8)；在UNIX下，可在命令行终端中输入assistant命令；在Mac  OS X Finder中，只需双击assistant即可，在主页的"API Reference"小节中的链接提供了浏览Qt类的几种不同方式，"All Classes"页面列表会列出Qt API中的每一个类，而"Main Classes"页面列表只会列出Qt中那些最为常用的类。作为练习，你或许可以去试着查询一下这一章中所使用过的那些类和函数。
\begin{linefig}[0.8]{qtassistant}
\caption{Windows Vista 下Qt Assistant中的Qt参考文档}
\label{fig:qtassistant}
\end{linefig}

需要注意的是，通过继承而得到的函数的文档会显示在它的基类中，例如，QPushButton就没有它自己的show()函数，因为它是从QWidget那里继承的函数。图1.9给出了到目前为止我们所见过的各个类之间的关系。
\begin{linefig}[0.8]{classtree}
\caption{目前为止我们所见过的那些Qt类的继承树}
\label{fig:classtree}
\end{linefig}

可以从\href{http://doc.trolltech.com}{http://doc.trolltech.com}中获取Qt的当前版和一些早期版本的在线参考文档。这个网站也选摘了Qt季刊(Qt Quarterly)中的一些文章。Qt季刊是Qt程序员的时事通讯，会发送给所有
获得Qt商业许可协议的人员。

本章介绍了一些重要概念：信号－槽连接和布局，也逐步展示了Qt的兼容性和Qt完全面向对象的构建方法和窗口部件的使用。如果你浏览了一遍Qt的参考文档，那么将会发现一种如何学习使用新窗口部件的统一方法，并且也将发现Qt对函数、参数、枚举等变量选名的严谨性，以及在使用Qt编程时令人叹服的愉悦感和舒适性。

本书第一部分的随后几章，都建立在本章的基础之上，它们演示了如何创建一个完整的GUI应用程序——拥有菜单、工具栏、文档窗口、状态条和对话框，还有与之相应的用于阅读、处理和输出文件的底层功能函数。



\chapter{创建对话框}
这一章讲解如何使用Qt创建对话框。对话框为用户提供了许多选项和多种选择，允许用户把选项设置为他们喜欢的变量值并从中做出选择。之所以把它们称为对话框，或者简称为“对话”，是因为它们为用户和应用程序之间提供了一种可以相互“交谈”的交互方式。

绝大多数图形用户界面应用程序都带有一个由菜单栏、工具栏构成的主窗口以及几十个对主窗口进行补充的对话框。当然，也可以创建对话框应用程序，它可以通过执行合适的动作来直接响应用户的选择（例如，一个计算器应用程序）。

本章将首先完全用手写代码的方式创建第一个对话框，以便能够说明是如何完成这项工程的。然后将使用Qt的可视化界面设计工具Qt设计师(Qt Designer)。使用Qt设计师比手写代码要快得多，并且可以使不同的设计测试工作以及稍后对设计的修改工作变得异常轻松。


\section{子类化QDialog}
第一个例子是完全使用C++编写的一个Find(查找)对话框，它的运行效果如图2.1所示，这将实现一个拥有自主权的对话框。通过这一过程，就可以让对话框拥有自己的信号和槽，成为一个独立的、完备的控件。

\begin{fig}{finddialog}
\caption{Find对话框}
\label{fig:finddialog}
\end{fig}

源代码分别保存在finddialog.h和finddialog.cpp文件中。首先从finddialog.h文件说起：
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{1}{9}
\end{cppline}


第1、2行（以及后面的第27行，见下页）能够防止对这个头文件的多重包含。第4行包含了QDialog的定义，它是Qt中对话框的基类。QDialog从QWidget类中派生出来。第6行到第9行前置声明了一些用于这个对话框实现中的Qt类。前置声明(forward declaration)会告诉C++编译程序类的存在，而不用提供类定义中的所有细节(通常放在它自己的头文件中)。关于这一点，将会再简单地多讲一些。

接下来定义FindDialog，并让它成为QDialog的子类：
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{11}{16}
\end{cppline}


对于所有定义了信号和槽的类，在类定义开始处的Q\_{}OBJECT宏都是必需的。

FindDialog的构造函数就是一个典型的Qt窗口部件类的定义方式。parent参数指定了它的父窗口部件。该参数的默认值是一个空指针，意味着该对话框没有父对象。
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{18}{20}
\end{cppline}

signals部分声明了当用户单击Find按钮时对话框所发射的两个信号。如果向前查询(search backward)选项生效，对话框就发射findPrevious()信号，否则它就发射findNext()信号。

signals关键字实际上是一个宏。C++预处理器会在编译程序找到它之前把它转换成标准C++代码。Qt::CaseSensitivity足一个枚举类型，它有\\ Qt::CaseSensitive和Qt::CaseInsensitive两个取值。
\begin{cppline}{qt4-book/chap02/find/finddialog.h}{22}{0}
\end{cppline}

在这个类的private段声明了两个槽。为了实现这两个槽，几乎需要访问这个对话框的所有子窗口部件，所以也保留了指向它们的指针。关键字slots就像signals一样也是一个宏，也可以扩展成C++编译程序可以处理的一种结构形式。

对于这些私有变量，我们使用了它们的类前置声明。这是可行的，因为它们都是指针，而且没有必要在头文件中就去访问它们，因而编译程序就无须这些类的完整定义。我们没有包含与这几个类相关的头文件（<QCheckBox>、<QLabel>，等等），而是使用了一些前置声明。这可以使编译过程更快一些。

现在看一下finddialog.cpp，其中包含了对FindDialog类的实现：
\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{1}{3}
\end{cppline}

首先，需要包含<QtGui>，该头文件包含了Qt Gui类的定义。Qt由数个模块构成，每个模块都有自己的类库。最为重要的模块有QtCore、QtGui、QtNetwork、QtOpenGL、QtScript、QtSql、QtSvg和QtXml。其中，在<QtGui>头文件中为构成QtCore和QtGui组成部分的所有类进行了定义。在程序中包含这个头文件，就能够使我们省去在每个类中分别包含的麻烦。

在filedialog.h文件中，本可以仅简单地添加一个<QtGui>包含即可，而不用包含<QDialog>和使用QCheckBox、QLabel、QLineEdit和QPushButton的前置声明。然而，在一个头文件中再包含一个那么大的头文件着实不是一种好的编程风格，尤其对于比较大的工程项目更是如此。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{5}{19}
\end{cppline}

在第6行，把parent参数传递给了基类的构造函数。然后，创建了子窗口部件。在字符串周围的tr()函数调用是把它们翻译成其他语言的标记。在每个QObject对象以及包含有Q\_{}OBJECT宏的子类中都有这个函数的声明。尽管也许并没有将你的应用程序立刻翻译成其他语言的打算，但是在每一个用户可见的字符串周围使用tr()函数还是一个很不错的习惯。在第18章中将对翻译Qt应用程序进行详细讲述。

在这些字符串中，使用了表示“与”操作的符号"\&{}"来表示快捷键。例如，笫15行创建了一个Find按钮，用户可在那些支持快捷键的平台下通过按下Alt+F快捷键来激活它。符号"\&{}"可以用来控制焦点：在第8行创建了一个带有快捷键(Alt+W)的标签，而在第10行设置了行编辑器作为标签的伙伴。所谓“伙伴”(buddy)就是一个窗口部件，它可以在按下标签的快捷键时接收焦点(focus)。所以当用户按下Alt+W（该标签的快捷键）时，焦点就会移动到这个行编辑器（该标签的伙伴）上。

在第16行，通过调用setDefault(true)让Find按钮成为对话框的默认按钮。默认按钮(default button)就是当用户按下Enter键时能够按下对应的按钮。在第17行，禁用了Find按钮。当禁用一个窗口部件时，它通常会显示为灰色，并且不能和用户发生交互操作。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{21}{26}
\end{cppline}

只要行编辑器中的文本发生变化，就会调用私有槽enableFindButton(const QString \& )。当用户单击Find按钮时，会调用findClicked()私有槽。而当用户单击Close时，对话框会关闭。close()槽是从QWidget中继承而来的，并且它的默认行为就是把窗口部件从用户的视野中、隐藏起来（而无须将其删除）。稍后将会看到enableFindButton()槽和findClicked()槽的代码。

由于QObject是FindDialog的父对象之一，所以可以省略connect()函数前面的QObject::前缀。

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{28}{45}
\end{cppline}

接下来，使用布局管理器摆放这些子窗口部件。布局中既可以包含多个窗口部件，也可以包含其他子布局。通过QHBoxLayout、QVBoxLayout和QGridLayout这三个布局的不同嵌套组合，就可能构建出相当复杂的对话框。

如图2.2所示，对于Find对话框，使用了两个QHBoxLayout布局和两个QVBoxLayout布局。外面的布局是主布局，通过第45行代码将其安装在FindDialog中，并且由其负责对话框的整个区域。其他三个布局则作为子布局。图2.2中右下角的小“弹簧”是一个分隔符（或者称为“伸展器”）。用它来占据Find按钮和Close按钮所余下的空白区域，这样可以确保这些按钮完全占用它们所在布局的上部空间。

\begin{linefig}[0.8]{finddialoglayout}
\caption{Find对话框的布局}
\label{fig:finddialoglayout}
\end{linefig}

布局管理器类的一个精妙之处在于它们不是窗口部件。相反，它们派生自QLayout，因而也就是进一步派生自QObject，在图2.2中，窗口部件用实线轮廓来表示，布局用点线来表示，这样就能够很好地区分窗口部件和布局。在一个运行的应用程序中，布局是不可见的。

当将子布局对象添加到父布局对象中时（第33、43和44行），子布局对象就会自动重定义自己的父对象。也就是说，当将主布局装到对话框中去时（第45行），它就会成为对话框的子对象了，于是它的所有子窗口部件都会重定义自己的父对象，从而变成对话框中的子对象。图2.3给出了父子层次关系的最终结果。

\begin{fig}[0.8]{finddialogrelation}
\caption{Find对话框中的父子关系}
\label{fig:finddialogrelation}
\end{fig}

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{47}{49}
\end{cppline}

最后，设置了显示在对话框标题栏上的标题的内容，并让窗口具有一个固定的高度，这是因为在对话框的垂直方向上再没有其他窗口部件可以去占用所多出的空间了。QWidget::sizeHint()函数可以返回一个窗口部件所“理想”的尺寸大小。

这样，就完成了对FindDialog对话框构造函数的分析。由于在创建这个对话框中的窗口部件和布局时使用的是new，所以需要写一个能够调用delete的析构函数，以便可以删除所创建的每一个窗口部件和布局。但是这样做并不是必需的，因为Qt会在删除父对象的时候自动删除其所属的所有子对象，也就会删除FindDialog中作为其子孙的所有子窗口部件和子布局。

现在来看一下这个对话框中所用到的槽：

\begin{cppline}{qt4-book/chap02/find/finddialog.cpp}{51}{0}
\end{cppline}

当用户单击Find按钮时，就会调用findClicked()槽。而该槽将会发射findPrevious()或findNext()信号，这取决于Search backward选项的取值。emit是Qt中的关键字，像其他Qt扩展一样，它也会被C++预处理器转换成标准的C++代码。

只要用户改变了行编辑器中的文本，就会调用enableFindButton()槽。如果在行编辑器中有文本，该槽就会启用Find按钮，否则它就会禁用Find按钮。

利用这两个槽就完成了这个对话框的功能。现在，可以创建一个main.cpp文件来测试一下这个FindDialog窗口部件。

\begin{cppinput}{qt4-book/chap02/find/main.cpp}
\end{cppinput}

为了编译这个程序，还像以前一样运行qmake。由于FindDialog类的定义包含Q\_{}OBJECT宏，因而由qmake生成的makefile将会自动包含一些运行moc的规则，moc就是指Qt的元对象编译器，即meta-object compiler。（会在下一节介绍Qt的元对象系统。）

为了使moc能够正常运行，必须把类定义从实现文件中分离出来并放到头文件中。由moc生成的代码会包含这个头文件，并且会添加一些特殊的C++代码。

必须对使用了Q\_{}OBJECT宏的类运行moc。因为qmake会自动在makefile中添加这些必要的规则，所以这并不成问题。但是如果忘记了使用qmake重新生成makefile文件，并且也没有重新运行moc，那么连接程序就会报错，指出你声明了一些函数但是却没有实现它们。这些信息可能是相当不明确的。GCC会生成像这样的出错信息：
\begin{Verbatim}
finddialog.o: In function `FindDialog::tr(char const*, char const*)':
/usr/lib/qt/src/corelib/global/qglobal.h:1430: undefined reference to
`FindDialog::staticMetaObject'
\end{Verbatim}

Visual C++输出的出错信息可能是这样的：
\begin{Verbatim}
finddialog.obj : error LNK2001: unresolved external symbol
"public:~virtual int __thiscall MyClass::qt_metacall(enum QMetaObject
::Call,int,void * *)"
\end{Verbatim}

如果曾经遇到过这种情况，那么请重新运行qmake以生成新的makefile文件，然后再重新构建该应用程序。

现在来运行该程序。如果在你的系统上能够显示快捷键，那么可以检验一下快捷键Alt+w、Alt+C、Alt+B和Alt+F是不是触发了正确的行为。可以通过敲击键盎上的Tab键来遍历这些窗口部件。默认的Tab键顺序就是创建窗口部件时的顺序。要改变这个键顺序，可以使用QWidget::setTabOrder()函数。

提供一种合理的Tab键顺序和键盘快捷键可以确保不愿（或者不能）使用鼠标的用户能够充分享受应用程序所提供的全部功能。完全通过键盘控制应用程序也深受快速输入人员的赞赏。

在第3章，将在一个真实的应用程序中使用Find对话框，并且将会把findPrevious()信号和findNext()信号与一些槽连接到一起。


\section{深入介绍信号和槽}
信号和槽机制是Qt编程的基础。它可以让应用程序编程人员把这些互不了解的对象绑定在一起。前面，已经把一些信号和槽连接在了一起，也声明了自己的信号和槽，还实现了自己的槽，并且还发射了自己的信号。让我们再花一点时间，来进一步深入地了解这个机制。

槽和普通的C++成员函数几乎是一样的——可以是虚函数；可以被重载；可以是公有的、保护的或者私有的，并且也可以被其他C++成员函数直接调用；还有，它们的参数可以是任意类型。唯一的不同是：槽还可以和信号连接在一起，在这种情况下，每当发射这个信号的时候，就会自动调用这个槽。

connect()语句看起来会是如下的样子：
\begin{Verbatim}
connect(sender, SIGNAL(signal), receiver, SLOT(slot));
\end{Verbatim}

这里的\textit{sender}和\textit{receiver}是指向QObject的指针，\textit{signal}和\textit{slot}是不带参数的函数名。实际上，SIGNAL()宏和SLOT()宏会把它们的参数转换成相应的字符串。

到目前为止，在已经看到的实例中，我们已经把不同的信号和不同的槽连接在了一起。但这里还需要考虑一些其他的可能性。

\begin{itemize}
\item \textbf{一个信号可以连接多个槽}：

\begin{Verbatim}
connect(slider, SIGNAL(valueChanged(int)),
        spinBox, SLOT(setValue(int)));
connect(slider, SIGNAL(valueChanged(int)),
        this, SLOT(updateStatusBarIndicator(int)));
\end{Verbatim}

在发射这个信号的时候，会以不确定的顺序一个接一个地调用这些槽。

\item \textbf{多个信号可以连接同一个槽}：
\begin{Verbatim}
connect(lcd, SIGNAL(overflow()),
        this, SLOT(handleMathError()));
connect(calculator, SIGNAL(divisionByZero()),
        this, SLOT(handleMathError()));
\end{Verbatim}

无论发射的是哪一个信号，都会调用这个槽。

\item \textbf{一个信号可以与另外一个信号相连接}：

\begin{Verbatim}
connect(lineEdit, SIGNAL(textChanged(const QString &)),
        this, SIGNAL(updateRecord(const QString &)));
\end{Verbatim}

当发射个信号时，也会发射第二个信号。除此之外，信号与信号之间的连接和信号与槽之间的连接是难以区分的。

\item \textbf{连接可以被移除}：
\begin{Verbatim}
disconnect(lcd, SIGNAL(overflow()),
        this, SLOT(handleMathError()));
\end{Verbatim}

这种情况较少用到，因为当删除对象时，Qt会自动移除和这个对象相关的所有连接。
\end{itemize}

要把信号成功连接到槽（或者连接到另外一个信号），它们的参数必须具有相同的顺序和相同的类型：
\begin{Verbatim}
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(processReply(int, const QString &)));
\end{Verbatim}

例外地，如果信号的参数比它所连接的槽的参数多，那么多余的参数将会被简单地忽略掉：
\begin{Verbatim}
connect(ftp, SIGNAL(rawCommandReply(int, const QString &)),
        this, SLOT(checkErrorCode(int)));
\end{Verbatim}

如果参数类型不匹配，或者如果信号或槽不存在，则当应用程序使用调试模式构建后，Qt会在运行时发出警告。与之相类似的是，如果在信号和槽的名字中包含了参数名，Qt也会发出警告。

到现在为止，我们仅仅在窗口部件之间使用了信号和槽。但是这种机制本身是在QObject中实现的，并不只局限于图形用户界面编程中。这种机制可以用于任何QObject的子类中：

\begin{Verbatim}
class Employee : public QObject
{
    Q_OBJECT
public:
    Employee() { mySalary = 0; }
    int salary() const { return mySalary; }
public slots:
    void setSalary(int newSalary);
signals:
    void salaryChanged(int newSalary);
private:
    int mySalary;
};
void Employee::setSalary(int newSalary)
{
    if (newSalary != mySalary) {
        mySalary = newSalary;
        emit salaryChanged(mySalary);
    }
}
\end{Verbatim}

注意一下setSalary()槽是如何工作的。只有在newSalary != mySalary的时候，才发射salaryChanged()信号。这样可以确保循环连接不会导致无限循环。

\begin{framed}
\vspace{-\parskip}
\begin{center}
\textbf{Qt的元对象系统}
\end{center}

Qt的主要成就之一就是使用了一种机制对C++进行了扩展，并且使用这种机制创建了独立的软件组件。这些组件可以绑定在一起，但任何一个组件对于它所要连接的组件的情况事先都一无所知。

这种机制称为元对象系统(meta-object system)，它提供了关键的两项技术：信号－槽以及内省(introspection)。内省功能对于实现信号和槽是必需的，并且允许应用程序的开发人员在运行时获得有关QObject子类的“元信息”(meta-information)，包括一个含有对象的类名以及它所支持的信号和槽的列表。这一机制也支持属性（广泛用于Qt设计师中）和文本翻译（用于国际化），并且它也为QtScript模块奠定了基础。从Qt 4.2开始，可以动态添加属性，这一特性将会在第19章和第22章中付诸实施。

标准C++没有对Qt的元对象系统所需要的动态元信息提供支持。Qt通过提供一个独立的moc工具解决了这个问题，moc解析Q\_{}OBJECT类的定义并且通过C++函数来提供可供使用的信息。由于moc使用纯C++来实现它的所有功能，所以Qt的元对象系统可以在任意C++编译器上工作。

这一机制是这样工作的：
\begin{itemize}
\item Q\_{}OBJECT宏声明了在每一个QObject子类中必须实现的一些内省函数：metaObject()、tr()、qt\_{}metacall()，以及其他一些函数。
\item Qt的moc工具生成了用于由Q\_{}OBJECT声明的所有函数和所有信号的实现。
\item 像connect()和disconnect()这样的QObject的成员函数使用这些内省函数来完成它们的工作。
\end{itemize}

由于所有这些工作都是由qmake、moc和QObject自动处理的，所以很少需要再去考虑这些事情。但是如果你对此充满好奇心的话，那么也可以阅读一下有关QMetaObject类的文档和由moc生成的C++源代码文件，可以从中看出这些实现工作是如何进行的。
\end{framed}


\section{快速设计对话框}
Qt的设计初衷就是为了能够直观并且友好地进行手工编码，并且对于程序员来说，纯粹通过编写C++源代码来开发整个Qt应用程序并不稀奇。尽管如此，许多程序员还是喜欢使用可视化的方法来设计窗体，因为他们发现使用可视化方式会比手工编码显得更自然、更快速，并且也希望能够通过可视化方法，对那些手工编码所设计的窗体，进行更快速、更容易的测试和修改。

Qt设计师(Qt Designer)为程序员们提供了可供使用的新选择，它提供一种可视化的设计能力。Qt设计师可用于开发应用程序中的所有或部分窗体。使用Qt设计师所创建的窗体最终仍旧是C++代码，因此，可把Qt设计师看作是一个传统的工具集，并且不会对编译器强加其他特殊要求。

\begin{fig}{gotocell}
\caption{Go to Cell对话框}
\label{fig:gotocell}
\end{fig}

在这一节，将使用Qt设计师来创建如图2.4所示的Go to Cell对话框。并且无论是使用手工编码还是使用Qt设计师，在创建对话框时总是要包含以下这几个相同的基本步骤：

\begin{enumerate}
\item 创建并初始化子窗口部件。
\item 把子窗口部件放到布局中。
\item 设置Tab键顺序。
\item 建立信号－槽之间的连接。
\item 实现对话框中的自定义槽。
\end{enumerate}

要启动Qt设计师，在Windows下，可单击“开始”菜单中的Qt by Trolltech v4.x.y→Designer；在UNIX下，在命令行中输入"designer"；在Mac OS X Finder中，直接双击designer。当Qt设计师开始运行后，它会弹出一个多种模板的列表。单击Widget模板，然后再单击Create。（"Dialog with Buttons Bottom"模板看起来可能更具诱惑力，但是对于这个例子来说，为了能够看到是如何完成OK和Cancel按钮的，所以需要采用手工方式来创建它们。）现在应该会看到一个名为"Untitled"的窗口。

默认情况下，Qt设计师的用户界面由多个顶级窗口构成。如果你更喜欢像图2.5所示的那种多文档(MDI)界面风格，即只有一个顶级窗口和多个子窗口构成的界面，则可以单击Edit→Preferences，然后将用户界面模式设置为Docked Window（停靠窗口）即可。
\begin{linefig}[0.8]{designer}
\caption{Windows Vista中显示为停靠窗口模式的Qt设计师}
\label{fig:designer}
\end{linefig}

第一步是创建子窗口部件并且把它们放置到窗体中。创建一个标签、一个行编辑器、一个水平分隔符和两个按钮。对于这里的每一项，可先从Qt设计师的窗口部件工具箱中拖拽其名字或者图标并将其放到窗体中的大概位罩。在Qt设计师中，分隔符会显示为一个蓝色的弹簧，但在最终结果的窗体中它是不可见的。

现在，向上拖动窗体的底部使它变短一些，这样将会产生一个类似于图2.6的窗体。不要在窗体上为确定这些项的位置而花费太多的时间，会在稍后使用Qt的布局管理器，它可以把这些项摆放得恰到好处。
\begin{fig}[0.7]{designer2-6}
\caption{带一些窗口部件的窗体}
\label{fig:designer2-6}
\end{fig}

使用Qt设计师的属性编辑器可以设置每一个窗口部件中的属性：
\begin{enumerate}
\item 单击文本标签。确保此时objectName的属性是"label"，那么就可以将它的text属性设置成"\&{}Cell Location:"。
\item 单击行编辑器。确保objectName属性是"lineEdit"。
\item 单击第一个按钮。将它的objectName属性设置成"okButton"，将它的enabled属性设置成"false"，将它的text属性设置成"OK"，并且把它的default属性设置成"true"。
\item 单击第二个按钮。将它的objectName属性设置成"cancelButton"，并且将它的text属性设置成"Cancel"。
\item 单击这个窗体中空白的地方，选中窗体本身。将objectName属性设置成"GoToCellDialog"，并且将它的windowTitle属性设置成"Go to Cell"。
\end{enumerate}

现在，除了文本标签，所有的窗口部件看起来都很不错，文本标签仍显示为"\&{}Cell Location:"。单击Edit→Edit Buddies进入一种允许设置窗口部件伙伴(buddy)的特殊模式。然后，单击这个标签并把红色箭头拖到行编辑器上，释放鼠标按键。现在标签看起来应该显示为"\uline{C}ell Location:"，如图2.7所示，同时，它还会把行编辑器看成是自己的伙伴。单击Edit→Edit Widgets离开伙伴设置模式。

\begin{fig}[0.7]{designer2-7}
\caption{带属性设置的窗体}
\label{fig:designer2-7}
\end{fig}

下一步是在窗体中摆放这些窗口部件，步骤如下：
\begin{enumerate}
\item 单击"\uline{C}ell Location:"标签并且当单击与之相邻的行编辑器时按下Shift键，这样就可以同时选择它们。单击Form→Lay Out Horizontally。
\item 单击分隔符，然后在单击窗体的OK按钮和Cancel按钮时一直按下Shift键。单击Form→Lay Out Horizontally。
\item 单击窗体中的空白，取消对所有已选中项的选择，然后单击Form→Lay Out Vertically。
\item 单击Form→Adjust Size，重新把窗体的大小定义为最佳形式。
\end{enumerate}

在窗体上出现的红线就是已经创建的布局，如图2.8所示。但是在窗体运行的时候，它们是绝不会出现的。
\begin{fig}[0.7]{designer2-8}
\caption{带布局的窗体}
\label{fig:designer2-8}
\end{fig}

现在，单击Edit→Edit Tab Order。在每一个可以接受焦点的窗口部件上，都会出现一个带蓝色矩形的数字，如图2.9所示。按照你所希望的接受焦点的顺序单击每一个窗口部件，然后单击Edit→Edit Widget，离开Tab键顺序设置模式。

\begin{fig}[0.7]{designer2-9}
\caption{设置窗体的Tab键顺序}
\label{fig:designer2-9}
\end{fig}

要预览这个对话框，可单击Form→Preview菜单选项。通过重复按下Tab键来检查对话框Tab键的顺序。使用窗体标题栏上的Close按钮，可以关闭对话框。

把对话框保存到gotocell目录下，另存为gotocelldialog.ui，然后使用一个纯文本编辑器在同一目录下创建一个main.cpp文件，内容如下：
\begin{cppinput}{qt4-book/chap02/gotocell1/main.cpp}
\end{cppinput}

现在运行qmake，生成一个.pro文件和一个makefile文件（命令分别是：qmake-project; qmake gotocell.pro）。qmake工具非常智能，它可以自动检测到用户界面文件gotocelldialog.ui并且可以生成适当的makefile规则来调用Qt的用户界面编译器(user interface compiler , uic)。uic工具会将gotocelldialog.ui文件转换成C++并且将转换结果存储在ui\_{}gotocelldialog.h文件中。

所生成的ui\_{}tocelldialog.h文件中包含了类Ui::GoToCellDialog的定义，该类是一个与gotocelldialog.ui文件等价的C++文件。这个类声明了一些成员变量，它们存储着窗体中的子窗口部件和子布局，以及用于初始化窗体的setupUi()函数。生成的类看起来如下所示：
\begin{Verbatim}
class Ui::GoToCellDialog
{
public:
    QLabel *label;
    QLineEdit *lineEdit;
    QSpacerItem *spacerItem;
    QPushButton *okButton;
    QPushButton *cancelButton;
    ...
    void setupUi(QWidget *widget) {
    ...
    }
};
\end{Verbatim}

生成的类没有任何基类。当在main.cpp文件中使用该窗体时，可以创建一个QDialog对象，然后把它传递给setupUi()函数。

如果现在运行该程序，对话框也可以工作，但它并没有正确地实现所想要的那些功能：    
\begin{itemize}
\item OK按钮总是失效的。
\item Cancel按钮什么也做不了。
\item 行编辑器可以接受任何文本，而不是只能接受有效的单元格位置坐标。
\end{itemize}

通过写一些代码，就可以让对话框具有适当的功能。最为简捷的做法是创建一个新类，让该类同时从QDialog和Ui::GoToCellDialog中继承出来，并且由它来实现那些缺失的功能（从而也证明了这句话：通过简单地增加另外一个间接层就可以解决软件的任何问题）。命名惯例是：将该类与uic所生成的类具有相同的名字，只是没有Ui::前缀而已。

使用文本编辑器，创建一个名为gotocelldialog.h的文件，其中所包含的代码如下所示：
\begin{cppinput}{qt4-book/chap02/gotocell2/gotocelldialog.h}
\end{cppinput}


在这里，使用了public继承，这是因为我们想在该对话框的外面访问该对话框的窗口部件。包含在gotocelldialog.cpp文件中的实现代码如下所示：
\begin{cppinput}{qt4-book/chap02/gotocell2/gotocelldialog.cpp}
\end{cppinput}

在构造函数中，调用setupUi()函数来初始化窗体。正是由于使用了多重继承关系，可以直接访问Ui::GoToCellDialog中的成员。创建了用户接口后，setupUi()函数还会自动将那些符合on\_{}objectName\_{}signalName()命名惯例的任意槽与相应的objectName的signalName()信号连接到一起。在这个例子中，这就意味着setupUi函数将建立如下所示的信号－槽连接关系：
\begin{Verbatim}
connect(lineEdit, SIGNAL(textChanged(const QString &)),
        this, SLOT(on_lineEdit_textChanged()));
\end{Verbatim}

同样还是在构造函数中，设置了一个检验器来限制输入的范围。Qt提供了三个内置检验器类：QIntValidator、QDoubleValidator和QRegExpValidator。在这里使用检验器类QRegExpValidator，让它
带一个正则表达式\\ \verb+"[A-Za-z][1-9][0-9]{0,2}"+，它的意思是：允许一个大写或者小写的字母，后面
跟着一个范围为1～9的数字，后面再跟0个、1个或2个0～9的数字。（对于正则表达式的介绍，请查看参考文档中的QRegExp类。）

通过把this传递给QRegExpValidator的构造函数，使它成为GoToCellDialog对象的一个子对象。这样，以后就不用担心有关删除QRegExpValidator的事情了：当删除它的父对象时，它也会被自动删除。

Qt的父－子对象机制是在QOject中实现的。当利用一个父对象创建一个子对象（一个窗口部件，一个检验器，或是任意的其他类型）时，父对象会把这个子对象添加到自己的子对象列表中。当删除这个父对象时，它会遍历子对象列表并且删除每一个子对象。然后，这些子对象再去删除它们自己所包含的每个子对象。如此反复递归调用，直至清空所有子对象为止。这种父－子对象机制可在很大程度上简化内存管理工作，降低内存泄漏的风险。需要明确删除的对象是那些使用new创建的并且没有父对象的对象。并且，如果在删除一个父对象之前先删除了它的子对象，Qt会自动地从它的父对象的子对象列表中将其移除。

对于窗口部件，父对象还有另外一层含义：子窗口部件会显示在它的父对象所在的区域中。当删除这个父窗口部件时，不仅子对象会从内存中消失，而且它也会在屏幕上消失。

在构造函数的最后部分，我们将OK按钮连接到QDialog的accept()槽，将Cancel按钮连接到reject()槽。这两个槽都可以关闭对话框，但accept()槽可以将对话框返回的结果变量设置为QDialog::Accepted（其值等于1），而reject()槽会把对话框的值设置为QDialog::Rejected（其值等于0）。当使用这个对话框的时候，可以利用这个结果变量判断用户是否单击了OK按钮，从而执行相应的动作。

根据行编辑器中是否包含了有效的单元格位置坐标，on\_{}lineEdit\_{}textChang\linebreak ed()槽可以启用或者禁用OK按钮。QLineEdit::hasAcceptableInput()会使用在构造函数中设置的检验器来判断行编辑器中内容的有效性。

这样，就完成了这个对话框。现在可以通过重写main.cpp文件来使用这个对话框：
\begin{cppinput}{qt4-book/chap02/gotocell3/main.cpp}
\end{cppinput}

使用qmake -project命令重新生成gotocell.pro文件（因为已经在工程中添加了源文件），使用qmake gotocell.pro命令更新makefile文件，然后再次构建并运行应用程序。在行编辑器中输入"A12"，这时可以注意到OK按钮已经变为启用了。尝试输入一些随机文本来看看检验器是如何完成它的工作的。单击Cancel按钮关闭对话框。

这个对话框工作得很好，但对于Mac OS X用户，这些按钮却显得不够圆润。在前面采用了单独添加每个按钮的方法，这是为了可以让我们看出是如何完成这些步骤的，但我们本来的确是应当使用QDialogButtonBox的，它是一个可以容纳给定的按钮的窗口部件，可以让那些按钮以正确方式呈现在应用程序所运行的平台上，如图2.10所示。
\begin{fig}[0.7]{designer2-10}
\caption{Windows Vista和Mac OS X上的Go to Cell对话框}
\label{fig:designer2-10}
\end{fig}

要使用QDialogButtonBox来制作这个对话框，必须同时修改设计过程和上述代码。在Qt设计师中，一共需要4步：
\begin{enumerate}
\item 单击窗体（不是任何窗口部件或者布局），然后单击Form→Break Layout。
\item 单击并删除OK按钮、Cancel按钮、水平分隔符以及（现在为空的）水平布局。
\item 在窗体上拖放一个“按钮盒”(Button Box)，放在标签和行编辑器单元的下方。
\item 单击窗体，然后单击Form →Lay Out Vertically。
\end{enumerate}

如果只打算修改设计，比如修改对话框的布局和窗口部件的属性等，那么只要重新构建应用程序即可。但在这里是移除了一些窗口部件并且添加了一个新的窗口部件，所以在这种情况下，通常还必须对代码进行修改。

我们所必须做的修改都在gotocelldialog.cpp文件中。这里给出的是其构造函数的新版本：
\begin{cppline}{qt4-book/chap02/gotocell3/gotocelldialog.cpp}{5}{16}
\end{cppline}

在前一版本中，一开始在Qt设计师中禁用了OK按钮。但是在使用QDialogButtonBox之后就不能那样做了，因而可以在代码中调用setupUi()之后，再立即禁用OK按钮，这样也可以达到同样的效果。类QDialogButtonBox有一组标准按钮的枚举值，并且可以利用这一点来访问这些特殊的按钮，本例就是访问OK按钮。

非常方便的是Qt设计师对于QDialogButtonBox的默认名称就是buttonBox。双方的连接会从按钮盒而不是从按钮自己创建出来。在单击一个带AcceptRole的按钮时，就会发射accepted()信号，这一点与单击一个带RejectRole的按钮会发射rejected()信号的情况相似。默认情况下，标准的QDialogButtonBox::Ok按钮具有AcceptRole属性，而标准的QDialogButtonBox::Cancel按钮具有RejectRole属性。

还需要在\verb+on_lineEdit_textChanged+槽中做一处修改：
\begin{cppline}{qt4-book/chap02/gotocell3/gotocelldialog.cpp}{18}{22}
\end{cppline}

与之前的唯一不同之处在于不是对存储为成员变量的特殊按钮进行引用，而是直接去访问按钮盒中的OK按钮。

使用Qt设计师的一个好处就在于它为程序员在修改自己设计的窗体时提供了很大的自由，并且不必再强迫自己去修改源代码。当完全通过手写C++代码开发窗体时，对窗体设计的修改将会相当耗时。利用Qt设计师，由于uic会自动为那些发生了改变的窗体重新生成源代码，所以就不会再浪费时间了。对话框的用户交互界面会被保存为.ui文件（一种基于XML的文件格式），而通过对uic所生成的类进行子类化，就可以实现自定义的函数功能。

\section{改变形状的对话框}
我们已经看到了如何创建对话框，无论何时使用它们，这些对话框永远只会显示出一些相同的窗口部件。在某些情况下，人们非常希望能够提供一些可以改变形状的对话框。最常见的可改变形状的对话框有两种：扩展对话框(extension dialog)和多页对话框(multi-page dialog)。在Qt中，不论是纯粹使用代码还是使用Qt设计师，都可以实现这两种对话框。

扩展对话框通常只显示简单的外观，但是它还有一个切换按钮(toggle button)，可以让用户在对话框的简单外观和扩展外观之间来回切换。扩展对话框通常用于试图同时满足普通用户和高级用户需要的应用程序中，这种应用程序通常会隐藏那些高级选项，除非用户明确要求看到它们。在这一节中，将使用Qt设计师来创建如图2.11所示的扩展对话框。
\begin{linefig}[0.8]{sortdialog}
\caption{具有简单外观和扩展外观的Sort对话框}
\label{fig:sortdialog}
\end{linefig}

这个对话框是一个用于电子制表软件应用程序的排序对话框（Sort对话框），在这个对话框中，用户可以选择一列或多列进行排序。在这个简单外观中，允许用户输入一个单一的排序键，而在扩展外观下，还额外提供了两个排序键。More按钮允许用户在简单外观和扩展外观之间切换。

我们将在Qt设计师中创建这个对话框的扩展外观，并且在运行时根据需要隐藏排序的第二键和第三键。这个窗口部件看起来有些复杂，但在Qt设计师中可以轻而易举地完成它。简单的诀窍是首先完成主键部分，然后再复制并且粘贴两次就可以获得第二键和第三键所需的内容。

\begin{enumerate}
\item 单击File→New Form，并选择"Dialog without Buttons"模板。
\item 创建OK按钮并把它拖放到窗体的右上角。将它的objectName修改为"okButton"，并将它的default属性设置为"true"。
\item 创建Cancel按钮并把它拖放到OK按钮的下方。将它的objectName修改为"cancelButton"。
\item 创建一个垂直分隔符并把它拖放到Cancel按钮的下方，然后再创建一个More按钮。并将它放在垂直分隔符的下方。将More按钮的objectName修改为"moreButton"，text属性设置成"\&{}More"，checkable属性设置为"true"。
\item 单击OK按钮，按下Shift键后再单击Cancel按钮、垂直分隔符和More按钮，然后单击Form→Lay Out Vertically。
\item 创建一个群组框、两个标签、两个组合框以及一个水平分隔符，然后把它们放到窗体上的任意位置。
\item 拖动群组框的右下角使它变大一些。然后，把其他窗口部件移到群组框中，并且按照如图2.12(a)所示的那样把它们放置到适当位置。
\item 拖动第二个组合框的右边缘，使它的宽度大约为第一个组合框的两倍。
\item 将群组框的title属性设置为"\&{}Primary Key"，第一个标签的text属性设置为"Column:"，第二个标签的text属性设置为"Order:"。
\item 右键单击第一个组合框。从Qt设计师弹出的上下文菜单的组合框编辑器中选择EditItems。用文本"None"创建一个项。
\item 右键单击第二个组合框并且同样选择Edit Items。创建一个"Ascending"项和一个"Descending"项。
\item 单击群组框，然后单击Form→Lay Out in a Grid。再次单击群组框，并且单击Form→Adjust Size。此时将会产生一个如图2.12(b)所示的布局。
\end{enumerate}

\begin{linefig}[0.8]{sortlayout}
\caption{将群组框的子对象摆放到网格中}
\label{fig:sortlayout}
\end{linefig}

如果没能生成你所希望的那种布局效果，或者是不小心做错了，那么总是可以随时先通过单击Edit→Undo或Form→Break Layout，然后再重新放置这些要摆放的窗口部件，最后再试着对它们重新布局，直到满意为止。

现在来添加其他两个群组框：Secondary Key和Tertiary Key：
\begin{enumerate}
\item 让对话框窗口足够高，以便可以容纳另外两个部分。
\item 按下Ctrl键（在Mac中按下Alt键），然后单击并拖动Primary Key群组框，这样就可以在原群组框（以及它所包含的所有组件）的上方复制出一个新的群组框。仍旧按下Ctrl键（或Alt键），把复制的这个群组框拖动到原群组框的下方。重复以上步骤，就可以生成第三个群组框，然后把它拖动到第二个群组框的下方。
\item 将它们的title属性分别修改为"\&{}Secondary Key"和"\&{}Tertiary Key"。
\item 创建一个垂直分隔符，并且把它放到Primary Key群组框和Secondary Key群组框的中间。
\item 把这些窗口部件按图2.13(a)所示的那样排列成网格状。

\begin{linefig}[0.8]{sort2-13}
\caption{把窗体的各个子对象摆放到网格中}
\label{fig:sort2-13}
\end{linefig}

\item 单击窗体，取消对任意选中窗口部件的选择，然后单击Form→Lay Out in a Grid。现在，向上和向左拖动窗体的右下角，以便让窗体变得尽可能地小。现在，窗体应该和图2.13(b)中显示的一样了。
\item 把两个垂直分隔符的sizeHint属性设置为[20,0]。
\end{enumerate}

最终的网格布局是4行2列，一共有8个单元格。Primary Key群组框、最左边的垂直分隔符、Secondary Key群组框和Tertiary Key群组框各占一个单独的单元格。包含OK、Cancel和More按钮的垂直布局占用了两个单元格。最后，会在对话框的右下角剩下两个空白单元格。如果你做出来的对话框不是这样，那么请撤销布局，重新放置窗口部件的位置，然后再重新试试。

把这个窗体重命名为"SortDialog"，并且把它的标题修改为"Sort"。根据图2.14修改各个子窗口部件的名称。
\begin{linefig}[0.8]{sort2-14}
\caption{重新命名窗体中的各个窗口部件}
\label{fig:sort2-14}
\end{linefig}
  
单击Edit→Edit Tab Order，从窗体的最上面到最下面依次单击每个组合框，然后单击窗体右侧的OK、Cancel和More按钮。单击Edit→Edit Widgets离开Tab键顺序设置模式。

现在，窗体已经设计完成，可以开始着手设置一些信号－槽的连接来实现窗体的功能了。Qt设计师允许我们
在构成同一窗体的不同部分内的窗口部件之间建立连接。我们需要建立两个连接。

单击Edit→Edit Signals/Slots，进入Qt设计师的设置连接模式。窗体中各个窗口部件之间的连接用蓝色箭头表
示，如图2.15所示，并且它们也会同时在Qt设计师的signal/slot编辑器窗口中显示出来。要在两个窗口部件之间
建立连接，可以单击作为发射器的窗口部件并且拖动所产生的红色箭头线到作为接收器的窗口部件上，然后松开鼠标按键。这时会弹出一个对话框，可以从中选择建立连接的信号和槽。

\begin{fig}{sort2-15}
\caption{连接窗体的各个部件}
\label{fig:sort2-15}
\end{fig}

要建立的第一个连接位于okButton按钮和窗体的accept()槽之间。把从okButton按钮开始的红色箭头线拖动
到窗体的空白区域，然后松开按键，这样会弹出如图2.16所示的设置连接对话框(Configure Connection dialog)。从该对话框中选择clicked()作为信号，选择accept()作为槽，然后单击OK按钮。

对于第二个连接，把从cancelButton按钮开始的红色箭头线拖动到窗体的空白区域，然后在设置连接对话框中连接按钮的clicked()信号和窗体的reject()槽。

要建立的第三个连接位于moreButton按钮和secondayGroupBox群组框之间。在这两个窗口部件之间拖动红色箭头线，然后选择toggled(bool)作为信号，选择setVisible(bool)作为槽。默认情况下，setVisible(bool)槽不会显示在Qt设计师的槽列表中，但如果选中了"Show all signals and slots"选项，就可以看到这个槽了。

\begin{linefig}[0.8]{sort2-16}
\caption{Qt设计师的连接编辑器}
\label{fig:sort2-16}
\end{linefig}

第四个也是最后一个要建立的连接是moreButton按钮的toggled(bool)信号和tertiaryGroupBox群组框的setVisible(bool)槽之间的连接。这些连接一旦完成，就可以单击Edit→Edit Widgets而离开创建连接模式。

将这个对话框保存在sort目录中，文件名为sortdialog.ui。要给这个窗体添加代码，同样将使用在前一节的Go to Cell对话框设计中已经用过的多重继承的方法。

首先，用如下内容创建一个sortdialog.h文件：
\begin{cppinput}{qt4-book/chap02/sort/sortdialog.h}
\end{cppinput}

然后再创建sortdialog.cpp文件 :
\begin{cppinput}{qt4-book/chap02/sort/sortdialog.cpp}
\end{cppinput}

构造函数隐藏了对话框的第二键和第三键这两个部分。它也把有关窗体布局的sizeConstraint属性设置为QLayout::SetFixedSize，这样会使用户不能再重新修改这个对话框窗体的大小。这样一来，布局就会负责对话框重新定义大小的职责，并且也会在显示或者隐藏子窗口部件的时候自动重新定义这个对话框的大小，从而可以确保对话框总是能以最佳的尺寸显示出来。

setColumnRange()槽根据电子制表软件中选择的列初始化了这些组合框的内容。在（可选的）第二键和第三键的组合框选项中插入了一个"None"选项。

第26行和第27行给出了布局中的一个特殊习惯用语。QWidget::sizeHint()函数可以返回布局系统试图认同的“理想”大小。这也解释了为什么不同的窗口部件或者具有不同内容的类似窗口部件通常会被布局系统分配给不同的尺寸大小。对于这些组合框，这里指的是第二键组合框和第三键组合框，由于它们包含了一个"None"选项，所以它们要比只包含了一个单字符项目的主键组合框显得宽一些。为了避免这种不一致性，需要把主键组合框的最小大小设置成第二键组合框的理想大小。

这里是一个用于测试效果的main()函数，它首先设置了列的范围为从"C"到"F"，然后再显示这个对话框：
\begin{cppinput}{qt4-book/chap02/sort/main.cpp}
\end{cppinput}

这样就完成了这个扩展对话框。就像这个实例所显示的那样，设计一个扩展对话框并不比设计一个简单对话框难：所需要的就是一个切换按钮、一些信号－槽连接以及一个不可以改变尺寸大小的布局。在实际的应用程序中，控制扩展对话框的按钮通常会在只显示了基本对话框时显示为Advanced>>>，而在显示了扩展对话框时才显示为Advanced<<<。这在Qt中实现起来非常容易，只需在单击这个按钮时调用QPushButton中的setText()函数即可完成这一功能。

在Qt中，无论是使用手工编码的方式还是使用Qt设计师，都可以轻松地创建另一种常用的可以改变形状的对话框：多页对话框。可以通过多种不同的方式创建这种对话框：
\begin{itemize}
\item QTabWidget的用法就像它自己的名字一样。它提供了一个可以控制内置QStackedWidge的Tab栏。
\item QListWidget和QStackedWidget可以一起使用，将\\ QListWidget::currentRowChanged()信号与\\ QStackedWidget::setCurrentIndex()槽连接，然后再利用QListWidget的当前项就可以确定应该显示QStackedWidget中的哪一页。
\item 与上述QListWidget的用法相似，也可以将QTreeWidget和QStackedWidget一起使用。
\end{itemize}

第6章将讲解QStackedWidget类。

\section{动态对话框}
动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件创建而来的那些对话框。动态对话框不需要通过uic把.ui文件转换成C++代码，相反，它是在程序运行的时候使用QUiLoader类载入该文件的，就像下面这种方式：
\begin{Verbatim}
QUiLoader uiLoader;
QFile file("sortdialog.ui");
QWidget *sortDialog = uiLoader.load(&file);
if (sortDialog) {
    ...
}
\end{Verbatim}

可以使用QObject::findChild<T>()来访问这个窗体中的各个子窗口部件：
\begin{Verbatim}
QComboBox *primaryColumnCombo =
    sortDialog->findChild<QComboBox *>("primaryColumnCombo");
if (primaryColumnCombo) {
    ...
}
\end{Verbatim}

这里的findChild<T>()函数是一个模板成员函数，它可以返回与给定的名字和类型相匹配的子对象。由于受编译器的制约，还不能在MSVC 6中使用该函数。如果需要使用MSVC 6编译器，那么可以通过调用全局函数qFindChild<T>()来代替该函数，这个全局函数同样也可以完全相同的方式工作。

QUiLoader类放在一个独立的库中。为了在Qt应用程序中使用QUiLoader，必须在这个应用程序的.pro文件中加入这一行内容：
\begin{Verbatim}
CONFIG += uitools
\end{Verbatim}

动态对话框使不重新编译应用程序而可以改变窗体布局的做法成为可能。动态对话框也同样可用于创建小型终端应用程序，这些程序只有一个内置的前端窗体，并且只是在需要的时候才会去创建所有的其他窗体。


\section{内置的窗口部件类和对话框类}
Qt提供了一整套内置的窗口部件和常用对话框，这可以满足绝大多数情况。在这一节，几乎给出了它们所有的屏幕截图。会在稍后提供那些少量的特殊窗口部件：第3章会讲到用于主窗口的那些窗口部件，如QMenuBar、QToolBar和QStatusBar等；第6章会讲到与布局相关的那些窗口部件，如QSplitter和QScrollArea等。在本书提供的实例中将会用到绝大多数内置窗口部件和对话框。所有这些窗口部件都会使用Plastique风格显示在从图2.17到图2.26的屏幕截图中。

如图2.17所示，Qt提供了4种类型的按钮：QPushButton、QToolButton、QCheckBox和QRadioButton。最常使用的就是QPushButton和QToolButton，当单击时，它们就能够发起一个动作，但它们也可以具有像切换按钮（按钮单击一次被按下，再单击一次会还原）一样的行为。复选框QCheckBox可用于打开/关闭单独的那些选项，而单选按钮QRadioButton通常用于需要互斥条件的地方。
\begin{linefig}[0.8]{widget2-17}
\caption{Qt的按钮窗口部件}
\label{fig:widget2-17}
\end{linefig}

Qt的容器窗口部件是一种可以包含其他窗口部件的窗口部件。图2.18和图2.19给出了这些容器窗口部件。QFrame也可用于它自身，这只是为了绘制一些直线，它也可以用作许多其他窗口部件的基类，如QToolBox和QLabel等。
\begin{linefig}[0.8]{widget2-18}
\caption{Qt的单页容器窗口部件}
\label{fig:widget2-18}
\end{linefig}

QTabWidget和QToolBox是多页窗口部件。在多页窗口部件中，每一页都是一个子窗口部件，并从0开始编号这些页。对于一个QTabWidget，它的每个Tab标签的形状和位置都可以进行设置。如图2.20所示，为处理较大的数据量，这些项视图已经进行了优化，并且会经常使用它们的滚动条(scroll bar)。滚动条机制是在QAbstractScrollArea中实现的，它是所有项视图和其他类型的可滚动窗口部件的基类。 

\begin{linefig}[0.8]{widget2-19}
\caption{Qt的多页容器窗口部件}
\label{fig:widget2-19}
\end{linefig}


Qt库含有一个富文本引擎(rich text engine)，它可用于格式化文本的显示和编辑。该引擎支持字体规范、文本对齐、列表、表格、图片和超文本链接等。可以通过编程的方式一个元素一个元素地生成富文本文档，或者也可以通过所提供的HTML格式的文本来生成富文本文档。至于该引擎所支持的HTML标记和CSS属性的详细说明，请参见\href{http://doc.trolltech.com/4.3/richtext-html-subset.html}{文档}。

\begin{linefig}[0.8]{widget2-20}
\caption{Qt的项视图窗口部件}
\label{fig:widget2-20}
\end{linefig}

如图2.21所示，Qt提供了一些纯粹用于显示信息的窗口部件。QLabel是这些窗口部件中最重要的一个，并且它也可以用来显示普通文本、HTML和图片。

\begin{linefig}[0.8]{widget2-21}
\caption{Qt的显示窗口部件}
\label{fig:widget2-21}
\end{linefig}

QTextBrowser是一个只读型QTextEdit子类，它可以显示带格式的文本。对于大型格式化文本文档的处理优先使用这个类而不是QLabel，因为它与QLabel不同，它会在必要时自动提供滚动条，同时还提供了键盘和鼠标导航的广泛支持。Qt 4.3助手就是使用QTextBrowser来为用户呈现文档的。

Qt提供了数个用于数据输入的窗口部件，如图2.22所示。QLineEdit可以使用一个输入掩码、一个检验器或者同时使用两者对它的输入进行限定。QTextEdit是QAbstractScrollArea的子类，具有处理大量文本的能力。一个QTextEdit可设置用于编辑普通文本或者富文本。在编辑富文本的时候，它可以显示Qt富文本引擎所支持的所有元素。QLineEdit和QTextEdit两者都对剪贴板提供完美支持。

\begin{linefig}[0.8]{widget2-22}
\caption{Qt的输入窗口部件}
\label{fig:widget2-22}
\end{linefig}

如图2.23所示，Qt提供了一个通用消息框和一个可以记住它所显示的消息内容的错误对话框。可以使用QProgressDialog或者使用图2.21中显示的QProgressBar来对那些非常耗时的操作进度进行指示。当用户只需要输入一行文本或者一个数字的时候，使用QInputDialog会显得非常方便。

\begin{linefig}[0.8]{widget2-23}
\caption{Qt的反馈对话框}
\label{fig:widget2-23}
\end{linefig}

Qt提供了一套标准的通用对话框，这样可以让用户很容易地选择颜色、字体、文件或者文档打印。图2.24和图2.25显示了这些对话框。
\begin{linefig}[0.8]{widget2-24}
\caption{Qt的颜色对话框和字体对话框}
\label{fig:widget2-24}
\end{linefig}

\begin{linefig}[0.8]{widget2-25}
\caption{Qt的文件对话框和打印对话框}
\label{fig:widget2-25}
\end{linefig}

在Windows和Mac OS X上，Qt有可能会使用本地系统的对话框，而不是它自己的通用对话框。颜色的选取也可以使用Qt Solutions的某个颜色选择窗口部件来完成，而字体也可以使用内置的QFontComboBox来选择。

最后，QWizard为生成向导（wizard，在Mac OS X上也称为助手）提供了一个基本框架。对于那些用户可能会难于理解的复杂或者不常见的工作，向导会非常有用。图2.26给出了使用向导的一个例子。

\begin{linefig}[0.8]{widget2-26}
\caption{Qt的QWizard对话框}
\label{fig:widget2-26}
\end{linefig}

内置窗口部件和常用对话框为用户提供了很多可以直接使用的功能。通过设置窗口部件的属性，或者是通过把信号和槽连接起来并在槽里实现自定义的行为，通常就可以满足许多更为复杂的需求。

如果Qt所提供的窗口部件或者常用对话框没有一个合适，那么可以从Qt Solutions，或者从商业或非商业的第三方软件中找到一个可用的。Qt Solutions提供了许多额外的窗口部件，包括各种颜色选择器、一个手轮控制器、许多饼状图菜单以及属性浏览器等，还有一个复制对话框。

在某些情况下，你可能希望手动创建一个自定义窗口部件。Qt使这种工作变得很简单，并且自定义窗口部件也可以像Qt的内置窗口部件一样获得与平台无关的所有相同绘制功能。自定义窗口部件甚至可以集成到Qt设计师中，这样就可以像使用Qt的内置窗口部件一样来使用它们。第5章将讲述如何创建自定义窗口部件。


\chapter{创建主窗口}
这一章讲解如何使用Qt创建主窗口。在本章的最后部分，你将能够创建一个应用程序的完整用户界面，包括菜单、工具栏、状态栏以及应用程序所需的足够多的对话框。

应用程序的主窗口提供了用于构建应用程序用户界面的框架。如图3.1所示的Spreadsheet（电子制表）应用程序的主窗口将构成本章的基础。这个Spreadsheet应用程序使用了在第2章中创建的三个对话框：Find、Go to Cell和Sort。
\begin{linefig}[0.9]{spreadsheet}
\caption{Spreadsheet应用程序}
\label{fig:spreadsheet}
\end{linefig}

在绝大多数图形用户界面应用程序的后台，都有一套提供底层功能的代码——例如，用于读写文件或者用于处理用户界面中的数据的代码。在第4章，将会再次把Spreadsheet应用程序当作实例，看看如何实现这些功能。

\section{子类化QMainWindow}
通过子类化QMainWindow，可以创建一个应用程序的主窗口。由于QDialog和QMainWindow都派生自QWidget，所以在第2章中看到的许多创建对话框的技术，对于创建主窗口也同样适用。

可以使用Qt设计师创建应用程序的主窗口，但是在这一章，将使用代码来完成所有的功能，以便可以说明它们是如何完成的。如果你更喜欢可视化的方式，可以参考Qt设计师在线手册中的"Creating a Main Window Application"一章。

Spreadsheet应用程序主窗口的源代码分别放在mainwindow.h和mainwindow.cpp中。先从头文件开始分析：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{1}{19}
\end{cppline}

我们将MainWindow类定义为QMainWindow类的子类。由于类MainWindow提供了自己的信号和槽所以它包含了Q\_{}OBJECT宏。

closeEvent()函数是QWidget类中的一个虚函数，当用户关闭窗口时，这个函数会被自动调用。类MainWindow中重新实现了它，这样就可以向用户询问一个标准问题"Do you want to save your changes?"，并且可以把用户的一些偏好设置保存到磁盘中。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{21}{29}
\end{cppline}

像File→New和Help→About这样的菜单项，在MainWindow中会被实现为私有槽。除了save()槽和saveAs()槽返回一个bool值以外，绝大多数的槽都把void作为它们的返回值。当槽作为一个信号的响应函数而被执行时，就会忽略这个返回值；但是当把槽作为函数来调用时，其返回值对我们的作用就和调用任何一个普通的C++函数时的作用是相同的。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{30}{47}
\end{cppline}

为了能够对用户界面提供支持，主窗口需要更多的私有槽以及数个私有函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.h}{49}{0}
\end{cppline}

除了它自己的私有槽和私有函数以外，MainWindow类还有很多私有变量。当用到这些私有槽和私有函数时，将再对它们进行解释。

现在来看看实现文件：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{1}{7}
\end{cppline}

我们包含了<QtGui>头文件，其中包含了在子类中所要用到的所有Qt类的定义。我们也包含了一些自定义头文件，特别是来自第2章的finddialog.h、gotocelldialog.h和sortdialog.h三个头文件。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{9}{26}
\end{cppline}

在这个构造函数中，先从创建一个Spreadsheet窗口部件并且把它设置为这个主窗口的中央窗口部件开始。中央窗口部件会占用主窗口的中央区域部分（如图3.2所示）。Spreadsheet类是QTableWidget类的一个子类，并且也具有一些电子制表软件的功能，如对电子制表软件公式的支持等。将会在第4章中实现这一功能。

私有函数createActions()、createMenus()、createContextMenu()、createToolBars()和createStatusBar()创
建主窗口中的其余部分，readSettings()则读取这个应用程序存储的一些设置。
\begin{linefig}[0.8]{spreadsheet3-2}
\caption{QMainWindow中的区域分配}
\label{fig:spreadsheet3-2}
\end{linefig}

我们把findDialog指针初始化为空(null)指针。在第一次调用MainWindow::find()函数时，将会创建该FindDialog对象。

在构造函数的最后部分，把窗口的图标设置为icon.png，它是一个PNG格式的文件。Qt支持很多图像格式，包括BMP、GIF、JPEG、PNG、PNM、SVG、TIFF、XBM和XPM。调用QWidget::setWindowIcon()函数可以设置显示在窗口左上角的图标。遗憾的是，还没有一种与平台无关的可在桌面上显示应用程序图标的设置方法。与平台相关的桌面图标设置方法在\href{http://doc.trolltech.com/4.3/appicon.html}{这个网页}中进行了阐述。


图形用户界面(GUI)应用程序通常会使用很多图片。为应用程序提供图片的方法有多种，如下是一些最常用的方法：
\begin{itemize}
\item 把图片保存到文件中，并且在运行时载入它们。
\item 把XPM文件包含在源代码中。（这一方法之所以可行，是因为XPM文件也是有效的C++文件。）
\item 使用Qt的资源机制(resource mechanism)。
\end{itemize}

这里，使用了Qt的资源机制法，因为它比运行时载入文件的方法更方便，并且该方法适用于所支持的任意文件格式。我们将选中的图片存放在源代码树中名为images的子目录下。

为了利用Qt的资源系统(resource system)，必须创建一个资源文件(resource file)，并且在识别该资源文件的.pro文件中添加一行代码。在这个例子中，已经将资源文件命名为spreadsheet.qrc，因此只需在.pro文件中添加如下一行代码：
\begin{Verbatim}
RESOURCES = spreadsheet.qrc
\end{Verbatim}

资源文件自身使用了一种简单的XML文件格式。这里给出的是从已经使用的资源文件中摘录的部分内容：
\begin{Verbatim}
<RCC>
<qresource>
    <file>images/icon.png</file>
    ...
    <file>images/gotocell.png</file>
</qresource>
</RCC>
\end{Verbatim}

所有资源文件都会被编译到应用程序的可执行文件中，因此并不会弄丢它们。当引用这些资源时，需要使用带路径前缀\verb+:/+（冒号斜线）的形式，这就是为什么会将图标表示成:/images/icon.png的形式。资源可以是任意类型的文件（并非只是一些图像），并且可以在Qt需要文件名的大多数地方使用它们。第12章将对此做进一步说明。  

\section{创建菜单和工具栏}
绝大多数现代图形用户界面应用程序都会提供一些菜单、上下文菜单和工具栏。菜单可以让用户浏览应用程序并且可以学会如何处理一些新的事情，上下文菜单和工具栏则提供了对那些经常使用的功能进行快速访问的方法。图3.3展示的是Spreadsheet应用程序的菜单。
\begin{linefig}[0.9]{spreadsheet3-3}
\caption{Spreadsheet应用程序中的菜单}
\label{fig:spreadsheet3-3}
\end{linefig}

Qt通过“动作”的概念简化了有关菜单和工具栏的编程。一个动作(action)就是一个可以添加到任意数量的菜单和工具栏上的项。在Qt中，创建菜单和工具栏包括以下这些步骤：
\begin{itemize}
\item 创建并且设置动作。
\item 创建菜单并且把动作添加到菜单上。
\item 创建工具栏并且把动作添加到工具栏上。
\end{itemize}

在这个Spreadsheet应用程序中，动作是在createActions()函数中创建的：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{163}{169}
\end{cppline}

动作New有一个加速键(\uline{N}ew)、一个父对象（主窗口）、一个图标、一个快捷键和一个状态提示。大多数窗口系统都有用于特定动作的标准化的键盘快捷键。例如，在Windows、KDE和GNOME中，这个New动作就有一个快捷键Ctrl+N，而在Mac OS X中则是Command+N。通过使用适当的QKeySequence::StandardKey枚举值，就可以确保Qt能够为应用程序在其运行的平台上提供正确的快捷键。

把这个动作的triggered()信号连接到主窗口的私有槽newFile()——将会在下一节实现它。这个连接可以确保在用户选择File→New菜单项、选择工具栏上的New按钮或者按下Ctrl+N时，都可以调用newFile()槽。

由于菜单中的Open、Save和Save As动作与New动作非常相似，所以将会直接跳到File菜单中的"recently opened files"（最近打开的文件）的部分。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{188}{193}
\end{cppline}

我们为recentFileActions数组添加动作。每个动作都是隐式的，并且会被连接到openRencentFile()槽。稍后，将会看到如何读这些最新文件中的动作变得可见并且可用。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{195}{198}
\end{cppline}

这个Exit动作与目前为止所看到的那些动作稍微有些不同。由于没有用于终止应用程序的标准化键序列，所以需要在这里明确指定键序列。另外一个不同之处是我们连接的是窗口的close()槽，而它是由Qt提供的。

现在，可以跳到Select All动作中：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{241}{246}
\end{cppline}

由于槽selectAll()是由QTabelWidget的父类之一的QAbstractItemView提供的，所以就没有必要再去亲自实现它。

现在，不妨进一步跳到Options菜单中的Show Grid动作中去：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{273}{279}
\end{cppline}

Show Grid是一个复选(checkable)动作。复选动作在菜单中显示时会带一个复选标记，并且在工具栏中它可以实现成切换(toggle)按钮。当启用这个动作时，Spreadsheet组件就会显示一个网格。我们用Spreadsheet组件的默认值来初始化这个动作，这样它们就可以从一开始就同步起来。然后，把Show Grid动作的toggled(bool)信号和Spreadsheet组件的setShowGrid(bool)槽连接起来，这个槽继承自QTableWidget。一旦把这个动作添加到菜单或者工具栏中，用户就可以对网格的显示与否进行切换了。

Show Grid动作和Auto-Recalculate动作是相互独立的两个复选动作。通过QActionGroup类的支持，Qt也可以支持相互排斥的动作。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{298}{301}
\end{cppline}

对于About Qt动作，通过访问qApp全局变量，我们可以使用QApplication对象的aboutQt()槽。这个动作会弹出一个如图3.4所示的对话框。
\begin{linefig}[0.8]{spreadsheet3-4}
\caption{About Qt对话框}
\label{fig:spreadsheet3-4}
\end{linefig}

现在已经创建了这些动作，还可以继续构建一个包含这些动作的菜单系统：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{303}{314}
\end{cppline}

在Qt中，菜单都是QMenu的实例。addMenu()函数可以用给定的文本创建一个QMenu窗口部件，并且会把它添加到菜单栏中。QMainWindow::menuBar()函数返回一个指向QMenuBar的指针。菜单栏会在第一次调用menuBar()函数的时候就创建出来。

从创建File菜单开始，然后再把New、Open、Save、Save As动作添加进去。插入一个间隔器(separator)，可以从视觉上把关系密切的这些项放在一起。使用一个for循环从recentFileActions数组中添加一些动作（最初是隐藏起来的），然后在最后添加一个exitAction动作。

我们已经让一个指针指向了这些间隔器中的某一个。这样就可以允许隐藏（如果没有最近文件的话）或者显示那个间隔器，因为不希望出现在两个间隔器之间什么都没有的情况。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{316}{329}
\end{cppline}

现在来创建Edit菜单，就像在File菜单中所做的那样使用QMenu::addMenu\linebreak ()函数添加各个动作，并且在希望出现子菜单的地方使用QMenu::addMenu()函数添加子菜单。一个子菜单与它所属的菜单一样，也是一个QMenu。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{331}{344}
\end{cppline}

通过类似的方式创建Tools、Options和Help菜单。在Options菜单和Help菜单之间插入一个间隔器。对于Motif和CDE风格，这个间隔器会把Help菜单放到菜单栏的最右端；对于其他的风格，则将会忽略这个间隔器。图3.5是这两种情况的示意图。

\begin{linefig}[0.8]{spreadsheet3-5}
\caption{Motif和Windows风格下的菜单栏}
\label{fig:spreadsheet3-5}
\end{linefig}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{346}{352}
\end{cppline}

任何Qt窗口部件都可以有一个与之相关联的QActions列表。要为该应用程序提供一个上下文菜单，可以将所需要的动作添加到Spreadsheet窗口部件中，并且将那个窗口部件的上下文菜单策略(context menu policy)设置为一个显示这些动作的上下文菜单。当用户在一个窗口部件上单击鼠标右键，或者是在键盘上按下一个与平台相关的按键时，就可以激活这些上下文菜单。Spreadsheet中的上下文菜单如图3.6所示。
\begin{fig}[0.6]{spreadsheet3-6.png}
\caption{Spreadsheet应用程序中的上下文菜单}
\label{fig:spreadsheet3-6.png}
\end{fig}

一种更为高级的提供上下文菜单方法是重新实现\\ QWidget::contextMenuEvent()函数，创建一个QMenu窗口部件，在其中添加所期望的那些动作，并且再对该窗口部件调用exec()函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{354}{368}
\end{cppline}

创建工具栏与创建菜单的过程很相似，我们据此创建一个File工具栏和一个Edit工具栏。就像菜单一样，工具栏也可以有多个间隔器，如图3.7所示。
\begin{linefig}[0.6]{spreadsheet3-7.png}
\caption{Spreadsheet应用程序的工具栏}
\label{fig:spreadsheet3-7.png}
\end{linefig}


\section{设置状态栏}
随着菜单和工具栏的完成，已经为设置Spreadsheet应用程序的状态栏做好了准备。在程序的普通模式下，状态栏包括两个状态指示器：当前单元格的位置和当前单元格中的公式。状态栏也用于显示状态提示和其他一些临时消息。图3.8给出了各种情况下的状态栏。
\begin{linefig}[0.7]{spreadsheet3-8.png}
\caption{Spreadsheet应用程序的状态栏}
\label{fig:spreadsheet3-8.png}
\end{linefig}

MainWindow的构造函数会调用createStatusBar()来设置状态栏。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{370}{388}
\end{cppline}

QMainWindow::statusBar()函数返回一个指向状态栏的指针。\footnote{在第一次调用statusBar()函数的时候会创建状态栏。}状态栏指示器是一些简单的QLabel，可以在任何需要的时候改变它们的文本。已经在formulaLabel中添加了一个缩进格式，以便让那些在它里面显示的文本能够与它的左侧边有一个小的偏移量。当把这些QLabel添加到状态栏的时候，它们会自动被重定义父对象，以便让它们成为状态栏的子对象。

图3.8所示的两个标签都有不同的空间需求。单元格定位指示器只需要非常小的空间，并且在重新定义窗口大小时，任何多余的空间都会分配给位于右侧的单元格公式指示器。这是通过在公式标签的QStatusBar::addWidget()调用中指定一个伸展因子$ 1 $而实现的。位置指示器的默认伸展因子为$ 0 $，这也就意味着它不喜欢被伸展。

当QStatusBar摆放这些指示器窗口部件时，它会尽量考虑由\\ QWidget::sizeHint()提供的每一个窗口部件的理想大小，然后再对那些可伸展的任意窗口部件进行伸展以填满全部可用空间。一个窗口部件的理想大小取决于这个窗口部件的内容以及改变内容时的变化大小。为了避免对定位指示器连续不断地重定义大小，设置它的最小尺寸大小为它所能包含的最大字符数("W999")和一些空格的总大小。还把它的对齐方式设置为Qt::AlignHCenter，以便可以在水平方向上居中对齐它的文本。

在函数结尾的附近，把Spreadsheet的两个信号和MainWindow的两个槽，updateStatusBar()和spreadsheetModified()，连接了起来。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{151}{155}
\end{cppline}

updateStatusBar()槽可以更新单元格定位指示器和单元格公式指示器。只要用户把单元格光标移动到一个新的单元格，这个槽就会得到调用。该槽也可以作为一个普通函数而在createStatusBar()的最后用于初始化这些指示器。因为Spreadsheet不会在一开始的时候就发射currentCellChanged()小心，所以还必须这样做。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{157}{161}
\end{cppline}

spreadsheetModified()槽把windowModified属性设置为true，用以更新标题栏。这个函数也会更新位置和公式指示器，以便可以让它们反映事件的当前状态。

\section{实现File菜单}
在这一节中，将实现那些能够让File菜单项正常工作并且能够对最近打开文件进行管理的槽函数和私有函数。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{38}{44}
\end{cppline}

当用户点击File→New菜单项或者单击工具栏上的New按钮时，就会调用newFile()槽。如果存在还没有被保存的信息，okToContinue()私有函数就会弹出如图3.9所示的对话框："Do you want to save your changes?"。如果用户选择Yes或者No（保存文档应该选择Yes），这个函数会返回true；如果用户选择Cancel，它就返回false。Spreadsheet::clear()函数会清空电子制表软件中的全部单元格和公式。setCurrentFile()私有函数会更新窗口的标题，以说明正在编辑的是一个没有标题的文档，它还会设置curFile私有变量并且更新最近打开文件的列表。  
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{416}{431}
\end{cppline}

在okToContinue()函数中，会检测windowModified属性的状态。如果该属性的值是true，就显示一个如图3.9所示的消息框。这个消息框包含一个Yes按钮、一个No按钮和一个Cancel按钮。
\begin{linefig}[0.8]{spreadsheet3-9}
\caption{"Do you want to save your changes?"消息框}
\label{fig:spreadsheet3-9}
\end{linefig}

QMessageBox提供了许多标准按钮，并且会自动尝试着让其中的一个成为默认的确认按钮（在用户按下Enter键时会得到激活），一个成为默认的退出按钮（在用户按下Esc时会得到激活）。选择一些特殊的按钮作为默认的确认按钮和退出按钮也是有可能的，用户还可以自定义按钮中将要显示的文本内容。

当首次看到warning()函数调用时，可能会觉得它有点复杂，但这种常用语法实际上是相当简单的：
\begin{Verbatim}
QMessageBox::warning(parent, title, message, buttons);
\end{Verbatim}

除了warning()之外，QMessageBox还提供了information()、question()和critical()函数，它们每一个都有自己特定的图标，这些图标如图3.10所示。
\begin{linefig}[0.8]{spreadsheet3-10.png}
\caption{Windows风格下的消息框图标}
\label{fig:spreadsheet3-10.png}
\end{linefig}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{46}{55}
\end{cppline}

open()槽对File→Open做出响应。就像newFile()一样，它首先调用okToContinue()函数来处理任何没有被保存的变化。然后它使用方便的QFileDialog::getOpenFileName()静态函数从用户那里获得一个新的文件名。这个函数会弹出一个文件对话框，让用户选择一个文件，并且返回这个文件名——或者，如果用户单击了Cancel按钮，则返回一个空字符串。

传递给QFileDialog::getOpenFileName()函数的第一个参数是它的父窗口部件。用于对话框和其他窗口部件的这种父子对象关系意义并不相同。对话框通常都拥有自主权，但是如果它有父对象，那么在默认情况下，它就会居中放到父对象上。一个子对话框也会共用它的父对象的任务栏。

第二个参数是这个对话框应当使用的标题。第三个参数告诉它应当从哪一级目录开始，在这个例子中就是当前目录。

第四个参数指定了文件过滤器。文件过滤器(filter)由一个描述文本和一个通配符组成。如果除了要支持Spreadsheet本地文件格式以外，还需要支持采用逗号分隔的数据文件和Lotus 1-2-3文件，就应当使用如下的文件过滤器：
\begin{Verbatim}
tr("Spreadsheet files (*.sp)\n"
"Comma-separated values files (*.csv)\n"
"Lotus 1-2-3 files (*.wk1 *.wks)")
\end{Verbatim}

loadFile()私有函数是在open()中得到调用的，它用来载入文件。我们让它成为一个独立的函数，是因为会在载入最近打开的文件中使用同样的功能。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{433}{443}
\end{cppline}

我们使用Spreadsheet::readFile()函数从磁盘中读取文件。如果载入成功，会调用setCurrentFile()函数来更新这个窗口的标题；否则，\\ Spreadsheet::readFile()将会通过一个消息框把遇到的问题通知给用户。在通常情况下，让底层组件来报告错误消息是一个不错的习惯，这是因为它们可以提供准确的错误细节信息。

在上述两种情况下，都会在状态栏中显示一个消息2秒（2000毫秒），这样可以通知用户应用程序正在做什么。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{57}{64}
\end{cppline}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{445}{455}
\end{cppline}

save()槽对File→Save做出响应。如果因为这个文件是之前打开的文件或者它是一个已经保存过的文件，这样已经有了一个名字，那么save()函数就会用这个名字调用saveFile()函数；否则，它只是简单地调用saveAs()函数。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{66}{75}
\end{cppline}

saveAs()槽对File→Save As做出响应。调用\\ QFileDialog::getSaveFileName()函数来从用户那里得到一个文件名。如果用户单击了Cancel，则返回false，这将会使这个结果向上传递给它的调用者[save()或者okToContinue()]。

如果给定的文件已经存在，getSaveFileName()函数将会要求用户确认是否需要覆盖该文件。但通过给getSaveFileName()函数传递一个QFileDialog::DontConfirmOverwrite附加参数，则可以改变这一行为。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{28}{36}
\end{cppline}

当用户单击File→Exit或者单击窗口标题栏中的关闭按钮时，将会调用QWidget::close()槽。该槽会给窗口部件发射一个“close”事件。通过重新实现QWidget::closeEvent()函数，就可以中途截取对这个主窗口的关闭操作，并且可以确定到底是不是真的要关闭这个窗口。

如果存在未保存的更改并且用户选择了Cancel，就会“忽略”这个关闭事件并且让这个窗口不受该操作的影响。一般情况下，我们会接受这个事件，这会让Qt隐藏该窗口。也可以调用私有函数writeSettings()来保存这个应用程序的当前设置。

当最后一个窗口关闭后，这个应用程序就结束了。如果需要，通过把QApplication的quitOnLastWindowClosed属性设置为false，可以禁用这种行为。在这种情况下，该应用程序将会持续保持
运行，直到调用QApplication::quit()函数，程序才会结束。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{457}{472}
\end{cppline}
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{497}{500}
\end{cppline}


在setCurrentFile()中，对保存正在编辑的文件名的curFile私有变量进行了设置。在把这个文件名显示在标题栏中之前，需要使用strippedName()函数移除文件名中的路径字符，这样可以使文件名看起来更友好一些。   

每个QWidget都有一个windowModified属性，如果该窗口的文档存在没有保存的变化，则应当把它设置为true，否则应当将其设置为false。在Mac OS X下，未保存的文档是通过窗口标题栏上关闭按钮中的一个点来表示的；在其他平台下，则是通过文件名字后跟一个星号来表示的。Qt会自动处理这一行为，只要始终让windowModified属性保持为当前最新状态，并且当需要显示星号的时候，把"[*]"标记放在窗口的标题栏上即可。

传递给setWindowTitle()函数的文本是：
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{470}{471}
\end{cppline}


QString::arg()函数将会使用自己的参数替换最小数字的"\%{}n"参数，并且会用它的参数返回结果"\%{}n"字符和最终的结果字符串。在本例中，arg()被用于两个"\%{}n"参教中。第一个arg()调用会替换参数"\%{}1"，第二个arg()调用则会替换参数"\%{}2"。如果文件名是budget.sp并且没有载入翻译文件，那么结果字符串将是"budget.sp[*]-Spreadsheet"。这本应更简单地写作如下代码：
\begin{Verbatim}
setWindowTitle(shownName + tr("[*] - Spreadsheet"));
\end{Verbatim}

但使用arg()函数可以为翻译人员提供更多的灵活性。

如果存在文件名，就需要更新应用程序的最近打开文件列表recentFiles。可以调用removeAll()从列表中移除任何已经出现过的文件名，从而避免该文件名的重复。然后，可以调用prepend()把这个文件名作为文件列表的第一项添加进去。在更新了文件列表之后，可以调用私有函数updateRencentFileActions()更新File菜单中的那些条目。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{474}{495}
\end{cppline}

使用一个Java风格的迭代器，可以移除任何不再存在的文件。一些文件或许已经在前面的会话中使用过，但在此之前还没被删除掉。recentFiles变量的类型是QStringList（QString型列表）。第11章会详细说明一些像QStringList一样的容器类，其中将会说明它们与C++标准模板库(Standard Template Library , STL)之间的关系，也会说明Qt的Java风格迭代器类的用法。

然后，再遍历一次文件列表，这一次使用数组风格的索引形式。对于每一个文件，创建一个由一个与操作符、一位数字(j+1)、一个空格和该文件名（不带路径）组成的字符串。我们要为使用这种文本设置相应的动作。例如，如果第一个文件是\verb+C:\My Documents\tab04.sp+，那么第一个动作的文本将会是"\&{}1 tab04.sp"。图3.11给出了recentFileActions数组和菜单的最终结果之间的对应关系。

\begin{linefig}[0.8]{spreadsheet3-11.png}
\caption{带最近打开文件列表的File菜单}
\label{fig:spreadsheet3-11.png}
\end{linefig}

每一个动作都可以带一个与之相关的QVariant型data项。QVariant类型可以保存许多C++和Qt型变量，第11章将说明这一点。这里，将文件的全名保存在动作的data项中，以便随后可以方便地找到它。还要将这个动作设置为可见。 

如果有比最新文件更多的文件动作，那么只需隐藏那些多余的动作即可。最后，如果至少还存在一个最近打开的文件，那么就应该把间隔器设置为可见。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{142}{149}
\end{cppline}

当用户选择了一个最近打开的文件，就会调用openRecentFile()槽。只要有任何未保存的变化，就会调用okToContinue()函数，并且假定用户没有取消，还可以使用QObject::sender()查出是哪个特有动作调用了这个槽。   

qobject\_{}cast<T>()函数可在Qt的moc（meta-object compiler，元对象编译器）所生成的元信息基础上执行动态类型强制转换(dynamic cast)。它返回一个指向所需QObject子类的指针，或者是在该对象不能被转换成所需的那种类型时返回0。与标准C++的dynamic\_{}cast<T>()不同，Qt的qobject\_{}cast<T>()可正确地跨越动态库边界。在例子中，使用qobject\_{}cast::<T>()把一个QObject指针转换成QAction指针。如果这个转换是成功的（应当是这样的），就可以利用从动作的data项中所提取的文件全名来调用loadFile()函数。

顺便值得一提的是，由于知道这个发射器是一个QAction，如果使用\\ \verb+static_cast<T>()+或者传统的C风格的数据类型强制转换代替原有的数据转换方式，这个程序应当仍然是可以运行的。请参见附录D中“类型转换”一节对不同C++数据类型强制转换的概述。


\section{使用对话框}
这一节将说明如何在Qt中使用对话框——如何创建、初始化以及运行它们，并且对用户交互中的选择做出响应。本节将会使用在第2章中创建的Find、Go to Cell和Sort对话框，也会创建一个简单的About对话框。

我们从如图3.12所示的Find对话框开始。由于希望用户能够在Spreadsheet窗口和Find对话框之间进行切换，所以Find对话框必须是非模态(modeless)的。非模态窗口就是运行在应用程序中对于任何其他窗口都独立的窗口。
\begin{linefig}[0.6]{spreadsheet3-12.png}
\caption{Spreadsheet应用程序的Find对话框}
\label{fig:spreadsheet3-12.png}
\end{linefig}

创建非模态对话框时，通常会把它的信号连接到能够对用户的交互做出响应的那些槽上。
\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{77}{94}
\end{cppline}

Find对话框是一个可以让用户在电子制表软件中搜索文本的窗口。当用户单击Edit→Find时，就会调用find()槽来弹出Find对话框。这时，就可能出现下列几种情形：
\begin{itemize}
\item 这是用户第一次调用Find对话框。
\item 以前曾经调用过Find对话框，但用户关闭了它。
\item 以前曾经调用过Find对话框，并且现在它还是可见的。
\end{itemize}

如果Find对话框还不曾存在过，就可以创建它并且把它的findNext()信号和findPrevious()信号与Spreadsheet中相对应的那些槽连接起来。本应该在MainWindow的构造函数中创建这个对话框，但是推迟对话框的创建过程将可以使程序的启动更加快速。还有，如果从来没有使用到这个对话框，那么它就决不会被创建，这样可以既节省时间又节省内存。

然后，调用show()、raise()和activateWindow()来确保窗口位于其他窗口之上并且是可见的和激活的。只调用show()就足以让一个隐藏窗口变为可见的、位于最上方并且是激活的，但是也有可能是在Find对话框窗口已经是可见的时候又再次调用了它，在这种情况下，show()调用可能什么也不做，那么就必须调用raise()和activateWindow()让窗口成为顶层窗口和激活状态。还有另外一种方法，本可以写成：

\begin{Verbatim}
if (findDialog->isHidden()) {
    findDialog->show();
} else {
    findDialog->raise();
    findDialog->activateWindow();
}
\end{Verbatim}


但这样的程序就好像明明在穿越单行道却又同时去看这条单行道的两个方向一样，显得多余。

现在看一下如图3.13所示的Go to Cell对话框。我们希望用户可以弹出、使用和关闭它，但是却不希望让这个窗口能够与应用程序中的其他窗口相互切换。也就是说，Go to Cell对话框窗口必须是模态(modal)的。模态窗口就是一个在得到调用可以弹出并可以阻塞应用程序的窗口，从而会从调用发生开始起妨碍其他的任意处理或者交互操作，直到关闭该窗口为止。前面使用的文件对话框和消息框就是模态的。

\begin{fig}{spreadsheet3-13.png}
\caption{Spreadsheet应用程序的Go to Cell对话框}
\label{fig:spreadsheet3-13.png}
\end{fig}

如果对话框是通过show()调用的，那么它就是非模态对话框[除非此后又调用了setModal()，才会让它变为模态对话框]。但是，如果它是通过exec()调用的，那么该对话框就会是模态对话框。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{96}{104}
\end{cppline}

如果对话框被接受，函数QDialog::exec()可返回一个true值\\ (QDialog::Accepted)，否则就会返回一个false值(QDialog::Rejected)。可以回想一下，当初在第2章利用Qt设计师创建Go to Cell对话框时，就曾经把OK连接到accept()，把Cancel连接到reject()。如果用户选择OK，就把当前单元格的值设置成行编辑器中的值。

QTable::setCurrentCell()函数需要两个参数：一个行索引和一个列索引。在Spreadsheet应用程序中，单元格A1就是单元格(0,0)，单元格B27就是单元格(26,1)。为了从函数QLineEdit::text()返回的QString中获得行索引，可以使用QString::mid()来提取行号（这个函数将返回一个从字符串的开始直到末尾位置的子字符串），然后使用QString::toInt()把它转换成一个整数值，并且把该值再减去1。对于列号，则可以用这个字符串中第一个字符的大写数值减去字符'A'的数值而得到。我们知道，该字符串将具有正确的格式，因为为对话框创建了一个QRegExpValidator检验器，只有满足一个字符后面再跟至多三个数字格式的字符串才能让OK按钮起作用。

goToCell()函数与目前看到的所有代码都有些不同，因为它在堆栈中创建了一个作为变量的窗口部件（一个GoToCellDialog）。虽然多使用了一行代码，但是换来了使用new和delete的简便：

\begin{Verbatim}
void MainWindow::goToCell()
{
    GoToCellDialog *dialog = new GoToCellDialog(this);
    if (dialog->exec()) {
        QString str = dialog->lineEdit->text().toUpper();
        spreadsheet->setCurrentCell(str.mid(1).toInt() - 1,
                str[0].unicode() - 'A');
}
    delete dialog;
}
\end{Verbatim}

由于在使用完一个对话框（或者菜单）后，通常就不再需要它了，所以在堆栈中创建对话框（和上下文菜单）是一种常见的编程模式。并且对话框会在作用域结束后自动销毁掉。

现在转到Sort对话框上。Sort对话框是一个模态对话框，它允许用户在当前的选定区域中使用给定的列进行排序。图3.14给出了一个排序的实例，用列B作为排序的主键，列A作为排序的第二键（两个都采用升序）。

\begin{linefig}[0.8]{spreadsheet3-14.png}
\caption{对电子制表软件的选定区域进行排序}
\label{fig:spreadsheet3-14.png}
\end{linefig}

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{106}{129}
\end{cppline}

sort()函数中的代码使用了一种和goToCell()函数中用到的类似模式：
\begin{itemize}
\item 在堆栈中创建对话框并且对其进行初始化。
\item 使用exec()弹出对话框。
\item 如果用户单击OK，就从对话框的各个窗口部件中提取并且使用这些用户输入的值。
\end{itemize}

setColumnRange()调用将那些可用于排序的列变量设置为选定的列。例如，使用图3.14中的选择，range.leftColumn()将返回值0，即$'A'+0='A'$，并且range. rightColumn()将返回值2，即$'A'+2='C'$。

compare对象储存了主键、第二键和第三键以及它们的排序顺序。（将会在下一章中看到SpreadsheetCompare类的定义。）这个对象会由Spreadsheet::sort()使用，用于两行的比较。keys数组存储了这些键的列号。例如，如果选择区域是从C2扩展到E5，那么列C的位置就是0。ascending数组中按bool格式存储了和每一个键相关的顺序。QComboBox::currentIndex()返回当前选定项的索引值，该值是一个从0开始的数。对于第二键和第三键，考虑到"None"项，我们从当前项减去1。

sort()函数会完成这项工作，但是它显得稍有不足。它认为Sort对话框是按照一种特定的方式来实现的，也就是像上面那样来处理组合框和"None"项。这就意味着，如果重新设计了Sort对话框，也许就需要重新编写这些代码。如果对话框只会从一个地方调用，那么这样的方式应该是足够了，但是如果对话框可能会在几个地方调用到，那么这种处理方式就等于打开了维护工作的梦魇之门。

一种更为稳健的方法是让SortDialog类具有自适应性，这可以通过让它自己创建一个SpreadsheetCompare对象，然后使这个对象只能被它的调用者使用来做到这一点。这样就可以有效地简化MainWindow::sort()函数：
\begin{Verbatim}
void MainWindow::sort()
{
    SortDialog dialog(this);
    QTableWidgetSelectionRange range = spreadsheet->selectedRange();
    dialog.setColumnRange('A' + range.leftColumn(),
                'A' + range.rightColumn());
    if (dialog.exec())
        spreadsheet->performSort(dialog.comparisonObject());
}
\end{Verbatim}


这种方法可产生松散的耦合组件，并且当从多个地方调用该对话框对，它几乎总可以做出正确的选择。

一种更为极端的方式是在初始化SortDialog对象的时候就为其传递一个指向Spreadsheet对象的指针，并且允许对话框直接对Spreadsheet进行操作。这样做会使SortDialog少一些通用性，因为它仅能适用于一种类型的窗口部件，但是通过去除SortDialog::setColumnRange()函数，它的确是进一步简化了程序代码。于是，现在的MainWindow::sort()函数将变成如下所示的样子：
\begin{Verbatim}
void MainWindow::sort()
{
    SortDialog dialog(this);
    dialog.setSpreadsheet(spreadsheet);
    dialog.exec();
}
\end{Verbatim}

相比而言，第一种方法中调用者需要知道与这个对话框相关的暗示信息，而第二种方法中的对话框需要知道由调用者所提供的与数据结构相关的暗示信息。在对话框需要作用于现场变化的地方，这种方法显得更为有用些。但是就像第一种方法中调用者的代码功能不足一样，如果数据结构发生了变化，则第三种方法也会失效。

一些开发者只会选用一种对话框处理方法并对其持之以恒。这有一个好处，就是能够精通和简练处理方法，因为所有的对话框都使用的是同一种处理模式，但是这也会失去对调用对话框时没有用到的那些其他有益处理方法。理想情况下，应根据每一个对话框的自身来选择应当使用的对话框处理方法。

我们将用About对话框来圆满结束这一节。可以创建一个像Find或Go to Cell对话框那样的自定义对话框来显示应用程序的有关信息，但是因为绝大多数About对话框都具有较为固定的格式，所以Qt提供了一种更为简单的解决方案。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{131}{140}
\end{cppline}

通过调用一个方便的静态函数QMessageBox::about()，就可以获得About对话框。这个函数和QMessageBox::warning()的形式非常相似，只是它使用了父窗口的图标，而不是标准的“警告”图标。这个对话框的最终结果显示在图3.15中。

\begin{linefig}[0.8]{spreadsheet3-15.png}
\caption{Spreadsheet的About对话框}
\label{fig:spreadsheet3-15.png}
\end{linefig}

到现在为止，已经使用了由QMessageBox和QFileDialog提供的多个方便的静态函数。这些函数可以创建一个对话框，初始化它，并且可以对它调用exec()。当然，也可以像创建其他任意窗口部件一样创建QMessageBox或者QFileDialog窗口部件，然后再明确地对它调用exec()，或者甚至是show()，尽管这样的处理方式会显得有些不大方便。

\section{存储设置}
在MainWindow的构造函数中，调用了readSettings()来载入应用程序存储的那些设置。与之相似的是，在closeEvent()中，调用writeSettings()来保存这些设置。这两个函数是最后两个需要实现的MainWindow成员函数。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{406}{414}
\end{cppline}

writeSettings()函数保存了主窗口的几何形状（位置和尺寸大小）、最近打开文件列表以及ShowGrid和Auto-Recalculate选项的设置值。

默认情况下，QSettings会存储应用程序中与特定平台相关的一些设置信息。在Windows系统中，它使用的是系统注册表；在UNIX系统中，它会把设置信息存储在文本文件中；在Mac OS X中，它会使用Core Foundation Preferences的应用程序编程接口。

构造函数的参数说明了组织的名字和应用程序的名字。采用与平台相关的方式，可以利用这一信息查找这些设置所在的位置。

QSettings把设置信息存储为键值对(key-value pair)的形式。键(key)与文件系统的路径很相似。可以使用路径形式的语法（例如，findDialog/matchCase）来指定子键(subkey)的值，或者也可以使用beginGroup()和endGroup()的形式： 
\begin{Verbatim}
settings.beginGroup("findDialog");
settings.setValue("matchCase", caseCheckBox->isChecked());
settings.setValue("searchBackward", backwardCheckBox->isChecked());
settings.endGroup();
\end{Verbatim}
  
值(value)可以是一个int、bool、double、QString、QStringList或者是QVariant所支持的其他任意类型，包括那些已经注册过的自定义类型。

\begin{cppline}{qt4-book/chap03/spreadsheet/mainwindow.cpp}{390}{404}
\end{cppline}

readSettings()函数可以载入之前使用writeSettings()函数所保存的那些设置。value()函数中的第二个参数可以在没有可用设置的情况下指定所需的默认值。在应用程序第一次运行时，使用的就是这些默认值。由于没有为形状或者最近打开文件列表指定第二个参数，所以在第一次运行时，窗口会使用任意但是却合理的大小和位置，而最近文件列表会是一个空表。

在readSettings()和writeSettings()中使用与QSettings相关的全部代码为MainWindow所选择的布置方案，都只是许多可用方案中的一种而已。可以在应用程序执行期间的任何时候和程序代码中的任何地方，随时随地创建一个QSettings对象，用它查询或者修改一些设置。

现在已经完成了对Spreadsheet的MainWindow的实现。在后续的几节中，将会讨论如何修改Spreadsheet应用程序来让它可以处理多文档以及如何实现一个程序启动画面(splash screen)。将会在下一章中完成它的功能，包括公式和排序的处理。


\section{多文档}
现在，已经为编写Spreadsheet应用程序的main()函数的代码做好了准备：

\begin{cppinput}{qt4-book/chap03/spreadsheet/main.cpp}
\end{cppinput}


这个main()函数和以前曾经写过的那些函数稍微有点不同：以变量的形式在堆栈里创建MainWindow实例，而不是使用new来创建它。当函数结束时，MainWindow实例会自动销毁。

就像上面main()函数所显示的那样，Spreadsheet应用程序只提供了一个单一主窗口，并且在同一时间只能处理一个文档。如果想让它在同一时间具有处理多个文档的能力，就需要同时启动多个Spreadsheet应用程序实例。但是这对于用户来讲是很不方便的，用户需要的是一个可以处理多个文档的单一应用程序实例，就像在一个网页浏览器实例中可以同时提供多个浏览器窗口一样。

下面将修改Spreadsheet应用程序，以使它可以处理多个文档。首先，需要对File菜单做一些简单改动：
\begin{itemize}
\item 利用File→New创建一个空文档主窗口，而不是再次使用已经存在的主窗口。
\item 利用File→Close关闭当前主窗口。
\item 利用File→Exit关闭所有窗口。
\end{itemize}

在File菜单的最初版本中，并没有close选项，这只是因为当时它还和Exit一样具有相同的功能。新的File菜单如图3.16所示。
\begin{fig}{spreadsheet3-16.png}
\caption{新的File菜单}
\label{fig:spreadsheet3-16.png}
\end{fig}

新的main()函数为：
\begin{Verbatim}
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    MainWindow *mainWin = new MainWindow;
    mainWin->show();
    return app.exec();
}
\end{Verbatim}


具有多窗口功能后，现在就需要使用菜单中的new来创建MainWindow。考虑到节省内存，可以在工作完成之后使用delete操作删除主窗口。

这是新的MainWindow::newFile()槽：
\begin{Verbatim}
void MainWindow::newFile()
{
    MainWindow *mainWin = new MainWindow;
    mainWin->show();
}
\end{Verbatim}

我们只创建了一个新的MainWindow实例。这看起来有些奇怪；因为没有保留指向这个新窗口的任何指针，但实际上这并不是什么问题，因为Qt会对所有的窗口进行跟踪。

以下是用于Close和Exit的动作：
void MainWindow::createActions()
\begin{Verbatim}
{
    ...
    closeAction = new QAction(tr("&Close"), this);
    closeAction->setShortcut(QKeySequence::Close);
    closeAction->setStatusTip(tr("Close this window"));
    connect(closeAction, SIGNAL(triggered()), this, SLOT(close()));
    exitAction = new QAction(tr("E&xit"), this);
    exitAction->setShortcut(tr("Ctrl+Q"));
    exitAction->setStatusTip(tr("Exit the application"));
    connect(exitAction, SIGNAL(triggered()),
        qApp, SLOT(closeAllWindows()));
    ...
}
\end{Verbatim}

槽QApplication::closeAllWindows()会关闭所有应用程序的窗口，除非其中一个应用程序拒绝了这个关闭事件。这正是在此所需的行为。我们不用再考虑那些有关是否保存的事情，因为就算关闭一个窗口，都会在MainWindow::closeEvent()中处理这些情况。

看起来好像已经完成了应用程序对多窗口处理能力的工作。遗憾的是，这里还隐藏着一个潜在的问题：如果用户一直创建并且关闭主窗口，那么这台机器早晚会耗尽它的全部内存。这是因为我们保存了newFile()中创建的MainWindow窗口部件，但是从没有删除它们。当用户关闭一个主窗口时，默认行为是隐藏它，所以它还会保留在内存中。对于如此多的主窗口，的确会造成一定的问题。

解决办法是在构造函数中对Qt::WA\_{}DeleteOnClose的属性进行设置：
\begin{Verbatim}
MainWindow::MainWindow()
{
    ...
    setAttribute(Qt::WA_DeleteOnClose);
    ...
}
\end{Verbatim}

这样做就会告诉Qt在关闭窗口时将其删除。Qt::WA\_{}DeleteOnClose属性是可以在QWidget上进行设置并用来影响这个窗口部件的行为的诸多标记之一。

内存泄漏并不是必须处理的唯一问题。最初的应用程序设计包含了一个隐含的假设，也就是它仅有一个主窗口。对于多窗口，每一个主窗口都有它自己的最近打开文件列表和它自己的一些选项。很明显，最近打开文件列表对于整个应用程序来说应该是全局的。通过把recentFiles变量声明为静态变量，可以相当容易地解决这个问题，这样对于整个应用程序来说，会只存在一个该列表的实例。但随后必须确保的是：无论何时调用updateRecentFileActions()函数来更新File菜单，都必须是在所有的主窗口上调用它。这是实现这一做法的代码：
\begin{Verbatim}
foreach (QWidget *win, QApplication::topLevelWidgets()) {
    if (MainWindow *mainWin = qobject_cast<MainWindow *>(win))
        mainWin->updateRecentFileActions();
}
\end{Verbatim}

这段代码使用了Qt的foreach结构体（将在第11章中对其进行说明）来遍历这个应用程序的所有窗口，并且对所有类型为Mainwindow的窗口部件调用updateRecentFileActions()。可以使用类似的代码来同步Show Grid和Auto-Recalculate选项，或者用于确保同一个文件不会被加载两次。

在每一个主窗口中只提供一个文档的应用程序称为单文档界面(single document interface，SDI)应用程序。在Windows系统下，一种常用的替代方法是多文档界面(multiple document inteface , MDI)，这种应用程序只有一个单一的主窗口，但可以对主窗口中央区域的多个文档窗口进行管理。Qt可以在它支持的所有平台上创建SDI和MDI应用程序。图3.17给出了使用这两种方法的Spreadsheet应用程序。第6章将对MDI进行说明。

\begin{linefig}[0.8]{spreadsheet3-17.png}
\caption{单文档界面和多文档界面}
\label{fig:spreadsheet3-17.png}
\end{linefig}

\section{程序启动画面}
许多应用程序都会在启动的时候显示一个程序启动画面(splash screen)，图3.18给出的就是这样的一个实例。一些程序员使用程序启动画面对缓慢的启动过程进行掩饰，而另外一些人则是用于满足市场部门的要求。使用QSplashScreen类，可以非常容易地为Qt应用程序添加一个程序启动画面。

\begin{linefig}{spreadsheet3-18.png}
\caption{程序启动画面}
\label{fig:spreadsheet3-18.png}
\end{linefig}    

类QSplashScreen会在应用程序的主窗口出现之前显示一个图片。它也可以在这个图片上显示一些消息，用来通知用户有关应用程序初始化的过程。通常，程序启动画面的代码会放在main()函数中，位于QApplication::exec()调用之前。

下面给出了一个main()函数的例子，在应用程序中，它使用QSplashScreen显示的程序启动画面表示启动时载入的一些模块和网络连接的建立。


\begin{Verbatim}
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    QSplashScreen *splash = new QSplashScreen;
    splash->setPixmap(QPixmap(":/images/splash.png"));
    splash->show();
    Qt::Alignment topRight = Qt::AlignRight | Qt::AlignTop;
    splash->showMessage(QObject::tr("Setting up the main window..."),
                topRight, Qt::white);
    MainWindow mainWin;
    splash->showMessage(QObject::tr("Loading modules..."),
                topRight, Qt::white);
    loadModules();
    splash->showMessage(QObject::tr("Establishing connections..."),
                topRight, Qt::white);
    establishConnections();
    mainWin.show();
    splash->finish(&mainWin);
    delete splash;
    return app.exec();
}
\end{Verbatim}

到此为止，我们已经创建了Spreadsheet应用程序的用户界面。在下一章中，将会通过实现电子制表软件的核心功能来完成这个应用程序。


\chapter{实现应用程序的功能}
前两章说明了如何创建Spreadsheet应用程序的用户界面。在这一章中，将通过编写它的底层功能函数来完成这个程序。此外，还将看到如何载人和保存文件，如何内存中存储数据，如何实现剪贴板操作，以及如何向QTableWidget中添加对电子制表软件公式的支持等功能。

\section{中央窗口部件}
QMainWindow的中央区域可以被任意种类的窗口部件所占用。下面给出的是对所有可能情形的概述。
\begin{enumerate}
\item \textbf{使用一个标准的Qt窗口部件}

像QTableWidget或者QTextEdit这样的标准窗口部件可以用作中央窗口部件。在这种情况下，这个应用程序的功能，如文件的载入和保存，必须在其他地方实现（例如，在QMainWindow的子类中）

\item \textbf{使用一个自定义窗口部件}

特殊的应用程序通常需要在自定义窗口部件中显示数据。例如，一个图标编辑器程序就应当使用一个IconEditor窗口部件作为自己的中央窗口部件。第5章将会说明如何在Qt中编写自定义窗口部件。

\item \textbf{使用一个带布局管理器的普通QWidget}

有时，应用程序的中央区域会被许多窗口部件所占用。这时可以通过使用一个作为所有这些其他窗口部件父对象的QWidget，以及通过使用布局管理器管理这些子窗口部件的大小和位置来完成这一特殊情况。

\item \textbf{使用切分窗口(splitter)}

多个窗口部件一起使用的另一种方法是使用QSplitter。QSplitter会在水平方向或者竖直方向上排列它的子窗口部件，用户可以利用切分条(splitter handle)控制它们的尺寸大小。切分窗口可以包含所有类型的窗口部件，包括其他切分窗口。

\item \textbf{使用多文档界面工作空间}

如果应用程序使用的是多文档界面，那么它的中央区域就会被QMdiArea窗口部件所占据，并且每个多文档界面窗口都是它的一个子窗口部件。
\end{enumerate}

布局、切分窗口和多文档界面工作空间都可以与标准的Qt窗口部件或者自定义窗口部件组合使用。第6章将会进一步深入地讲解这些类。

对于Spreadsheet应用程序，会使用一个QTableWidget子类作为它的中央窗口部件。类QTableWidget已经提供了我们所需要的绝大多数电子制表软件的功能，但是它还不支持剪贴板操作，并且也不能理解诸如"=A1+A2+A3"这样的电子制表软件公式的意义。我们将会在Spreadsheet类中实现这些缺少的功能。

\section{子类化QTableWidget}
类Spreadsheet派生自QTableWidget，如图4.1所示。
\begin{linefig}[0.5]{spreadsheet4-1.png}
\caption{类Spreadsheet和Cell的继承树}
\label{fig:spreadsheet4-1.png}
\end{linefig}

QTableWidget是一组格子，可以非常有效地用来表达二维稀疏数组。它可以在规定的维数内显示用户滚动到的任一单元格。当用户在一个空单元格内输入一些文本的时候，QTableWidget会自动创建一个用来存储这些文本的QTableWidgetItem。

QTableWidget派生自QTableView，它是模型/视图类之一，我们将在第10章进一步了解它。对于另外一个表QicsTable，它有更多的非常规功能，可以从http://www.ics.com/中获取。

让我们一起来实现Spreadsheet，首先从它的头文件开始：
\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{1}{7}
\end{cppline}

头文件是从Cell和SpreadsheetCompare类的前置声明开始的。

QTableWidget单元格的属性，比如它的文本和对齐方式等，都存储在QTable-WidgeItem中。与QTableWidget不同的是，QTableWidgetItem不是一个窗口部件类，而是一个纯粹的数据类。Cell类派生自QTableWidgetItem，会在本章的最后一节对这个Cell类进行解释。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{9}{23}
\end{cppline}

之所以把autoRecalculate()函数实现为内联函数，是因为无论自动重新计算的标识符生效与否，它都必须要有返回值。

在第3章中，当实现MainWindow时，我们依赖于Spreadsheet中的一些公有函数。例如，我们从MainWindow::newFile()中调用clear()来重置电子制表软件。也使用了一些从QTableWidget中继承而来的函数，特别是setCurrentCell()和setShowGrid()。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{25}{38}
\end{cppline}

Spreadsheet提供了许多实现Edit、Tools和Options菜单中的动作的槽：并且它也提供了一个modified()信号，用来告知用户，可能已经发生的任何变化。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{40}{41}
\end{cppline}

还定义了一个由Spreadsheet类内部使用的私有槽： 

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{43}{52}
\end{cppline}

在这个类的私有段中，声明了3个常量、4个函数和1个变量。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{54}{0}
\end{cppline}

在这个头文件的最后，给出了SpreadsheetCompare类的定义。当查看Spreadsheet::sort()时，会解释这个类。

现在来看一下它的实现文件：

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{1}{18}
\end{cppline}

通常情况下，当用户在一个空单元格中输入一些文本的时候，QTableWidget将会自动创建一个QTableWidgetItem来保存这些文本。在电子制表软件中，我们想利用将要创建的Cell项来代替QTableWidgetItem。这可以通过在构造函数中调用setItemPrototype()来完成。实际上，QTableWidget会在每次需要新项的时候把所传递的项以原型的形式克隆出来。

同样是在构造函数中，我们将选择模式设置为QAbstractItemView::Contiguo\\ usSelection，从而可以允许简单矩形选择框方法。我们把表格窗口部件的itemChanged()信号连接到私有槽somethingChanged()上，这可以确保在用户编辑一个单元格的时候，somethingChanged()槽可以得到调用。最后，调用clear()来重新调整表格的尺寸大小并且设置列标题。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{39}{53}
\end{cppline}

clear()函数是从Spreadsheet构造函数中得到调用的，用来初始化电子制表软件。它也会在MainWindow::newFile()中得到调用。
 
我们原本使用QTableWidget::clear()来清空所有项和任意选择，但是那样做的话，这些标题将会以当前大小的尺寸而被留下。相反的是，我们要把表格向下调整为$ 0\times 0 $。这样就可以完全清空整个表格，包括这些标题。然后，重新调整表的大小为ColumnCount × RowCount(26 × 999)，并且把QTableWidgetItem水平方向上的标题修改为列名"A"，"B"，$ \cdots $，"Z"。不需要设置垂直标题的标签，因为这些标签的默认值是"1"，"2"，$ \cdots $，"999"。最后，把单元格光标移动到单元格A1处。

QTableWidget由多个子窗口部件构成。在它的顶部有一个水平的QHeaderView，左侧有一个垂直的QHeaderView，还有两个QScrollBar。在它的中间区域被一个名为视口(viewport)的特殊窗口部件所占用，QTableWidget可以在它上面绘制单元格。通过从QTableView和QAbstractScrollArea中继承的一些函数，可以访问这些不同的子窗口部件（参见图4.2）。QAbstractScrollArea提供了一个可以滚动的视口和两个可以打开或关闭的滚动条。第6章将讲述QScrollArea子类。

\begin{linefig}[0.7]{spreadsheet4-2.png}
\caption{构成QTableWidget的各个窗口部件}
\label{fig:spreadsheet4-2.png}
\end{linefig}

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{286}{289}
\end{cppline}

cell()私有函数可以根据给定的行和列返回一个Cell对象。它几乎和QTableWi-dget::item()函数的作用一样，只不过它返回的是一个Cell指针，而不是一个QTableWidgetItem指针。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{312}{320}
\end{cppline}

text()私有函数可以返回给定单元格中的文本。如果cell()返回的是一个空指针，则表示该单元格是空的，因而返回一个空字符串。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{302}{310}
\end{cppline}

formula()函数返回给定单元格中的公式。在很多情况下，公式和文本是相同的。例如，公式"Hello"等价于字符串"Hello"，所以如果用户在单元格中输入"Hello"并且按下回车键，那么该单元格就会显示文本"Hello"。但是还有一些例外的情况：
\begin{itemize}
\item 如果公式是一个数字，那么它就会被认为是一个数字。例如，公式"1.50"等价于双精度实数(double)的1.5，它在电子制表软件中会被显示为右对齐的"1.5"。
\item 如果公式以单引号开始，那么公式的剩余部分将会被认为是文本。例如，公式"'12345"等价于字符串"12345"。
\item 如果公式以等号开始，那么公式将会被认为是一个算术公式。例如，如果单元格A1包含"12"并且单元格A2包含"6"，那么公式"= A1+A2"就会等于18。
\end{itemize}

把公式转换成值的任务是由Cell类完成的。这时，要记住的事情是显示在单元格内的文本是公式的结果，而不是公式本身。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{291}{300}
\end{cppline}

setFormula()私有函数可以设置用于给定单元格的公式。如果该单元格已经有一个Cell对象，那么我们就重新使用它。否则，可以创建一个新的Cell对象并且调用QTableWidget::setItem()把它插入到表中。最后，调用该单元格自己的setFormula()函数，但如果这个单元格已经显示在屏幕上，那么就重新绘制它。我们不需要担心随后对这个Cell对象的删除操作。因为QTableWidget会得到这个单元格的所有权，并且会在正确的时候自动将其删除。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{20}{24}
\end{cppline}

currentLocation()函数返回当前单元格的位置，它是按照电子制表软件的通常格式，也就是一个列字母后跟上行号的形式来表示这个位置的值。MainWindow::updateStatusBar()使用它把这个单元格的位置显示在状态栏上。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{26}{29}
\end{cppline}

currentFormula()函数返回当前单元格的公式。它是从MainWindow::upda-teStatusBar()中得到调用的。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{279}{284}
\end{cppline}

如果启用了"auto-recalculate"（自动重新计算），那么somethingChanged-()私有槽就会重新计算整个电子制表软件。它也会发射modified()信号。

\begin{framed}
\vspace{-\parskip}
\begin{center}
\textbf{把数据存储为项}
\end{center}

在Spreadsheet应用程序中，每一个非空单元格都被当作一个独立的QTableWidgetItem对象而保存在内存中。把数据存储为项(item)是一种对QListWidgetItem和QTreeWidgetItem进行操作的方法，该方法也可用于QListWidget和QTreeWidget。

Qt的项类可以用作非常规的数据持有者。例如，一个QTableWidgetItem已经存储了一些属性，其中包括一个字符串、一种字体、一种颜色和一个图标，以及一个返回到QTableWidget的指针。项也可以保存数据（QVariant型），包括一些已经注册过的自定义类型，以及通过项类的子类化，我们还可以提供其他功能。

许多老一点的工具包在它们的项类中提供一个void指针来存储自定义数据。在Qt中，更为自然的方法是使用带QVariant的setData()，但如果需要一个void指针，那么可以通过子类化一个项类并且添加一个void指针成员变量来很简单地实现这一点。

对于更具有挑战性的数据处理需求，比如大数据集、复杂数据项、数据库集成以及多数据视图等，Qt提供了一套模型/视图(model/view)类，利用这些类可以把数据从它们的直观表示中分离出来。这些内容将会在第10章中加以讲述。
\end{framed}


\section{载入和保存}
现在，我们将使用一种自定义的二进制数格式来实现Spreadsheet文件的载入和保存。将使用QFile和QDataStream来完成这一工作，由它们共同提供与平台无关的二进制数输入/输出接口。

首先从一个Spreadsheet文件的输出开始：

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{92}{118}
\end{cppline}

从MainWindow::saveFile()中调用的writeFile()函数把文件输出到磁盘中。如果输出成功，它会返回true；如果出现错误，则返回false。

我们使用给定的文件名创建一个QFile对象，并且调用open()打开这个用于输出的文件。我们也会创建一个QDataStream对象，由它操作这个QFile对象并且使用该对象输出数据。

在输出数据之前，我们把这个应用程序的光标修改为标准的等待光标（通常是一个沙漏），并且一旦所有的数据输出完毕，就需要把这个应用程序的光标重新恢复为普通光标。在函数的最后，文件会由QFile对象的析构函数自动关闭。 

QDataStream既可以支持C++基本类型，也可以支持多种Qt类型。该语法模仿了标准C++的<iostream>中的那些类的语法。例如：
\begin{Verbatim}
out << x << y << z;
\end{Verbatim}
会把变量x、y和z输出到一个流中，而：
\begin{Verbatim}
in >> x >> y >> z;
\end{Verbatim}
会从流中读出它们。因为C++的基本类型在不同平台上可能会有不同的大小，所以把这些变量强制转换成qint8、quint8、qint16、quint16、qint32、quint32、qint64以及quint64中的一个是最安全的做法，这样做可以确保它们能够获得应有的大小（按位计算）。 

Spreadsheet应用程序的文件格式是相当简单的。一个Spreadsheet文件以一个32位数字作为文件的开始，由它确定文件的格式（MagicNumber，在spreadsheet.h中定义为Ox7F51C883，它是一个任意的随机数）。然后是连续的数据块，每一数据块都包含了用于一个单元格中的行、列和公式。为了节省空间，我们没有输出空白单元格。该文件格式如图4.3所示。 
\begin{fig}[0.8]{spreadsheet4-3.png}
\caption{Spreadsheet的文件格式}
\label{fig:spreadsheet4-3.png}
\end{fig}

关于这些数据类型的二进制数确切表示方法则是由QDataStream决定的。例如，一个quint16按照高字节在后的顺序存储为两个字节，而一个QString则被存储为字符串的长度后跟Unicode字符的形式。

关于Qt数据类型的二进制数确切表示方法，自Qt1.0以来已经发生了许多变化。而且在未来的Qt发行版中，为了能够与现存的数据类型和将来允许出现的新的Qt类型保持一致，这样的表示方法还可能会继续变化下去。默认情况下，QDataStream会使用最近版本的二进制数格式（在Qt 4.3中的版本是第9版），但是可以设置它，使它可以读取那些旧的数据版本。如果以后有可能使用新的Qt发行版来重新编译这个应用程序，那么为了避免出现任何可能的兼容性问题，需要明确告诉QDataStream应该使用的是第9版，从而无需再考虑要使用的Qt版本。（QDataStream::Qt\_{}4\_{}3是一个方便的常量，它就等于9。）

QDataStream的功能非常齐全。既可以把它用于QFile中，也可以把它用于QBuffer、QProcess、QTcpSocket、QUdpSocket或者QSslSocket中。在读取和输出文本文件时，Qt也提供了一个QTextStream类，可以使用它代替QDataStream类。第12章将深入地讲解这些类，并且也会讲述处理不同
的QDataStream版本时所使用的各种方法。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{55}{90}
\end{cppline}

readFile()函数与writeFile()函数非常相似。我们使用QFile读取一个文件，但这一次使用的是QIODevice::ReadOnly标记，而不是QIODevice::WriteOnly标记。然后，把QDataStream的版本设置为
9。用于读取文件的格式必须总是与输出文件的格式相同。

如果该文件在开始处具有正确的幻数(magic number)，那么可以调用clear()来清空电子制表软件中的所有单元格，并且读入单元格中的数据。由于该文件中只包含那些非空单元格的数据，并且也不大可能重置电子制表软件中的每个单元格，所以必须确保在读入数据之前已经清空了所有的单元格。


\section{实现Edit菜单}
现在，我们已经为实现响应应用程序Edit菜单中的各个槽做好了准备。Spreadsheet应用程序中的Edit菜单如图4.4所示。    
\begin{fig}[0.8]{spreadsheet4-4.png}
\caption{Spreadsheet应用程序的Edit菜单}
\label{fig:spreadsheet4-4.png}
\end{fig}

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{146}{150}
\end{cppline}

cut()槽可以对Edit→Cut菜单做出响应。由于Cut的执行效果与Copy之后再加上一个Delete的执行效果相同，所以其实现代码很简单。 

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{152}{167}
\end{cppline}

copy()槽能够对Edit→copy做出响应。它会遍历当前选择（如果没有明确的选择，那么就认为选择的只是当前单元格）。每一个选中单元格的公式都会被添加到一个QString中，行与行之间利用换行符\verb+\n+分隔，列与列之间则以制表符\verb+\t+来分隔。图4.5给出了这一实现方法的示意图。

\begin{fig}[0.8]{spreadsheet4-5.png}
\caption{把选择复制到剪贴板中}
\label{fig:spreadsheet4-5.png}
\end{fig}

在Qt中，通过调用QApplication::clipboard()静态函数可以使用系统的剪贴板。通过调用QClipboard::setText()，就既可以在本应用程序中又可以在其他应用程序中使用放在剪贴板上的这些文本。这种使用制表符\verb+\t+和换行符\verb+\n+作为文件分隔符的形式可以被包括微软Excel在内的许多应用程序所支持。  

函数QTableWidget::selectedRanges()返回一个选择范围列表。我们知道，由于在构造函数中已经将选择模式设置为QAbstractItemView::ContiguousSelec-tion，所以选择范围不可能再超过一。为方便起见，我们定义了一个selectedRange()函数来返回这个选择范围。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{31}{37}
\end{cppline}

如果只有一个选择，则只需简单地返回第一个（并且也只有这一个）选择即可。没有选择的情况应该永远不会发生，因为ContiguousSelection模式至少可以把当前单元格当作是已经选中的选择。但是，为了避免使程序出现缺陷的可能性，还是需要对这种当前没有选中单元格的情况进行单独处理。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{169}{196}
\end{cppline}

paste()槽对Edit→Paste菜单选项做出响应。我们从剪贴板中取回文本，并且调用静态函数QString::split()把这串字符变成一个QStringList。每行都会变成这个列表中的一个字符串。

接下来，需要求出复制区域的维数。行数就是QStringList中字符串的个数，列数就是第一行中制表符\verb+\t+字符的个数再加上1。如果只选中了一个单元格，就把这个单元格作为粘贴区域放在左上角；否则，就把当前选择作为要粘贴的区域。

为了执行粘贴操作，我们遍历所有行并且再次使用QString::split()把它们分隔到每一个单元格中，但是这一次要把制表符\verb+\t+当作分隔符。图4.6给出了这一过程中所使用的步骤。
\begin{fig}[0.8]{spreadsheet4-6.png}
\caption{把剪贴板中的文本粘贴到电子制表软件中}
\label{fig:spreadsheet4-6.png}
\end{fig}

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{198}{206}
\end{cppline}

del()槽对Edit→Delete菜单选项做出响应。如果有选中的项，那么该函数就会删除它们并且调用somethingChanged()函数。对选择中的每一个Cell对象使用delete足以清空所有这些单元格。当删除QTableWidget的QTableWidgetItem的时候，QTableWidget就会注意到这一情况的发生，而如果这些项中有可见的任意项，QTableWidget将会自动对自己进行重绘。如果在一个已经删除过的单元格位置上又调用了cell()，那么该函数将会返回一个空指针。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{208}{216}
\end{cppline}

selectCurrentRow()和selectCurrentColumn()对Edit→Select→Row和Edit→Select→Column菜单选项做出响应。这些实现分别依赖于QTableWidget的selectRow()和selectColumn()函数。我们不必再去实现Edit→Select→All菜单选项的功能，因为该功能可以由QTableWidget从QAbstractItemView::selectAll\\()的函数中继承过来。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{236}{255}
\end{cppline}

findNext()槽会遍历单元格一遍，它从当前光标右侧的单元格开始遍历到这一行的最后一列，然后再从下一行的第一个单元格开始继续遍历，如此反复，直到找到所要查找的文本，或者是直到最后一个单元格为止。例如，如果当前的单元格是C24，那么就会搜索D24、E24、$ \cdots $、Z24，然后再去搜索A25、B25、C25、$ \cdots $、Z25，等等，一直遍历到Z999为止。如果找到了一个匹配项，那么就清空当前选择，把单元格光标移动到那个匹配的单元格上，并且让包含Spreadsheet的窗口变成激活状态。如果没能找到匹配的单元格，那么就让应用程序发出“哔”(beep)的一声来表明搜索已经结束，匹配没有成功。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{257}{277}
\end{cppline}

findPrevious()槽与findNext()槽相似，区别之处是它会向相反的方向遍历并且会在单元格A1处停下来。


\section{实现其他菜单}
现在，我们将要实现那些对Tools和Options菜单做出响应的槽。这些菜单项如图4.7所示。
\begin{fig}{spreadsheet4-7.png}
\caption{Spreadsheet应用程序的Tools和Options菜单}
\label{fig:spreadsheet4-7.png}
\end{fig}

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{218}{227}
\end{cppline}

recalculate()槽能够对Tools→Recalculate莱单选项做出响应。当必要时，它也会被Spreadsheet自动调用。  

我们遍历每一个单元格，并且对每一个单元格调用setDirty()把它们标记为需要重新计算。为了在电子制表软件中显示一个Cell对象的值，QTableWidget会再次对该对象调用text()以获得其值，从而使该值重新计算一次。

然后，对这个视口调用update()来重新绘制整个电子制表软件。QTableWidget中的重绘代码就又会对每一个可见单元格调用text()来获得它们中要显示的值。因为在每一个单元格上都调用了setDirty()，所以这些对text()的调用将会使用重新计算过的值。该计算可能需要重新计算那些不可见的单元格，这就会造成一个级联计算，直到每一个需要被重新计算的单元格能够在刚才刷新过的视口中重新得到计算，从而使它们也能够显示正确的文本。这一计算是由Cell类执行的。

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{229}{234}
\end{cppline}

setAutoRecalculate()槽对Options→Auto-Recalculate菜单选项做出响应。如果启用了这个特性，则会立即重新计算整个电子制表软件以确保它是最新的，然后，recalculate()会自动在somethingChanged()中得到调用。

因为QTableWidget已经提供了一个从QTableView中继承而来的setShowCrid()槽，所以不需要再对Options→Show Grid菜单选项编写任何代码。所有要保留的东西就是Spreadsheet::sort()，它会在MainWindow::sort()中得到调用：

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.cpp}{120}{144}
\end{cppline}
 
排序操作会对当前的选择进行，并且会根据存储在compare对象中的排序键和排序顺序重新排列这些行。我们使用一个QStringList来重新表示每一行数据，并且把该选择存储在一个行列表中。我们使用Qt的qStableSort()算法，并且根据公式而不是根据值来进行简单排序。这一过程如图4.8和图4.9所示。第11章中会讲述Qt的标准算法和数据结构。

\begin{linefig}[0.8]{spreadsheet4-8.png}
\caption{把选择存储为一个行列表}
\label{fig:spreadsheet4-8.png}
\end{linefig}

\begin{linefig}[0.8]{spreadsheet4-9.png}
\caption{排序后把数据放回表中}
\label{fig:spreadsheet4-9.png}
\end{linefig}


qStableSort()函数可以接受一个开始迭代器、一个终止迭代器和一个比较函数。这个比较函数是一个带两个参数（两个QStringList）的函数，并且如果第一个参数“小于”第二个参数，它就返回true，否则返回false。传递的作为比较函数的这个compare对象并不是一个真正的函数，但是它可以用作一个函数，将会很快看到这一点。

在执行完qStableSort()之后，我们把数据移回到这个表中，接着清空这一选择，并且调用。somethingChanged()函数。

在spreadsheet.h文件中，Spreadsheet类的定义如下：

\begin{cppline}{qt4-book/chap04/spreadsheet/spreadsheet.h}{54}{63}
\end{cppline}

SpreadsheetCompare类有些特殊，因为它实现了一个“()”操作符。这样就允许把这个类像函数一样使用。把这样的类称为函数对象(function object)，或者称为仿函数(functor)。为了理解仿函数是如何工作的，首先从一个简单的例子开始：

\begin{Verbatim}
class Square
{
public:
    int operator()(int x) const { return x * x; }
}
\end{Verbatim}

Square类提供了一个函数，operator()(int)函数，它返回其参数的平方值。通过把这个函数命名为operator()(int)，而不是将其命名为compute(int)之类的函数，就可以把一个类型为Square的对象当作一个函数。

\begin{Verbatim}
Square square;
int y = square(5);
// y equals 25
\end{Verbatim}

现在，让我们来看一个包括SpreadsheetCompare的实例：
\begin{Verbatim}
QStringList row1, row2;
SpreadsheetCompare compare;
...
if (compare(row1, row2)) {
    // row1 is less than row2
}
\end{Verbatim}

使用compare对象就像使用一个普通的compare()函数一样。另外，它的实现可以访问所有存储为成员变量的排序键和排序顺序。  

与此方案相同的另一种方法是，把这些排序键和排序顺序存储在全局成员变量中，并且使用一个普通的compare()函数。然而，在全局成员变量之间通信是一种并不提倡的做法，并且可能会产生一些莫名其妙的问题。作为像qStableSort()这样的模板函数的接口，仿函数是一种更为常用的做法。

这里给出的是对电子制表软件中的两个行进行比较的函数实现：
\begin{Verbatim}
bool SpreadsheetCompare::operator()(const QStringList &row1,
                const QStringList &row2) const
{
    for (int i = 0; i < KeyCount; ++i) {
        int column = keys[i];
        if (column != -1) {
            if (row1[column] != row2[column]) {
                if (ascending[i]) {
                    return row1[column] < row2[column];
                } else {
                    return row1[column] > row2[column];
                }
            }
        }
    }
    return false;
}
\end{Verbatim}

如果第1行小于第2行，该仿函数就返回true；否则，就返回false。qStableSort()函数会使用这个函数的结果来执行排序操作。

SpreadsheetCompare对象的key与ascending数组和MainWindow::sort\\()函数（已经在第2章中给出过）一起配合使用。每个键都保存一个列索引，或者-1（为"None"时）。

我们按键顺序比较两行中相应的单元格条目。一旦发现有不同之处，就返回一个适当的true或者false值。如果所有的比较关系都证明两者是相等的，就返回false。qStableSort()函数会使用这里给出的顺序来解决这种平局情形。如果一开始的时候row1在row2之前，并且它们都不“小于”对方，那么，在结果中row1还在row2前面。这就是qStableSort()与它很相似的非稳定版本的qSort()函数之间的区别。 

现在已经完成了这个Spreadsheet类。在下一节中，将分析Cell类的代码。这个类用作保存单元格的公式，并且它还重新实现了QTableWidgetItem::data()函数，Spreadsheet可以通过QTableWidgetItem::text()间接调用该函数，用它显示单元格公式的计算结果。

\section{子类化QTableWidgetItem}
Cell类派生自QTableWidgetItem类。这个类被设计用于和Spreadsheet一起工作，但是它对类QTableWidgetItem没有任何特殊的依赖关系，所以在理论上讲，它也可以用于任意的QTableWidget类中。这里给出的是Cell类的头文件：

\begin{cppinput}{qt4-book/chap04/spreadsheet/cell.h}
\end{cppinput}

通过增加两个私有变量，Cell类对QTableWidgetItem进行了扩展：
\begin{itemize}
\item cachedValue把单元格的值缓存为QVariant。
\item 如果缓存的值不是最新的，那么就把cacheIsDirty设置为true。
\end{itemize}
之所以使用QVariant，是因为有些单元格是double型值，另外一些单元格则是QString型值。

在声明cachedValue和cacheIsDirty变量时使用了C++的mutable关键字，这样就可以在const函数中修改这些变量。或者，在每次调用text()时，我们可以重新计算这个值，不过这样做是不必要而且效率低下的。

我们注意到，在该类的定义中并没有使用Q\_{}OBJECT宏。这是因为，Cell是一个普通的C++类，它没有任何信号或者槽。实际上，因为QTableWidgetItem不是从QObject派生而来的，所以就不能让Cell拥有信号和槽。为了使Qt的项(item)类的开销降到最低，它们就不是从QObject派生的。如果需要信号和槽，可以在包含项的窗口部件中实现它们，或者在特殊情况下，可以通过对QObject进行多重继承的方式来实现它们。 

以下是cell.cpp文件的开始部分：
\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{1}{8}
\end{cppline}

在构造函数中，只需要将缓存设置为dirty。没有必要传递父对象，当用setItem()把单元格插入到一个QTableWidget中的时候，QTableWidget将会自动对其拥有所有权。

每个QTableWidgetItem都可以保存一些数据，最多可以为每个数据“角色”分配一个QVariant变量。最常用的角色是Qt::EditRole和Qt::DisplayRole。编辑角色用在那些需要编辑的数据上，而显示角色用在那些需要显示的数据上。通常情况下，用于两者的数据是一样的，但在Cell类中，编辑角色对应于单元格的公式，而显示角色对应于单元格的值（对公式求值后的结果）。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{10}{13}
\end{cppline}

当QTableWidget需要创建一个新的单元格时，例如，当用户在一个以前没有使用过的空白单元格中开始输入数据时，它就会调用clone()函数。传递给QTableWidget::setItemPrototype()中的实例就是需要克隆的项。由于对于Cell来讲，成员级的复制已经足以满足需要，所以在clone()函数中，只需依靠由C++自动创建的默认复制构造函数就可以创建新的Cell实例了。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{41}{44}
\end{cppline}

setFormula()函数用来设置单元格中的公式。它只是一个对编辑角色调用setData()的简便函数。也可以从Spreadsheet::setFormula()中调用它。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{46}{49}
\end{cppline}

formula()函数会从Spreadsheet::formula\\()中得到调用。就像setFormula()一样，它也是一个简便函数，这次是重新获得该项的EditRole数据。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{15}{20}
\end{cppline}

如果有一个新的公式，就可以把cacheIsDirty设置为true，以确保在下一次调用text()的时候可以重新计算该单元格。

尽管对Cell实例中的Spreadsheet::text()调用了text()，但在Cell中没有定义text()函数。这个text()函数是一个由QTableWidgetItem提供的简便函数。这相当于调用data(Qt::DisplayRole).toString()。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{51}{54}
\end{cppline}

调用setDirty()函数可以用来对该单元格的值强制进行重新计算。它只是简单地把cacheIsDirty设置为true，也就意味着cachedValue不再是最新值了。除非有必要，否则不会执行这个重新计算操作。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{22}{39}
\end{cppline}

data()函数是从QTableWidgetItem中重新实现的。如果使用Qt::DisplayRo-le调用这个函数，那么它返回在电子制表软件中应该显示的文本；如果使用Qt::EditRole调用这个函数，那么它返回该单元格中的公式；如果使用Qt::TextAli-gnmentRole调用这个函数，那么它返回一个合适的对齐方式。在使用DisplayRole的情况下，它依靠value()来计算单元格的值。如果该值是无效的（由于这个公式是错误的），则返回"\verb+####+"。

在data()中使用的这个Cell::value()函数可以返回一个QVariant值。QVariant可以存储不同类型的值，比如double和QString，并且提供了把变量转换为其他类型变量的一些函数。例如，对一个保存了double值的变量调用toString()，可以产生一个表示这个double值的字符串。使用默认构造函数构造的QVariant是一个“无效”变量。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{56}{87}
\end{cppline}

value()私有函数返回这个单元格的值。如果cacheIsDirty是true，就需要重新计算这个值。

如果公式是由单引号开始的（例如，"'12345"），那么这个单引号就会占用位置0，而值就是从位置1直到最后位置的一个字符串。

如果公式是由等号开始的，那么会使用从位置1开始的字符串，并且将它可能包含的任意空格全部移除。然后，调用evalExpression()来计算这个表达式的值。这里的参数pos是通过引用(reference)方式传递的，由它来说明需要从哪里开始解析字符的位置。在调用evalExpression()之后，如果表达式解析成功，那么在位置pos处的字符应当是我们添加上的QChar::Null字符。如果在表达式结束之前解析失败了，那么可以把cachedValue设置为Invalid。

如果公式不是由单引号或者等号开始的，那么可以使用toDouble()试着把它转换为浮点数。如果转换正常，就把cachedValue设置为结果数字；否则，把cachedValue设置为字符串公式。例如，公式"1.50"会导致toDouble()把ok设置为true并且返回$ 1.5 $，而公式"World Population"则会导致toDouble()把ok设置为false并且返回$ 0.0 $。

通过给toDouble()一个bool指针，可以区分字符串转换中表示的是数字$ 0.0 $还是表示的是转换错误（此时，仍旧会返回一个$ 0.0 $，但是同时会把这个bool设置为false）。有时候，对于转换失败所返回的0值可能正是我们所需要的。在这种情况下，就没有必要再麻烦地传递一个bool指针了。考虑到程序的性能和移植性因素，Qt从来不使用C++异常(exception)机制来报告错误。但是，如果你的编译器支持C++异常，那么这也不会妨碍你在自己的Qt程序中使用它们。

value()函数声明为const函数。我们不得不把cachedValue和cacheIsValid声明为mutable变量，以便编译器可以让我们在const函数中修改它们。当然，如果能够把value()声明为一个非const函数并且移除mutable关键字可能会更吸引人些，但是这将会导致无法编译，因为是从一个const函数的data()函数中调用value()的。

除了要解析这些公式之外，现在已经完成了整个Spreadsheet应用程序。这一节的剩余部分将说明evalExpression()以及evalTerm()和evalFactor()这两个帮助函数。这些代码有一些复杂，但是把它们放在这里是为了能够让整个应用程序显得更完善些。由于这些代码和图形用户界面编程无关，所以你可以非常放心地略过这一部分，从第5章继续阅读下去。

evalExpression()函数返回一个电子制表软件表达式的值。表达式可以定义为：一个或者多个通过许多"+"或者"-"操作符分隔而成的项。这些项自身可以定义为：由"*"或者"/"操作符分隔而成的一个或者多个因子(factor)。通过把表达式分解成项，再把项分解成因子，就可以确保以正确的顺序来使用这些操作符了。

例如，"2*C5+D6"就是一个表达式，它由作为第一项的"2*G5"和作为第二项的"D6"构成。项"2*C5"是由作为第一个因子的"2"和作为第二个因子的"C5"组成的，而项"D6"则由一个单一的因子"D6"组成。一个因子可以是一个数("2")、一个单元格位置("C5")，或者是一个在圆括号内的表达式，在它们的前面可以有负号。

在图4.10中，定义了电子制表软件表达式的语法。对于语法（表达式、项和因子）中的每一个符号，都对应一个解析它的成员函数，并且函数的结构严格遵循语法。通过这种方式写出的解析器称为递归渐降解析器(recursive-descent parser)。

\begin{linefig}[0.8]{spreadsheet4-10.png}
\caption{用于电子制表软件表达式的语法图}
\label{fig:spreadsheet4-10.png}
\end{linefig}

让我们先从evalExpression()开始，这个函数可以解析一个表达式：

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{89}{111}
\end{cppline}

首先，调用evalTerm()得到第一项的值。如果它后面紧跟的字符是"+"或者"-"，那么就继续第二次调用evalTerm()；否则，表达式就只包含一个单一项，并且把它的值作为整个表达式的值而返回。在得到前两项的值之后，根据操作符计算出这一操作的结果。如果两项都求出一个double值，就把计算出的结果当作一个double值；否则，把结果设置为Invalid。

像前面那样继续操作，直到再没有更多的项为止。这样做可以正确地进行，因为加法和减法都是左相关(left-associative)的；也就是说，"1-2-3"的意思是"(1-2)-3"，而不是"1-(2-3)"。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{113}{139}
\end{cppline}

除了evalTerm()函数是处理乘法和除法这一点不同之外，它和evalExpression()都很相似。在evalTerm()中唯一的不同就是必须要避免除零，因为在一些处理器中这将是一个错误。尽管测试浮点数值是否相等通常并不明智，因为其中存在取舍问题，但是在这个防止除零的问题上，这样做相等性测试已经足够了。

\begin{cppline}{qt4-book/chap04/spreadsheet/cell.cpp}{141}{193}
\end{cppline}

evalFactor()函数比evalExpression()和evalTerm()函数都要复杂一些。它先从计算因子是否为负开始。然后，判断它是否是从左圆括号开始的。如果是，就先把圆括号内的内容作为表达式并通过调用evalExpression()来处理它。当解析到带圆括号的表达式时，evalExpression()调用evalTerm()，evalTerm()调用evalFactor()，evalFactor()则会再次调用evalExpression()。这就是在解析器中出现递归调用的地方。

如果该因子不是一个嵌套表达式，就提取下一个记号，它应当是一个单元格的位置，或者也可能是一个数字。如果这个记号匹配QRegExp，就把它认为是一个单元格引用并且对给定位置处的单元格调用value()。该单元格可能在电子制表软件中的任何一个地方，并且它可能会依赖于其他的单元格。这种依赖不是什么问题，它们只会简单地触发更多的value()调用和（对于那些"dirty"单元格）更多的解析处理，直到所有相关的单元格的值都得到计算为止。如果记号不是一个单元格的位置，那么就把它看作是一个数字。

如果单元格A1包含公式"=A1"时会发生什么呢？或者如果单元格A1包含公式"=A2"并且单元格A2包含公式"=A1"时又会发生什么呢？尽管还没有编写任何特定代码来检测这种循环依赖关系，但解析器可以通过返回一个无效的QVariant来完美地处理这一情况。之所以可以正常工作，是因为在调用evalExpression()之前，我们会在value()中把cacheIsDirty设置为false，把cachedValue设置为Invalid。如果evalExpression()对同一个单元格循环调用value()，它就会立即返回Invalid，并且这样就会使整个表达式等于Invalid。

现在，我们已经完成了公式解析器。通过扩展因子的语法定义，公式解析器可以非常方便地处理那些在电子制表软件中像"sum()"和"avg()"一样的某些预定义函数。而另外一种比较容易的扩展方式是将"+"操作符实现为字符串连接（就像串联一样），这样就无需再对这个语法进行修改了。


%附录
\appendix

\part{附录}
\chapter{Qt的获取和安装}
本部分工作稍后将会补上，可能还会加入一些最新的资源信息。


\chapter{编译Qt应用程序}
本部分工作放在稍后面些。

\chapter{Qt Jambi简介}
本部分工作将放在最后面最后面。

\chapter{面向Java和C\#{}程序员的C++简介}
这个附录为已经熟知Java或者C\#{}的开发人员提供一个关于C++的简短介绍。这里假定你已经熟悉了面向对象中的那些概念，如继承和多态，并且认为你也的确是想学习C++。为了不让本书变成一部厚达1500页的涵盖全部C++入门知识的不实用的“大部头”，所以要把这个附录仅仅限定在基本知识的范围内：只给出用来理解本书其他部分所示例子的基本知识和方法，但这些知识也足以使用Qt开发跨平台的C++图形用户界面应用程序。

在编写这本书的时候，C++是开发跨平台、高性能、面向对象的图形用户界面应用程序的唯一现实选择。而一些别有用心的批评者也可能会指出，Java或者C\#{}具有更好的可用性，而C++则降低了C的兼容性。实际上，作为C++发明人的Bjarne Stroustrup，他在"The Design and Evolution of C++"(Addison-Wesley，1994)一书中早就指出：“即使有C++，还可以找出更小、更简洁的语言”。

幸运的是，在使用Qt进行编程的时候，我们通常只关注于C++的子类，这非常接近于Stroustrup所设想的“乌托邦”式的编程语言，从而能够让我们集中精力去解决手头的问题。此外，通过Qt独创性的“信号和槽”机制、对统一字符编码标准的支持以及foreach关键字，Qt也在多个方面扩展了C++。

在这个附录的第一节中，将会看到如何使用C++的源文件产生一个可执行程序。这将可以引导我们探索C++的一些核心概念，如编译单元、头文件、目标文件、库等，并且也可以让我们逐步熟悉C++的预处理器、编译器和连接器。

然后，会转到对C++、Java和C\#{}这些主要语言不同点的说明上：如何定义类，如何使用指针和引用，如何重载运算符，如何使用预处理器，等等。尽管C++语法从表面上看与Java或者C\#{}的语法很相似，但从深层意义上来讲，这些概念却稍微显得不尽相同。同时，作为Java和C\#{}的创意之源，C++语言也与这两种语言有着诸多相同之处，包括相似的数据类型，同样的数学运算符，以及同样的基本控制流语句等。

最后一节专门用于说明标准C++库，该库提供了可用于任意C++程序中的完善功能。这个库是30多年来演化的结果，并且因此提供了涵盖程序、面向对象、函数编程风格以及宏和模板等方面的诸多方法。与Java和C\#{}提供的库相比，标准C++库的范围显得有些窄。比如，标准C++库不支持图形用户界面程序设计、多线程、数据库、国际化、网络、XML或者统一字符编码标准。要在这些领域进行开发，C++程序员则可能要使用各种各样（通常是与平台相关的）的库。

这就是为什么说Qt可以节约时间的原因。Qt首先作为跨平台的图形用户界面工具包（一个让编写可移植图形用户界面应用程序成为可能的类的集合）而起步，但很快发展成为一个成熟的程序开发框架，它对标准C++库进行了部分扩展和部分替换。尽管本书使用的是Qt，但是如果能够知道标准C++库到底提供了哪些功能也是很有用的，因为你有可能需要去处理一些使用了那些功能的代码。

\section{C++入门}
一个C++程序由一个或者多个编译单元(compilation unit)构成。每个编译单元都是一个独立的源代码文件，通常是一个带.cpp扩展名（其他常用的扩展名还有.cc和.cxx）的文件，编译器每次可以处理一个这样的文件。对于每一个编译单元，编译器都会产生一个目标文件，它的扩展名是.obj（在Windows中）或者.o（在UNIX和Mac OS X中）。这个目标文件是一个二进制文件，其中包含了系统架构方面的机器代码，而程序则要运行在此基础之上。  

一旦所有的.cpp文件都已编译完成，那么我们就可以使用一个称为连接器的特殊程序，把这些目标文件连接在一起，生成一个可执行程序。连接器会连接这些目标文件，并且会解析函数和编译单元中引用到的其他符号的内存地址。

在构建一个程序时，必须确保其中的某个编译单元包含一个main()函数，它是程序入口的标志。这个函数不属于任何类，它是一个全局函数(global function)。图D.1给出了这一过程的原理图。
\begin{fig}[0.8]{c++compilation}
\caption{C++的编译过程（在Windows中）}
\label{fig:c++compilation}
\end{fig}

不像Java的每一个源文件都必须严格包含一个类那样，C++可以按我们想要的形式组织各个编译单元。我们可以在同一个.cpp文件中实现多个类，或者也可以把一个类的实现分散到多个.cpp文件中，并且还可以把这些源文件命名为我们所喜欢的任意名字。当在某一个特殊的.cpp文件中进行修改时，只需要重新编译那个文件，然后再重新连接这个应用程序就可以生成一个新的可执行程序。

在进一步深入学习之前，让我们快速看一个C++小程序的源代码，该程序可以计算一个整数的平方。这个程序由两个编译单元构成：main.cpp和square.cpp。

这是square.cpp文件中的内容：
\begin{cppinput}{qt4-book/appendixD/square/square.cpp}
\end{cppinput}

这个文件只简单包含了一个称为square()的全局函数，它可以返回所带参数的平方值。

这里是main.cpp文件中的内容：
\begin{cppinput}{qt4-book/appendixD/square/main.cpp}
\end{cppinput}

源文件main.cpp包含了main()函数的定义。在C++中，这个函数的参数是一个int和一个char * 数组（一个字符串数组）。可以从argv[0]中获取程序的名字，命令行参数则分别放在argv[1]、argv[2]、$\cdots$、argv[argc-1]中。把参数命名为argc（argument count，参数个数）和argv（argument values，参数值）是一种习惯性的做法。如果这个程序不能使用命令行参数，那么可以把main()定义成不带参数的形式。
 
这个main()函数使用标准C++库中的strtod()（即“string转换到double”)、cout（c++的标准输出流），和cerr（c++的标准错误信息输出流），把命令行参数转换成double，并且以文本的形式打印到终端控制台。字符串、数字和行尾标记符(endl)都是使用<<操作符的输出流，该操作符也用于移位操作(bit-shifting)中。为了可以使用这一标准功能，我们需要在第1行和第2行中加入\verb+#inlcude+指示符。

标准C++库中的所有函数和大多数的其他对象都在std命名空间中。一种访问命名空间中的某一项的方法是用命名空间的名字和::操作符作为该项名字的前缀。在C++中，::操作符可以作为复杂名字的分隔符。命名空间可以使巨大的多人合作项目变得更容易些，因为命名空间可以避免命名冲突问题。在本附录的后面，还会做进一步的讨论。

位于第3行的代码是一个函数原型(function prototype)。它告诉编译器：存在这样一个带有给定参数和返回值的函数。而实际的函数则可以位于同一个编译单元中，也可以放在其他编译单元中。没有这个函数原型，编译器将不会让我们在第12行调用函数。在函数原型中，这些参数的名字是可有可无的。

编译这个程序的过程因平台的不同而略有不同。例如，要在Solaris上使用Sun C++编译器编译这个程序，应当输入以下命令：
\begin{Verbatim}
CC -c main.cpp
CC -c square.cpp
CC main.o square.o -o square
\end{Verbatim}

最前面的两行会调用编译器生成这些.cpp文件对应的.o文件。第三行则调用连接器，并且据此生成一个称为square的可执行程序，于是我们就可以像下面那样来运行该程序：
\begin{Verbatim}
./square 64
\end{Verbatim}

这个程序运行后会在终端上输出下列信息：
\begin{Verbatim}
The square of 64 is 4096
\end{Verbatim}

要编译这个程序，你可能希望从C++专家那里得到帮助。但如果无法从别人那里获得帮助，那么可以继续阅读本附录中剩余的部分而不必编译任何东西，并且可以按照第1章中给出的用法说明来编译你的第一个C++/Qt应用程序。Qt提供了一些工具，它们可以让你在所有平台上编译应用程序都变得轻松、简单。

再重新回到我们的程序中：在真实的应用程序中，我们通常会把square()函数的函数原型放在一个单独的文件中，然后在需要调用这个函数的所有编译单元中都包含那个文件。这样的文件就是所谓的头文件(header file)，并且通常带一个.h的扩展名（常见的还有.hh、.hpp、.hxx等）。如果使用这种头文件的形式重写我们的程序，则需要创建一个名为square.h的文件，它所包含的内容如下所示：

\begin{cppinput}{qt4-book/appendixD/square2/square.h}
\end{cppinput}

这个头文件被预处理命令（\#{}ifndef、\#{}define和\#{}endif）分成三部分。这三个命令可以确保这个头文件只作用一次，即使这个头文件在同样的编译单元中被包含了多次都是如此（当在一个头文件中又包含了其他的头文件时，就会发生这种多次包含的情况。根据惯例，一般使用这个文件的名字作为预处理器的符号（在我们的例子中，就是SQUARE\_{}H），在本附录的稍后部分，还会回到预处理器这一主题上。

此时，新的main.cpp文件看起来像这样：
\begin{cppinput}{qt4-book/appendixD/square2/main.cpp}
\end{cppinput}

第3行中的\verb+#include+命令扩展了square.h文件的内容。C++预处理器会在编译开始之前获取所有这些以"\#{}"开始的指示符。以前，预处理器是一个单独的程序，需要在运行编译器之前由程序员手动调用它。而现在的编译器则会隐式地调用预处理器。

第1行和第2行中的\#{}include命令扩展了cstdlib和iostream头文件的内容，它们都是标准C++库的一部分。标准的头文件没有.h后缀。包围文件名的尖括号说明这些头文件都位于系统的标准位置，而双引号则告诉编译器要到当前目录中查找头文件。这些包含命令通常都会放在.cpp文件内容的最前面。

不像.cpp文件，这些头文件自身都不是编译单元，并且也不会产生任何目标文件。头文件或许只包含一些让不同的编译单元能够互相联系的声明而已。因此，把square()函数的实现代码放在一个头文件中就显得有些不合适了。如果在我们的例子中那样做了，也不会产生任何不良影响，因为只包含了square.h一次，但是如果在多个.cpp文件中都包含了square.h文件，那么就会得到square()函数的多重实现（每个.cpp文件都包含头文件一次）。于是，连接器就会抱怨square()出现了多重（同样的）定义，并且会拒绝生成可执行程序。相反，如果我们声明了一个函数但是却再没有实现它，那么连接器也会报错，输出"unresolved symbol"（不可解析的符号）的错误信息。

到目前为止，我们可能会认为：一个可执行程序只是由一些目标文件构成的。但在实际情况中，可执行程序通常都会连接许多库，而这些库则可以实现许多现成的功能。库主要有两种类型：
\begin{itemize}
\item 静态库(static library)可以直接放进可执行程序，就好像它们也是一些目标文件一样。这可以确保不会弄丢这些库，但却会让可执行程序变得很大。
\item 动态库（dynamic library，也称共享库或DLL）位于用户机器上的标准位置，并且会在应用程序启动的时候自动加载它们。 
\end{itemize}

对于以上的square程序，连接的是标准的C++库，通常在大多数平台上都是采用这种动态库的形式实现的。Qt自身就是一个库的集合，既可编译为静态库又可编译为动态库（默认是动态库）


\section{主要语言之间的差异}
现在：我们将会采用一种更有条理的方式来看看C++与Java和C\#{}之间的不同之处。语言之间的这些许多不同之处都是因为C++的可编译本性和对性能的追求而产生的。因此，C++不会在运行时检测数组是否越界，并且也没有垃圾信息收集器回收那些分配出去但是却不再使用的动态内存。

为简便起见，对于C++与Java和C\#{}中结构几乎一致的地方就不再提及了。另外，还有一些C++的主题在这里也不再涉及，因为在使用Qt编程时并不需要它们。这其中就包括了模板类和模板函数的定义、共用体类型的定义，以及异常的使用等主题。如果要对所有这些主题都想了解，可以参考像Bjarne Stroustrup编著的"The C++ Programming Language"(Addison-Wesley, 2000)和Mark Allen Weiss编著的"C++ for Java Programmers"(Prentice Hall, 2003)等这样的一些书籍。

\subsection{基本数据类型}
由C++语言提供的这些基本数据类型(primitive data type)与Java或者C\#{}中的数据类型很相似。下表列出了C++的基本类型以及它们在Qt 4所支持的平台上的定义。

\begin{minipage}{0.9\linewidth}
\begin{table}[H]
\centering
\caption{C++基本类型}
\label{tab:C++基本类型}
\medskip 
\begin{tabular}{@{}ll@{}}
\toprule
C++类型 & 说明  \\ \midrule
bool  &  布尔值 \\
char  &  8位整型值 \\
short  &  16位整型值 \\
int  &  32位整型值 \\
long  &  32位或64位整型值 \\
long long\footnote{微软将long long类型称为\_{}int64，在Qt程序中，可以使用qlonglong类型来代替long long类型，qlonglong可以运行于所有Qt支持的平台上。}  &  64位整型值 \\
float  &  32位浮点值(IEEE 754) \\
double  &  64位浮点值(IEEE 754) \\
O  & 奇数页(odd)
 \\ \bottomrule
\end{tabular}
\end{table}
\end{minipage}

默认情况下，short、int、long和long long数据类型都是符号型数据。也就是说，它们既可以保存负数值，又可以保存正数值。如果只需要存储非负型整数值，只需把unsigned关键字放在该类型前面即可。因此，一个short变量可以保存介于-32 768到+32 767之间的任意值，而一个unsigned short变量则只能保存介于0到65 535之间的任意值。如果在操作符中有这个unsigned操作符，那么右移操作符>>就会具备unsigned（“用多个0填充”）的语法含义。

bool类型可以接受的值是true和false。此外，数字类型也可以用于需要bool值的地方，其使用规则是：0表示false，而其他任意的非零值表示true。

char类型用于存储ASCⅡ字符和8位整型值（字节）。当用作整型值时，它可以是signed或者unsigned类型，这取决于所在的平台。类型signed char和unsigned char可用于在那些能够区分char正负的地方代替char。Qt提供了一个QChar类型，它可用于存储16位的Unicode字符。

内置类型的实例不会被默认初始化。当创建一个int变量时，它的值应当可以明确地说是0，但是也很有可能是-209 486 515。幸运的是，绝大多数的编译器都会在我们试图读取未初始化变量时给予警告，并且我们也可以使用一些像Rational PurifyPlus和Valgrind这样的工具来检查运行时对未初始化内存的访问和其他与内存相关的问题。

在内存中，数值类型（long除外）在Qt所支持的不同平台上都具有相同的大小，但它们的表示方法会根据系统存储字节顺序的不同而略有不同。对于高字节在后的系统架构（如PowerPC和SPARC)，32位变量值0x12345678会存储为4个字节：0x12 0x34 0x56 0x78。然而，对于高字节在前的系统架构（比如Intel x86体系），这些字节的存储顺序就会颠倒过来。这样就会在一些需要把内存区域中的数据复制到磁盘或者是在网络上发送二进制数据的程序中产生差异。Qt的QDataStream类（参见第12章的说明）则可用于存储与平台无关的二进制数据。

\subsection{类定义}
在C++中，类定义(class definition)与Java和C\#{}中的类定义相似，但是也有一些不同之处需要注意。我们将使用一系列的例子来研究这些不同点。先从一个表示(x, y)坐标对的类开始：

\begin{cppinput}{qt4-book/appendixD/point2d/point2d.h}
\end{cppinput}

上面的类定义将会放在一个头文件中，通常把这个文件命名为point2d.h。这个例子说明了C++的以下几个特性：
\begin{itemize}
\item 类定义可以划分为public、是和private三段，且以一个分号结束。如果没有定义段，那么就默认是private段。（为了保持与C的兼容性，C++提供了一个struct关键字，除了在没有指定段时它的默认段是public这一点不同外，萁他都与类相同。）
\item 类有两个构造函数（一个没有参数，一个则有两个参数）。我们没有声明构造函数，那么C++将会自动提供一个不带参数的构造函数，并且这个构造函数的函数体为空。
\item 用来获取值的函数x()和y()声明为const。这就意味着它们不会（而且也不能）修改成员变量或者调用非const成员函数[比如setX()和setY()]。
\end{itemize}

上述的这些函数都实现为内联函数(inline)，是类定义的一部分。还有另外一种方式是只把函数原型放在头文件中，而把实现这些函数的代码放在.cpp文件中。使用这种方式时，头文件看起来应当是这样的：

\begin{cppinput}{qt4-book/appendixD/point2d2/point2d.h}
\end{cppinput}

于是就可以在point2d.cpp文件中实现这些函数：
\begin{cppinput}{qt4-book/appendixD/point2d2/point2d.cpp}
\end{cppinput}

文件是从包含point2d.h开始的，因为编译器需要在它分析类的成员函数的实现之前要先知道类的定义。然后，我们再实现这些函数，并且在函数的名字前加上以"::"操作符和类名一起构成的前缀。

我们在前面看到了如何把一个函数实现成内联函数的方法，而现在则看到了如何在.cpp文件中实现它。从语法上来讲，这两种方法是等效的，但是当我们调用一个声明为内联函数的函数时，绝大多数的编译器都只是简单地扩展其函数体，而不会生成实际的函数调用。这通常可以产生更为快速的代码，但是可能会增加应用程序的大小。基于这样的原因，只有非常简短的函数才应该实现为内联函数，比较长的函数都总是应当在.cpp文件中加以实现。此外，如果我们忘记了某个函数的实现并试图去调用这样的函数，那么连接程序将会报错："unresolved symbol"（不可解析的符号）。

现在尝试一下这个类：
\begin{cppinput}{qt4-book/appendixD/point2d2/main.cpp}
\end{cppinput}

在C++中，任意类型的变量都可以直接声明而不必一定要使用new。第一个变量会使用默认的Point2D构造函数（这个构造函数没有参数）进行初始化。第二个变量则使用第二个构造函数进行初始化。对一个对象的成员进行访问需要使用"."（点）操作符。

以这种方式声明变量的行为就像在Java/C\#{}中声明一些基本类型一样，比如int和double。例如，当使用赋值操作符时，会复制变量的内容，而不是复制对象的引用(reference)。如果要在以后修改一个变量值，那么从它那里赋值而来的其他任何变量都仍旧会保持不变。

作为一种面向对象的语言，C++支持继承(inheritance)和多态(polymorphism)。为了说明它们是如何工作的，我们将分析一个例子，该例以Shape为抽象基类，以Circle为子类。先从基类开始：

\begin{cppinput}{qt4-book/appendixD/shape/shape.h}
\end{cppinput}

这个定义放在头文件shape.h中。由于在这个类的定义中引用了类Point2D，所以需要包含头文件point2d.h。

类Shape没有基类。这一点不像Java和C\#{}，C++没有为所有的类提供一个可以从中继承出来的一般类Object。Qt则为所有类型的对象提供了一个简单基类QObject。

draw()函数的声明有两个有趣的特点：它含有virtual关键字，并且以"=0"为结尾，关键字virtual表明这个函数可能会在子类中重新得到实现。就像在C\#{}中一样，C++的成员函数在默认情况下也是不能重新实现的。这个奇特的"=0"的语句表明这个函数是一个纯虚函数(pure virtual function)——一个没有默认实现代码并且必须在子类中实现的函数。要把Java和C\#{}中的“接口”的概念对应到类中，就只能用C++的纯虚函数来表示了。

以下是子类Circle的定义：

\begin{cppinput}{qt4-book/appendixD/shape/circle.h}
\end{cppinput}

类Circle通过公有(public)方式继承了Shape，也就是说，Shape中的所有公有成员在Circle中仍旧是公有的。C++也支持保护(protected)继承和私有(private)继承，利用它们可以限制对基类的public成员和protected成员的访问。

这个构造函数带有两个参数。第二个参数是可选的，并且如果没有给定参数值就会取0.5。构造函数在函数名和函数体之间使用一种特殊的语法把center参数传递给基类的构造函数。在函数体中，我们对成员变量myRadius进行了初始化。在基类构造函数初始化时，我们也本应在同一行初始化该变量：
\begin{Verbatim}
Circle(Point2D center, double radius = 0.5)
    : Shape(center), myRadius(radius) { }
\end{Verbatim}

另一方面，C++不允许在类定义中初始化成员变量，因此，下面的代码就是错误的：
\begin{Verbatim}
// 将无法编译通过
private:
    double myRadius = 0.5;
};
\end{Verbatim}

draw()函数与Shape中声明的虚函数draw()具有相同的名字。它是该函数的一个重新实现，并且在Circle实例上通过Shape引用或者指针调用draw()时，就会以多态的形式调用该函数。C++不像C\#{}那样有override关键字。而且C++也没有能够指向基类的super或者base关键字。如果需要调用一个函数的基本实现，则可以在这个函数的名字前加上一个由基类的名字和"::"操作符构成的前缀。例如：
\begin{Verbatim}
class LabeledCircle : public Circle
{
public:
    void draw() {
        Circle::draw();
        drawLabel();
    }
...
};
\end{Verbatim}


C++支持多重继承，也就是说，一个类可以同时从多个类中派生出来。语法形式如下所示：
\begin{Verbatim}
class DerivedClass : public BaseClass1, public BaseClass2, ...,
                public BaseClassN{
    ...
};
\end{Verbatim}

默认情况下，类中声明的函数和变量都与这个类的实例相关。我们也可以声明静态(static)成员函数和静态成员变量，可以在没有实例的情况下使用它们。例如：
\begin{Verbatim}
#ifndef TRUCK_H
#define TRUCK_H

class Truck{
public:
    Truck() { ++counter; }
    ~Truck() { --counter; }
    static int instanceCount() { return counter; }

private:
    static int counter;
};

#endif
\end{Verbatim}

通过这里的静态成员变量counter，我们可以在任何时候知道还存在多少个Truck实例。Truck的构造函数会增加它的值。通过前缀"\~{}"识别的析构函数(destructor)可以减少它的值。在C++中，在静态分配的变量超出作用域或者是在删除一个使用new分配的变量时会自动调用这个析构函数。除了我们还可以在某个特定时刻调用析构函数这一点之外，这都与Java中的finalize()方法相似。

一个静态成员变量在一个类中只有单一的存在实体：这样的变量就是“类变量”(class variable)而不是“实例变量”(instance variable)。每一个静态成员变量都必须定义在.cpp文件（但是不能再次重复static关键字）中。例如：
\begin{Verbatim}
#include "truck.h"

int Truck::counter = 0;
\end{Verbatim}

不这样做将会在连接时产生一个"unresolved symbol"（不可解析的符号）的错误信息。只要把类名作为前缀，就可以在该类外面访问这个instanceCount()静态函数。例如：
\begin{Verbatim}
#include <iostream>
#include "truck.h"

int main(){
    Truck truck1;
    Truck truck2;
    std::cout << Truck::instanceCount() << " equals 2" << std::endl;
    return 0;
}
\end{Verbatim}



\subsection{指针}
在C++中，指针(pointer)就是一个可以存储对象的内存地址的变量（而不是直接存储这个对象）。Java和C\#{}都有类似的概念——“引用”(reference)，但是在语法上却并不相同。我们从研究一个精心设计的例子开始，利用它来说明指针的用法：

\begin{cppinput}{qt4-book/appendixD/pointer/pointer.cpp}
\end{cppinput}

这个例子依赖于前一小节中给出的Point2D类。第4行和第5行定义了两个Point2D对象。根据Point2D的默认构造函数，这两个对象将被初始化为(0, 0)。

第6行定义了一个指向Point2D对象的指针。指针的语法是在变量名的前面再加上一个星号。由于没有初始化这个指针，所以它包含的是一个随机的内存地址值。通过在第7行给这个指针分配alpha对象的地址就可以解决这个初始化问题。这里的一元运算符"\&{}"可以返回一个对象的内存地址值。地址值通常是一个32位或者是一个64位的整型值，可以用来确定一个对象在内存中的偏移量。 

在第8行和第9行，我们通过ptr指针访问alpha对象。因为ptr是指针而不是对象，所以必须使用"->"（箭头）操作符代替"."（点）操作符。

在第10行，我们把beta的地址也赋给这个指针。于是从此时开始，通过这个指针执行的任何操作都将会影响到beta对象。 

第13行把这个指针设置为空(null)指针。C++没有一个可以用于表示不指向对象指针的关键字。所以，我们改换用值0（或者是符号常量NULL，它可以扩展为0）来代替。试图使用一个空指针会造成系统的崩溃，其提示的错误信息有“段错误”(Segmentation fault)、“常规保护错误”(General protection fault)或者是“总线错误”(Bus error)等。使用程序调试器，可以找出是那一行代码造成了系统的崩溃。 

在这个函数的最后，alpha对象保存了坐标对(1.0, 2.5)，而beta保存了(4.0, 4.5)。

指针通常用于存储使用new动态分配的对象。在C++术语中，我们把这样的对象称为是分配在“堆”(heap)上，而局部变量（在一个函数中定义的变量）则存储在“栈”(stack)里。

这里给出了一段用来说明使用new进行动态内存分配的代码片段：
\begin{tcbcode}[]{cpp}
#include "point2d.h"

int main(){
    Point2D *point = new Point2D;
    point->setX(1.0);
    point->setY(2.5);
    delete point;
    return 0;
}
\end{tcbcode}

new操作符返回一个新近分配对象的内存地址。我们把这个地址存储在一个指针变量中，并且通过这指针访问该对象。当处理完这个对象后，就可以使用delete操作符释放它的内存。不像Java和C\#{}，C++没有垃圾信息收集器，当不再需要那些动态分配的对象时，就必须明确使用\textbf{delete}来释放它们。利用第2章中讲述的Qt父－子对象机制，可以大大简化C++程序中的内存管理工作。

如果忘记调用delete，则内存就会一直保留到该程序结束时为止。这在上面的例子中不是什么大问题，因为我们只是分配了一个对象，但是如果在一个总是需要不断分配新对象的程序中，就可能造成程序总是在不断分配内存，那么就可能将机器的内存耗尽。对象一旦删除，则指向该对象的指针变量仍旧会保存这个对象的地址值。这样的指针就称为“悬摆指针”(dangling pointer)，最好不要再使用这样的指针访问该对象。Qt提供了一种“智能”(smart)指针QPointer<T>，如果删除了它所指向的QObject对象，那么它就会自动把自己设置成0。

在上面的例子中，我们调用了默认的构造函数并且调用setX()和setY()来初始化该对象。我们本应当使用带两个参数的构造函数来代替默认的构造函数：
\begin{Verbatim}
Point2D *point = new Point2D(1.0, 2.5);
\end{Verbatim}

这个例子并不需要使用new和delete。我们最好也像下面那样在栈上分配该对象：
\begin{Verbatim}
Point2D point;
point.setX(1.0);
point.setY(2.5);
\end{Verbatim}

像这祥分配的对象会在出现它们的程序块的末尾自动得到释放。

如果不打算通过该指针来修改这个对象，则可以把指针声明为const型指针。例如：
\begin{Verbatim}
const Point2D *ptr = new Point2D(1.0, 2.5);
double x = ptr->x();
double y = ptr->y();

// WON'T COMPILE
ptr->setX(4.0);
*ptr = Point2D(4.0, 4.5);
\end{Verbatim}

这个常量指针ptr只能用于调用常量成员函数，比如x()和y()。当不打算使用指针修改它们时，把指针声明为const是一种不错的习惯。而且，如果该对象自身就是常量，那么我们就没有什么选择了，只能使用常量指针来存储它的地址值。const的用法可以为编译器提供一定的信息，这可以提早发现一些bug，并且也可以获得良好的性能。C\#{}有const关键字，与C++的const关键字相似。而在Java中，最为接近的等价概念就是final了，但是它只能保护变量不被赋值，避免在它上面调用“非常量”的成员函数。

指针既可以用在内置类型上，也可以用在类上。需要说明的是，一元运算符"*"可以返回与这个指针相关的对象的值。例如：
\begin{Verbatim}
int i = 10;
int j = 20;

int *p = &i;
int *q = &j;

std::cout << *p << " equals 10" << std::endl;
std::cout << *q << " equals 20" << std::endl;

*p = 40;

std::cout << i << " equals 40" << std::endl;

p = q;
*p = 100;

std::cout << i << " equals 40" << std::endl;
std::cout << j << " equals 100" << std::endl;
\end{Verbatim}

箭头运算符"->"可用于通过指针来访问对象的成员，这纯粹是一种语法糖(syntactic sugar)而已。除了ptr->member的形式之外，我们还可以使用(*ptr).member的形式。这里的圆括号是必需的，因为"."运算符具有比"*"运算符更高的运算优先级。

指针在C和C++中名声不良，正是因为这一点，Java经常借鼓吹自己没有指针而大做文章。实际上，C++指针在概念上与Java和C\#{}中的引用非常相似，只是我们还可以使用指针来遍历整个内存而已——关于这一点，在这一节的后面还会讲到。此外，在Qt中还包含了“写时复制”(copy on write)的容器类，它具有与C++一样的可在栈上实例化任意类的能力，这就意味着通常可以尽量避免指针的使用。


\subsection{引用}
除了指针，C++也支持“引用”的概念。像指针一样，一个C++的引用存储的也是一个对象的地址值。两者的主要不同点在于：
\begin{itemize}
\item 声明引用时使用的是"\&{}"而不是"*"。
\item 引用必须是初始化过的，并且不能在后面再次重新赋值。
\item 可以直接访问与引用相关联的对象，且没有像"*"或者"->"这样的特殊语法。
\item 引用不能为空(null)。  
\end{itemize}

在声明参数时，经常会用到引用。对于大多数类型来讲，C++会使用按值调用(call-by-value)的方式来作为它的默认参数传递机制。也就是说，当给一个函数传递参数的时候，该函数会接收到这个对象的一个新的副本。这里给出了一个函数的定义，它就是通过按值调用的方式来接收它的参数值的：

\begin{Verbatim}
#include <cstdlib>
double manhattanDistance(Point2D a, Point2D b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}
\end{Verbatim}

于是就可以按照如下的方式来调用该函数：
\begin{Verbatim}
Point2D broadway(12.5, 40.0);
Point2D harlem(77.5, 50.0);
double distance = manhattanDistance(broadway, harlem);
\end{Verbatim}

C程序员通过把参数声明为指针而不是值的方式，能够避免不必要的复制操作：
\begin{Verbatim}
double manhattanDistance(const Point2D *ap, const Point2D *bp)
{
    return std::abs(bp->x() - ap->x()) + std::abs(bp->y() - ap->y());
}
\end{Verbatim}

于是，在调用该函数的时候传递的必须是地址而不是值：
\begin{Verbatim}
double distance = manhattanDistance(&broadway, &harlem);
\end{Verbatim}

C++引入引用的概念而使得语法变得更为简单，并且还可以使调用者避免出现传递空指针的现象。如果使用的是引用而不是指针，那么该函数看起来就会像下面这样：
\begin{Verbatim}
double manhattanDistance(const Point2D &a, const Point2D &b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}
\end{Verbatim}

引用的声明与指针的声明有点相似，只是用的是"\&{}"而不是"*"罢了。但是当我们实际使用引用的时候，无需记住它是一个内存地址，而只需把它看作是一个普通的变量就行了。另外，调用一个带有引用作参数的函数时；并不需要给予太多的考虑（不带"\&{}"运算符）。

总而言之，通过在参数列表中把Point2D替换为const Point2D \&{} ，就可以降低函数调用的开销：不用再复制256位（4个double值的大小），需要复制的只是64位或者128位——这取决于目标平台指针的大小。

在前一个例子中使用const引用，就可以让函数避免修改与这些引用相关联的对象。但是当我们需要这种特殊效果时，则可以传递一个非常量引用或者一个指针。例如：
\begin{Verbatim}
void transpose(Point2D &point)
{
    double oldX = point.x();
    point.setX(point.y());
    point.setY(oldX);
}
\end{Verbatim}

在某些情况下，我们有一个引用并且需要调用一个带指针的函数，或者是相反的情形。要把引用转换成指针，可以使用一元运算符"\&{}"：
\begin{Verbatim}
Point2D point;
Point2D &ref = point;
Point2D *ptr = &ref;
\end{Verbatim}


要把指针转换成引用，可以使用一元运算符"*"：
\begin{Verbatim}
Point2D point;
Point2D *ptr = &point;
Point2D &ref = *ptr;
\end{Verbatim}

引用和指针在内存中的表达方式一样，并且在使用时会经常互换它们，这需要根据具体问题来具体确定到底应该使用哪一种形式。一方面，引用具有更为简便的语法；另一方面，指针可以在任何时刻指向其他的任意对象，它们都可以保存一个空值，并且它们更为明晰的语法通常可以使事情变得似繁而简。基于这些原因，指针会略占上风，而用于声明函数的参数时引用则是最佳的选择，它们还可以与const一起配合使用。




\end{common-format}  
\end{document}

\subsection{数组}
在C++中，通过在变量声明和变量名字后面跟一对方括号就可以声明一个数组，但需要同时
在方括号中给定数组所包含的元素个数。二维数组就是使用一维数组的数组：这里给出了一个
一维数组的定义，其中包含了10个int型元素值：    ／
    可以采用fibonacci[0]，fibonacci[1]，…，fibonacci[9]的形式对这些元素进行访问。通常情况下，
我们希望以定义的方式来初始化数组：
在这种情况下，可以忽略数组的大小，因为编译器能从数组的初始状态推算出元素J个数：
静态初始化也可用于复杂数据类型，比如Point2D:

如果我们无意在后续程序中修改数组，则可以让它成为常量型数组：
要找出一个数组中包含的元素个数，可以像T面这样使用sueof()运算符：

附录D面向Java和C#程序员的C++简介475
    sizeof()运算符以字节为单位返回它的参数的大小值。一个数组中元素的个数就是它的字节
数除以其中一个元素的字节数。因为这一方法非常麻烦，所以，一种更为常用的方法就是先定义
一个常量，然后用这个常量来定义数组：

    这里的本意是想把该常量声明成const int型变量。但遗憾的是，一些编译器已经可以用const
变量作为数组大小的指示标记。本附录的后面会解释enum关键字。
    数组的遍历通常是使用整数来完成的。例如：

也可以使用指针来遍历数组：

    我们用第一个元素的地址来初始化这个指针，并且一直循环到“最詹≯个元素之后”的元素
（即“第11个”元素，fibonacci[10]）。在每一次遍历中，“++”运算符就会把擐钍蜘后移动一次而指
到下一个元素处0    7    j  ，i《继，c一，  、．  t^。
  、不使用&fibonacci[0]，应当也可以完成对fibonacci的写操作。．这是因．汐，单独使用_个数组的
名字会自动转换为指向该数组中的第一个元素的指针。与此相似，可以使用., fibonacci+10．代替
&fibonacci[ 10]。这种方式也能够很好地工作：我们可以使用*pti或者肛．[o]获得当前元豢的内
容，并且可以通过* (pti+1)或者妒[1]访问下一个元素。这一原理有时称为“指针和数组的等
    ，  ’
价性”。
    为了避免出现无故的低效率，C++不允许我们给函数传递数组的值。相反，它们必须以地址
的形式传递。例如：  ’    _．．    i。

    具有讽刺意味的是，尽管C++没有给我们任何选择的余地，而不管我们是以地址的方式还是以
值的方式来传递一个数组，但它还是在用于声明参数类型的语法中给了我们一些自由。使用的不是
const int*table，我们也本可以写作const int table[]的方式来声明一个指针pointer到constant int的参
数。与之相似的是，用于main()中的tuBv参数则可以声明为char *tuBv[]或者char **argv。
    要把一个数组复制到另一个数组，一种方法是在这个数组中进行循环：

    对于像int这样的基本数据类型，也可以使用std:：memcpy()，它可以复制一块内存中的数据。
例如：
    std::memcpy (temp,  fibonacci,  sizeof( fibonacci));
    当声明一个C++数组的时候，数组的大小必须是一个常数值①。如果希望创建一个可变大小
的数组，可以有多种方法。

    这个new[]运算符会在内存的连续位置分配一定数量的元素，并且可以返回一个指向第一个元
素的指针。由“指针和数组的等价性”原理可知，可以通过该指针访问元素fibonacci[0]，．fibonacci[1]，
…，fibonacci[n -1]。当使用完数组后，应当使用运算符delete[]释放它所占用捧的内存空间：。，二。

    QVector <T>的API与std:：vector<T>的API类似，但使用Qt的foreach关键字，它还可以支持
遍历操作，并且可以使用隐式数据共享（“写时复制”）作为内存和速度的优化技术。。第．11章给出
了q的容器类并且讲述了它们与标准C++容器类之间的联系。
    无论何时，或许都应当力求避免使用内置数组而应当尽量用std：：vector之T>或者'QVector <T>
来代替它们。尽管如此，还是很有必要理解内置数组究竟是如何工作的，因为迟早或许还是希望
能够把它们放进高度优化的代码中，或者还是需要利用它们与现有的C函数库进行交流。

\subsection{字符串}

    C++中，字符串(character string)最为基本的表达方式就是使用一个以空字节(‘＼0’)为结束符
的字符数组。下面的4个函数给出了字符串的这些工作方式：

                                                                                           ..
言指令，它就与前面的两个函数
    第四个函数则有一点不同，
变量，并且用这个指针来存储该
个函数与前面三食函数都__样，
  。‘以C++字符串作为参数的
序显示了这两种方法的用法：

    在C++中，char类型通常保存为8位的值。这就是说，我们可以毫不费力地在_AI .char数组
中存储ASCII、IS0 8859-1 (IAtin-l)以及其他采用8位编码的字符串，但是在没有使用多字节序列的
情况下，就不能存储任意的Unicode字符。Qt提供了强大的QS雠ng类．，它会把-Umtode字符串存储
为16位QChar序列，同时在内部还会使用隐式数据共享（“写时复制”）的优化技术。第ir章和
第18章曾经详细地介绍了QSUiIlg类。

\subsection{枚举}

    c++使用颇具特色的枚举(enumeration)声明给定名字的常量，这和c#以及最近版本的Java
所提供的方式相似。现在，假定我们需要在程序中存储一周中的每一天：

通常情况下，我们将会把这一声明放在一个头文件中，或者甚至会放进一个类中。上面的声
明可以简单地与下列常量的定义相等价：

  “通过使用枚举结构，我们可以在后面声明一些DayOfWeek类型的变量或者参数，并且编译器
将可以确保只对那些来咱DayOfWeek枚举中的变量才赋值。确如：    ：。  ‘

    如果我们不关芯类窭婪全性( tpe。afety)，那么也可以写作：，    ，．
    需要注意的是，为了读取DayOfWeek枚举中的Sunday常量，我们只需写作Sunday即可，而不必
写成DayoWeek:：Suiiday。
    ．．
    默认情况市，编译器会从0开始给枚举中的常数值分配连续的整型值’，如果需要，也可以把
它们指定成其他的常量值：-  ‘

    如果没有给某个枚举元素指定值，那么该元素就会用前面元素的取值加1来作为自己的取
值。有时候，枚举用于声明整型常量，这时，我们通常会忽略枚举的名字：

    另外一种常见的枚举用法是用来表达选项的集合。我们以那个Find对话框为例，假定它有4
个复选框，分别用来控制查询算法（使用通配符、区分大小写、向前查找以及循环查找）。我们可以
用一个以2的幂次方为值的枚举常量来表示这一算法：

‘
  每个选项通常都称为“标记”( flag)。我们可以使用按位“I”或者“I=”运算符来组合这些标记：
可以使用按位“&”运算符来测试是否选中了某个标记：

    C++允许我们使用关键字typedef把一个数据类型设定成其他的名字（别名）j’例如，如果需要
使用许多QVecto，<Point2D>，并且希望能够少敲几次键盘（或者不幸使用了我们著不熟悉的Norwe-
gian键盘，这会让我们难于确定尖括号的位置），那么就可以通过把这个typedef r声明放在某个头交
    ‘    ．
件中来实现这一点：
    typedef QVector<Point2D> PointVector;
    从此以后，就可以把PomtVector当做QVector <Point2D>酌缩略形式。注意；类型的薪名字需要
放在旧名字的后面。typedef的语法有些故意地模仿了变量声明的形式。
    在Qt中，使用typedef主要有三个原因：    ’
    1．方便性。Qt可以使用typedef把unsigned int和QList <QWidget*>声明为uint和QWidgetLis‘，
    从而可以大大节省击键的次数。
    2．平台差异性。在不同的平台上，某些类型需要使用不同的定义形式。例如，qlonglong在
    Windows上定义为int64，而在其他平台上则定义为long long。    1
    3．兼容性。q 3中的类QIconSet在Qt 4中被重命名为QIcon。为了帮助Qt J3的用户能够把他
    们的应用程序移植到Qt4，当启用Qt 3兼容性时，就会用typedef把QlconSet当作是QIcon的
    别名。
类型转换
    C++提供了多种把变量从一种类型强制转换成另外一种类型的语法。从c那
传统语法是把结果类型放在一对括号内，然后把它们再放到要转换的变量前：
里继承过来的

    使用传统c风格的强制转换方式来转换指针和引用，可以认为是一种类似子极限运动的做
法，就好像在滑翔祝上跳伞和利用飞机冲浪一样危险，因为编译器会让我们把任意指针（或者引
用）类型都强制转换为其他的指针（或者引用）类型。正是由于这个原因，C++引入孑4种具有更
为准确语义的新强制转换类型。对于指针和引用，这些新风格的强制转换比那些冒险的c风格强
制转换更为可取，并且我们早已将其用在了本书的写作中。    。。：．  。
    1．s诅tic_cast<D()可用于把指向A的指针强制转换为指向B的指针，基约束条件是类B必须
    是类A的子类。例如：

乏0:b~_ someF.unct,c'm' Oe'cla淹dInB()．
    五日果该对象不是B的一个实例，那么使用结果指针将可以导致莫名其妙的系统崩溃。
  2．dymrnjtcaSt<I>()与static cast<D()类似，只是它使用的是运行时类型信息（r1II，runtime
    坼'e i面咖丘on）的方法来验证与这个指针相关的对象是否是类B的一个实例。如果不是，
    强制转换就会返回一个空指针nuu，例如：    。一，、    ，

-!：．在某些编译器中，dy逾r血Lc曲t<D<）不能跨动态库工作j它也依赖于编译器对Rr的支
．j．=_持，但为了减小可执行文件的大小，程序员可以关闭对r1II的支持这÷特色。Qt通过对
n…毫，。Q0ijject的矛类提供q嘲ect-cast<D()来解决这些问题。  。    ，    ．
  3．consLcast<D()添加或移除对指针或者引用的const限定。例如：


．在前面的例子中，我们舍弃了对this指针的const限定，是为了调用非const-成员函数recom-
  puteIntemalData()。但不推荐这种做法，并且也通常可以通过使用mutable关键字来避免这
  种做法，这一点已经在第4章中进行了说明。

在Java和C#中，如果需要，任何引用都可以存储成0bject引用。．C++则没有这种j般性的基
类，但是它提供了●种特殊的数据类型：void*，它可以存储任意类型的实例的地址。‘在使用void*型
数据之前，必须把它转换成另_种数据类型[可以使用static：cast<D()]。  。，、’    。，．．
    C++提供了许多强制转换类型的方法，但是在大多数时间里，我们甚至不需任何强制转换。
在使用容器类(比如std．：：vector <T>或者QVector <T》的时候，可以指定T鞠类型并且可以解析出
各个元素而不必使用强制转换。另外，对于那些基本数据类型，可以使用一些隐式转换（例如，从
char类型转换成int类型）来完成数据转换，而对于自定义类型的数据，则可以通过提供单参数构
    _    f
造函数的方法来定义隐式转换。例如：    ．~．  …，．

    对于一些单参数构造函数来说，自动转换没有多大意义。可以通过声明带？explicit关键字的构
造函数来禁用自动转换功能。j，．一．。■，，、。    ．    ．    ’

\subsection{运算符重载}

    C++允许我们重载函数，这就意味着可以荏同÷作用域内用同样的名字同时声明多个函数，
而只需保证它们的参数列表不网就可以承。t另外je千阜支持运算符重载(operator'- overloading)。也
就是说，当需要在自定义的类型内使用：内置辱簿符<比如、+、<<和[．]）时i就可以给它们分配特殊
的语义。    .-t’  -：≯’F事，0象。。每_：t、~．’    j．‘、：_
    我们已经看到了许多运算符重载的例子。当使用《把文字输出到一cout或者cerr时，我们并没
有触发C++的左移运算符，而是将其作为遵算簿趋|三种特殊使用形式：左侧带一个o。tream对象
(比如cout和cerr)，右侧带一个字符串(或者；也可以是一个数字或者是二个流控制器，比如endl)，
返回的是该ostream对象，而且也允许在一行中多次调用。
    运算符重载的巧妙之处在于我们可以让自定义类型的行为表现得就像使用内置类型韵行


    运算符可以被初始化力成员函数或者全局函数。在例子中，我们把+=和一=实现为成员函
数，把+和一实现为全局函数a-    ‘
    +：和一：运算符带一个指向另一个Point2D对象的引用，并在其他对象的x坐标和y坐标基
础上，对当前对象的x坐标和y坐标进行增或减运算。它们返回* this，该值表示一个指向当前对象
（它的类型是Point2D*）的引用。利用返回的这个引用，就可以写出特殊形式的代码，比如：  ．
a+=b+=C：
    +和一运算符带两个参数并且通过变量（不是一个指向现存对象的引用）返回一个Point2D对
象。inline关键字允许我们把这些函数的定义放在头文件中。如果某个函数的函数体比较长，那
么将会把该函数的函数原型放在头文件中，然后把该函数的定义（不带inl_ine关键字）放在一个
:cpp文件中。
    下列代码片断给出了编程应用中4种运算符的重载方法：  一’    。


也可以像调用其他函数一样来调用运算符函数：

    在C++中，运算符重载是一个复杂的话题，但是在不必详知所有细节的情况下我们仍旧可以
使用C++。但了解运算符重载的基本原理还是非常重要的，因为有多个q的类（包括QString和
QV曲tor<D）就是利用这一特性来提供一种更为简单和自然的语法的，比如字符串的连接和追加
等操作。

\subsection{值类型}


    Java和C#的主要区别在于两者的僮类型（valueye）和引用类型（reference帅e）的不同。
    ●值类型适用于基本类型，如char、int和noat，还有C#的s扛uctS。区分它们的主要特征在于创
    建它们时并不需要使用new。还有，在执行赋值运算时会对变量持有者进行复制。例如：

    。引用类型适用于一些类，比如Integer（在Java中）、s晡ng和M肌r）01帅clasS：实例是通过n洲创
    建的。执行赋值运算时，只是对指向这个对象的引用的复制。要想获得深度复制(deep copy)
    的效果，必须调用函数clone()（在Java中）或者Clone()（在C#中）。例如：

  ．在C++中，所有类型都可以用作“引用类型”，并且那些具有可复制性的类型也还可以用作
“值类型”。例如，C++不需要任何Integer类，因为我们可以像下面这样使用指针和new：


不像Java和C#．C++会像对待内置类型一样对待用户自定义的类：

如果想让某个C++类具备可复制性，那么必须确保类有一个复制构造函数(copy、constructor)和一
个赋值运算符。当用同一种类型的对象初始化另外一个对象时，就会调用复制构造函数。对于这
一操作，C++提供了两种等价的语法：    j

    在定义一个类时，C++编译器会自动提供一个复制构造函数和一个赋值运算符，以用于执行
成员到成员的复制。对于这个Point2D类，这样做就相当于在这个类的定义中写下了下列代码：

    对于某些类，默认的复制构造函数和赋值运算符可能都不够用。‘比如当这些类使用韵是动态
内存-.，通常就舍出观这弛耩形毒一要让该类具有可复制特性，就必须自己实现它的复制构造函数
和赋值运算符。一．  _~：一i：，    。    ，，．．：，~  r.’，    ‘
    对于-些不必具有可复制特性的类，可以通过让复制构造函数和赋值运算符成为私有(研一
vate)类型而禁用它们…如果随后不小心试图去复制该类的实例，那么编译器就会报错。j例如二

    在Qt中，许多类都被设计用作值类(value class)。它们都有。个复制构造函数和一·个赋值运
  算符，并且通常可以在没有new的堆栈上对它们进行实例化。用在这方面的例子有QDateTime、
  QImage、QSUing类和容器类，如QList<rr、QVector <1'>和QMap <K，T>。
    ．还有其他的一些类可以归入？引用类型”的范畴中，特别是QObject以及它们的子类（如QWid-
  get、QTimer、QTopSoeket，等等）。这些类都有虚函数，并且也都不能被复制。例如，一个QWidget表
  示一个具体的窗口或者屏幕上的一个控件。如果内存中有75个QWidget的实例；那么屏幕上也就‘
  有硒．个窗口或者控件j3这些类通常都使用new操作符来实例化。

\subsection{全局变量和全局函数}
C++允许声明一些不属于任何类的函数和变量，并且这些函数和变量可以被其他的任意函数
  访问。我们已经看到了多个全局函数的例子，包括作为程序人口的main()函数。全局变量还没有
  看到几个，因为它们需要在程序的模块和线程之间来回重复以求取折衷。但理解它们还是很重要
  的，因为你可能在那些C程序员高手和其他的C++用户那里会遇到它们。    ，．：。-  ．一r

    为了能够举例说明全局函数和全局变量是如何工作的，我们将会从研究一个小程序开始，该
程序使用quick-and-dirty算法打印一个由128个伪随机数构成的列表。这个程序的源代码放在两
个.cpp文件中。

。：j i第』个：cpp文件的源文件是random．cpp：    ：

    这个文件声明了两个全局变量(randomN umbers和seed)和两个全局函数[nextrandomN11n蚤er()和
populateRandomAnay()]。其中的两个声明包含了关键字static，这样的声明只有旌当前编译单元
( random. cpp)中才是可见的，可以把逮种情况称为静态连接(static linkage)。其他两个则可以从程
序的任意编译筚元书访问，可以把这种情况称为外部连接（e】矗hlalm氆南痨眷≮r?。一■T_f．…~
善。。：静态连接非常遥辔用于那些不需要在其他编译单元中使用的帮搦蔼数；}Ⅱ内部变量誊老可j以
降低标识符（具有同样名字的全局变量或者是在不同编译单元中具有同样署名的全局菌数．》弹突
的风险，．并且钶叛仿韭那些不怀好意或者是考虑不成熟-蝴j户访问≥个编译单元的：内部。？j二，
  现在1，让我们÷起来看-看第二个文件，mairt cpp，它使用了在-商idom;:: cpp文件牛角外部连接
声明的两个全局变量？：

    在调用外部变量和函数之前，需要先声明它们o'X+Irarid。mNumbers的外部变量声朗<可以让一
个外部变量在当前编译单元_申可见）以extem关键字并始。1设有. extem+，编译器就会认为它需要处
理的是一个不确定的定义j这样就会导致连接器报错，因为同一变量同时在两个编译单元(．an。
dom. cpp和Ⅱiain．cpp)中都棼定义了o二./p.要需要，可以任意多次地声明变量，.但~jci:能定义它们一
次。定义(definition)就是让编译器为该变量保留内存空间。    、

    populateRandomAnay()函数是通过使用函数原型来声明的。对于函数，extem关键字是可有可

  ．通常情况下，会把extemal：变量和函数声明放在头文件中，并且把该3件在所有需要它们的文
件中包含一次：．．，o  毒。澎‘.  ,、‘：    ~-¨一j．；？’：    ，

    我们已经看到了如何使用static来声明一些不属于任何一个类实例的成员变量和成员函数，
并且现在也已经看到了如何使用它来声明静态连接的函数和变量。statlc关键字还有另外一种用
法不能忘记。在C++中，可以声明一个局部静态变量(local static variable)。这样的变量会在第一
次调用函数的时候得到初始化，并且会在两个函数调用时保留它们的值。例如：  ．

局部静态变量除了只能在定义它们的函数中可见之外，在其他方面，它们都与全局变量一样。

\subsection{命名空间}
命名空间(namespace)是一种用于减少C++程序中名字冲突的机制。在使用了第三方软件库
的大程序中，名字冲突是一个常常需要提及的话题。在你自己的程序中，可以选择是否使用命名
空间。
    通常，我们把命名空间放在头文件中所有声明的周围，以确保在该头文件中声明昀所有标识
符不会与全局命名空间中的标识符相冲突。例如：

（需要注意的是，为了避免多重包含，我们对预处理器宏也进行了重命名，。以便降低与不同目录中
    r，
具有同样名字的头文件的冲突可能性。）
    命名空间的语法与类的语法相仿，但是它不以分号结尾。这里是random. cpp文件的新形式：

、  与类不同，可以在任何时候“重新打开”命名空间。例如：  一    ’

1．定义命名空间的别名

    在定义了别名之后，就可以用这个别名代替它原有的名字了。
2．从命名空间中导入一个简单的标识符

    这里的using声明可以让我们从一个命名空间中访问某个给定的标识符，而不用再把该命名
  空间作为标识符的前缀。
3．只用一条指令导入整个命名空间

使用了这种方法，似乎就更容易产生名字冲突了。如果编译器抱怨有二义性的名字（例如

    两个不同命名空间中定义了j两个具有相同名字的类），那么在需要引用这个名字的时候，通常
    就要使用命名空间来限定这个标识符。  ，

\subsection{预处理器}
c++盼预处理器( preprocessor)就是一个程序，它可以把，印p、源文件中包含的“#”指令符（比
如#include、#ifndef以及#endif等）转换成不再包含那些指令符的源文件。这些指令符可以对源文
件执行简单的文字处理操作，比如条件编译、文件包含以及宏扩展等。一般情况下，编译器会自动
调用预处理器，但是大多数系统仍旧提供了单独调用它的方法（通常是通过编译器的．E或者／E选
项来调用）。    ？    ~．
    1．#include指令会把尖括号或者双引号所包含的文件扩展成它们的内容，这取决于头文件是
    否是安装在标准位霉或者是否是当前工程中的_ A部分。文件名中可能会含有“．√，或者
    “／”( Windows编译器可以将其正确解释为目录分隔符)。例如：    。
  2．#define指令定义宏。在#define；指令之后，宏如果再次出现，那么就会在这些出现的地方
    用宏的定义来替换。例如，这里有一条#define指令：    一～一  -∥。-.？j

    这条指令会告诉预处理器把当前编译单元中所有出现PI记号的地方全部用3.141 592 653 59
    ‘来替换。为了避免与变量和类的名字冲突，在实际应用中，宏通常命名为全部大写的字母。


    ～，在宏体内量用圆括号包围出现的所有参娄蝗÷种不错的习惯j对于整个宏体也要如此，这样
    ．。就曩哗孽叁零纂簿佐袅级所出现的向题≯总而胄之，我们希望表达式7*som衄(2+3)
    ?7扩展后的绪某是、7。*((≥+‘j)*(2+j))，而不是7*、2+3*芝0 3就存亍。    ‘    、  。
    c++缔译器通常也允许在命令行中使用．D或者加选项来定义宏。例如：    ’：
    c‘一DPI=3.14159265359一c main.cpp    ”    +
    在引入类型别召、枚举、常量、内鹾和模板功能之前，宏是。种非常流行的使用方法。现如
    今，宏的最主要的角色就是用于避免头文件的多重包含。
  3．，可以在任何地方使用#undef来解除宏的定义：    ．j    一
    群undef PI    {    一，巾    ’
    这在我们希望重新定义宏的时候非步有用，因为孤处理器不允许我们把同一个去定义两
    次。在进行条件编译时，这一点也非常有用。    r


！，』在上面的例子中．；只有第二个typedef声明才会得到编译器：的处理：其结果将使Mylnt"定义
  为。hort的同意符。通过改变宏OPTIMIZATION的定义，就商以禧蓟禾墒的程序。．如果一个
  宏没有给定其定义值，那么它的值就会认为是0。    ？1 0哆0
  条件编译的另外一种用法就是可以用来测试一个宏是否被定义过。像下面这样使用de-
：fined()操作符，我们就可以做到这一点：  ：
5。为简便起见，预处理器可以识别#ifdef X和#ifndef X，并且会把它们当作#if;.defined( X)和
    #if! defined( X)的同义词。为了避免某个头文件越多次包筑可踢使用以下常毋方法来包
  ：由该文f4中的全部内容：


不像其他大多数的C++结构体，其中的空格不起任何作用，预处理器指令需要独占一行，
且不需要用分号结尾。对于非常长的指令，可以通过在除最后等行；铃冀纂‘獯鲍拳尾加
上一个反斜杠方法把指令分隔成跨行的表示形式p    、    ．    一．




\section{C++标准库}


    这一节将简单讨论C++标准库。图D.3列出了C++中的核心头文件；，头文件<exception>、
<linuts>、<new>和<typeinfo>支持C++语言，侧如，<limits>允许我们测试编译器a.<J整数和-点数

在数学方面的支持情况，<typeinfo>则为我们提供了基本的内省(introspection)功能。其他的头文件

也通常都提供了一些有用的类，包括一个字符串类和一组复杂的数值类型0由<bitset>、<locale>、
<string>和<tjpeinfo>提供的功能大致可以与Qt中的QBitArray、QLocale、QString和QMetaObject类
相当。

    标准C++也包含亍二组用于处理输入／输出的头文件，列在图D.4中的表格里。这些标准输
入／输出类设计字‘20谴凳电o年代并且也不算复杂，这使得非常难于扩展它们——实际上，仅就只
    j    ‘
说明这个困难性就足以写生j{/奉书。同时，它还给程序员留下了一个潘多拉魔盒；其中包含了许
多与字符编码相关和基手平台的基本数据类型的二进制数据表示方法等许多问题。

    第12章给出了相应的Qt类，其中给出了富有特色的统一字符编码标准输入／输出和传统大字
符集的字符编码，还给出了与平台无关的用于存储二进制数据的抽象类。Qt的输入／输出类构成
了Qt处理进程之间的通信、网络和XML支持的基础。Qt的二进制和文本流类都非常容易扩展成
处理自定义数据类型的类。
    20世纪90年代初期出现了标准模板库(SI'L．Standard Template Library)的介绍，它是一个基于
模板的容器类、迭代器类和在最后一刻才归人][SO标准C++的算法的集合。图D.5给出了构成标
准模板库的头文件列表。标准模板库非常简约，几乎全是提供一般类型安全功能的数学设计。Qt
提供了它自己的容器类，这些类的部分设计灵感就来自于标准模板库。至于这些，已经在第11章
    ‘    ．    、
中进行了阐述。    ：

    由于C++从本质上来说是c程序设计语言的一个超集，C++程序员也可以随意调用整个c
库。既可以通过传统方式（例如，<stdio．1l>）使用c头文件，也可以使用带一个c作为前缀并且没
有．h后缀的新风格（例如，<cstdio>）使用c头文件。当使用新风格方式对，这些函数和数据类型
都是在。td命名空间中声明的。(这不能用于像ASSERT()这样的宏，，因为预处理器不会指导命名
空间的存在。）如果休的编译器支持新风格的表达方式，那么就建议你使用这种方式。
    图D.6列出了用于c库的头文件。它们中的大多数都提供了与最新版夺的c++或者Qt的头
文件相同的功能。但有一个例外值得注意，它就是<cⅡiath>，只有它声明了二些诸如sin()、sqrt()
和pow()这样的数学函数。

    至此，就完成了对C++标准库的简要回顾。在因特网上，Dinkumware为C十十标准库提供了完
整的参考文档，网址是：http：//www. dinkumware．com/refxcpp．html，并且sGi在http：／／Ww．sgj．com/tech/
stl/为程序员提供了全面的STL编程指南。C++标准库的官方定义可以在“the C and C'++ standmds”
    ，：_：  ：+
中找到，可以从国际标准化组织(I苘，．Intematwnalz}i: amzai/on:for StandardizaUon)获得该文档的PDF格
式的文件或者纸质副本。
    在这一附录中，我们已经快速涉猎了许多有关C++的基础性东西。当从第1章开始学习Qt的
时候，你应当发现其中使用的语法还是要比这个附录中所提到的语法简单和有条理得多。在良好的
Qt程序设计中，只需要使用，C++j的子类，并且通常可以避免那些更为复杂的需求和那些可能让C++
变得晦涩难懂的语法。一旦在你开始键人代码并-且编j翠和运行可执行程序的时候，请晰而简便的．Qt
方法就会展现出来。1并且j．旦开始编写更其挑战硅的表序；芜其是在缟写那些需要兼具速度和技巧
的图形程序时，C++"tQi的组合就能够轻而易举地满足你的需求≥‘’


%这里空一行

\end{common-format}
\end{document}

