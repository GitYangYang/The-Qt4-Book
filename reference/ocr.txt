
第5章  创建自定义窗口部件
    这一章讲解如何使用Qt开发自定义窗口部件。通过对一个已经存在的Qt窗口部件进行子类
化或者直接对QWidget进行子类化，就可以创建自定义窗口部件。本章将示范这两种方式，并且也
会说明如何把自定义窗口部件集成到Qt设计师中，这样就可以像使用内置的Qt窗口部件一样来
使用它们了。最后，将通过展示一个使用了双缓冲技术（一种用于快速绘制的强大技术）的自定义
窗白部件来结束这一章的内容。

5.1  自定义t窗口部件
  ’在某些情况下，我们发现Qt窗口部件需要更多的自定义定制，这些定制可能要比它在Qt设计
师里可设置的属性或者对它调用的那些函数更多一些。一个简单而直接的解决方法就是对相关
的窗口部件类进行子类化并且使它能够满足我们的需要。
    这一节将开发一个如图5.1所示的十六进制微调框，以说明是如
何完成这一工作的。QSpinBox -般只支持十进制整数，但是通过子类
化方法，可以让它非常容易地接受并且显示十六进制数值。

    HexSpinBox从QSpmBox中继承了它的绝大多数功能，它提供了一个典型的构造函数，并且重
新实现了QSpinBox中的三个虚函数。    ，
我们设置的默认范围是从0到255(即从Ox00到OxFF)。对于十六进制微调框来说，这样的设
置比QSpinBox的默认设置值范围(从0到99)更为合适些。
    用户可以通过单击微调框的向上和向下箭头或者在它的行编辑器中输人数值来修改微调框
的当前值。在后一种情况中，我们想要严格控制用户输入的数据必须是合法的十六进制数字。为
了实现这一点，我们使用一个QRegExpValidator，它可以接受1到8个字符，所有这些字符都必须是

    这个函数由QSpinBox调用，用来检查目前为止用户输入文本的合法性。有三种结果可能会出
现：Invalid(无效，输入的文本与常规表达式不匹配)、Intennediate（部分有效部分无效，输入的文本是
～个有效值中似是而非的一部分）以及Acceptable(可以接受，输入的文本合法有效)。QR。gExpVali-
dator有一个合适的validate()函数，因此只需返回对其调用后的最终结果即可。理论上，应当为位
于微调框范围之外的那些值返回Invalid或者Intennediate，但是QSpinBox具有很好的自适应性，它
可以在没有任何帮助的情况下检测出那种情况。    ：  ’
    textFromValue()函数把一个整数值转换成一个字符串。当用户按下微调框的向上或者向下箭
头时，QSpinBox会调用它来更新微调框的编辑器部分。我们使用静态函数QString．：：numbe，()，将其
第二个参数设置为16，把该值转换为小写格式的十六进制字符串，并且对结果调用QString：：
toUpper()，使其成为大写格式的结果。
    valueFromText()函数执行从字符串到整数值的逆向转换。当用户在微调框的编辑器部分输入
一介值并且按下Enter时，QSpinBox就会调用它。我们使用QString：：tolnt()试着把当前文本转换成
一个整数值，当然还是使用16作为基数。如果这个字符串不是有效的十六进制数习5么就把ok设
置为false，并且由tolnt()返回一个0。在这里，不需要考虑这种可能出现的情况，因为此处的验证
器只允许输入有效的十六进制字符串。我们希望能够给tolnt()的第一个参数传递的是一个空指
针，而不是传递一个虚拟变量(ok)的地址。
    现在已经完成了这个十六进制微调框。自定义其他Qt窗口部件也可以遵循相同的模式：选
择一个合适的Qt窗口部件，对它进行子类化，并且通过重新实现一些虚函数来改变它的行为即
可。如果我们想做的全部就是对一个已经存在的窗口部件的外观进行自定义设置，那么只需对其
应用一个样式表或者重新实现一种自定义风格即可，而不必对其进行子类化，就像第19章中说明
的那样。
5.2子类化QWidget
    许多自定义窗口部件都是对现有窗口部件的简单组合，不论它们是内置的Qt窗口部件，
其他一些像HexSpinBox这样的自定义窗口部件。通过对现有窗口部件的组合构建而成的自定义
，窗口部件通常都可以在Qt设计师中开发出来：
    ●使用“Widget”模板创建一个新窗体。
    ●把一些必需的窗口部件添加到这个窗体上，并且对它们进行摆放。
    ●设置一些信号和槽的连接。
    ●如果通过信号和槽不能获得所需的行为，则只需在类中添加一些必要的代码即可――这个
    类需要同时从QWidget类和IUC生成的类中派生出来。
    当然，要对这些现有窗口部件进行组合，也完全可以通过手写代码方式来加以实现。但无论
使用的是哪种方式，最终生成的类都会是QWidget类的一个子类。
    如果窗口部件本身没有任何信号和槽，并且它也没有重新实现任何虚函数，那么我们甚至还
是有可能通过对现有窗口部件的组合而不是通过子类化的方式来生成这样的窗口部件。这就是
在第1章创建Age应用程序时所使用的方法，其中用到了一个QWidget、一个QSpinBox以及一个
QSLde。。虽然如此，也还是可以很容易地通过子类化QWidget，并且在它的子类构造函数中创建
QSpinBox郓QSlider．的方式来做到这一点。
    当手里没有任何一个Qt窗口部件能够满足任务要求，并且也没有办法通过组合现有窗口部
件来满足所需的期望结果时，仍1日可以创建出我们想要的窗口部件来。要实现这一点，只需通过
子类化QWidget，并且通过重新实现一些用来绘制窗口部件和响应鼠标点击的事件处理器即可。
这一方法给了我们定义并且控制自己的窗口部件的外观和行为的完全自由。Qt的一些内置窗口
部件，像QiLabel、QPushButton和QTableWidget，都是通过这种方法得以重新实现的。如果它们没有
在Qt中存在，那么还是完全有可能以与平台无关的方式使用QWidget所提供的公有函数来创建
它们。
    为了说明如何使用这种方法编写一个自定义窗口部件，
我们将会创建一个如图5.2所示的IconEditor窗口部件。这个
IconEditor本来是一个用于图标编辑器程序中的窗口部件。
    实际上，在我们开始潜心研究和创建一个自定义窗口部
件之前，还是很有必要先去检查一下是否已经有了可用的相
关窗口部件，无论是在Qt Solu【ion(http://wwW.trolltech.com/
products/qt/addon/soluUons/catalog/4/)申还是在商业或者非商业
第三方(http：//www．trolltech．com/products/qt/3 rdparty/)那里都
行，因为这样将很有可能会节省许多时间和精力。在本例中，
假设没有可用的合适窗口部件，因而需要创建我们自己的窗口部件。
    让我们先从它的头文件开始看起：

    类IconEciitor使用Q_PROPERTY()宏声明了三个自定义属性：penColor<iconlmage和zoomFacto，。
每一个属性都有一个数据类型、一个“读”函数和一个作为可选项的“写”函数。例如，penColor属性
的类型是QColor，并且可以使用penColor()和setPenColor()函数对它进行读写。
    当我们在Qt设计师中使用这个窗口部件时，在Qt设计师属性编辑器里，那些继承于QWidget
的属牲下面，将会显示这些自定义属性。这些属性可以是由QVant所支持的任何类型。对于定
义属性的类：Q_OBJECT宏是必需的。    ，．
IconEditor重新实现了QWidget中的三个保护函数，并且也拥有一些自己的私有函数和私有变
量。这三个私有变量保存这三个属性的值。
    实现文件是从IconEditor的构造函数开始的。

    枸造函数有一些巧妙的地方，比如这里的Qt：：WA StaticContents属性和setSizePolicy()调用。
我们将简单地讨论一下它们。
    画笔的颜色被设置为黑色。缩放因子(zoom factor)被设置为8，也就是说，图标中的每一个像
素都将会显示成一个8x8的正方形。
    图标数据会保存在image成员变量中，并且可以通过sedconlmage()和iconlmage()函数对它们
进行访问。当用户打开一个图标文件时，图标编辑器程序通常会调用sedconlmage()函数；当用户
C++ GUI Qt 4编程（第二版）
想保存这个图标时．，它就会调用iconlmage()来重新得到这个图标。Image变量的类型是QImage。
我们把它初始化为16×16的像素大小和32位的ARGB颜色格式，这种颜色格式可以支持半透明
效果。通过填充一种透明的颜色，就可以清空image中的数据。
    QImage类使用一种与硬件无关的方式来存储图像。可以把它设置成使用1位、8位或者32位
色深。一个具有32位色深的图像分别对每一个像素各使用8位来存储它的红、绿、蓝分量。剩余
的8位存储这个像素的alpha分量（即不透明度）。例如，一个纯红颜色的红、绿、蓝和alpha分量的
值分别是255、0、0和255。在Qt中，这种颜色可以通过如下形式给定：
    QRgb red=qRgba(255,0.7..f255);
或者，由于该颜色是不透明的，所以可以表示为：
    QRgb red i qRgbT255,0,’0);    ‘    ’、    ，
，  QRgb只是unsigned int类型的一个typedef(类型别名)，并且qRgb()和'qRgba()都是用来把它们
的参数组合成一个32位ARGB整数值的内联函数。也可能写成这样的形式：
    QRgb red=OxFFFFOOOO；
    这里的第1个FF对应于alpha分量，第2个FF对应于红色分量。在IconEditor的构造函数中，
我们通过使用0作为alpha分量而构成的透明色来填充这个QImage。
    Qt提供了两种存储颜色的类型：QRgb和QColor。虽然QRgb仅仅是一个用在QImage中存储
32位像素数据的类型别名，但QColor则是一个具有许多有用函数并且在q中广泛用于存储颜色
的类。在QIconEditor窗口部件中，只有在处理QImage时，我们才使用QRgb，而对于其他任意东西，
包括这里的penColor属性，我们都只使用QColor。

sizeHmt()函数是从QWidget中重新实现的，并且可以返回二个窗口部件的理想大小。在这里，
我们用缩放因子乘以图像的尺寸大小作为这个窗口部件的理想大小，但如果缩放因子是3或者更
大，那么在每一个方向上需要再额外增加一个像素，以便可以容纳一个网格绂。（如果缩放因子是
2或者1，就不必再显示网格线，因为这些网格线将几乎不能再给图标的像素留下任何空间。）
    在和布局联合使用时，窗口部件的大小提示非常有用。当Qt的布局管理器摆放一个窗体的
子窗口部件时，它会尽可能多地考虑这些窗口部件的大小提示。为了能够让IconEditor成为一个
具有良好布局的窗口部件，它必须报告一个可靠的大小提示。
    除了大小提示，窗口部件还有一个大小策略，它会告诉布局系统是否可以对这个窗口部件进行
拉长或者缩短。通过在构造函数中调用以QSizePolicy：：MiniⅡnⅡn为水平和垂直大小策略的setSize-
Policy(.)，会告诉负责管理这个窗口部件的任意布局管理器，这个窗口部件的大小提示就是它的最小
尺寸大小。换句话说，如果需要的话，可‘以拉长这个窗口部件，但是决不允许把它缩短到比它的大
小提示还要小的尺寸。在Qt设计师中，通过设置这个窗口部件的sizePolicy属性也可以实现这一
特性。第6~章将会解释各式各样韵大小策略。    ‘．

    函数sedconlmage()会设置需要编辑的图像。‘如果这个图像还不是我们正在编辑的图像，则会
调用convertToFormat()把它变成一个带alpha缓冲的32位图像。在其他代码中，将假设图像数据是
存储在32位的ARGB值中的。
    在设置完iⅡiage变量后，调用QWidget：：update()，它会使用新的图像强制重绘这个窗口部件。
接下来，调用QWidget：：updateGeometry()，告诉包含这个窗口部件的任意布局，这个窗口部件的大
心提示已经发生改变了。于是，该布局将会自动适应这个新的大小提示。
setZoomFactor()函数设置图像的缩放因子。为了避免在其他地方被0除，应纠正任何小于I的
  值。之后，会再次调用update()和updateGeometry()来重新绘制该窗口部件，以便可以把大小提示
  的变化通知给其他任何一个负责管理它的布局。    ，
    ．    一，r
    在头文件中，我们把penColor()、iconlmage()和zoomFactor()函数都实现成了内联函数。
    现在查看pa/ntEvent()函数的代码。这个函数是IconEditor最为重要的函数。只要需要重新绘
  制窗口部件，就会调用它。它在QWidget中的默认实现什么都不做，这样就留下了，个空白的窗口

    就像在第3章中碰到的closeEvent()函数一样，paintEvent()也是一个事件处理器。Qt还有很多
  其他的事件处理器，每一个都对应一种不同类型的事件。第7章将会进一步深入介绍事件的
  处理。
    当产生～个绘制事件并且调用pa/ntEverit()函数的时候，会出现如下几种情况：
    ●在窗口部件第一次显示时，系统会自动产生一个绘制事件，从而强制绘制这个窗口部件

    ●当重新调整窗口部件大小的时候，系统也会产生一个绘制事件。
    ・当窗口部件被其他窗口部件遮挡，然后又再次显示出来的时候，就会对那些隐藏的区域产
    生一个绘制事件（除非这个窗口系统存储了整个区域）。
    也可以通过调用QWidget：：update()或者QWidget.：：repaint(')来强制产生一个绘制事件。这两
  个函数之间的区别是：repaint()函数会强制产生一个即时的重绘事件；而update'()函数则只是在Qt
  下一次处理事件时才简单地调用一个绘制事件。（如果窗口部件在屏幕上是不可见的，那么这两
  个函数会什么也不做。）如果多次调用update()，Qt就会把连续多次的绘制事件压缩成一个单一的
-绘制事件，这样就可以避免闪烁现象。在IconEditor中，我们总是使用update()函数。

第5章创建自定义窗口部件
    一个窗口部件的调色板由三个颜色组构成：激活组( Active)、非激活组(Inactive)和不可用组
( Disabled)。应该使用哪一个颜色组取决于该窗口部件的当前状态：
    ●Active颜色组可用于当前激活窗口中的那些窗口部件。
    ●Inactive颜色组可用于其他窗口中的那些窗口部件。
    ●Disabled颜色组可用于任意窗口中的那些不可用窗口部件。
    QWidget:：palette()函数可以返回窗口部件的调色板，它是一个QPalette型对象。颜色组给定
为QPalette：：ColoICroup型枚举变量值。
    如果我们希望获得一个用于绘制的适当的画笔或者颜色，正确的方法就是使用当前调色板。它
可以通过QWidget：：palette()而获得，并且也可以使用所需的角色，例如，QPalette:：foreground()。每个
角色函数都可以返回一个画笔，它通常就正是我们所想要的东西，但如果我们只需要颜色的话，则
可以将其从画笔中提取出来，就像paintEvent()中所做的那样。默认情况下，返回的那些画笔都是
能够适用于窗口部件的状态的，因而就没有必要再去给定颜色组。
    以图像自舟的绘制作为paintEvent()函数的结尾。对IconEditor:：pixelRect()的调用会返回一个
QRect，其中定义了需要重新绘制的区域。（图5.4说明了矩形是如何绘制的。）作为简单的优化处
理方法，我们没有对落在这个区域之外的像素进行重新绘制。
    (width() -1,height() -1)
图5.4使用QPainter绘制一个矩形
    我们调用QPainter:：fllRect()来绘制一个缩放后的像素。QPainter:：fiⅡRect()带一个QRect和
一个QBrush。通过传递一个用作画笔的QColor，我们获得了一个实心填充图案。如果该颜色并非
完全不透明(它的‘alpha通道小于255)，就会先绘制出一个白色的背景来。

    pixelRect()函数返回一个适用于QPainter:：fmRect()酌QRect。这里的参数i和j是QJmage的
像素坐标，而不是窗口部件中的坐标。如果缩放因子是1，那么这两个坐标系就可以恰好一致了。
    QRect构造函数具有QRect(菇，，，，wtath，height)的语法形式，这里的（菇，，，）是这个矩形左上角的
位置坐标，而widt..h×height就是矩形的尺寸大小。如果缩放因子是3或者更大，则可以在矩形的
水平和竖直方向大小上都减去一个像素，以便在填充时不会覆盖那些网格线。
当用户按下鼠标按钮时，系统就会产生一个“鼠标按下”事件。通过重新实现QWidget：：mou。e．
PrI粥sEvent()，就可以响应这一事件，并且可以对鼠标光标下的图像像素进行设置或者清空。
    女口果用户按下了鼠标左键，则使用true作为调用私有函数setImagePix。l1()的第二个参数，告诉
它要把这个像素设茸成当前画笔的颜色：如果用户按下了鼠标右键，也会调用。etImagePixel()，但
这一次是通过传递false来清空这个像素。
mouseMoveEvent()赴理“鼠标移动”事件。默认情况下，只有当用户按住一个键不放的时候，才
会产生这些事件。通过调用QWidget：：setMouseTracking()则有可能改变这一行为，但是在这个例子
中不需要这样做。。
    就像按下鼠标左键或者右键可以设置或者清空一个像素一样，把按键按下不放并且悬停在另
一个像素上也足可以设置或者清空一个像素。由于有可能会同时按下多个键，所以最终结果实际
是QMouseEvent：：buttons()的返回值与鼠标的按键按照按位“或：！(|oR)运算之后的结果。可以使用
“&”操作符来测试某个特定键是否按下了，并且如果是这样的话，就调用setImagePixel()
    setImagePixel()西数是从mousePressEvent()和mouseMoveEvent()中得到调用的，用来设置或者清
空一个像素。pos参数是鼠标在窗口部件中的位置。
    第一步是把鼠标的位置从窗口部件的坐标转换到图像的坐标。这可以通过使用鼠标的x()．和
y()分量除以缩放因子完成。接下来，检查该点是否位于正确的范围之内。使用QImage：：re。t()和
QRect：：contains()可以很容易地完成这一检查过程。这样就可以高效地检查出i是不是在0和unt-
age.width() -1之间，j是否位t于0和'l/nage .height() -1之间。
    根据opaque参数，我们可．以设置或者清空图像中的像素。清空一个像素，实际就是把它设置
成透明。我们必须把画笔的QColor转换为一个用于调用QImaue：：setPixel()的32位ARGB值。最
后，对需要重新绘制的区域调用带QRect的update()。
    现在已经查看了各个成员函数，下面将回刭构造函数中使用的。Q：：WA_StaticContent。属性上。
这个属性告诉Qt，当重新改变窗口部件的大小时，这个窗口部件的内容并没有发生变化，而且它的
    第5章创建自定义窗口部件    89

内容仍旧保留从窗口部件左上角开始的特性。当重新定义窗口部件的大小时，通过使用这个信
息，Qt就可以避免对已经显示区域的重新绘制。图5.5图示了这一情形。

    图5.5重新改变Qt:：WA_StaticContents窗口部件的大小
    ’’
    通常情况下，当重新定义一个窗口部件的大小时，Qt会为窗口部件的整个可见区域生成一个
绘制事件。但是如果该窗口部件在创建时使用了Qc：：WA_ Stat/cContents属性，那么绘制事件的区
域就会被严格限定在之前没有被显示的像素部分上。这也就意味着，如果重新把窗口部件改变为
比原来还要小的尺寸，那么就根本不会产生任何绘制事件。
。  IconEditor窗口部件现在就完成了。．通过使用前几章中的知识和例子，我们编写代码，把
IconEditor作为一个独立的窗口，或者作为QMainWindow．申舶一个中央窗口部件、布局中的．个子
窗口部件以及QScrollArea(参见6.4节)中的一个子窗口部件。在下一节中，我们将会看到如何把
在Qt设计师中使用自定义窗口部件之前，我们必须让Qt设计师先察觉到它们的存在。有两
种方法可以完成这一任务：改进法( promot/on)和插件法(plugin)。    ：    ．。    ．
    改进法是最为快捷和简单的方法。这种方法包括：选择一个内置的Qt窗口部件t，但该窗口部
件要和我们自定义的窗口部件具有相类似的应用程序编程接口，并在Qt设计师的自定义窗口部
件对话框（如图5.6所示）中填写一些与这个窗口部件相关的信息。然后，这个自定义窗口部件就
可用于由Qt设计师开发的窗体中，尽管在编辑或者预览该窗体时它有可能仍旧显示为与之相关
的内置Qt窗口部件的形式。
。    ．    。。
图5.6 q设计师中的自定义窗口部件对话框
90
C++ GL11 Qt 4编程（第二版）
以下给出了如何使用这种方法在窗体中插入一个HexSpinBox窗口部件的步骤：    一
1．从Qt设计师的窗口部件工具盒中拖动一个QSpinBox到窗体中，由此创建一个QSpinBox。
2．右键单击这个微调框，并且从上下文菜单中选择“Promote to Custom Widget”（改进成自定义
  窗口部件）。
3．在弹出的对话框中，填入“HexSpinBox”作为类的名字，填入“hexspinbox．∥作为头文件的
  名字。
    这三步就足够了。由uic生成的代码将会包含hexspinbox．h，而不是<QSpinBox>，并且会生成
一个HexSpinBox的实例。在Qt设计师中，将会用QSpinBox的图标来代表HexSpinBox窗口部件，从
而允许我们设置QSpinBox的所有属性（例如，它的作用范围和当前值）。
    改进法的缺点是：在Qt设计师中，无法对自定义窗口部件中的那些特定属性进行访问，并且
也无法对这个窗口部件自身进行绘制。所有这两个问题都可以通过使用插件法得到解决。
    插件法需要创建一个插件库，Qt设计师可以在运行时加载这个库，并且可以利用该库创建窗
口部件的实例。在对宙体进行编辑或者用于窗体预览时，Qt设计师就会用到这个真正的窗口部
件，这要归功于Qt的元对象系统iQt设计师才可以动态获取它的这些属性的列表。’为了说明它是
如何工作的，我们将把前一小节中的IconEditor集成为一个插件。
    首先，必须对QDesigneICustomWidgetlnterface进行子类化，并且需要重新实现一些虚函数。假
定插件的源代码放在一个名为iconeditorplugin的目录中，并且IconEditor的源代码放在与iconeditor-
plugin目录同级的iconeditor目录中。
    以下是类的定义：    。
群include <QDesignerCustomWidgetlnterface>

    IconEditorPlugin予类是一个封装了这个IconEditor窗口部件的工厂(factoIy)类。它从QObject和
QDesigneICustomWidgetlter~ace中派生而来，并且使用Q_IRTERFACES()宏通知moc：这里的第二个基
类是一个插件接口。q设计师会使用这些函数创建这个类的各个实例并且获取相关信息。

构造函数非常简单。


第5章创建自定义窗口部件    91
name()函数返回由该插件提供的这个窗口部件的名字。
    includeFile()函数返回由该插件封装的特定窗口部件的头文件的名称。这个头文件会包含在
由LUC工具所生成的代码中。

    group()函数返回自定义窗口部件所应属于的窗口部件工具箱群组的名字。但如果以这个名
字命名的窗口部件工具箱群组还没有使用到，那么Qt设计师将会为这个窗口部件创建一个新
群组。

 icon()函数返回一个图标，可以在Qt设计师窗口部件工具箱中用它来代表自定义窗口部件。
这里，我们假定IconEditorPlugin有一个与之相关联的Qt资源文件(resource file)，其中有适当的一项
可作为图标编辑器图像。

toolTip()圈数返回一个工具提示信息，可在鼠标悬停在Qt设计师窗口部件工具箱中的自定义
窗口部件上时显示该信息。
whatsThis()函数返回用于Qt设计师“What's Tlus?”中显示的文本。

如果该窗口部件还可以包含其他窗口部件，isContainer()函数就返回true；否则；它就返回false。
例如，QFrame就是一个可以包含其他窗口部件的窗口部件。一般情况下，任何窗口部件都可以再

包含其他窗口部件，但是当isContainer()返回false时，Qt设计师则不会允许它再包含其他的窗口
部件。

Qt设计师会调用createWidget()函数，利用给定的父对彖创建该窗口部件类的一个实例。


    在实现该插件类的源文件的末尾，必须使用Q―EXPORT_PLUGIN2()宏，从而可以在Qt设计师
中使用这个插件。第一个参数是希望给插件的名字，第二个参数是实现该插件类的名字。
    用于构建该插件的．pro文件看起来如下所示：

qmake构建工具已经构建了一些预定义变量。．就是它们当中的一
个，它保存了指向Qt安装目录中plugins目录所在的路径。当键人make或者nmake来构建该插件
时，它就会自动把自己安装到Qt设计师的plugins/designer目录中。插件二旦构建宪毕，在Qt设计
师中就可以像使用其他内置的Qt窗口部件一样来使用IconEditor窗口部件。
    如果想在Qt设计师中集成多个自定义窗口部件，则既可以为每个窗口部件创建一个插件，也
可以通过从QDesigneICustomWidgetCollectionlnterface中派生的方式把它们组合成一个单一插件。
’  5.4双缓冲
    双缓冲(double buffering)是一种图形用户界面编程技术，它包括把一个窗口部件渲染到一个脱
屏像素映射( off-screen pixmap)中以及把这个像素映射复制到显示器上。在Qt的早期版本中，这种
技术通常用于消除屏幕的闪烁以及为用户提供一个漂亮的用户界面。
    在Qt 4中，QWidget会自动处理这些情况，所以我们很少需要考虑窗口部件的闪烁问题。尽管
如此，但如果窗口部件的绘制非常复杂并且需要连续不断地重复绘制时，明确指定使用双缓冲则
是非常有用的事情。于是就可以把这个窗口部件固定不变地存储成一个像素映射，这样就总可以
为下一个绘制事件做好准备，并且一旦收到绘制事件，就可以把这个像素映射复制到窗口部件上。
当我们想做一些小的修改时，比如一个橡皮筋选择框的绘制，此时并不需要对整个宙口部件进行
重复绘制和计算，从而就会显得特别有用。
    本章将通过回顾在图5.7和图5.9中显示的Plotter自定义窗口部件来结束。这个窗口部件使
用了双缓冲技术，并且也对Qt编程中的一些其他方面的知识进行了示范，包括像键盘事件处理、
手动布局和坐标系统等。

    第5章创建自定义窗口部件    93
    对于需要具有一个图形处理或者图形测绘窗口部件的真正应用程序来说，最好还是使用那些
可以获取的第三方窗口部件，而不是像这里所做的那样，去创建一个自定义窗口部件。例如，我们

Plotter窗口部件可以按照给定的矢量坐标绘制一条或者多条曲线。用户可以在图像中拖拽一
条橡皮筋选择框，并且Plotter将会对由这个橡皮筋选择框选定的区域进行放大。用户通过单击图
上的一个点、按住鼠标左键并且把鼠标拖动到另外一个位置，就可以拖拽出一个橡皮筋选择框，然
后就可以松开鼠标按键。Qt为绘制橡皮筋选择框提供了类，但这里通过我们自己来绘制它，以提
供更好的视觉控制效果，并且藉此说明双缓冲技术。．，    ，
    通过多次拖拽出橡皮筋选择框，可以重复进行放大操作。使用Zoom Out按钮可以进行缩小操
作，而使用Zoom In按钮又可以再放大回来。Zoom In和Zoom Out按钮在第一次出现的时候就处于
启用扶态。这样的话，如果用户没有对这个曲线图进行缩放，它们也不会弄乱图形的显示效果。
    Plotter窗口部件可以保存任意条曲线的数据。它还维护着一个PlotSett/ngs堆栈对象，而这每
一个堆栈对象都对应一个特定的缩放级别。
    让我们来查看一下这个类，先从plotter.h开始：
 苜先关注plotter头文件中包含的相应的Qt类头文件。在零件肇琴女譬聱劈jj还箭置声明了一些

在Plotter类中，提供三个公有函数来用于创建绘图区(：plot)，并且用薅个公有槽来响应图形的
放大和缩小操作。还重新实现了QWidget中的minimumS;izeHint(-和SrzeHint()两个函数。我们把曲
线的顶点存储为QVector <QPointF>t这里的？QPointF是二个其希浮j举数形式的QPomt。  ．

声明了一些用于绘制这个窗口部件的函数、一个常量和几个成员变量。
Margin帝量可以为图形区域的周围提供一些空间。
    在这些成员变量中，pixmap变量的类型为QPixmap。这个变量对整个窗口部件的绘制数据的
进行了复制保存，这和屏幕上显示的图形是相同的。绘图区总是先在脱屏像素映射上绘制图形。
然后，才把这一像素映射复制到窗口部件中。

    PlotSeffings类给定了x轴和y轴的范围，以及在这些轴上刻度标记符的数量。图5.8给出了一
个PlotSettings对象和一个Plotter窗口部件之间的对应关系。
    依照惯例，，把r/umXI'iCks和numYTicks部会减去1。如果numXI'icks是5，那么Plotter实际会在
x轴上绘制6个刻度标记符。这样可以简化后续运算。
    现在让我们查看一下它的实现文件：

setBackgroundRole()调用告诉QWidget使用调色板中的
“暗”分量作为重绘窗口部件的颜色，而不是使用“背景色”分
量。这样就可以为Qt设置一种默认颜色，当把这个窗口部件
重新改变成一个更大的尺寸时，甚至有可能是在paintEvent()
事件绘制那些新近显示的任意像素之前，就可以使用这种默
认颜色来填充这些新的像素。我们也需要调用se tAutoFill-
Background( true)来启用这一机制。（默认情况下，子窗口部件
会从它们的父窗口部件那里继承相应的背景色。）
    setSizePolicy()调用可以把这个窗口部件的大小策略设置
为在两个方向上都是QSizePolicy：：Expanding。这样就会告诉
图5.8 PlotSe/tings.的成员变量
负责这个窗口布局的任意布局管理器，这个窗口部件可以放大，也可以缩小，这对于那些要占用
很多屏幕空间的窗口部件来说，通常是一种比较典型的设置方法。在两个方向上，默认设置都是
QSizePoliqr：：Preferred，它的意思是指这个窗口部件的合适大小就是大小提示所给出的大小，但是如
果有必要，也可以无限放大它，或者也可以一直把它缩小到大小提示给出的最小大小。
    setFoucusPolicy(Qt：：StrongFocus)调用可以让窗口部件通过单击或者通过按下Tab键而输入焦
点。当Plotter获得焦点时，它将会接收由按键而产生的事件。Plotte。窗口部件可以处理一一些按键：
“+，，用来放大图形，“一”用来缩小图形，以及还可以使用四个方向键来上、下、左、右地滚动图形。
图5.9滚动Plotter窗口部件
    同样还是在构造函数中，创建了两个QToolButton，二者都有一个图标。允许用户通过这些按
钮进行缩小和放大操作。这些按钮的图标存储在一个资源文件中，因此任何使用Plotte，窗口部件
的应用程序都需要在它们的．pro文件中加入这一条代码：
资源文件与我们在Spreadsheet应用程序中曾经使用过的形式类似：

在这些按钮上调用的adjustSize()，可以把它们的大小设置成大小提示所给定的大小。这些按
钮没有放在布局中舛目反，我们将自己动手把它们放在Plotter的重定义大小事件中。由于没有使
用任何布局，所以必须通过对QPushButton的构造函数传递一个this指针来明确指定这些按钮所在
的父对象。    ．  ，  ．    。．
    最后，通过对setPlotSettings()的调用就完成了初始化工作：

setPlotSettings()豳数用于指定显示绘图区时所用到的PlotSettings。它可以被Plotter的构造函数
调用，也可以被使用这个类的用户调用。绘图区开始时使用它的默认缩放级。用户每放大一次，
都会创建一个新的PlotSettings实例，并且会将其放进缩放堆栈中。这个缩放堆栈由两个成员变量
来表示：
    ・类型为QVector <PlotSettings>的zoomStack保存不同的缩放级设置值。
    ・curZoom在这个zoomStack中保存PlotSettings的当前索引值。
    对setPlotSettings()进行调用之后，该缩放堆栈会只包含-项，并且Zoom In和Zoom Out按钮也
是隐藏的。只有当我们在zoomJn()和zoomOut()槽中对它们调用show()的时候，才会把这些按钮显
示出来。(一般情况下，在顶层窗口部件中调用show()足以显示所有的子窗口部件。但是，。当明确
地对子窗口部件调用hide()时，除非再次对它调用show()，否则它就．直会处于隐藏状态。）
    为了更新显示，refreshPixmlp()调用是很有必要t0'o通常情况下，本可以调用update()：但是这
里的傲法将会稍微有些不同，因为我们想让QPixmap在任意时刻都处于最新状态。在重新生成像
素映射之后，refreshPixmap()会调用update()。，会把像素映射复制到窗口部件中。一

图形放大后，可以使用这个zoomOut()槽进行缩小。它可以减小当前的缩放级数，并且可以根
据这个图形是否还允许缩得更小来设置Zoom Out按钮是否生效j Zoom In按钮会设置为生效并且
显示出来；而通过调用refreshPixmap()可以更新当前的显示结果a    ．

如果用户在此之前已经放大过图形并且又缩小了图形，那么用于下一缩放级数的PlotSettings将
会放在这个缩放堆栈中，因而就可以放大图形j（此外，还有可能通过橡皮筋选择框来放大图形。）  ：
    这个槽可以把curZoom移动到缩放堆栈中更深的位置上，它会根据是否允许把这个图形放得
更大来决定Zoom In按钮是生效还是无效，并且会启用和显示Zoom Out按钮。此外，会再次调用
refreshPixmap()，以便让这个绘图区能够使用到最新的缩放设置值。
setCurveData()函数设置了用于给定曲线ID中的数据。如果一条曲线的ID与girveMap中已经
存在的ID相同，那么将会用新的曲线数据替换原有的那些数据；否则，只是简单地插入新的曲线。
curveMap成员变量的类型为QMap <mt，QVector <QPointD>，    ，，

clearCurve()函数可以从curveMap中移除一条给定的曲线。

m/nimumSheHint()函数与sizeHint()函数相似。就像sizeHint()函数可以指定二个窗口部件的
理想大小一样，m/nimumSizeHint()可以指定一个窗口部件理想的最小大小。布局决不会把一个窗
口部件的大小修改为比它的最小大小提示还要小的大小。    二    ‘
    我们返回的这个值是300x 200(因为Margin= 5.0)，这可以在4条边上留出÷些空白区域，也可
以为图形本身留出一些空间。如果小于这个大小，那么该绘图区就会显得太小了，，也就没有什么

    茌sizeHint()中，我们返回一个和边白常量Mar~jn成比例的“理想”大小，它们会形成合适的3：2
比例，就像min/mumSizeHint()中用到的比例一样。    ’  。    ，。
    至此，就完成了对Plotter公有函数和公有槽的回顾。现在，来看一下处于protected段中的事件

    通常情况下，paintEvent()是执行所有绘制任务的地方。但这里，图形区的所有绘制任务都在
之前的refreshPixmap()中完成了，所以只需简单地通过把该像素映射复制到窗口部件的(O，O)位置
处来完成整个图形的绘制工作。
    如果橡皮筋选择框可见，则可以把它绘制在图形区的顶部。我们从窗口部件的当前颜色组中
选择“亮”分量作为画笔的颜色，这样可以确保绘制出的橡皮筋选择框能够与“暗”背景形成很好的
反差。需要注意的是，我们是直接在窗口部件上绘制的，而并未改变脱屏像素映射。使用QRect：：
nonnalized()可以确保这个矩形橡皮筋选择框的宽度和高度（如有必要，可以对换坐标）郡是正值，
并且adjusted()可以把矩形的大小减去1个像素，以允许它具有1像素宽的轮廓。
    如果Plotter拥有焦点，就会使用窗口部件风格的drawPrimitive()函数绘制这个焦点选择框(fo-
cus rectanle)，并使用QStyle:：PE_FrameFocusRect作为函数的第一个参数，使用QStyleOptionFocusRect
对象作为函数的第二个参数。焦点选择框各个绘制选项的初始化会基于Plotter窗口部件[通过调
用initFrom()]。背景颜色需要明确给定。
    当希望使用当前风格进行绘制时，则可以直接调用QStyle函数，例如：
也可以使用QStylePainter代替常用的QPainter，就像Plotter中所做的那样，并且使用QStylePa/nter会
使绘制工作显得更加方便些。
    QWiclget:：style()函数返回绘制窗口部件时应当使用的风格。在Qt中。窗口部件风格是QSt}le
的一个子类。内置的风格类型包括QWindowsStyle.QWindowsXPStyle、QWindowsVistaStyle、QMotifStyle、
QCDEStyle、QMacStyle~QPlastiqueStyle以及QCleanlooksStyle。每一种风格都重新实现了QSt}le中的
一些虚函数，它们会以该风格所模拟平台的正确方式来执行绘制操作。QStylePainter的drawPrimi-
tive()函数调用与QStyle中函数同名的函数，这样就可以用来绘制像面板、按钮和焦点选择框这样
的一些“基本元素”(primit/ve element)。在一个应用程序中，所有窗口部件的风格(QApplication：：
style())通常都是相同的，但是也可以在每个窗口部件的基础上使用QWidget：：setStyle()对它们的
风格进行重新定义。
  ：通过子类化QStyle，就有可能定义一种新的自定义风格。这样就可以为一个或者一组应用程
序设置一种与众不同的外观，就像第19章中将看到的那样。通常情况下，尽管我们认为使用目标
平台所提供的本地化外观是一种明智的选择，但如果你乐于探索的话，Qt还是为你提供了很大的
自由度。
    Qt的内置窗口部件几乎都只依赖于QSt}le来绘制自身。这就是为什么在'Qt支持的所有平台
上，它们看起来都像原有平台上的窗口部件一样。要获得与风格楣关的自定义窗口部件，既可以
通过使用QSt}le绘制它们自身的方式，也可以通过把Qt的内置窗口部件作为子窗口部件的方式。
对于Plotter，则使用这两种方式的组合：使用QSt}le(借助QStylePainter)绘制焦点选择框，而Zoom In
和Zoom Out按钮则使用Qt的内置窗口部件来完成。
第5章创建自定义窗口部件

只要一改变Plotter窗口部件的大小，Qt就会产生一个“重定义大小”事件。这里重新实现了
resizeEvent()，它把Zoom In和Zoom Out按钮放置在Plotter窗日部件的右上角。  ‘    ，
    我们把Zoom In和Zoom Out按钮一个挨一个地放好，它们之间有5个像素的间隔，并且距离它
们的父窗口部件的上边缘和右边缘各有5个像素。
    如果想把这些按钮总是放在图形的左上角，其坐标是(o，o)，那么只需在Plotte。的构造函数中
简单修改一下就可以了。但是，如果想追踪的是图形的右上角，那么此处的坐标就取决于窗口部
件的大小。正是因为这一点，重新实现resizeEvent()井且把这些按钮的位置放在那里就显得很有
必要了。    。二
    在Plotter的构造函数中，没有为按钮设置任何位置。但这不并是什么问题，因为‘在一个窗口
部件第一次显示之前，Qt总是会自动产生一个重定义大小事件。。。    一．二-
    除了通过重新实现resizeEvent()并且手动摆放这些子窗口部件这一方法之外，还有可能使用
的另外一种方法是使用布局管理器(例如，QCriidLayout)。使用布局可能会稍微有些麻烦，并且可能
会消耗更多的资源。另一方面，能够按照从右到左的方式来处理布局可能会显得更漂亮些，而且
这对于像阿拉伯语和希伯来语的那些语言来说也是很有必要的。    ：。j。√
    最后，调用refreshPixmap()，以按照新的尺寸大小重新绘制像素映射。  ‘  ：‘、

    驾用户按下鼠标左键，就开始显示一个橡皮筋选择框。这样会产生一系列事件，像把rubber-
BandIsShown设置为true，以当前鼠标指针所在的位置初始化rubberBandRect，调用―个绘制该橡皮
筋选择框的绘制事件以及把鼠标光标修改成十字形光标等。
    rubbcrBandRect变量的类型是QRect。QPLect既可以通过．4个分量（菇1，y，wulth，height）定义――
这里的（菇，，，）是它的左上角的点的位置坐标，width.×height是这个矩形的大小，也可以使用一个左
上角和一个右下角两个点而形成的一个坐标对来定义。这里使用的表示方法就是坐标对表示法。
我们把用户点击的点既当作橡皮筋选择框的左上角坐标又把它当作右下角坐标。然后，调周up-
dateRubberBandRcgion()来对橡皮筋选择框所覆盖的（最小）区域进行强制重绘。
    Qt提供了两种用于控制鼠标光标形状的机制：
-当鼠标悬停在某个特殊的窗口部件上时，QWidget：：setCursor()可以设置它所使用的光标形
100
C++'GUI Qt 4:编程（第二版）
状。如果没有为窗口部件专门设置光标，那么就会使用它的父窗口部件中的光标。顶层窗
，口部件的默认光标是箭头光标：‘  L    ’
・对于整个应用程序7中所使用的光标形状，可以通过QApplicaUoni：setOverrideCursor()进行设
置，它会把不同窗口部件中的光标形状全部覆盖掉，直到调用restoreOverrideCursor()。
    在第4章中，就调用了以Qt:：WaitCurosr为参数的QApplicaUon:：setOverrideCursor()，它把应用
程序的光标变成了标准的等待光标(wait cursor)。

当用户按下鼠标左键并移动鼠标光标的时候，会首先调用updateRubberBandRegion()未预约一
个绘制事件，由其对橡皮筋选择框所在的区域进行重新绘制。然后，重新计算rubberBandRect来说
明这次鼠标移动的距离。最后，调用updateRubberBandRegion()再一次对绘制橡皮筋选择框已经移
动到的区域进行重新计算。这样做，可以有效地擦除橡皮筋选择框，并且可以在新的坐标系中重
新绘制它。    、    ‘
  如果用户向上或者向左移动鼠标，那么rubberBandRect名义上的右下角看起来就好像跑到了
左上角的上面或者左面了。如果发生这种情况，那么这个QRect就会具有一个负的宽度或者高度
值。因此在paintEvent()中使用QRect：：nonnalized()，从而可以对它的左上角和右下角坐标进行调
整，以确保能够获得非负的宽度值或者高度值。

  驾用户释放鼠标左键时，会擦除这个橡皮筋选择框，并且把光标恢复成标准的箭头光标。如
果橡皮筋选择框不小于4x4，那么就执行缩放操作。如果橡皮筋选择框小于4x4，看来应当是用
户错误地点击了窗口部件，或者仅仅是为了让窗口部件获得焦点，所以就什么也不做。
  这段执行缩放的代码稍微有一点复杂。这是因为需要同时处理窗口部件坐标系和绘图区坐
    ・    J
第5章创建自定义窗口部件
101
标系。这里所做的绝大多数工作都是为了把rubberBandRect的坐标从窗口部件坐标系转换成绘图
    L    ．    ．
区坐标系。这一转换过程一旦完成，就可以调用PlotSetUngs：：ajust()圆整这些数据，并且为每根坐
    _    L
标轴找出一个合适的刻度标记符个数。图5.10和图5.11描述了这一处理过程。
(0，0)
图5.10把橡皮筋选择框的坐标从窗口部件坐标系转换成绘图区坐标系
图5.11调整绘图区坐标系并且放大橡皮筋选择框。
  然后，执行缩放操作。这一缩放工作的实现是通过把刚刚计算过的PlotSefUngs放到缩放堆栈
的顶端并且调用zoomln()来完成的。    …。

  。当用户按下_个键并且Plotter窟口部件拥有焦点时，就会调用keyPressEyent()函数。在这里，
我们重新实现该函数以响应6个按键：+、一以及向上-、向下、向左和向右4个方向键。如果用户
按下的是一个无法处理的键，那么就调用基类的实现。为简便起见，我们忽略了Shift、Cul和Alt这
些修饰键，可以通过QKeyEvent:：modifiers()来获得它们的状态。
 wheel)时，就会产生滚轮事件。绝大多数鼠标只提供一个垂直滚轮，但是也
有一些鼠标还提侠了另外一个水平滚轮。对这两种滚轮Qt都可以支持。滚轮事件会到达那些拥
有焦点的窗口部件。delta()函数可以返回一个距离，它等于滚轮旋转角度的8倍。，鼠标通常都以
15度作为步长。这里，通过修改缩放堆栈上最顶端的元素来改变所需的标记符的数量，并且使用
refreshPixmap()更新显示。    、
    鼠标滚轮最为常见的用法是用它来滚动一个滚动条。当使用QScronArea（将会在第6章中讲
到）来提供一些滚动条的时候，QScronArea会自动处理鼠标的滚动事件，所以不需要重新实现
wheemvent()。
    这样就完成了对事件处理器的实现。现在来看一下私有函数。


到调用，用来擦除或者重新绘制橡皮筋选择框。这个函数由4个update()调用组成，它们为橡皮筋
选择框（由两条垂直线和两条水平线构成）所覆盖的4个小矩形区域调用一个绘制事件。
    refreshPinnap()函数把绘图区重新绘制到脱屏像素映射上，并且对显示加以更新。我们把像素
映射的大小调整为与窗口部件的大小一样，并且使用窗口部件的擦除颜色来填充该像素映射。这
个颜色就是调色板中的“暗”分量，因为是在Plotter的构造函数中调用setBack&ounidRole()的。如果
背景色是一个非实心画笔，QPixmap:：fll()就需要知道窗口部件中的偏移量，像素映射需要在那里
恰好与画笔图案相对齐。这里，像素映射与整个窗口部件相对应，所以就指定位置(O，O)。

    然后，创建一个QPainter在这个像素映射上进行绘制。initFrom()调用可以设置painter所使用的
画笔、背景色和字体，这些都与Plotter窗口部件中的一样。接下来，调用drawGrid()和drawCLuves()来
执行绘制。最后，调用update()，从而为整个窗口部件预约一个绘制事件。在97页的paintEvent()
函数中，已经将把这个像素映射复制到窗口部件中。，

    drawCrid()卤数绘制曲线和坐标轴后面的网格。绘制网格的区域是通过rect给定的。如果窗
口部件不够大，不能容纳下这个图形，就立即返回。
    第1个for循环绘制了网格的垂直线和沿x轴方向上的标记符。第2个for循环绘制了网格的
水平线和沿y轴方向上的标记符。最后，沿空白区域绘制一个长方形。drawText()函数用于绘制两
个坐标轴上与记号相对应的那些数字。
    对于drawText()的调用遵循下面的语法形式：
定义了一个矩形，alignmenL是在这个矩形中文本的位置，而text就是要
绘制的文本。在本例中，已经人工计算出了用于绘制文本的矩形。另外一种具有更好适应性的方
法或许应当是使用QFontMetrics，其中包含了文本边界框的计算。  ，
drawCurves()函数在网格上绘制这些曲线。我们从调用setClipRect()开始，它为包含这些曲线
（边白和包围绘图区的框架除外）的矩形设置QPainter剪辑区。‘然后，QPainter将会忽略在这个区域
之外的像素绘制操作。
    一旦已经将_条曲线全部点的坐标都转换成了窗口部件中的坐标，就可以为用于这条曲线的画笔
设置颜色(使用预定义的颜色集之-)，并直调用dr?wPolyline(．)绘制F条经过该曲线上所有点的直线。
’  这就是完整的Plotter类。毋在只剩下PlotSettinE;s中aj:_些函数了。
 scroll()函数使用两个记号之间的距离乘以j个给定数字的方式来增加（或者减少）lninX、
maxX、minY和maxY的值。这个函数在Plotter:：keyPressEvent()中用来实现滚动功能。

    从mouseReleaseEvent()中调用的adjust()函数，用来把minX、maxX、minY和maxY圆整成“合适
的”数值，并且用于决定每一个坐标轴上应当使用的标记符个数。私有函数adjustAx/s()每次可以
处理一个坐标轴。

。adjustAxis()函数把它的nun和max参数转换成“合适的”数值，并且在给定的【nun，max]范围内
计算出合适的标记符个数，然后把它的numTicks参数设置成该值。因为、需要对变量
（minX、Ⅱ，axX、nurnXI'ick,s，等等）进行实际修改而不仅仅只是复制，所落《的i
adjustAxis()中的绝大多数代码都只是简单地试图确定两个记号之间适当距离的合适数值（这
里就是“步长”）。为了沿每一根轴都可以获禧这样的合适数值，必须小心地选择这爷步篝。侈jI如，
一个步长为3.8的数值会导致这根轴的长度应当是3.8的若干倍，但是这样的数值很难使人认同
它。+对于以十进制为标记的轴，“合适的”步长值应该具有像10“、2×10“或者5×10n这样的数值
形式。    1
    一开始，我们先计算“总步长”，它是该步长最大僮的一种形式。然后，找到一个小于或等于这
个总步长并且形式为10“的对应值。对它进行以10为基数的对数运算，然后对它取整，再以10为
底、以前面取整所得的整数为指数，从而形成幂的形式。例如，如果总步长为236，则计算．log 236：
2.-37291．．‘。然后，对它取整得到整数2，这样就可以得到l02= 100，也就是具有形式为lOn的一个
候选步长值。    ，j  i：  j．,'?    。，：    ’
    一旦获得了第一个步长候选值，就可以使用它计算另外两种形式的候选值：2×10”和5×
10“。根据前面的计算示例，这另外的两个候选值分别为200j和5010。而500比总步长要大，所以不
能使用它。200则比236要小，所以在这个例子中，我们使用200’作为步长值。
    利用这个步长值，就可以很容易地推算出numTicks、nun和max的值。新的nun值是小于初始
m/n值的最近的步长倍数值，而新的max值大于初始max的最近的步长倍数值。新的nurnTicks是
取整后的nuii和max之间的距离个数。例如，如果在这个函数中输入的nun为240并且rnax为
1184，那么新的范围就变为[200，1200]，有5个标记符。

这种算法在有些情况下给出的并不是最佳结果。发表在“Graphics Gems”(Morgan Kaufinann，
1990)上Paul S．Heckbert的文章“Nice Numbers for Graph Labels”中，描述了一个复杂的算法。
    通过这一章，就结束了本书的第一部分。这一章解释了如何对已经存在的Qt窗口部件进行
自定义，并且说明了如何使用QWidget作为基类来构建窗口部件的方法。第2章讲解了如何使用
已有的窗口部件来组建新的窗口部件，而在第6章还会对这一主题做进一步探索。
    到此为止，我们利用Qt已经足以编写出完整的图形用户界面应用程序。在第二部分和第三
部分，将会更进一步探索Qt，以使我们能够更为充分地利用Qt的强大功能。

二部
分  Qt中级
第6章  布局管理
第7章  事件处理
第8章  二维图形
第9章拖放
第。10章’项视图类
第11章容器类
第12章  输入与输出
第13章数据库
第14章  多线程
第15章  网络
第16章XML
第17章  提供在线帮助
第6章  布局管，理
    放置在窗体中的每一个窗口部件都必须给定-个合适的大小和位置。Qt提供了多个用于在
窗体中摆放窗口部件的类：QHBoxLayout、QVBoxLayout、QGridlayout和：QStackLayout。。这些类简单易
用，几乎每个Qt开发人员都会用到它们――或者直接在源代码中j或者通过Qt设计师。
    使用Qt布局类的另外一个原因是：它们可以确保窗体能够自动适应于不同的字体、语言和系
统平台。如果用户改变了系统的字体设置，那么该应用程序的窗体将能够立刻做出响应，并在必
要的情况下重新改变自己的大小。并且如果将应用程序的用户接口翻译成了另外一种语言，那么
这些布局类就会考虑窗口部件中翻译的内容，以尽量避免文本被截断的现象发生。    ：
    可以执行布局管理功能的其他类还有QSplitter、QScrollArea、QMainWindow和QMdiArea。这些类
所拥有的共同点在于它们提供了一种用户可以灵活掌控的布局方式。例如，QSplitter就提供了一
个切分窗口拖动条(splitter bar)j通过拖拽它，用户可以改变窗．日部件的大小。QMdiArea则为多文
档界面(multiple document interface．MDI)-可以在一个应用程序主窗口中同时显示多个文档的
方法――提供了支持。：因为它们经常适合用作布局类的替换方式，所以将在本章对它们进行详细
介绍。    ；一  ，，    i、    ‘    ，    ．
6.1．在窗体中摆放窗口部件
    7    7    、    ’    ，
    ・    ^    ，
：    二    ’  ．    一．    ，    ：
“。共有三种基本方法用于管理窗体上子窗口部件的布局：绝对位置法、人工布局法和布局管
    ，    i、    r    ，～’
遗器法。’我们将以图6.i中所给出的Find File对话框为例来依次说明这三种方法。
t。：？i、-，图,6，a Find.File对话框
    绝对位置法是一种最原始的摆放窗’口部件的方法a这可以通过对窗体的各个子窗口部件分
配固定的大小和位置以及对窗体分配固定的大小实现。这里给出的是使用了绝对位置法的Find-
FileDialog构造函数，它看起来具有如下形式：
第6章布局管理    109
Find FileDialog : : Find FileDialog ( QWidget   *pa rent)
   : QDialog(parent)
{
namedLabel->setGeomet ry (9,- 9, :50,  25) ;      ."            . : ^
namedLineEdit->setGeometry(65, 9, 200,' 25);          ' ' .
lookInLabel->setGeometry(9, 40, 50, 25);
lookInLineEdit->setGeometry(65, 40, 200, 25);
subfoldersCheckBox->setGeometry(9,. .71, 256, .23);  ..'  -, '  .t  .  .:       .
tableWidget->setGeometry(9, 100, 256, 100); :    ’
                                                                           .      '           ,:
messageLabel->setGeometry(9, r206, 256, 25); .          .t,  _:
findButton->setGeometry(271, 9, 85, 32); : . .     . : : ;'         : .
stopButtori->setGeometry(271,.'47, 85, _    :...       -   :. .  . :   \
closeButton->setGeomet ry(271, .84,_  "g;13g),》 { ; ;. :.
helpButton->setGeometry(271, 199, 85,        .";, :..: ' .:   t;~     ~  ':7     .
setWindowTitle ( t r ( " Find
setFixedSize(365, 240);
鲍对位置法有很多缺点：
Files or Fotders,,)l,;: ;.  ’ :   .  .
    ●用户无法改变窗口韵大小。’    +轧，  ‘  一．一  ‘，4r．'lt  ’：j i―
    o如果用户选择了一种不常用的大字体，或者当应用程序被翻译成另外一种语言时，也许会
    ‘一把一些文本截断。    ，  ‘、    ‘、、．    i  '一，．    h…：！．  +
    ．o对于某些风格的平台，这些窗口部件可能会具有并不合适的尺寸天：。，一  ，．．    ’
    o必须人工计算这些位置和大小。这样做不仅非常枯燥乏味且极易出错，并且还会让后期的
    ‘维护工作变得痛苦万分。
    T’。    1～、+t‘^^；    t：
    代替绝对位置法的另外一种方法是人工布局法。尽管还是需要绪建窗台舔梓的菇翥位盘，-值
是利用人工布局方法给定的大小尺寸总是可以和窗口的大小零比例，蒋毕书全依靠手写代码要好
得多了。通过重新实现窗体的resizeEvent()函数，该函数可以设置宙体f的子窗，日部件的几何形
    ’？    ？    4    ~，
状，就可以实现人工布局法。
 Find FileDialog : : FindFileDialog ( QWidget  *pa rent )         .                             /'  .          '
  ,: QDialog(parent) , .                           .  .
{                 .
                                                                                                                                                                                                   '    .
      setMinimumSize(265,  190) ;
.  resize(365, 240);   .                           .  1
void FindFileDialog::resizeEvent(QResizeEvent,*./* event */)
{
    int extraWidth = width() - minimumWidth{);
   int extraHeight = height() - minimumHeight();
   namedLabel->setGeometry(9r 9, 50, 25);
    namedLineEdit->setGeometry(65, 9, 100 + extraWidth, 25);  .
   lookInLabel->setGeometry(9, 40, 50, 25);
   lookInLineEdit->setGeometry(65, 40, 100 + extraWidth, 25); ..:.;'  I;
   subfoldersCheckBox->setGeometry(9, 71, 156 + extraWidth, 23);
    tableWidget->setGeometry(9, 100, 156 + extraWidth-:"   f.'”+ '; . ...  .
                            50 + extraHeight);
    messageLabel->setGeometry(9, 156'+ extraHeight, 156..+; extraWidth,
             25);
     findButton->setGeometry{171. + extraWidth, !                   ..'/, ;.     '
      stopButton->setGeometry(171 + extraWidth: ,j'7,"8:5,3_;2)'):~ . .  ..';
    closeButton->setGeometry(171 + extraWidth, 84, 85, 32),  .
    helpButton->setGeometry(171 + extraWidth, 149 + extraHeight: 85:' ::
}
110
C++ GUI Qt 4编程（第二版）
    在FindFileDialog构造函数中，我们把窗体的最小大小设置为265×190，把它的初始大小设置
为365×240。在resizeEvent()处理器中，将多余的任意空间都留给了那些希望变长或者变高的窗
口部件。这样就确保了当用户重新改变该窗体大小时，可以稳步地缩放它。
    就像前面的绝对位置法一样，人工布局法需要程序员对很多手写代码中的常量进行计算。像
这样来编写代码的确是一件烦人的事情，尤其是在改变设计的时候更是如此，并且它仍旧存在文
本会被截断的危险。通过考虑子窗口部件的大小提示，就可以避免这种风险，但是那样将会使代
    ，    。
码变得更为复杂。1
    对于在窗体上如何摆放窗口部件，最简便易行的解决方法是使用'Qt的布局管理器。布局管
理器会为每种类型的窗口部件提供一些合理的默认值，并且也会考虑每一个窗口部件的大小提
示，这些大小提示又通常会取决于该窗口部件的字体、风格和内容。布局管理器也会充分考虑其
最小和最大尺寸，并且会自动通过调整布局来响应字体的变化、内容的改变以及窗口大小的调整。
一种可以改变大小的Find File对话框新版本如图6.2所示。
    图6.2重定义可变尺寸耐话框的大小
    最为重要的三种布局管理器是：QHBoxLayout、QVBoxLayout和QGridLayout。这三个类从Qlayout
中派生出来，而Qlayout类为布局提供了基本框架。这三个类可以得到Qt设计师的完全支持，并
且也可以直接在代码中使用它们。
    以下是使用布局管理器的FindFileDialog的代码：
    Find FileDi.alog:: FindFileDialog( QWidget   *pa rent)
    ：QDialog(parent)
    {
QVBo
righ
righ
righ
righ
righ
rd      rd   ~ -O h   .r
L  ~-O r LU U lJ a)
Q o o -o C: L c:n'<r}
   -o r= ra rl a) -O _J
3  ra  rd J _l -O  rd  a)
o -t L c: c:   3 c:n
c: -o -O H H O O f0
-l -O -o -o -o -o -o -o
4J rd H rd rd rd rd rl
a) -o -o -o -o -o -o -o
y===3333
hoOOOi
J ra ra ra ra ra m ra
t
y
-J
x    ；
    iJ  IJ  iJ   . 4J
3 4J 4J =   iJ
c: ca ca a) .  :ca
  -o o \n   o
   rl lJ r -e
4J f \n u(_c
= -(( -C(
ra g g g a) g
J -O -O -O L -O
iJ rl rd r  IJ.:rl
 g-O -O d _O _O
rd -O -O -O -O -O
  illij
IJ iJ IJ iJ iJ IJ
oooooo
ra m m m m ra
J -J -J -J J -J
    第6章布局’管理    111
    ‘‘‘‘‘‘‘’‘！‘‘‘‘‘‘‘‘‘’.‘.......___________一
    setLayout (mainLayout);  i    ..    :
    setWindowTitle(tr( "Find  Files or Folders"));
    )
    通过一个QHBoxLayout、一个QGddLa)，out和一个QVBoxLayout，该布局就得到处理，如图6.3所示。
通过外面的QHBoxLayout，就把左侧的QGridLayout和右侧的QVBoxLayout -个挨一个地放在了一
起。对话框周围的边白和两个子窗口部件之间的间隔均被设置为默认值，该值取决于当前窗口
部件的风格，但通过QLayout：：setContentsMargins()和QLayout：：setSpacing()，可以对它们的值进行
修改。
图6.3  Find File对话框中的布局
    在Qt设计师中，也可以通过可视化的方式创建出同样的对话框，即：通过把这些子窗口部件
摆放在大致的地方，选择那些需要摆放在一起的窗口部件，然后再单击FomrbLay Out Horizontally，
Form+  Lay Out Verdcally，或者LayourbLay Out in a Grid印可。在第2章，我们就是使用这种方法创
建了用于Spreadsheet应用程序的Go to Cell对话框和Sort对话框的。
  ‘QHBoxLayout和QVBoxLayout的用法相当简单明了，但QGridLayout的用法则稍微有些麻烦。
QGridLayout的工作基于一个二维单元格。在这个布局中，左上角的QLabel的位置是(0，0)，而与之
相应的QLineEdit的位置是(0，1)。QCheckBox占用两列，也就是位置为(2，0)和(2，1)的两个单元
格。在它下面的QTreeWidget和QLable也占用两列。对于QGridLayout：：addWidget()的调用遵循如
下的语法形式：
layout->addWidget(w/dget, row, column, row5pan, column5pan};
  其中，wz:dget是要插入到布局中的子窗口部件，(rou)，column,）是由该窗口部件所占用的左上角单元
  格，mu)Span,是该窗口部件要占用的行数，而columnSpan,是该窗口部件要占用的列数。如果省略了
  这些参数，则参数mw Span,和．co如unnS，m将会取默认值l。
    addStretch()调用告诉垂直布局管理器，它会占满布局中这一处的空l可。通过添加一个拉伸
  项，就相当于已经告诉布局管理器，需要占用Close按钮和Help按钮之间的全部多余空间。在Qt
  设计师中，可以通过插入一个分隔符( spacer)来达到同样的效果，分隔符会显示成蓝色的“弹簧”
  形状。
√    对于目前所探讨的问题，使用布局管理器的确为我们提供了很多额外的好处。如果往布局中
＼    ，
112
C++ GUI Qt 4编程（第二版）
添加一个窗口部件或者从布局中移除一个窗口部件，布局都会自动适应所产生的这些新情况。如
果对一个子窗口部件调用了lude()或者shoiw()，也同样能够做到自动适应。如果一个子窗口部件
的大小提示发生了变化，布局将会自动进行调整，从而把新的大小提示考虑进去。还有，布局管理
器也会自动根据窗体中子窗口部件的最小大小提示和大小提示，从总体上为这个窗体设置一个最
小尺寸。
    在迄今为止所给出的每一个例子中。，我们只是简单地把窗口部件放置到布局中，并且使用一
定的分隔符元素（拉伸因子）来占用任何多余的空间。但在某些情况下，由此形成的布局看起来可
能还不是我们最想要的形式。在这些情形中，可以通过改变要摆放的窗口部件的大小尺寸策略和
大小提示来调整布局。
．  一个窗口部件的大小策略会告诉布局系统应该如何对它进行拉伸或者压缩。Qt为它所有的
内置窗口部件都提供了合理的默认大小策略值，但是由于不可能为每一种可能产生的布局都提供
唯一的默认值，所以在一个窗体中，开发人员改变它上面的一个或两个窗口部件的大小策略是非
常普遍的现象。一个QSiz ePolicy既包含一个水平分量也包含2个垂直分量。烈下是一些最为常
    L    ’    ’r    t
用的取值：    1    '
    r    1
    ●Fixed的意思是该窗口部件不能被拉伸或者压缩。窗口部件的大小尺寸总是保持为其大小
    ‘    ．    ．
  。提示的尺寸。
  ●Minimum;的意思是该窗口部件的大小提示就是它的最小大小。再不能把窗口部件压缩到比，
    这个大小提示还要小的大小，但是如有必要，可以拉伸它来填充尽可能多的空间。
‘●Maximum的意思是该窗口部件的大小提示就是它的最大大小。但是可以把该窗口部件压缩
    成它的最小大小提示的尺寸。
    o Pteferred的意思是该窗口部件的大小提示就是它比较合适的大小。但是如果需要，还是可
    以对该窗口部件进行拉伸或者压缩。
    。Expanding的意思是可以拉伸或者压缩该窗口部件，并且它特别希望能够变长变高。
  ：图6.4使用一个显示“Some Text”文本的QLabel为例，对这些不同的大小策略的含义进行了概括。
    置套李今聋示    I；大小提示，I
FixedoUl.lIF//e
………警辫鬻篓篓
Minimum匦暖圈―．图纛曛蒸飘
    、    一
Maximum  圈・一医曛l
Preferred圈一匮l一縻蓊溺
Expanding医圈．―寸匦麟泰圈―一匦重藤囊囊蘩圈
图6.4不同大小策略的含义
    在图6.4中，Prefened相Expanding描述成了同样的效果。但是，它们之间到底有何不同呢？在重
新改变一个既包含有Pteferred又包含有Expanding窗口部件的窗体的尺寸大小时，多出来的空间就会
分配给Expanding窗口部件，而Pteferred窗口部件仍旧会按照原有大小提示而保持不变。
    这里还有另外两种大小规则：MirumumExpanding和Ignored。前者仅仅用于Qt老版本的极少数
情况中，但是如今它已经不再会被用到了。‘一种比较好的方式是使用Expanding，并且再适当地对
mirumumSizel-Lnt()进行重新实现即可。后者与ExpandJ ng相似，只是它可以忽略窗口部件的大小提
示和最小大小提示。
∥
    耄
    ≯
    螽
    墓
    孽
    蔓
    錾
    萄
    增
第6章布局管理
113
    除了大小规则中包含的水平方向和垂直方向两个分量之外，，Q$izePolicy类还保存了水平方向
和垂直方向的一个拉伸因子。这些拉伸因子可以用来说明在增大窗体时，对不同的子窗口部件应
使用的不同放大比例。例如，假定在一个TextEdit的上面还有一个.QTreeWidget，并且希望这个t
QTextEdit的高度能够是QTreeWidget高度的两倍，那么就可以把这个QTextEdjt在垂直方向上的拉
伸因子设置为2，而把QTreeWidget在垂直方向上的拉伸因子设置为1。
    影响布局方式的另一种方法是设置它的子窗口部件的最小大小、最大大小或固定大小。当布
局管理器在摆放这些窗口部件的时候，它就会考虑这些约束条件。并且如果这样还不够的话，还
可以对子窗口部件的类进行派生并且重新实现sizeHint()_函数，由此获得所需的大小提示。    ．
6.2分组布局
    QStackedLayout类可以对一组子窗口部件进行摆放，或者对它
们进行“分页”，而且一次只显示其中一个，而把其他的子窗口部件
或者分页都隐藏起来。QStackedLayout本身并不可见，并且对于用
户改变分页也没有提供其他特有的方法，图6.5中的小箭头和暗
灰色框架是由Qt设计师提供的，利用它们可以使布局设计变得更
容易些。为方便起见，Qt还提供了QStackedWidget类，这个类提供
了一个带内置QStackedLayout的QWidget。    ．
QStackedLayout
．  分页是从o开始编号的。要使某个特定的子窗口部件可见，可以用一个页号来调用setCurrent-
Index()。使用indexOf()可以获取子窗口部件的页号。
    j    一  ‘
-・在图6.6中显示的Preferences对话框就是一个使用了QStackedLayout，的例子。这个对话框由
左侧的QListWidget和右侧的QStackedLayout构成。在QListWidget中的每i项，，费分别对应于
QStackedLayout中的不同页。这里给出了与这个对话框的构造函数相关的部分代码：
    P refe renceDialog::Prefe renceDialog(QWidget  *pa rent)    .
    ’    jQDiaLog（parent）    ：
e):  .
anged (int》
ndex(int》 )
    ．．I
    listWidget->setCurrentRow(0);    .
    )    --
    我们创建一伞QListWidget，并且把它和这些分页的名字一起配合使用。然后，创建一个
QStackedLayout，并且对每一个分页分别调用addWidget()。我们把这个列表窗口部件的currentRow-
Changed(i，1t)信号连接到这个分组布局的setCurrentlndexk int)，可以用来实现分页的切换操作，并且
    一    ’  ‘¨
在构造函数的最后，对这个列表窗口部件调用setCru ren/Row()，这样就可以把页号0设置为起
    ‘    ，
始页。
      N N -- --
JEEEE
 ----
?HHHH
Q -o -o -o -o
C -o -o -o -o
    ro ro ro ro
JlAAAA
   'I  l  I  I
IJ IJ -  -  -
Ol 01 g g g
-o -o -o -o -o
rl rl rl rl rl
33 W3 W
IJ IJ  -  IJ  -
  nn nn ro __ u  _.
   11, /D O- o) 3 C
    o- o- cn cn o a~
.. a~.t- 3 m a: L
- u Q o O- IJ L
= C cn z d C =
C, {1, 3 -0 Q) .Q) u
yLOCuL_
{1, {1, 1 < C L Q
J Q CO' 1、 {1, = cn
-o o-b.ri > u -
O p QJ  rr, d - F-
t rD 3 E rD _i o
u ----< -l
ro rJ rJ _  _ z S
ffl :071 071 071 0IH
o -o -o -o -o cn rJ
   trl rl rl rl    =
o -o -o -o -o - y
    rD tV (U rD g_i
Jl A A A Ad -O
- IJ - - t
Q Q Q Q o cn {i,
m m m m ro - cn
J _l _l _l _J -
-o -o d -o d -
114
C++ GUI Qt4编程（第二版）
    图6.6 Preferences对话框中的两个分页：
  利用Qt-设计9币创建这祥的对话框也是非常容易的：    ．    j
    ：    ；    ：
  11．基于‘‘Dialog”或者“Widget”模板，，创建一个新的窗体。    1
  ，2．在这个窗体上添加一个，QListWidget和一个QStackedWidget。
  3．用一些子窗口部件和布局来填充每一个分页。    ．．    一    i
    （要创建一个新的分页，可以在窗体上单击鼠标右键并且选择“Insert Page”；如果要在不同  l
    的分页间切换，可以点击QStackedW idget右上角的那个向左或者向右的小箭头。）    j
    i
  4．使用水平布局，把这些窗口部件一个挨一个地摆放好。    ；
  5．．把这个列表窗口部件的currentRowChanged (int)信号与分组窗口部件的setCurrentlndex( int)  i
    槽连接起来。    {
  6．把列表框的cuⅡentRow属性值设置为00    i
  由于已经使用预先定义的信号和槽来实现了分页之间的切换操作，所以当我们在Qt设计师  i
中预览这介对话框时i它将可以直接显示出正确的行为特性。    i
    1    穹
  对于页数较少或者可能会保持较小的一些情况，一种比使用QStackedWidget相QListWidget更  l
为简单的替换方法是使用QTabWidgeto一    婆
    §
    ：萋
6.3切分窗口
    QSplitter就是一个可以包含一些其他窗口部件的窗口、部件。在切分窗口(splittet)中的这譬
口部件会通过切分条' splitter handle)而分隔开来。用户可以通过拖动这些切分条来改变切分琶
中子窗口部件的大小。切分窗口常常可以用作布局管理器的替代品，从而可以把更多的控制耄
给用户。    ．．  ．
    QSplitter中的子窗口部件将会自动按照创建时的顺序一个挨一个地（或者一个在另外一●
下面）放在一起，并以切分窗口拖动条(splitter bar)来分隔相邻窗口部件。以下是用于创建如图
所示窗口的代码。
    int main(int argc, char *argv【1)
    {
    QApplication app(argc,  argv);    ,
    QTextEdit *editorl=new QTextEdit;
    QTextEdit..*:editor2=new -QTextEdit;    .‘一    ？  j
    QTextEdit *editor3=new QTextEdit;
    QSplitter splitter(Qt：：Horizontal)；    ，．，‘．兰薹
    第6章布局管理    115
    splitter,addWidget (editorl);    ,.
    splitter.addWidget(editor2);
    splitter,addWidget(editor3);
    splitter,show()；
    return app.exec()；
    }
┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┓
┃ klan enfant, ma soeur.         ┃jMychlld.myskter.    .   .'               ┃Efh,ein FOnd. melne Schwester.            ┃
┃ Songe b la douceur             ┃ think af the sweetness                   ┃'adenke an de几 Traum                     ┃
┃ D'aller th-bas dvre ensemhle,  ┃ af goIng there to ltve togetherl         ┃;;;:jdort hld(unterlm gehen um            ┃
┃Aimer a kisir,                  ┃ To lwe et lelsure,                       ┃jzusammen   .                             ┃
┃Almer et mourir                 ┃ to low and to die            '           ┃i;iz.u leben und in aller Ruhe zu Ueben,  ┃
┃ Au pays qul te ressemble. .    ┃  in a country that is the image of yoU!  ┃a:/ij Zu lleben und zu sterben            ┃
┃                                ┃                                          ┃;jlri dem Land, das dir glelcht.          ┃
┗━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━┛
    囹6.7': Splitter应用程序
    ‘    ^    ．    ．
    这个例子由三个QTextEdit组成，通过一个QSplitter窗口部件水平地摆放它们，图6.8给出了
它们的构成原理图。与布局管理器不同之处在于，布局管理器只是简单地摆放一个窗体中的子窗
口部件并且也没有可见的外形，但QSplitter是从QWidget派生的j并且在使用的时候，它也可以像
任何其他窗口部件一样使用。    、．“    ，    ：
    图6.8 Splitter应用程序的窗口部件，    ，…  ～
    通过对多个QSplitter进行水平或者垂直方向的嵌套，就可以获得更为复杂的』些布局。例如，
在如图6.9所示的Mail Client(邮件客户端)应用程序中，就由一个水平的QSplitter:~J成，而在它的
右侧又包含了一个垂直的QSplitter。图6.10给出了该布局的示意图。一：’‘．    一i㈡
图6.9  Mail Clienf应用程序
116
C+中GUI Qt 4编程（第二版）
图6.10  Mail Client的切分窗口布局图
以下是Mail Client应用程序QMainWindow子类的构造函数中所使用的代码：
MailClient::MailClient()
{
itte
itte
itte
itte
ralW
Qt::Verti
gesTreeWi
dit) ;
t::Horizo
sTreeWidg
plitter) ;
 r   .
        setWindowTitle ( t r( "Mail  Client" 》
       readSettings ( ) ;
  1在创建了我们希望显示的三个窗口部件之后，再创建一个垂直切分窗口．rightSplitter，并且把我
们想要的两个窗口部件添加到它的右侧。然后，再创建一个水平切分窗口mainSplitter，并且把我们
想要在左侧显示的窗口部件和想要在右侧显示的rightSplitter等这些窗口部件统统放进去。我们
把mainSplitter作为QMainWmdow的中央窗口部件。
    当用户重新改变窗口的大小时，QSplitter通常会重新分配空间，以便能够使所有的子窗口部件
的相对大小能够与先前一样保持相同的比例。在Mail Client例子中，我们想要的不是逮种行为，相
反，我们希望QTreeWidget和QTableWidget保持它们的大小不变，而把任何多余的额外空间都留给
QTextRlit。这一点可以通过两次调用setStretchFactor()来实现。第一个参数是切分窗口子窗口部
件的索引值，该值是一个从0开始的整数值；第二个参数是我们想要设置的伸展因子，伸展因子的
默认值是0。
    第一次是对rightSplitter调用setStretchFactor()，它会把位置1处的窗口部件(textEdit)的伸展因
子设置为1。第二次则是对mainSplitter调用setStretchFactor()，它会把位置1处的窗口部件(right-
Splitter)的伸展因子设置为1。这样将可以确保textEdit总是可以获取那些任何多余的可用空间。
    在启动应用程序时，QSplitter会根据子窗口部件的初始大小（或者在没有给定初始大小的时
候，根据它们的大小提示）给它们分配合适的大小。在程序中，可以通过调用QSplitter:：setSizes()来
移动切分条。QSplitter类也可以保存它的状态，并且可以在下次运行应用程序的时候直接恢复它
的状态值。似下给出了Mail Client应用程序的writeSettings()函数，它可以保存Mail Client的各个状
态设置值：    1
L cn 4J J  "v n 4J o L
o cn X u  . L -O _C t O
4J o o CI,   .O r O U t
t E t U_    J O .+ ra  J
rl(( _C     4J ._  L U_  rl
S g g§．p e e t S
Qd d r S g g e n
w眦眦虬  0州州”缸
e d d t  W W W S m
n d d e  e d d t C
  a a S  n d d e t
Il>>>    a a S e
  一一一  ll>>>g
r r r r    一一一d
.  rJ rl rJ rJ   m m m m o
  L L L- L  . E E E E tn
第6章布局管理    117
void  MailClient: :writeSettings()
{..    .
   QSettirigs settings("Software Idc,,,,' Ma/l Client")
settings, beginGroup ( "mainWindow" ) ;
settings, setValue ( "geomet ry " ,’:SaveGeomet ry ( 》 ;  .
settings . setValue ( "mainSplitte r" ,   mainSplitte r->saveSta'
settings . setValue ( " rightSplitte r" ,    rightSplitte r_>savlS:et( e》( ) ; ;
settings.endGroup();  ..
以下是用于相应的readSettings()函数中的代码：
void FlailClielnt': : readSettings ( ) l        .
                                                                                                  ,
   QSettings settings("Software Inc,", "Ma/l Client");
 settings. beginG roup ( "mainWindow" ) ;     J'           .
 rest o reGeomet ry ( settings . value ( "geomet ry" ) ,toByteA r ray ( 》
mainSplitter->restoreState(  . , ' '.
    .              settings.value ( "mainSplitter" ) .toByteA rray ( 》 ;
rightSplitter->restoreState( '
                        settings .value ( " rightSplitter" ) .toByteA r ray ( 》 ;
settings.endGroup() ;
    Qt谩计师完全支持QSplitter。要把多个窗口部件放到一个切分窗口中，可以先把这些子窗口
部件放置在期望的大致位置，选中它们，然后再单击FonⅡ一Lay Out Horizontally in Splitter或者Form
-*Lay Out Vertically in Sphtter即可。
6.4滚动区域
    QScroⅡArea类提供了一个可以滚动的视口和两个滚动条。如果想给一个窗口部件添加一个滚
动条，则可以使用一个QScrollArea类来实现，这可能要比我们自己通过初始化QScroⅡBar，然后再实
现它的滚动等功能简单得多。
    QScrollArea的使用方法，就是以我们想要添加滚动条的窗口部件为参数调用setWidget()，如
果这个窗口部件的父对象不是视口，QScrollArea会自动把这个窗口部件的父对象重定义为该视口
(可以通过QScroⅡArea：：yiewport()来访问），并且让它成为视口的子对象。例如，如果想在第5章中
开发的IconEditor窗口部件的周围添加滚动条（如图6.11所示），则可以编写如下代码：
int main(int argc, char *-argv[J)
i  QApplication app(argc, argv);
    IconEditor *iconEditor = new IconEditor;
            iconEdito r->setlconlmage (QImage ( ii :/images/mouse. png " 》
QScrollArea scrollArea;
sc rollA rea . setWidget (.iconEdito r) ;         ,
sc rollA rea . viewpo'rt ( ) ->setBackg roundRole ( QPaidtte :  :Da rk)
sc rollA rea . viewpo rt ( ) -,>setAutoFillBackg ro und ( t rue) ;
s c rollA rea . setWindowTitle ( QObject: :t r( "Icon   Editor"》 ;
scrollArea.show() ;
return  app.exec () ;
    囹6：12给出了QScroUArea的原理图，它会以窗口部件的当前大小来显示它，或者在没有重旁7
改变窗口部件大小的时候以它的大小提示来显示它。通过调用setWidgetResizable( true)，可以告j
QScroUArea要自动重新改变该窗口部件的大小，以利用超过它的大小提示之外的任何多余空旷  j
118
C++ GUI Qt 4编程（第二版）
图6.11重新调整QScrollArea的大小
  一~…_…    ’’’j  ’，    图6.12 QScrollArea的窗臼部件构成
    一。j；  、：  。一    、1  j  ’  ．    -  一    ，
    默认情况下，只有在视口的大小小于子窗口部件的大小时，才会把滚动条显示出来。但通过
设置滚动条的策略，可以强制滚动条总是可见：
    '    ．    1    。    -
    scrollArea. setHo rizontalSc rollBa rPolicy( Qt:: ScrollE    )n);
    sc rollArea.setVe rticalStrollBa rPolicy(Qt：：S'cr_ollBarAlwaysOn);
    、，，
    QScronArea从QAbsUactScronArea继承了它的许多功能。像TextEdit和QAbsUactltemVjew( Qt
项视图类的基类)这样的二些类，由于它们是从QAbstractScrollArea中派生出来的，所以为了获得滚
动条，就没有必要再把它们封装在QScrollArea中j    。’
6.5停靠窗口和工具栏
    停靠窗口(dock window);指一些可以停靠在QMainWindow中或是浮动为独立窗口，的窗口。
    1'
QMainWindow捉供了4个停靠窗口区域：分别在中央窗口部件的上部、下部、左侧和右侧。诸如像
Microsoft Visu:al Studio和Qt h/gLUst这样的应用程序都广泛使用了停靠窗口，以提供一种非常灵活
的用户接口方式。在Qt中，，各个停靠窗口都是QDockWjdget的实例。图6.13给出了一个带有工具
栏和停靠窗口的Qt应用程序。    ？。-
    每一个停靠窗口都有’自己的标题栏，即使它处于停靠时也是如此。通过拖拽这一标题栏，用
户可以把停靠窗口从一个停靠区域移动到另外一个停靠区域。通过把这个停靠窗口拖动到其他
停靠区域的外面，就可以把停靠窗口从．个停靠区域中分离出来，让它成为一个独立的窗口。自
                                                              '  - ..
                                                                                                       ' . '-
第6章布局管理    119
由浮动的停靠窗口总是显示在它们的主窗口，的上面。通过券声窗口部件标题栏上的“关闭”按钮，
    一    ～    “
就可以关闭QDockWldget。通过调用QDockWidget：：setFeatures()；就可以禁用所有这些特性以及它
    '    ．
    ’；：
们的任意组合。    7~    ：
    图6.13带一个停靠窗~口韵QMainWindow
    在Qt的早期版本中，工具栏采用与停靠窗口一样的处理方式，并且共享同一停靠区域。从
Qt 4开始，工具栏围绕中央窗口部件，占有它们自己的区域（如图6.14所示），并且不能取消停靠
( undock)。如果需要一个浮动工具栏，只需把它放进'QDockWidget即可。
图6:14．QMainWindow的停靠区域和芏具栏区域‘
      120                                               C++ GUI Qt 4编程(第二版)
-r
  ，用虚线显示的四个角可以属于两个相邻停靠区域中的任何一个。例如，假定我们需要让左上
角属于左侧的停靠区域，则只需调用QMainWir/dow：：setComer( Qt：：TopLeftComer，Qt：：LeftDockWid-
getArea)即可。
    以下程序片段说明了如何对QDockWidget中已经存在的窗口部件(在这个例子中，就是一个
QTreeWidget)进行封装，并把它插入到右侧的停靠区域：
    setAllowedAreas()调用说明对停靠区域加以限定即可以接受停靠窗口。在此给出的代码中，只
允许把停靠窗口拖拽到左侧和右侧的停靠区域，这两个地方都有显示它的足够垂直空间，因而可
以合理地把它显示出来。如果没有明确地设置所允许的区域，那么用户就可能把该停靠窗口拖动
到这四个可停靠区域中的任何一个地方。    ~  ’
    每个QObject都可以给定一个“对象名”。在进行程序调试时，这个名字会非常有用，并且一些
测试工具也会用到它。通常，我们不必费劲地给定窗口部件的名字，但是在创建一些停靠窗口和
工具栏时，如果希望使用QMainWindow：：saveState()和QMainWindow:：restoreState()来保存、恢复停
靠窗口和工具栏的几何形状及状态的话，给定窗口部件的名字就很有必要了。
    下面的代码显示了如何创建一个工具栏的过程，该工具栏包含一个QComboBox、一个QSpinBox
和一些QToolButton。其中的这些QToolButton来自QMainWindow子类的构造函数：  。
QToolBa r  *fontToolBa r  =  new  QToolBa r(tr( " Font "》 ;
 fontToolBa r->setObj ectName ( " fontToolBa r") ;     .
fontToolBa r->addWidget ( familyComboBox) ;
fontToolBar->addWidget (sizeSpinBox) ;  i          .
 fontToolBa r-. >addAction ( boldAction) ;
 fontTootBa r->addAction ( italicAction) ;
 fontToo'L Ba r->ad dAction ( unde rl'ineAction) ;
fontToolBar->setAllowedA reas (Qt: :TopToolBarArea
                         I Qt::BattomToolBarArea)
addToolBar(fontToolBar) ;
    知果想保存所有停靠窗口和工具栏的位置，以使下一次运行应用程序时能够恢复它们的值，
那么可以像以前在保存．个QSplitter的状态值时所使用的代码一样来编写类似的代码，也就是使
用QMainWindow的saveState()和restoreState()函数：
void MainWindow::writeSettings()  .
{
         QSettings  settings ( " Softwa re  Inc. " ,  "Icon  Edito r" )
          settings . beginG roup ( "mainWindow" ) ;
         settings. setValue( "geomet ry" ,  saveGeomet ry ( 》 ;
        settings. setValue( "state'l r  saveState( 》 ;
settings.endGroup();
}
void MainWindow: : readSettings ( )      .
                                                                                                      ,,
       QSettings  settings ( "Software  Inc, " ,  "Icon  Edito r" )
settings . beginGroup ( "mainWindow" ) ;
 resto reGeomet ry ( settings ,value ( "geomet ry" ) .toByteA rray ( 》 ;
 resto reState ( settings . value ( "state"i) , toByteA rray ( 》 ;
settings,endGroup() ;
j÷。+_?每蠹2蕊鼍誊一谤螽∥磷誊相琏麓一埘强均制封搿碉剩韵鞠刹辩嘲湖翎剽甥镧删剁捌潮
第6章布局管理
121
    最后，QMainWindow提供了一个上下文菜单，其中列出了所有的停靠窗口和工具栏。图6.15给
出了这个上下文菜单。用户可以使用这个菜单关闭和恢复停靠窗口，也可以用它隐藏和恢复工具栏。
6.6多文档界面
    在主窗口的中央区域能够提供多个文档的那些应用程序就称
为多文档界面(Multiple  Document .Interface，MDI)应用程序，或者称为
MDI应用程序。在Qt中，通过把QMdi_Area类作为中央窗口部件，
并且通过让每一个文档窗口都成为这个QMdi_Area的子窗口部件，
就可以创建一个多文档界面应用程序了。
图6.15 QMainWindow
    的上下文菜单
    对于多文档界面应用程序有一个惯例，就是为它提供一个Window菜单，这个菜单中包含一些
管理这些窗口以及这些窗口列表的命令。激活窗口会使用一个选择标记标识出来。用户通过在
Window菜单中单击代表特定窗口的一夏，就可以激活任何窗口。
    这一节将开发如图6.16所示的Editor多文档界乏应用程序，从而说明如何创建一个多文档界面
应用程序以及如何实现它的Window菜单。该应用程序的全部菜单如图6.17所示。
图6.16  Editor乡文档界面应用程序
图6 .17      Editor多文档界面应用程序的菜单
熬
圈嗣
    “≮一
¨壤嚣一
    懈熙
飘
122
C++=GUI Qt 4编程（第二版）
    这个应用程序由两个类组成：MainWindow类和Editor类。在本书的例子程序中提供了它的代
码，并且由于其中的绝大部分代码都与第一部分中的Spreadsheet应用程序相同或者相似，所以我
们仅仅给出那些与多文档界面相关的代码。
    让我们先从MainWindow类开始：
MainWindow: :MainWindow( )                                                     <.-.
{  . ,.
   mdiArea = new QMdiArea;     .
setCentralWidget(mdiArea);
            connect ( mdiA rea ,   SIGNAL ( s ubWindowActivated ( QMdiSubWindow* 》
         this, SLOT(updateActions(》);  .
.    . setWindoylcon (QPixmap(“':/:images/icon.png”))i    .i“;...  ’
    setWindowTitle(tr('”MDI Editor“));    ::
    QTimer:.singleShot (0,  this,  SLOT(loadFiles())j'P”~黏i,’7’  '’
．    }-    -．“二，’r
    ?    j
    在MainWindow构造函数中，创建7/-介QMdiArea窗口部件，并且让它成为中央窗口部件。我
们把QMdiArea的subWindowAc蔓黟ed()信号与将要用来保持更新Window菜单的槽连接起来，并且
会根据应用程序的状态来稿角或者禁用那些动作。
    在构造函数/最后，我们把单触发定时器的时间间隔设置为0毫秒，以调用loadFiles()函数。
对于这样的定时器，只要事件循环一空闲就会触发它。实际上，这意味着只要构造函数结束，同时
在主窗口显示出来之后，它就会调用loadFiles()。如果不这样做，而且如果还需要加载许多大文件
的话，那么该构造函数在文件加载完毕之前就无法结束。在此期间，用户极有可能在屏幕上看不
到任何东西，这样他可能会认为是应用程序启动失败了。
    void  MainWindow::loadFiles()
    {    ，    二    ．
    QSt'r'ingList args=QApplication旧rgoments();    .
    args.removeFirst();’    .  ,    .
    if (!args．isEmpty(》{
    foreach (QString arg, args)
    openFile(arg)；
    ‘    mdiA rea->cas cadeSLibWindows();
    、：}el se{～
    newFile()；
    }    ：i    一    ，
    mdiArea->activateNextSubWindow():
    }
    、    。’    ，
    如果用户在命令行中启动该应用程序时使用了一个或者多个文件名，那么这个函数就会试图
加载每一个文件，并且会按照逐级层叠的方式显示这些子窗口，以便用户可以轻松地看到它们。
Qt的一些特殊命令行选项，比如- style和- font，QApplication的构造函数会自动把它们从参数列表中
    ，：
剔除出去。因此，如果在命令行中写成：y
QApplication：：aruments()就会返回一个含有两个项（“mdieditor”和”readme．txt”）的QSUing口st，那么
MDIEditor应用程序就会在启动的时候打开readme．txt。
    如果在命令行中没有指定文件，就会创建一个空的编辑器子窗口，以便用户可以方便地直接
开始输入j对于activateNextSubWindow()的调用意味着对编辑器窗口赋予焦点，并且可以确保调用
upclateActions()函数来更新Window菜单，以及根据应用程序的状态来启用和禁用一些动作。
     .    ‘』
 . N       -，．、
--  (L
( .- Ln ro
Ln _ L m
c( ro Ln
O Ln m =
< H l- S
0000
IJ IJ IJ IJ
u u u.u
第．6章布局’管理
123
    void  MainWindow:: newFile()    .    ,
    {
    , EditOr *editor=new Editor;    ~
    editor->newFile()；
    addEditor(editor)；
    }
    newFile()槽对File―New菜单项做出响应。它创建一个Editor窗口部件，并且把它传递给add-
Editor()私有函数。
    void MainWindow::open()    .{:
    {    、  ．
    Editor *ieditor=Editor::open(this);
    iff
    。d ,jeditoditor）；
    ’    ．
    open()函数对File一Open菜单项做出响应。它调用Editor:：open()函数，该函数会弹出一个文
件对话框。如果用户选择了一个文件，就会创建一个新的Editor，读人文件的文本内容，并且如果
读取成功，就会返回一个指向Editor的指针。、如果用户取消了该文件对话框，或者如果读取失败，
就会返回一个空指针并通知用户出错。在Editor类中实现文件操作要比在MainWindow类中实现
文件操作更有意义，因为每个Edito，都需要维护它自己的独立状态。    一．    -
    +    r    』  ：  +    。  ，    ．    ．
    void  MainWindow::addEdito r( Edito r  *editor)
‘    {    “  ：    ：，    。q-  ‘
    connect(edito‘,SIGNAL(copyAvailable(bool)),    ‘    ,    .j．一
    cutAction,  SLOT(setEnabled( bool)));
    connect(e d.itor,SIGNAL( copyAvailable( bool)),    ,    ‘,,    、    ？
    copyAction,  SLOT( setEnabled( bool)));
    QMdiSubWindow丰subWindow=mdiArea->addSubWindow(editor);    j  一    ^‘  ’~    ‘  ‘、  .~    ’
    .  windowMenu->addAction( edito r->windowHenuActionl));    ’    r?    :_.
    windowActionGroup-’addActio“(edito‘―》windo州en“Actio“())_;    ,  ．  一    ：
    subWindow->show()；
    ’    ．．
    addEditor()私有函数会从newFile()和open()中得到调用，以完成一个新的Editor.窗口部件的
初始化。它以创建两个信号一槽的连接开始。根据是杏有选中的任意文本，这两个连接可以确保
Edit-  Cut和Edit―Copy菜单的启用或者禁用。
    因为我们正在使用的是一个多文档界面，所以完全有可能同时使用多个Editor窗口部件。这
一点之所以需要关注，是因为我们只对来自激活的Editor窗口的copyAvailable( bool)信号做出响应，
而不会对其他的Editor窗口做出响应。但由于只能由激活的窗口发射这些信号；i所以，实际上这并
    、    ，    J    、
不算什么问题。
    QMdiArea:：addSubWindow()函数创建一个新的QMdiSubWindow，把作为参数传递的该窗口部件
放进子窗口中，并且返回该子窗口。接下来，我们创建一个QAction，由其代表Window菜单中的一
个窗口。该动作由Ed/tor类提供，后面会说明这个类。我们还会在一个QActionGroup对象中添加
该动作。QActionGroup对象可以确保每个时刻只能选中Window菜单项中的一项。最后，对新的
QMdiSubWindow调用show()，使其可见。
    void  MainWindow:: save()
    {    ‘一    ！
    if (activeEditor(》    ．    ．
    activeEditor()->save();
    }
    加果存在激活的编辑器，save()槽就会对它调用Editor：：，save()。同样，执行真正工作的代码就
，放在Ed/tor类中。
124    C++ GUI Qt 4：编程（第二版）
 Edito r丰MainWindow: : activeEdito r ( )
{
       QMdiSubWindow丰subWindow = mdiArea->activeSubWindow( ) ;
   if (subWindow)
  .    . '  return qobject_cast<Editor *>(subWindow->widget(》
   return O;    .
    act/veEditor()私有函敛返回一个类型为Editor的指针，它指向当前激活的子窗口；或者在没有
激活的子窗口时，返回一个空指针。
    void  MainWindow:: cut()
    {
    if (activeEditor(》
    activeEditor()->cut();
  一    ）
    cut()槽可以对激活的编辑器调用Ed;itor：：cut()。：由于copy()槽和paste()槽都与cut()槽遵循
相同的模式，所以没有再给出它们的代码。
void MajnWindow::updateActions()  .
{.
  . bool'.hasEditor = (activeEditor() != o);
 '  bool hasSelection = activeEditor()     .
      '  '.   .                                 && activeEditor ( )=>textCu rsor( ) . hasSelection ( )
saveActio n->setEna bled ( hasEdito r) ;
saveAsAction->setEna bled ( has Edito r) ;
cutActio'n-. >setEnabled ( hasSelection ) ;
copyAction->setEna bled ( hasSelection ) ;
pasteAction->setEnabled { hasEdito r) ;
closeAction->set Enabled ( hasEdito r) ;
closeAllAction->setEnabled ( hasEdito r) ;
tileActio n->setEna bled ( hasEdito r) ;
cascadeAction->setEnabled ( hasEd.ito r) ;
nextActio n->setEnabted ( hasEdito r) ;
p reviousActio n->setEna bled ( hasEdito r) ;
sepa rato rAction->setVisible ( hasEdito r)
if   ( activeEdito r( 》              '  '
           activeEdito r ( ) ->windowMen uAction ( ) ->setChecked ( t rue) ;
    。每当一个新的子窗口成为激活窗口，或者在关闭最后一个子窗口时，都会发射subWindowActi-
vatcd()信号。在后一种情况下，它的参数就是一个空指针。这个信号会连接到updateAct/ons()槽。
    只有在存在激活窗口时，绝大多数的菜单项才会起作用。如果不存在激活窗口，就可以禁用
它们。最后，我们在QAction上调用setChecked()，表示这是一个激活窗口。由于有了QActionGroup
的帮助，就不必再明确地对前面的激活窗口进行解除选定操作了。
void  MainWindow::createMenus ( )
                                                                    .
windowMenu  -  menuBa r( ) ->addMenu (tr ( "6&\lindow"》 ;
 windo\dlen u->addAction ( closeAction )  ;                   .
windowMenu->addAction ( closeAllAction) ;
windowMenu->addSeparator( ) ;
windowMenu->addAction.(tileAction) ;
windowMenu->addAction( cascadeAction) ;
windowMenu->addSeparator( ) ;
windowMenu->addAction (nextAction) ;
windowMenu->addAction (previousAction) ;
windowtlen u->addAction ( sepa rato rAction ) ;
―，
第：6章布局，管理    125
    createMenus()私有函数会让这些动作和Window菜单一起配合工作。所有这些动作都是一些这
种典型的菜单项，并且可以很容易地使用QMdiArea的closeActiveSubWindow()~closeAllSubWindows()、
tileSubWindows()和cascadeSubWindows()槽来实现它们。每当打开一个新窗口时，都会把该动作添
加到Window菜单的动作列表中。[在123页的addEditor()函数中，就已经看到了是如何完成这一
过程的。]当用户关闭编辑器窗口时，就会删除它在Window菜单中的对应动作（因为该编辑器窗口
拥有这个动作），因而就会自动从Window菜单中移除这个动作。
void MainWindow::closeEvent(QCloseEvent *event)
{
           mdiA rea->closeAllSubWindows ( ) ;
'  if (!mdiArea->subWindowList(),isEmpty(》 {
  . event->ignore();
   } else {      '
               event->accept ( ) ;
    重新实现closeEvent()函数来关闶所有的子窗口，从而使得每个子窗口都要接收一个关闭事
件。如果这些子窗口的其中之一“忽略”了它的关闭事件（可能是因为用户撤销了一个“未保存变
化”的消息框），那么也就忽略对MainWindow的关闭事件；否则，我们就接受它，这样的结果就是Qt
会关闭整个应用程序。如果没有在MainWindow中重新实现它的closeEvent()，那么将不会给用户
留下对那些“未保存变化”进行存储的任何机会。
    现在已经完成了对MainWindow窗口的查看，因而就可以转到对Editor的实现上。Editor类表
示一个子窗口，它继承了QTextEdit，而QTextEdit提供了文本编辑功能。．在实际的应用程序中，如果
需要一个代码编辑的组件，也许会考虑使用ScintiUa，可以从http：//www．riverl）ankcomputing．co．uk/
qscintla/中获取专门用于Qt的组件QScintilla。
    就像任何Qt窗口部件都可以作为一个单独的窗口一样，任何Qt窗口部件都可以放进QMdi-
SubWindow．中，并将其作为多文档界面窗口工作区中的一个子窗口。
    以下是这个Editor类的定义：
class Editor : public QTextEdit
                                   .
   Q OBJECT
pu blic :        .'
   Editor(QWidget *parent = 0)
void newFile( ) ;
bool  save( ) ;
bool  saveAs ( ) ;
QSize sizeHint() const;
QAction *windowMenuAction() const { return action; }
 static Editor *open(QWidget *parent = O);
 static Editor *openFile(const QString &fileName,
                                    QWidget *parent = O) ;
p rotected:
  . void closeEvent(QCloseEvent *event),
private slots:
   void documentWasModified()
'p rivate:
  ' bool okToContinue();
     . bool  saveF.ile(const QString &fileName) ;
    void setCurrentFile(const QString &fileName);
    booL readFile(const QString &fileName);
      bool writeFile(const QString &fileName) ;
  126    C++ GUI Qt 4_编程<第二版）
    _-_-__。。_。_。_。_-，．--二，----_-一
,  .QString strippedName(const QString &fullFileNamejy  ,  j。    一  ．一    ’+
    QString curFile;    .    .,  :    .:
    bool isUntitled;    ，
    ‘    QAction *action;
    }；    、
    Editor类中已经包含了在Spreadsheet应用程序的MainWindow类中出现过的4个私有函数：ok-
ToConLinue()、saveFile()  .setCurrentFile()和strippedNaine().
    Editor::Editor( QWidg et   *'pa rent)
    ：QTextEdit( parent)
    {
    aCtion=new QAction(this);    ’~’    ‘
    action->setCheckable(true);
    ’connect(action,   SIGNAL(triggered()),thrsi'sLOT(show()));
    connect(action.SIGNAL(t riggered()),this,SLOT(SetFocus()));
    iSUntitled=trUe：
    ，。
    connect(document(),S工GNAL(contentsChanged()),    ,    .  ’
    this,SLOT(documentWasHodified()));
    ．’
    setWindowIcon(QPixmap(‘‘:／images／document.png”));
    setwindowTitle(”【+】“);
    setAttribute(Qt::WA DeleteonClose);
    }
    首先，创建一个QAction，用它表示应用程序Window菜单中的编辑器，并且把这个动作与show()
和setFc圮u5()槽连接起来。，。    ，，  ；．4
．  由手允许用户创建任意数量的编辑器窗口，所以必须为它们预备一些名字，这样就可以在第
一次保存这些窗口之前把它们区分开来。处理这种情况的一种常用方式是分配一个包含数字的
名称（例如，docurIlem1．戗t）。我们使用一个isUn甜ed变量来区分是用户提供的名称还是程序自动
创建的名称。    ：
    我们把文本文档的comentsCh．越ged()信号连接到documentWasModified()私有槽上。这个槽只
会简单地调用setWindowModifie【I（虹ue）。
    最后，为了防止用户关闭Editor窗口时出现内存泄漏，需要设置Qt：：WA-DeleteOnClose属性。
    void Editor::newFile()
    {    ，    、    ‘
    StatiC int docUmentNUmber=l;    ’    .    、
        cu rFile  =  t r( "document%l.txt " ) .a rg (documentNumbe r) ;
         setWindowTitle ( cu rFile  +  " [*] " ) ;
       action->setText ( cu rFile) ;
   isUntitled = true;
++documentNumber;
}
    newFile()函数会为新的文档产生一个像docurnentl. txt这样的名称。由于当在一个新创建的
Edito，中调用open()而打开一个已经存在的文档时，我们并不想白白浪费一个数字，因而把这段代
码放在了newFile()中，而不是放在构造函数中。由于documentNumber声明为静态变量，所以它可
以被所有的FAitor实例共享。
    在窗口标题中的“[*]”标记是一种位置标记符，在除Mac OS X系统平台之外的文件中，当存：
在未保存的变化时，我们就希望能够让这个星号出现。而在Mac OS X泵统中，未保存的文档会在
它们的窗口关闭按钮中出现一个点。已经在第3章（见48页）说明过这个位置标记符的用法。
    除了创建一些新文件之外，用户通常希望打开一’些已经存在的文件，即从文件对话框中打开
已有文件，或者从文件列表中打开已有文件。比如，从最近打开文件列表中选择一些文件打开。
第6章布局管理    127
为了支持这些用法，Qt提供了两个静态函数i open(’)用于从文件系统中选择一个文件的名字，而
openFile()用于创建一个Editor并且读人一个指定文件的内容。
Edito r  *Edito r: :open ( QWidget  *pa rent)
{       .
ost ring
if（fil
    ret
 fileName =
  QFileDialog: : getOpenFileName ( pa rent, . t r( "Open " ) r  ii . i' )
eName.isEmpty(》
urn 0,                              ,   .
                     retu rn  openFile ( fileName,   pa rent) ;
    静态函数open()会弹出一个文件对话框，用户可以通过它选择一个文件。如果选择了文件，
就会调用openFile()创建一个Editor并且读人该文件的内容。  ：
    ．    ’
    Edito'r *Editor::openFile(const QString &fileName, QWidget *parent)
    {
    Editor #editor=new Editor(parent);
    if( edito r-> read File( fileName)){
    edito r->setCur rent File( fileName);    、
    return editor;    ‘
    )else{    一
    delete editor;    ．
    return 0：
    )
    )    、
    这个openFile()静态函数从创建新的Editor窗口部件开始，然后会试着读人指定的文件。如果
读人成功，就会返回该Editor;否则，用户就会得到出现问题的信息[在readFile()中]，删除该编辑
    ．    ‘
器，并且返回一个空指针。
bool Editor::save()          .
{
  if (isUntitled) {
      return saveAs(.);  .'
   } else {      .
      return saveFile(curFile);
    }                   ..
            ..
save()函数使用isUntided变量来决定它是应该调用saveFile()还是应该调用saveAs()。
    ’  void  Edito r::closeEvent (QCloseEvent  *event)    ’  +    :
    {
    if( okToContinue()){
    event->accept()；
    ) else{
    event->ignore()：
    )    ，？
    )
    这里重新实现了closeEvent()函数，它允许用户保存那些未保存的变化。这部分逻辑判断代码
放在okToContinue()函数中，该函数可以弹出一个消息框：询问”Do you want to save your changes?”
（你想保存你的改变吗？）。如果okToConUnue()函数返回true，就接受这个关闭事件；否则，就“忽
略”它，并且让这个窗口不受其影响。
void  Edito r: : setCu rrentFile ( const  QSt r
 '  . . ' '         'String&filjName)
   curFile - fileName; .         .   .    .
   isUntitled = false; '
         action->setText ( st rippedName ( cu rFile 》 ;
  '    ' document ( ) ->setModified ( false) ;
        setWindowTitle ( st rippedName ( cu rFjle)  + :l [*] " ) ;
  128    C++ GUI Qt 4编程（第二版）
    setWindovdlodified(false);
    )
    setCurr℃ntFile()函数会在。penFile()和saveFile()中得到调用，用来更新curFile和isUntitled变
量，设置窗口的标题和动作的文本，以及用来把这个文档的“modified”标记设置成falseo -旦用户
修改了编辑器中的文本，底层的QTextDocument就会发射contentsChanged()信号，并且把它内部的
“modified”标记设置成tme。
QSize Editor: :sizeHint( )  const
         retu rn  QSize (72  *, fontMet rics ( ) .width( 'x' ) ;
                                     25  *  fontMet rics ( ) .lineSpacing ( 》 ;
    最后，根据字符“x”的宽度和文本行的高度，sizeHint()函数可以返回一个大小提示o QMdiArea
可以使用这个大小提示为窗口设定一个初始的尺寸大小值。
    多文档界面就是同时处理多个文档的一种方法。在Mac'OS x系统中，一种更好的方法是使
用多个顶层窗口。第3章的3.7节中已经介绍了这种方法。
第7章事件处理
    事件( event)是由窗口系统或者Qt自身产生的，用以响应所发生的各类事情。当用户按下或
者松开键盘或者鼠标上的按键时，就可以产生一个键盘或者鼠标事件；当某个窗口第一次显示的
时候，就会产生一个绘制事件，用来告知窗口需要重新绘制它本身，从而使得该窗口可见。大多数
事件是作为用户动作的响应而产生的，但是也有一些例外，比如像定时器事件，则是由系统独立产
生的。。；    、    ，  ．    L    -
    在使用Qt进行编程开发时，基本不需要考虑事件，因为在发生某些重要的事情时，Qt窗口部
件都会发射信号。但是当我们需要编写自己的自定义窗口部件，或者是当我们希望改变已经存在
的Qt窗口部件的行为时，事件就变得非常有甩了。
    不应该混淆“事件”和“信号”这两个概念。一般情况下，在使用窗口部件的时候，信号是十分
有用的；而在实现窗口部件时，事件则是十分有用的。例如，当使用QPushButton时，我们对于它的
clicked()信号往往更为关注，而很少关心促成发射该信号的底层鼠标或者键盘事件。但是，如果要
实现的是一个类似于QPushButton的类，就需要编写一定的处理鼠标和键盘事件的代码，而且在必
要的时候，还需要发射clicked()倍号。
7.1  重新实现事件处理器
    在Qt中，事件就是QEvent子类的一个实例。Qt处理的事件类型有一百多种，其中的每一种都
可以通过一个枚举值来进行识别。例如，QEvent:：type()可以返回用于处理鼠标按键事件的
QEvent::MouseButtonPreSS。
    许多事件类型需要的信息要比存储在普通QEvent对象中的信息多得多。例如，鼠标按键事件
既需要保存是哪一个按键激发了该事件的信息，又需要保存发生该事件时鼠标指针所在的位置信
息。这些额外信息就需要存储在专用的QEvent子类中，比如QMouseEvent。
  ’通过继承QObject，事件通过它们的event()函数来通知对象。在QWidget中的event()实现把绝
大多数常用类型的事件提前传递给特定的事件处理器，比如mou,sePressEvent()、keyPtessEvent()以
及paintEvent()。
    在前几章中，当实现MainWindow、IconEditor和Plotter时，我们已经看到过许多事件处理器。在
QEvent的参考文档中，还列出了很多其他类型的事件，并且也可以自己创建一些自定义事件类型
和发布一些事件，在此将会回顾两种值得详述的常用事件类型：键盘事件和定时器事件。
    通过重新实现keyPressEvent()和keyReleaseEvent()，就可以处理键盘事件了。Plotter窗口部件就
重新实现了keyPressEvent()。通常，我们只需要重新实现keyPr sEvent()就可以了，因为用于表明释
放重要性的键只是Ctrl、Shift和Alt这些修饰键，而这些键的状态可以在keyPressEvent()中使用
QKeyEvent:：modifiers()检测出来。例如，如果我们正打算实现一个CodeEditor窗口部件，那么要区分
按下的键是Home还是Ctrl+  Home，它的keyPressEvent()函数中的部分内容看起来应当是这样的：
void  CodeEdito r: :'keyPressEvent ( QKeyEvent  *event)
  switch (event->key(》 {
   case Qt::Key_Home:
            if  (event->modifiers( ) .& Qt::ControlModifier)
     130                                           C++ GUI Qt 4编程(第二版)
．．．．．．．．．，二，．二____．．．．．．．．．．．．．．．．．．．．．．二．．．．．．．．．．．．．二．．-_____一
 :            goToBeginningOfDocument ( )
   } else {
               goToBeginningOfLine ( ) ;
break;
case Qt::Key_End:
default :       .
          QWidget : : keyPres s Event ( event) ;
    Tab键和BackTab(Shift+ Tab)键是两种特殊情况。。在窗口部件调用keyPressEvent()之前，QWid-
get：：event()会先处理它们，它所包含的语义就是用于把焦点传递给焦点序列中的下一个或者上一
个窗口部件石这种行为通常正是我们想要的，但是在CodeEditor窗口部件中，我们或许更愿意让
Tab键起到缩进文本行的作用。于是，重新实现后的event()看起来应当是下面的样子：
bool CodeEditor::event(QEvent *event)  .     ,
{.
   if (event->type() == QEvent::KeyPress) {
' .      QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
  .   if (keyEvent->key() == Qt::Key_Tab) {
                              inse rtAtCurrentPosition ( '\t ' ) :
          return true;
             }
       return QWidget::event(event) ;
    加果该事件是一个按键事件，那么就把这个QEvent对象强制转换成QKeyEvent并且检查按下
的是哪个键。如果按下的键是Tab键，就做一些处理并返回true，告诉Qt已经把这个事件处理完
毕了。如果返回的是false，那么Qt将会把这个事件传递给它的父窗口部件来处理。
    实现键绑定的一种更为高级的方法是使用QAction。例如，如果在CodeEditor窗口部件中有
goToBeginningOfLine()和goTo
()两个公有槽，并且这个CodeEditor是用作Main-
Window类的中央窗口部件的，那么本可以使用下面的代码来添加键绑定：
，
MainWindow::MainWindow( )
{
   editor = new CodeEditor;
setCentralWidget(editorJ
goToBeginningOfLineAction =.
       new QAction(tr("Go to Beginning of
 goToBegin ningOfLineActio n ->setSho rtcut ( t r
connect(goToBeginningOfLineAction, SIGNAL
      editor, SLOT(goToBeginningOfLine(
  Line") ,  this) ;
activated( 》 ,
》;
goToBeginningOfDocumentAction =     .
       new QAction(tr("Go to Beginning of Document"), this)
goToBeginningOfDocumentAction->setShortcut(tr( "Ctrl+Home")) ;
connect ( goToBeginningOfDocumentAction,   SIGNAL ( octivated ( 》 ,
         .         editor,   SLOT (goToBeginningOfDocument ( 》 ) ;
    达样就可以很容易地把这个命令添加到菜单或者工具栏中了，就像第3章中看到的那样。如
果这些命令没有出现在用户界面中，那么就可以用一个QShortcut对象替换这些QAction对象，这个
类在QAction肉部用来支持键绑定。
    默认J隋况下，一旦把包含窗口部件的窗口激活，就可以在该窗口部件上使用QAction或QShortcut来
启用所设置的绑定键。但使用QAction::setShortcutContext()或者QShortcut：：set.Context()可以改变这一点。．
第7章事件处理    ．131
    另外一种常用的事件类型是定时器事件。虽然绝大多数的其他事件类型的发生是因为用户
的动作，但是定时器事件允许应用程序可以在一定的时I旬间隔后执行事件处理。定时器事件可以
用来实现光标的闪烁和其他动画的播放，或者只简单地用作显示的刷新。
    为了说明定时器事件，我们将会实现一个Ticker窗口部件，如图7.1所示。这个窗口部件显示
了一串文本标语，它会每30毫秒向左移动一个像素。如果窗口部件比文本宽，那么文本将会被多
次重复，直到能够填满整个窗口部件的宽度为止。
．以下给出的是头文件：
#ifndef TICKER H
#define TICKER H
#include <QWidget>
图7.1  Ticker窗口部件
class Ticker : public QWidget
                      .
Q_OBJECT
     Q: PROPERTY(QString text READ text WRITE setText)
public:
   Ticker(QWidget *parent = O)
void setText(const QString &newText);
QString text() const { return myText; }
QSize sizeHint() const;
protected: .
     void paintEvent(QPaintEvent *event) ;
   void timerEvent(QTimerEvent *event),
   void showEvent(QShowEvent *event),
   void hideEvent(QHideEvent *event);
private:.  .
   QString myText;
'  int offset;
   int myTimerld;
};             .
#endif
    1    _'
    我们重新实现了Ticker中的4个事件处理器，其中的3个以前不曾见到过：timerEvent()、show-
    ’    ．  +  ，
Event()和hideEvent()。
    ．    ：
    以下是它的实现文件：  ，
    #include <QtGui>    卜
    #include "ticker.hJI
 Tic ke r: : Tic ke r( QWidget   *pa rent )
          :  QWidget ( pa rent)
{
    offset=0：
    myTimerld=0；
，
构造函数把offset变量初始化为0。用来绘制文本的x坐标值就取自于这个offset值。定时器
的ID通常是非零的，所以可以使用0来表示定时器还没有启动。
 void  Ticker: :setText ( const .QSt ring  &newText )
 '  myText = newText;  .  '
132
C++' GUI Qt.4编程（第二版）
    ～    ‘
    ：}
    7．  J    ．    ’…
    r j．  ‘一    ：
    setText()函数用来设置要显示的文本。它调用update()强制执行一个重绘操作，并且调用update -
Geometr}-()通知对Ticker窗口部件负责的任意布局管理器，提示该窗口部件的大小发生了变化。
QSize  Ticker: : sizeHint ( )  const       .      '
{
         retu rn  fontMet rics( ) .size (0,  text ( 》
}
    sizel-lint()函数返回文本所需的空间大小，并以此作为窗口部件的理想尺寸。QWidget:：font-
Metrics()函数返回一个QFontMetrics对象；荀以用这个对象查询并获得与这个窗口部件字体相关的
信息。在这种情况下：，可以询问给定文本所需的必要大小。E QFonMetrics；：size()的第一个参数是
一个标识符j对于那些比较简单的字符串来讲并不需要它，因而只给它传递了二个0值。]  ‘
    ：    ，：    ～    ‘
    voi廿’Ticker五paintEvent( QPaintEvent+／+event+／)  :.,
    {    一    ．．    ，  ，：  一    ，    ．：
    QPainter painter(this);
    int  textW/dth=fontMet rics() .width( text());
    if (textWidth<1)
    return;    -：    ．
    int X=-offset：
  J’  -‘while‘.<wid‘“‘’j 2{ij o,7tE
    painter.drawText    ixtWidth,  he'ight().
    Qt::AlignLeft I Qt::AlignVCenter,  text());    、
    x十= teKtWldth；
    。)    ：．    ．    一：    一
：  ){：  i．，  ，；    ．一，    ．    ，    ’
    、    1
  ・paintEvent()函数使用QPainter:：drawText()绘制文本。它使用fontMetrics()确定文本在水平，方
向上所需要的空间，并且在考虑offset值的伺时，多次绘制文本，直到能够填充整个窗口部件的宽
度为止。    ，．    -
    void  Ticke r::showEvent( QShowEvent丰／丰event丰／)
    {    ．．
    myTimerld=startTimer(30);
    )
    showEvent()函数用来启动一个定时器。QObject:：startTimer()调用会返回一个ID数字，可以在
以后用这个数字识别该定时器。QObject支持多个独立的定时器，每一个都可以有自己的时间间
    -    -
隔。在startTimer()调用之后，大约每30毫秒Qt都会产生二个定时器事件。至于具体的时间精度，
则取决于所在的操作系统。
    _    ‘    -    ，
    我们本可以在Ticker的构造函数中完成swtTimer(,)的调用，但是只有在窗口部件实际可见的
时候，才有必要保存由Qt产生的定时器事件的那些资源。
    void  Ticker::time rEvent( QTime rEventf *event')    -    ’
    {    一
    if (event->timerld()一myTimerld){
    ++offset；    ，．
    if  (offset>三fontMet rics() .'width (text()))
    offset=0：    t
    scroll(-l, 0);
    ) else{  ，    ．
    QWidget::timerEvent(event);    一
    )    ：
    )
    系统每隔一定时间，都会调用一次timerEvent()函数。它通过在offset上加i来模拟移动，从而
形成文本宽度的连续滚动。然后，它使用QWidget:：scroll()把窗口部件的内容向左滚动一个像素。
第7_章事件处理
133
本来也足可以调用update()代替scroll()，但使用scroll()会更有效率，因为它只是简单地移动屏幕
上已经存在的像素并且只对这个窗口部件的新显示区域（此时，只是一个1像素乘以宽度的像素
条）产生二个绘制事件。    ，’    “。．    、    J    ‘
    如果这个定时器事件不是我们所关注的那个定时器，就可以把它传递给基类。
    void Ticker::hideEvent(QHideEvent丰／丰event丰／)    .  …  。
    {
    killTimer(myTimerld);    ！.、’  ‘  ‘…
    myTimerld=0；
  )    .+一    …,,.    ...i-  々,.、..  j.
hideEvent()函数调用QObject:：killTimer()来停止该定时器。；  ．，j。一  。    ：  ，
  ．定时器事件是一种低级事件，而且如果需要多个定时器时，保持对所有定时器ID的跟踪将会
变得很麻烦。在这种情况下，通常更为简单的方式是为每一个定时器分别创建_个QTimer对象。
QTimer会在每个时间间隔发射timeout()信号。QTimer也提供了一个非常方便的接口，可用于单触
发定时器（只触发一次的定时器），就像第6章（见122页）中看到的那样。    。
7.2支装事件过滤器
    Qt事件模型一个非常强大的功能是：QObject实例在看到它自己的事件之前，可以通过设置另
外一个QObject实例先监视这些事件。．-
    假定有一个由几个QLineEdit组成的CustomerInfoDialog窗口部件，并且我们想使用Space（空
格）键把光标移动到下一个QLineEdit中。这种非标准行为对于公司内部的某个应用程序来讲也
许是非常合适的，因为使用它的用户可能都早已训练有素了。一种更为直接的解决方案是子类化
QLineEdit并且重新实现keyPressEvent()，由它调用focusNextChild(-)，就像如下所示的形式：：’
    void  MyLineEdit:: keyPressEvent( QKeyEvent  *event)    、
    {    ：，，，    一    …
    if (event->key()==Qt::Key_Space){
    focusNextChild()：    ．    ，
    ) else{
    QLineEdit:: keyPressEvent (event):
    )    ．    ‘
    )    ‘_+    __’
    ，    +    ．二    ，
    这种方法有一个主要的缺点：如果在窗体中．使用了好几种不同类型的窗口部件(例如，QCom-
boBox和QSpinBox)．我们也必须对它们逐一子类化，以便让它们能够实现相同的行为。一个更好
的解决方案是让CustomerInfoDialog监视它的子窗口部件中键的按下事件并且在监视代码中卖现所
需的行为。这种方法可以通过使用事件过滤器来实现。创建一个事件过滤器包括如下两步过程：
    #，    ～‘
    1.通过对目标对象调用installE、rentFilter()来注册监视对象。．．  ．    。    ．．
    2．在监视对象的eventFilter()函数中处理目标对象的事件。
一个不错的注册监视对象的地方是在CustomerInfoDialog的构造，函数中：
    ’-
Cus to'me rInfoDialog::Custome rInfoDialog( QWidget  *pa rent)
    ：QDialog( pa rent)
{，
    firstNameEdit->in stall Event Fil ter( this);
    la stNameEdit->in stallEventFil ter( this);
    cityEdit->ins tallE vent Filter(this);
    phoneNurribe rEdit->install EventFilter( this);    t一．~    _’,    』1
    )
    首先，需要检查一下目标窗口部件是不是QLineEdit中'a<J -个。如果事件是一个按键事件，那
么就把它强制转换为QKeyEvent并且检查按下的是哪个键。如果按下的键是空格键，那么就调用
focusNextChild()把焦点传递到焦点序列中的下一个窗口部件并且返回true，告诉Qt已经处理了这
个事件。如果返回fal。e，Qt将会把这个事件发送给指定的目标对象，而在这个QLineEdit中产生一
个虚假的空格插入操作。
    如果窗口部件不是QLineEdit，或者该事件不是一个空格按键事件，那么就把控制权传递给它’
的基类的eventFilter()来执行。这个目标窗口部件也可能是某个基类(比如QDialog)正在监控的窗
口部件。（在Qt 4.3中，对于QDialog来说这不是什么问题。然而，其他的一些Qt窗口部件类，比如
QScroUArea，会因为各种各样的原因对它们自己的子窗口部件进行监控。）
    Qt提供了5个级别的事件处理和事件过滤方法。
1．重新实现特殊的事件处理器
    重新实现像．nousePre。。Event()、keyPressEvent()和paintEvent()这样的事件处理器是到现在力止
最常用的事件处理方式。我们已经看到很多有关这种处理方式的例子了。
2．重新实现QObject/：eVent()
，  ，通过event()函数的重新实现，可以在这些事件到达特定的事件处理器之前处理它们。这种方
式常用于覆盖Tab键的默认意义，就像在前面（见130页）看到的那样。这种方式也可以用于处理
那些没有特定事件处理器的不常见类型的事件中(例如，QEvent：：HoverEnter)。当重新实现event()
时，必须对那些没有明确处理的情况调用其基类的event()函数。
3．在QObject中安装事件过滤器1、
    ‘对象一旦使用installEventFilte。()注册过，用于目标对象的所有事件都会首先发送给这个监视
对象的eventFilter()函数。如果在同一个对象上安装了多个事件处理器，那么就会按照安装顺序逆
序，从最近安装的到最先安装的，依次激活这些事件处理器。
4．在QApplication对象中安装事件过滤器
    一旦在qApp(唯一的QApplication对象)中注册了事件过滤器，那么应用程序中每个对象的每
个事件都会在发送到其他事件过滤器之前，先发送给这个eventFilter()函数o这种处理方式对于调
试是非常有用的。它也可以用来处理那些发送给失效窗口部件的鼠标事件，因为QApplication通
常都会忽略这些事件。
    口
    窗    ，
    荽．
    蒜_
    柑一
_  舭拍    叭，
州？=叽
    一  沁
    ～  ¨    ？
一．一一一一一一一一州
    ■孙  -
    ．，
m粉一  瓣黜
发一一．一一一～一～，''一    一
    l：t q    叼
    I叶5=    ?a
    [e==；
    册一    一删粤
    戛
    器、
    滤・
    譬  ～量_  -
    倍一一一一一一――oo  ．一
    眦呲    呼
    。L
    ・1上
    I〉K 1    }    D
    I忙0。一    Q
    、    n
    ”    ，：盯
    事一    ～…    。y陀
    个膊虾姒
弘  这    w t
 1    舯
第7章事件处理
135
5．子类化QApplication并且重新实现notify()    ’
    Qt调用QApplication：：notif()来发送一个事件。重新实现这个函数是在事件过滤器得到所有
事件之前获得它们的唯一方式。事件过滤器通常更有用，因为可以同时有多个事件过滤器，而no -
tify()函数却只能有一个。    ’
    很多事件类型，包括鼠标事件和按键事件，都
可以对它们进行传递。如果在事件到达它的目标
对象之前没有得到处理，或者也没有被它自己的
目标对象处理，那么就会重复整个事件的处理过
程，但这一次会把目标对象的父对象当作新的目
标对象。这样一直继续下去，从父对象再到父对
象的父对象，直到这个事件完全得到处理或者是
到达了最顶层的对象为止。
图7.2对话框中事件的传递
    图7.2给出了一个按键事件是如何从对话框，
的子对象传递到父对象的过程。当用户按下一个键时，这个事件就会首先发送给拥有焦点的当前
窗口部件，在本例中就是对话框右下角的QCheckBox。如果QCheckBox没有处理这个事件，另B么Qt
就把它发送给QGroupBox，直到最后的QDialog对象。    、
7.3处理密集时的响应保持
    当调用QApplicadon：：exed()时，就启动了Qt的事件循环。在开始的时候，Qt会发出一些事件
命令来显示和绘制窗口部件。在这之后，事件循环就开始运行，它不断检查是否有事件发生并且
把这些事件发送给应用程序中的QObjecto  ．    一
    当处理一个事件时，也可能会同时产生j些其他的事件并且会将其追加至Qt,的事件队列中。
如果在处理一个特定事件上耗费的时间过多，那么用户界面就会变得无法响应。例如，在应用程
序把一个文件保存到磁盘的过程中，直到文件保存完毕，才会处理那些由窗口系统产生的事件。
在文件保存过程中，应用程序就不能响应来自窗口系统的重新绘制的请求。
    在此情况下，一种解决方法就是使用多线程：一个线程用于处理应用程序的用户，界面，另外一
个线程则执行文件保存操作（或者任意的其他耗时操作）。这样的话，在保存文件的时候，应用程
序的用户界面仍然可以保持响应。第14章中将看到如何实现这一方法。、
    一种更为简单的解决方法是在文件保存的代码中频繁调用QApplication:：procbssEvents()。这
个函数告诉Qt处理所有那些还没有被处理的各类事件，然后再将控制权返还给调用者。实际上，
QApplicatjon：：.exec()兢是一个不停调用processEvents()函数的while循环。    。．    ，  一
    以下是一个如何使用processEvents()来保持用户界面响应的例子，该例基于Spreadsheet（见65
页）的文件保存功能的程序代码：
    bool Spreadsheet::writeFile(conat QSt.ring &fileName)
    {    ，
    QFile .file(fileName);  4    .    .  :
QAppljcation:
for (int row
   for (int
   .           OSt ri
  ..o
rso
unt
(co
:++column) {
 , '.           .
umn)“ str;
 =( Q -- .  .6
u  u C  r-l
4- -- C E   4J
 .. + u
}J      -   v
o .N v )   v
- -J     o
L C C L  _.
O=E- 3
 S o = O  o
LUlLlL  L
= ) o =---
U o U E，6
 v a:      L _ r-l
 o      .- Q y 4J
 _l v 0 .+- 4J C
   L    p .r:l
L 3 " ll E =
o o    LU U
> L C L S
o   E 4- -1 V
-J .N = S  . V
 S    o rj,4J 4J
136
C++'、GUI Qt 4编程（第；版）
    }  _    ．    j    ．．  ’    ：’    0：’．．  ，一，    、    ．  、
    .  qApp->processEvents()’；    ‘    “’
    }
    一QApplicat ion::resto reOver rideCur50r(J;    +
    、return true;    ..-    .  ‘  .    ’、‘    7
    ．    十
    }    ．  ：    ，‘；‘，’…    ，
    使用这种方法存在一个潜在问题，即用户也许在应用程序还在保存文件的时候就关闭了主窗
口，或者甚至在保存文件的时候又一次单击了File- Save，这样就可能会产生不可预料的后果。对
于这个问题，最简单的解决方式是将’  ’。‘，    ’
    _    _
    qApp->processEvents();
替换为
    qApp->processEvents (QEventLoop::ExcludeUse rInputEvents);
以告诉Qt忽略鼠标事件和键盘事件。
    ．    ．  ‘：，；，，  二
    L    '
    通常情况下，当需要发生一个长时间运行的操作时，我们希望能够显示一个QP rogressDialog。
    ．    f
QProgressDialog有一个进度条，它可以告诉用户应用程序中的这个操作目前的进度信息。‘’QPro-
gressDialog还提供了一个Cancel按钮，它允许用卢取消操作。以下是这种方法在保存Spreadsheet中
的一个文件时所使用的代码：
bool' Sp readsheet: :writeFile ( const  ost ring  &fileName)
{
       QFile  file( fileName) ;
       .QP rog ressDialog  prog ress (this) ;
         p rog ress .setLabelText ( t r( "Sa,i "g  %1" ) .a rg ( fileName》 ;
   .    p rog ress . setRange (0,  RowCount) ;
      progress.setModal(true) ;
for (int row =
progress.se
'. qApp->proce
' if (progres
  . '  ' file.re
return
 < RowCount; ++row) {
anceled ( ). ). {
    }
    for (int column=0;column<ColurnnCount; ++column){
    QString str=formula(row, column);
    if(!st r:isEmpty(.))
    out<<quint16( row)<<quint16;(olumn)-<str;
    ，}    }
    、    ．    ．
    、    return true;    ．
    ，
    我们烈NumRows为总步数，创建一个QProgressDialog。然后，对于每一行，都调用setValue()来更
新这个进度条。QPtogressDialog可以自动地计算出进度的百分比，该值等于当前进度值除以总步
数。我们调用QApplication：：processEvents()来处理催意的重绘事件或者用户任意的鼠标单击或者
按键事件(例如，要允许用户可以单击Cancel)。如果用户单击了Cancel，就应该放弃保存这个文件
并且将其删除。
    我们没有对QProgressDialog调用show()，这是因为进度对话框会自动调用它。如果这个操作
可以很快完成（比如，可能是由于文件很小，或者可能是计算机的速度特别快），QP上10gressDialog就
会检测到这些情况并且不再显示出来。
    除使用多线程和QProgressDialog之外，还有一种处理长时间运行操作的完全不同的方法：不是
在用户请求的时候执行处理，而是一直推迟到应用程序空闲下来的时候才处理。如果该处理可以
第7章事件处理
137
被安全中断后继续，那么就可以使用这种方法了，因为我们并不能事先知道应用程序要多长时间
后才能闲置下来。
    在Qt中，通过使用一个0毫秒定时器就可以实现这种方法。只要没有其他尚待处理的事件，就
可以触发这个定时器。以下是一个timerEvent()实现的例子，其中给出了程序空闲时的处理方法：
    void  Spreadsheet::timerEvent( QTimerEvent  *event):    -‘    ‘
    {
    ,if, (event->timerld()==myTimerld){    ‘    ‘
    while (step<MaxStep＆＆!qApp->hasPendingEvents(》{.    ‘i.i..  ,
    performStep(step)；
    ++step;    ‘
    }
    }else{
    QTableWidget:: time rEvent( event);
    4  }    ：    …一  +    -  。‘
    }    ，
    如果hasPendingEvents()的返回值是true，就停止处理并且把控制权交还给Qto当Qt处理完所
    T  ．’    ，    -
有事件后，‘就会重新恢复这项操作。．    ，
    ．  ．    -    ，．    1，    ？  ：__?
  8章  二维图形
  Qt的二维图形引擎是基于QPainter类的。QPainter既可以绘制几何形状（点、线、矩形、椭圆、
弧形、弦形、饼状图、多边形和贝塞尔曲线），也可以绘制像素映射、图像和文字。此外，QPainter还
支持一些高级特性，例如反走样（针对文字和图形边缘）、像素混合、渐变填充和矢量路径等。
QPainter也支持线性变换，例如平移、旋转、错切和缩放。
    QPainter可以画在“绘图设备”上，例如QWidget、QPixmap、Qlmage或者QSvgGenerator。QPainter
也可以与QPrinter -起使用来打印文件和创建PDF文档。这意味着通常可以用相同的代码在屏幕
上显示数据，也可以生成打印形式的报告。    ，
    重新实现QWidget:：paintEvent()可用于定制窗口部件，并且随心所欲地控制它们的外观，就像
第5章中看到的那样。定制预定义Qt窗口部件的外观，可以指定某一风格的表单或者创建_个
QStvle的子类，第19章将介绍这两种方法。
    一项普通的需求是在二维画板上显示大量的、轻量级的、可与用户交互的、任意形状的项。‘Qt
4.2围绕着QGraphicsView、QGraphicsScene郓QGraphicsltem类引入了一个全新的“图形视图”体系。
这个体系提供了一个操作基于项的图形的高级接口，并且支持用户对项的操作，包括移动、选取、
分组。项本身依然用QPainter画出，并且可以独立变换。本章稍后将描述这一体系。，
    可以使用OpenGL命令来代替QPainter。OpenGL是一个绘制三维图形的标准库。第20章将介
绍如何使用QtOpenGL模块，该模块简化了OpenGL代码与Qt应用程序之间的集成一
8.1  用QPainter绘图
    要想在绘图设备（一般是窗口部件）上绘图，只需创建一个QPainter，再将指针传到该设备中。
例如：
    void  MyWidget:: paintEvent (QPaintEvent  *event)
    {
    QPainter painter(this);
    ．．．
    )
    使用QPainter的dr洲…()函数，可以绘制各种各样的形状。图8.1列出了其中最重要的一些
函数。绘制的效果取决于QPainter的设置。一些值是从设备中取得的，然而有些被初始化成默认
值。三个主要的设置是画笔、画刷和字体：
    e画笔用来画线和边缘。它包含颜色、宽度、线型、拐点风格以及连接风格。画笔的凤格分别
    如图8.2和图8.3所示j
    ●画刷用来填充几何形状的图案。它一般由颜色和风格组成，但同时也可以是纹理（一个不
    断重复的图像）或者是一个渐变。画刷风格如图8.4所示。
    。字体用来绘制文字。字体有很多属性，包括字体族和磅值大小。
    可以随时调用QPen、QBrush或者QFont对象的setPen()、setBmsh()和setFont()来修改这些
设置。
(×，y)。
第8章二维图形    139
(X2,y2)?Pi
d rawPoint\ )                            d rawLine ( )                          d rawPolyline ( )
p2．    ．p3
pl-    ，-p4    pl
(x，y)
7 0 p，圈譬
drawPoints()  .   .  '  drawLines()
d rawPolygop (,)
豳卜仅∥’’露熏豇：I，？蛩遂萋讣
h●．―――――――――――――刊 I
  .w
   drawRect ()
(X，y)-／一
  i’一、、、、≤至：；。
  、、，    ，／
  l●  ’+I．…一一  ，I
    W
    drawA广c()
卜―――――――――――’l
..w
drawRoundRect()
    . drawChc
d rawEllipse( )
y)．
      \N   .
drawPie()
  ∽儿Ag仅∥’麓、震震
drawText()        drawPixmap()        drawPath()  . <
图8.1 QPainter最常用的各种draw…()函数
    弋  @
j～  爹  ‰
Flat(ap
SquareCap
RourdCap
卜卜除
Mite rjoin
    Beveljoin    Roundjoin
图8.2各种拐点风格和连接风格
来看几个实际的例子。下面是绘制图8.5(a)中的椭圆的代码：
'QPainte
painter
painter
painter
painter
painter(this) ;
etRenderHint (QPainter::Antia
etPen(QPen(Qt::blackr 12, Qt
etBrush(QBrush(Qt::green, Qt
rawEllipse(80, 80, 400', 240)
RoundCap))
     -C    .:
a-
-- ~C
a) a) L
= C a)
L rl J
4J -J 4J
   4J rD
 -'O L
oo -o
C -C rl
. -l  Ln r
cn m o
ra o cn
   140                                  C++ GUI Qt 4编程(第=版)
图8.3各种线型风格．、．．．？’、一
SolidPattern':   DenselPattern   Dense2Patterr^ Dense3Pattern ' Dense4Pattern
Dense5 Patte rn        Dense6 Pattern        Dense7Pattern           Ho rPatte rr/              Ve rPattern
C ross Patte rn          BDiagPatte rn          FDiagPatte rn         D.iagCrossPat .               NoB rus h
图8.4各种预定义的画刷风格
图8.5各种几何图形示例
    调用setRenderFIint()可以启用反走样，它会告诉QPainter用不同的颜色强度绘制边框以减少视
觉扭曲，这种扭曲一般会在边框转换为像素的时候发生。由此生成的结果是可以在支持这一特性
的平台和设备上得到平滑的边缘。
  下面是绘制图8.5(b)的饼状图所用的代码：
QPainter  painl:e r ( this ) ;       . _
painter.s
painter.s
painter, s
painl:e r. d
el:RenderHi
etPen(QPen
etBrush(QB
 rawPie (80,
Antilliasing,  true) ;   .
5, Qt::SDlidLine;T Qt;,tRaundCap
 ,  Q\:l,:DiagCrossPattern》 ;:
    -    t
drawPie()酌最后两个参数以1/16度为单位。
下面是绘制图8.5(c)的三次贝塞尔曲线时所使用的代码：j，、ji．。
    ．~
QPainter painter(this):    7‘’
    h'  ’    。
painter. setRende rHint( QPainter::Ant ra;liasing,t rueyj'1‘  ’‘
QPainterPath path
    第宅章二维图形
141
    path．moveTo( 80，320)；
    path,cubicTo(200, 80, 320r 80, 480, 320);
    painter.setPen(QPen(Qt::black，一8));    :
    painter.drawPath(path);    1    :
    _  _
    QPainterPath类可以通过连接基本的图形元素来确定任意的矢量形状：直线、椭圆、多边形、弧
形、贝塞尔曲线和其他的绘制路径。绘制路径是基本的图元，从这个意义上来说，任何图形或图形
组合都可以用绘制路径描述。
    路径可以确定一个边缘，由边缘锁定的区域可以用画刷来填充。在图8.5(c)的例子中没有设
置画刷，所以只能看见边缘。-一’  r:Qt．：茹≤薹fr;ps Pattern:和一囊嚣囊随≥荔警
这三个例子利用内置的画刷模式(Qt1譬淤笸插值岱
代应用中，渐变填充已成为单色填充的流饿    渐挛填充霉蜩颜
之间能够平滑过渡。它们常被用来创建三维效果，Plastique和、Cleanlooks风格就是使用渐变来渲染
    …¨
QPushButton的。    j 0。？0iI
    Qt支持三种类型的渐变：线性渐变、锥形渐变和辐射渐变。下一节中的釜霎≥黟零的例子就
是在一个独立的窗口都件上结合了这三种类型的渐变，从而使其看起来更加适
●线性渐变(linear gradient)由两个控制点定义，连接这两点的线上有一系列的颜色断点。例
    ~    ‘
如，图8.6的线性渐变由以下的代码创建：    …“、
    ’    ．  …I'一
    一一‘：    ．
  QLinearGradient  gradient (50, .100,  300, 350)；    一’  ～二
  g radient. setColo rAt(0.0;Qt::white):    .    ’:1…-‘
  g radient'. setColo rAt (0.2,   Qt::green);    +1    .  ,7  .
  gradient .setColo rAt (1.0,  Qt:, black);
  在两个控制点之间的不同位置指定三种颜色。位置用0和1之间的浮点数来指定，0对应
  第一个控制点，1对应第二个控制点。两个指定断点之间的颜色由线性插值得出。
●辐射渐变(Iadial {7adient)由一个中心点（戈。，y。）、半径r、一个焦点（戈fjyf），以及颜色断点定义。
  中心点和半径定义一个圆。颜色从焦点向外扩散，焦点可以是中心点或者圆内的其他点。
・锥形渐变( conical gradient)由一个中心点（xe，y。）和一个角度Ⅱ定义。颜色在中心点周围俅
钟表的秒针掠过一样扩散。    ．，
图8.6 QPainter的各种渐变画刷，
142
C++ GUI Qt 4编程（第二版）
    目前，我们提到了QPainter的画笔、画刷和字体设置。另外，QPainter还有其他影响图形和文字
绘制方式的设置：
    o当背景模式是Qt：：OpaqueMode(默认设置是Qt：：TransparentMode)时，背景画刷可以用来填充
    几何图形的背景（画刷模式下）、文字或者位图。  ，
    o画刷的原点是画刷模式的启动点，通常是窗口部件的左上角。
    ●剪切区域是设备的绘图区域。在剪切区域以外绘图不起作用。
    0视图、窗口和世界矩阵决定了如何将QPainter的逻辑坐标映射到设备的物理绘图坐标。默认
    情况下，为了使逻辑坐标和物理坐标保持一致，这些是设置好的。下一节将描述坐标系统。
．’：●复合模式指定新绘制的像素如何跟绘图设备上已经显示的像素相互作用。默认方式是
    “source,over’？j这种情况下像素会被‘alpha混合在存在的像素上；只有特定的设备支持这种
    ．    ：    ，，~
    模式；本章稍后将描述这种模式。．  。    -+r  一。。
    可以通过调用save'()而随时将设备的当前状态存人一个内部堆栈，稍后通过调用restore()恢
复。这对我们如果想临时修改一些设备的设置然后恢复到以前的状态舍很有用，会在下一节见到
这种情况。
8.2坐标系统变换
    I i 4|≯t．‘．‘  1    、    ，’
    ’    ’；    。    。
    在QPainter的默认坐标系中，点'(0，0)位于绘图设备的左上角，x坐标向右增长，y坐标向下增
长。默认坐标系的每个像素占lxl大小的区域。
    理论上，像素的中心取决于半像素坐标。例如，窗口部件的左上角像素覆盖了点(0，0)到点
(1，1)的区域i它的中心在(0.5，0.5)位置。如果告诉QPainter绘制一个像素，例如(100，100)，它会
相应地在两个方向做~+0.5的偏移，使得像素点的中心位置在(100.5，100.5)。
    这一j差别初看起来理论性很强，但它在实践中却很重要。首先，只有当反走样无效时（默认情
况）才偏移+0.5；如果反走样有效，并且我们试图在(100，100)的位置绘制一个黑色的像素，实际上
QPainter会为(99.5，99.5)、(99.5，100.5)、(100.5，99.5)和(100.5，100.5)四个像素点着浅灰色，给人
的印象是一个像素正好位于四个像素的重合处。如果不需要这种效果，可以通过指定半像素坐标
或者通过偏移QPainter( +0.5，+0.5)来避免这种效果的幽现。
    当绘制图形时，例如线、矩形和椭圆，可以使用相似的规则。图8.7表明当反走样关闭时调用
drawRect(2，2，6，5)时不同画笔宽度产生’的变化。值得特别注意的是，6x5宽度为1的矩形可以有
效地覆盖7x6的区域。这不同于1日的工具，’包括早期的Qt版本，其本质是要支持真正可缩放的、
与分辨率无关的矢量图。图8.8表明当反走样打开时调用drawRect(2，2，6，5)产生的结果，图8.9
表明当指定半像素坐标时产生的结果。
    既然已经了解了默认的坐标系统，就可以进一步看一下怎样使用．QPainter的视口、窗口、世界
矩阵。（在上下文中，术语“窗口”说的不是顶层窗口部件窗口，“视口”跟QScrollArea的视口也没有
关系。）    +’
    视口和窗口密不可分。视口是物理坐标系下指定的任意矩形。窗口也是指同一矩形，只不过
是在逻辑坐标系下。当绘制图形时，在逻辑坐标系下指定的点，这些坐标都是基于当前的窗口一视
口设定并以线性代数的方式转换为物理坐标的。
    默认情况下，视口和窗口都被设置成设备的矩形。例如，如果设备是320×200的矩形，视口和窗
口都是左上角为(0，0)的320×200的相同矩形。这种情况下，逻辑尘标系和物理坐标系是一致的。
第8章二维图形
143
雕雕雕群
无画笔    画笔宽为1    画笔宽为2    画笔宽为3
图8：7未经反走样处理的drawRect(2，2，6，5)函数的绘制效果
需雕解1隰
无画笔    四笔宽为1    画笔宽为2    画笔宽为3
图8.8反走样处理的drawRect(2，2，6，5)函数的绘制效果
1 0’罐雕隅熊
    尢画笔    画笔宽为1    画笔宽为2    画笔宽为3
图8.9反走样处理的drawRect(2.5，2.5，6，5)函数的绘制效果
    这种窗口一视口机制对于编写独立于绘制设备大小和分辨率的绘制代码是很有用的。例如，
如果想让逻辑坐标从(-50，-50)到(+50，+50)，并且(0，0)在中间，可以这样设置窗口：
(-50，-50)指定了原点，(100，100)指定了宽和高。这意味着逻辑坐标(-50，- 50)对应物理坐标(0，0)，
而逻辑坐标(+50，+50)对应物理坐标(320，200)，如图8.10所示。这个例子没有改变视口。
窗口
    图8.10逻辑坐标向物理坐标的转换
    现在来介绍世界变换。世界变换(world trahsfonn)是在窗口一视口转换之外使用的变换矩阵。
它允许移动、缩放、旋转或者拉伸绘制的项。例如，如果想以450角绘制文本，可以使用这段代码：、
QTransform transform;
transform.rotate(+45.0); ' .
painter.setWo rldTransfo rm ( t ransfo rm) ;
painter, d rawText ( pos,  tr( "Sales "》 ;
144    C++ GUI Qt 4编程（第二版）
  传递给drawText()的逻辑坐标会被世界变换转换，然后使用窗口二视口设置映射到物理。
  如果进行了多次变换，它们会按照给定的顺序生效。例如，如果想要使用点(50，50)作为旋转
的中心点，可以移动窗口到(+50，+50)，执行旋转，然后把窗口移回到原来的初始位置。
QTransform transform;
t ransform. t ranslate( +50.0,   +50.0) ;
transform.rotate(+45.0) ;   .
t ra nsform. t ranslate( -50.0,   -. 50 . 0') ;      .
painter. setWo rl.dTransfo rm ( t ransfo rm) ;
painter.d rawText ( pos,  tr( "Sales " 》 ;
    坐标变换的一种更为简单的方式是使用QPainter的translate()、scale()jrotate()和shear()这些
简便函数。
    painter,t ra.n slate C. 50.,0，一50.0),;
    painter; rotate(+45j0).;    ‘  ’    ..、    、    t  ’
.    painter.translate(+50.0,+50.0);~  一    ‘  t  '
    painter.draw_rext(pos,t r(”Sal÷s“));
    如果想重复使用相同的变换，可以把它们保存到一个
QTransform对象中，这样会更高效。在需要变换的时候，再把
世界变换设置到绘制器上。．
    为了描述绘制器的变换，我们将分析如图8.11和图8.12
所示OvenTi/ner窗口部件的代码。这个OvenTimer模仿烤箱的
定时器，它是烤箱内置的钟表。用户可以单击刻度来设置持
续时间。转轮会自动地逆时针转到0，OverLTimer在这一点发
射timeout()信号。
    class OvenTimer:public QWidget
    {
    Q_OBJECT
public :
   OvenTimer(QWidget *parent = 0)
void setDuration(int secs),
int duration() const; .
void draw(QPainter *painter)';
signals:
        void  timeout ( ) ;
protected:
   void paintEvent(QPaintEvent *event),
   void mousePressEvent(QMouseEvent *event)
   private:     ' .
  . ' QDateTime finishTime
     QTime.r *upda.teTimer;
  '   QTimer *finis'hTimer;
  I.
囹8 .11       0venTimer窗口部件
OvenTimer类继承自QWidget，重新实现了两个虚函数：paintEvent()和mousePressEvent()j
const double DegreesPerMinute = 7.0;      .
const double DegreesPerSecond = DegreesPerMinute / 60
const int MaxMinutes t 45;
const int MaxSeconds = MaxMinutes *'60;.    .
const int Updatelnterval = 5;
在oventnner. cpp中，定义了几个控制烤箱定时器外观的常量。
{141j，2■1 vj{!armij目H口{3§
    1    9蔼遵溜壤馏Mj
第8章二维图形
145
OvenTime r:  :OvenTime r( QWidget   *. pa rent )
   : QWidget(parent)  .
finishTime = QDateTime::currentDateTime() ;  .
updateTimer = new QTimer(this);  . .          : . '..,.  . "
connect (updateTimer,   SIGhlAL (timeout ( 》 ,  this ,   SLOT(update ( 》 )
finishTimer = new QTimer(this) ;
 finis hTimer->setSingleShot{ t rue) ;
connect ( finishTimer,  SIGhlAL (timeout { 》 ,  this ,  SIGNAL ( timeout ( 》 ) ;
connect ( finishTime r,  SIGNAL (timeout ( 》 ,  updateTimer,  SLOT( stop ( 》 )
QFont font,       .
font.setPointSize(8) ;
setFont (font) ;
    在构造函数中，创建了两个QTimer对象：updateTimer用来每隔5秒刷新窗口部件的外观，fin-
ishTimer在定时器达到0时发肘timeout()信号。finishTimer只需要执行一次，因此我们调用'setSin-
gleShot( true)。默认情况下，定时器会重复触发直到它们被停止或销毁。最后一个connect()调用是
一个优化，目的是当定时器停止运行时停止更新窗口部件。’    1
    在构造函数的末尾，我们把用来绘制窗口部件的字体的磅值设置为8磅i这保证了显示的数
    。    ．    ’
字大小大体一致。：
void  OvenTime r: : s etDuratron ( int  secs )
       secs '.- 'qBound (O: .secs,  MaxSeconds) ;
finishTime  =  QDateTime: :cu r rentDateTime ( ) .addSecs ( secs ) ;
jf (secs > 0) {
       updateTimer->start (Updatelnterval  *  1000)
       finishTimer->start (.secs  *  1000) ;
 else {
      updateTimer->stop( ) ;
       finishTimer->stop( ) ;
:pdate ( ) ;
    setDuration()函数设置了烤箱定时器的持续时间为给定的秒数。，使用’Qt的qBound()函数意味
着可以不必写达样的代码：
    if (secs<0){    ‘
    secs=O：
    ) else if (secs>MaxSeconds){
    secs=MaxSeconds：    t
    )
    -  j
    我们通过在当前时间[从QDataTime：：currentDateTime()获得]加上间隔时间得到结束时间，并
且把它保存到缶ushTime私有变量中。在结束的地方，我们调用update()，用新的间隔时间重绘窗
口部件。
    finishTime变量的类型是QDateTime0这个变量保存日期和肘间，避免了由于当前时间是在午
夜之前并且完成时间是在午夜之后而产生的折回缺陷( wrap-around  bug)?  、
int OvenTimer::duration( )  const
{
        int  secs  =  QDateTime: :currentDateTime ( ) .secsTo ( finistrTimef
   if (secs < 0)                         '.
       secs = 0;
   return secs;                . '   : .
     146                                               C++ GUI Qt 4编程(第 -版)
     -
duration()返回定时器完成前剩余的秒数。如果定时器未激活，返回0。
void  OvenTime r: :mousePressEvent ( QMouseEvent  *event)
{     '
    QPointF point = event->pos()一 rect().center();
     double, theta = std::atan2(-point,x(), -point.y(》 * 180.0/ M_PI
    .   setDuration (duration( )  +  int (theta /  Deg reesPerSecond》 ;
         update ( ) ;
}
    当用户点击窗口部件时，我们使用一个巧妙且有效的数学公式找到最近的刻度，并且使用这
个结果来设置新的持续时间，然后安排一个重绘。用户点过的刻度移到了顶部，然后随着时间逆
时针移动到0。
void OvenTimer::paintEvent(QPaintEvent * /* event */)
{     .
.  QPainter painter(this);
         painter. setRenderHint (QPainter: :Antialiasing,  .t rue) ;
int side = qMin(width(), height(》
painter.setViewport《width() - side) / 2,  (height() - side). / 2,+j
                             side,  side) ;   .
paint.er.,setWindow(-50, -50, ,100, 100);     .  .
    draw(&painter)；    。
    }    ．
    在paintEvent()函数中，我们把视口设置成窗口部件中最大的正方形，把窗口设置成(- 50，
-50，100，100)的矩形，也就是说，100×100的矩形从(-50，-50)扩展到(+50，+50)。qMin()模板函
数返回两个参数中最小的一个。然后调用draw()函数实际执行绘图。
    如果没有设置视口为正方形，当窗口部件被缩放为非正方形的矩形时，烤箱定时器就会变为
椭圆。为了避免这种变形，必须把视口和窗口
设置成具有相同纵横比的矩形，这种效果见图8.12。
图8.12三种不同尺寸的OvenTimer窗口部件
现在，来看看绘图的代码：
void OvenTimer::draw(QPainter 'painter)
                                                                                                                                                           '                    '.
     static const int triangle[3] [21 = {     .
   };  .
         QPen  thickPen ( palette( J . fo reg round ( ) ,   1.5)
         QPen  thinPen (palette ( ) .fo reg round( ) ,  0,5) ;
   QColor niceBlue(150, 150, 200); .
painter->setPen(thinPen) ;
painter->setB rush (palette( ) . fo reg round ( 》 ;        .
painte r->d rawPolygon (QPolygon (3,  &t riangle [ei [ol 》 ;
囊震
io乏。
；．二墨二
磐§
i一崔i
?v曩
j‘、f
：：蓐j
_．：j，．
我们绘制外面的圆，用锥形渐变填充。锥形的中心点位于(0，0)，角度是- 90。。
QRadialGradient haloGradien
haloGradient.setColorAt(0.0
haloGradient.setColorAt(0.8
haloGradient.setColorAt(0,9
haloGradient.setColorAt(l.0
Qt::lightGray
 Qt; :darkGray)
  Qt : :white) ;
  Qt : :. black) ;
40)
我们用辐射渐变填充内部的圆。渐变的中，l■氧和焦点都在(0，0)。渐变的半径是20。
QLinearGradient knobGradient
knobGradient: setColorAt(0:0,
knobGradient.setColorAt(0.2,
knobGradient.setColorAt(0.3,
knobGradient.setColorAt(0.8,
knobGradient.setColorAt (1.0,
for (int i = 0; i(= MaxMi
    if (1 96 5 == 0) {
              painter->setPen (th
   . .          painte r->d rawLine (
                 painte r->d rawText (
(-7, -25,.7
Qt::black)
 niceBlue) ;
Qt::lightG
 Qt: :white)
Qt::black)
nutes;
-25】；
reesPerSecond) ;
14, 50, 99, 49);
ickPen) ;
0, -41, 0, -44); '
-15, -41, 30, 30,
Qt::AlignHCenter j Qt::AlignTop,
QString::number(i》 ;
, painter->setPen(thinPen); ',.
   painter-7drawLine(0, -42, 0: -44)
}   , '-
 painte r-> rotate C-Deg rees P.e rMinute) ;
    }
    }，
    我们调用rotate
现在，这个标记移到
()来旋转绘图器的坐标系统。在旧的坐标系统中，O-minute的标记在最上面；
了对应着剩余时间的位置。在这个旋转之后，我们绘制了矩形把手，因为它的
    +．
方位依赖于旋转的角度。
    在for循环中，我们在外面圆的边缘绘制了标记，并且绘制的数字都是5分钟的倍数。文本被
放置在标记下边一个不可见的短形里。在每个迭代的最后，顺时针旋转绘图器7。，这相当于1分
钟。下次将把标记绘制在圆的其他位置，尽管传给drawLine()和drawText()的坐标总是一样的。
    for循环中的代码有一个小缺陷，如果执行了更多的迭代，这一问题会变得很明显。每次调用
，rotate()，就高效地用一个旋转矩阵去乘当前的世界变换，从而创建一个新的世界变换。浮点数的
 .- o.
a) -f
rl  I.
-o
6 -f
C-
-C rl
=r
L LU
{J a,
 rn -o
AA
  I    I
LL
 {J {J
CC
 rl rl
. p p
0)
   <7>
 co
.~ rl I
- -o
c a,  -
Q) LO
o- 6 (-J
OOI
.. C rn
{J u o
a -C  rl
- rn r
C =r
Q) L LU
a- ca 3
Q) Q) L
Ln rn -o
AAA
 III
LLL
CCC
 nr nr a-
，；阳！，
几了 .-
Q) -    N
o iJ   Ln
   C   (-J
*  Q)    I
- -o       -
- m -r-
C L_ ]
0 6 C -
.+ -a orrJ
{J o o- u
L k rl a:
=- C -o
-o -C IJ C
- rn - =
Q) = C o
IJ L Q) R
m ca 0_ 3
{J IJ iJ n,
o Q) Q) L
L Ln Ln -o
AAAA
 1IIl
LLLL
 IJ IJ IJ IJ
CCC n
 rJ rJ rl rl
 p o o p
148
C++：GUI Qt 4编程（第二版）
舍入误差不断累积，得到了越来越不准确的世界变换。用下面的办法重写这段代码可以避免这个
问题，使用save()和restore()函数为每次迭代保存和加载原始的矩阵：
    for (int i=0;i<='MaxMinutes; ++i){    ,
    painter->save()；    ．
    painte r-> rotate(一i丰Deg reesPe rMinute);
：AlignTop,
    ．    ) else{
    painter->setPen(thinPen);
    painter->drawLine(0,-42,0,'-44);
，    ．    )    ．    、
    painter->restore()；
    ’
：  ：实现烤箱定时器的另外一个办法是自己计算(x，y)位置，使用sin()和cos()函数找到圆上的位
置。但之后将仍然需要利用移动和旋转并以―定的角度来绘制文本。
8.3◆用Qlmage高质量绘图。  ’
，÷  ．．  ．；j：．i．．j!。。o    。一‘
    绘图时，我们可能需要面对速度和准确率的折中问题。例如，在Xll和Mac OS X系统中，要
在QWidget或QPixmap上绘图，需要依赖于平台自带的绘图引擎。在Xll上，这保证了与x服务器
的通倍限制在一个最小集莩仅仅发送绘图命令，而不是图像数据。这一方法的主要缺点是' Qt受限
于平台的内在支持：    ，’
    。在Xll上，类似反走样暾及对分数坐标的支持只有当x服务器上存在x渲染扩展时才
    有效。，    ，二
    -．
    ●在Mac OS X上，内置的走样绘图引擎使用与Xll和Windaws不同的算法绘制多边形，绘制
    结果也稍有不同。    、
    当准确率比效率更为重要时，我们可以画到一个QImage上，然后把结果复制到屏幕上。这样
可以总是使用Qt自己内置的绘图引擎，在所有平台上得到同样的结果。唯一的限制就是QImage
在被创建时会用到QImage:：Fonnat_RGB32或者QImage：：Fonnat_ARGB32_Premultiplied参数。
    预乘ARGB32格式与常规的ARGB32格式(OxAARRGGBB)差不多是一样的，不同之处在于红、
绿和蓝通道自左乘alpha(透明)通道。这意味着，RGB通道的值，一般是从Ox00到OxFF，变换为从
Ox00到透明通道的值。例如i 50 010透明的蓝色用ARGB32格式表示为Ox7FOOOOFF，但用预乘
ARGB32格式表示为Ox7F00007F。同样，ARGB32格式的75 010运明的黑绿表示为Ox3F008000，用预
    t，  、
乘ARGB32格式表示为Ov3F002000。  +
    假设我们想应用反走样绘~IJ-个窗口部件，并且想在没有X渲染扩展的Xll系统上获得很好
的结果。原始的pantEvent()处理器，反走样依赖于X渲染的代码类似于：
void MyWidget::paintEvent (QPaintEvent  *event)
{
    QPainter painter(this):
.painte r.setRenderHint (QPainter::Antialiasj ng,t rue);
    draw(&painter)；
)
下面的代码给出了如何使用Qt的平台无关的绘图引擎重写窗口部件的pa/ntEvent()函数：
Q‘，
  --
    .-O L(
    ^rn a) L
     -t  t a)
    -t  N C a
     I o Q) E
        rn u =
     -  z: C
  - -4 H CD
C+I+C
   o -t   < H
   CL  I   ~ .. L
  k    Ln ..t
    u  - + t cn
    rl C,  I  OO
   -C((
   4J a) t
 -C x
  C H Q)
   o -lI-
,-- 0_ 3 3
  t ra r。
_OL L
 AAA
 II  J  I  I
fl L L L
Ln 4J t t
CCC
d\o rl rl rl
  m m r。
rl p p p
.-
H
4嘈馐壤缁姻
第8章二维图形    149
yoid MyWjdget::paintEvent(QPaintEvent *event)      . .   .
       QImage  image( size( ) ,  QImage: :Format_ARGB32_Premultiplied)
     QPainter imagePainter(&image) ;
  imagePainter.initFrom(this); .
        imagePainte r. setRenderHint (QPainter: :Antialiasing,  true) ,
          imagePainter. e raseRect ( rect ( 》 ;
      dr.aw(&imagePainter) ;
   imagePainter.end();  .
      QPainter widgetPainter(this) ;
   widgetPainter.drawImage(OF 0, image);
    我们以预乘ARGB32模式创建一个跟窗口部件大小一致的QImage，以及一个QPainter引用此
图像。调用initForm()函数初始化画笔、背景和字体。我们照常使用QPainter绘图，在结尾处，仍然
使用QPa/nter对象把图像复制到窗口部件上。这种方法在所有平台上产生同样商质量的结果，对
于字体渲染，依赖于安装的字体库。
    Qt图形引擎的一个特别强大的特性是它支持复合模式。这规范了源和目的像素如何在绘制
时复合在一起。该模式可用于所有的绘制操作，包括画笔、画刷。渐变以及图像绘制．。  ．  ，  二
    默认的复合模式是QImage：：Composit/onMode_SourceOver，这意味着源像素（正在绘制的像素）被
}昆合在目的像素（已存在的像素）上，这样，源图像的透明部分给我们璐透明教暴名．图’8曩_3列举了
应用不同模式在（玻璃钢化时的）风嘴印图像（目的图像）上绘制j个半透明的蝴蝶（源图像）的
效果。
鬻紧’≯‘≮
Source    .   SourceOver    Sourceln
SourceOut     SourceAtop  . ;'CLear
■寮，■鬻摹
Destination
Destinatiori- Destination- Destination- Dgj;ination- ;Xor
Over       In .       Out        Atop
毒泸≯j妒j一簿j。≯I
PLus .  .      Screen       . Darken  .      ColorDodge .   HardLight  .  Difference
矿萨铲≯．，擎i。爹
MultipLy    OverLay    Lighten    ColorBurn-  SoftLight'  ~ExcLusion
    __
    图8.13 QPainter的各种复合模式7
    使用QPainter:：setCompositionMode()可以设置各种复合模式。；例如，下面就是如何设置蝴蝶和
风嘴印图像XOR复合模式的代码：
150
C++ GUI Qt 4编程（第二版）
    QImage resultlmage=checkerPatternlmage;.
    QPainter  painte r (&resultlmage)';
    painte r. setCompositionMode (QPainter::CompositionMode_Xor);
    painter.drawlmage(0,0,butterflylmage);
    值得注意的是，QImage：：CompositionMode_Xo?操作也会影响到透明通道。这意味着，如果白色
(OxFFFFFFFF)对自己做XOR复合，会得到透明色(Ox00000000)，而不是黑色(OxFFOOOOOO)。
8.4基于项的图形视图
    对于用户自定义窗口部件和绘制_个或者几个项来说，使用QPajnter是理想的。{
果需要处理从几个到几万的项时，而且要求用户能够单击、拖动和选取项，Q．的视图类鬟褛慧；婺
一问题的解决方案。
    Qt的视图体系包括一个由QGraphicsScene充当的场景和一些由QGraphicsltem的子类充当的场
景牛的项。场景（以及它的项）在视图中显示，这样用户就可以看到了，它由QGraphicsView粪充当。
同一场景可以在多个视图中显示――例如，便于部分地显示一个大的场景，或者以不同的变换来
显示场景。参见示意图8.14。
图8.14 -个场景可用于多个视图中
    图8.15提供了几个预定义的QGraphicsltem子类，包括QGraphicsLineltem、QGraphicsPixmapltem、
QGraphicsSimpleTextltem(应用于纯文本)，以及QGraphicsTextltem(应用于多文本)o‘也可以创建自己
的QGraF．hicsltem子类，稍后将在本节中看到①。
    QGraphicsScene是一个图形项的集合。一个场景有三层：背景层(background layer)、项层(item
layer)和前景层(foreground layer)。’背景层和前景层通常由QBrush指定，但也可能需要重新实现
drawBackground()和drawForegrouhd()，以便可以实现完全控制。如果想用一个图片作为背景，可以
简单地创建该图片作为QBmsh纹理。前景画刷可以设置成半透明的白色，给犬一种褪色的效果，
或者设置成交叉模式，提供一种格子覆盖的效果。
    场景可以告沂我们哪些项是重叠的，哪些是被选取的，以及哪些是在一个特定的点处，或者在
一个特定的区域内。场景中的项或者是最高层的项（场景就是其父对象），或者是子项（它们的父
对象是另外的项）。任何应用于项的变换都会自动地应用于子对象。
    视图体系提供了两种分组项的方法。一种方法是简单地使一个项成为另一个项的子项。另
①Qt 4.4有望支持在图形视图中添加窗口部件，如同视图项一样，包括对它们进行坐标变换的能力。
    2。2趣j844“2蔻W蓬蓬爆扇惫蓦霪舒prn潮甾冀露Ⅲ藿臻惫氍霸粼榭弼娓渡ⅧⅧⅧ滔
第8章二维图形
151
外一种方法是使用QGraphicsItemGroup。把一个项添加到组中不会引起任何变换，这些组可以很方
便地处理大量的项，就像它们是一个单独项一样。    ‘
    QGraphicsView是一个窗口部件，这个窗口部件可以显示场景，在需要的情况下提供滚动条，以
及影响场景绘制方式的变换能力。这有利于支持缩放和旋转，帮助浏览场景。
圈镬》
QG raphicsRectltem            QG raphicsEllipseItem     .   QG raphicsLineltem
Cat for Sale
She．5 gray
and 30ng-haired
with a srriall nose，
鬣，    一’。圈黼
QGraphicsPathltem    QGraphicsPixmapltem    QGraphicsSvgltem
    图8.15   Qt 4.3中可用的各种图形视图项
    默认情况下，QGIaphicsView使用Qt的内置二维图形引擎绘图，但这可以改变，在其创建完后
调用setViewport()改为使用OpenGL窗口部件。打印一个或部分场景也是很容易的，将在下一节中
介绍使用Qt打印的几种方法。
    这个体系使用三种不同的坐标系统――视口坐标、场景坐标和项坐标~二一而且还包含从一个
坐标系统映射到另一个坐标的函数。视口坐标是QGaphicsView的坐标。场景坐标是逻辑坐标，用
来布置场景中的项。项坐标针对某一项，并且以(0，0)点为中心。当在场景中移动项时，项坐标保
持不变。在实际应用中，我们常常只关心场景坐标（用于布置上层的项），以及项坐标（用于布置子
项和绘制项）。依照本身的坐标系统绘制项意味着我们不用去关心项在场景中的位置或者关心需
要应用的变换。
    视图类用起来很简单，而且具有很强的功能。为了介绍它能做什么，我们来看两个例子。第
一个例子是个简单的图表编辑器，我们将看到怎样创建项，以及怎样处理用户交互。第二个例子
是个有注解的地图程序，介绍了如何处理大量的图形对象，以及如何以不同的缩放比例高效地绘
制它们。
    图8.16所示的图表应用程序可以让用户创建节点和Link。节点就是项，是可以在内部显示文
本的圆角矩形，而Link是连接两个节点的线。被选中的节点用比普通线粗的虚线边缘表示。首
先，我们来看看Link，因为它是最简单的，然后是节点，最后将看到怎样在上下文中使用它们。
E
o
4J
_   .
o
rl
J  .
cn
u
rl
-C
a-
 r0 .     ,
o
u
rl
_D
rl
J   ..
    u
U,  r
r0   _D
r=
U{ o
152
C++ GUI Qt 4编程1（第二版）
     ILink(Node *fromNode,  llode *toNode) ;
  一Lirrk ( ) ;
   Node *fromNode() const;
 .; Node *toNode() const;
    void setColor(const QColor &color);
   QColor color() const;
        void  trackNodes ( ) ;
private:
   Node *myFromNode;
   Node *myToNode; .
    图8.16图表应用程序
    Link类派生自QGraphicsLineltem，它可以在QGrdphicsScene中显示一条线。Link有三个属性：连
接的两个节点以及画线所用的颜色。我们不需要使用QColor成员变量来保存颜色，这是因为简捷
的原因。‘QGraphic'sltem不是QObject的子类，但如果需要在Link类中添加信号和槽，可以使用QOb-
ject做多重继承。，，    一    j    r    ．
    在用户拖动一个连接节点到一个不同的位置时，trackNodes()函数用来更新线的端点。
    Link::Link(Node .*fromNode,  Node  *toNode)
    {  ，
    myFromNode=fromNode;
，  ．  myToNode=toNode;    ，    一
    myFromNode->addLink(this);
    myToNode->addLink( this);
    set Ftags( QG ra phic sIteR::ItemIsSelectable);    ‘    ‘    4
    :  ~ sftZyalue(-l.l;.    ,.,  .    ,.    ‘
    setColor{Qt::darkRed);
    trackNodes{)：
    )
    当创建一个Link时，它会把自己添加到连接的节点中。每个节点保存一个Link的集合，而且
可以保存任意数量的Link。’图形琐有几个标识；但在这种情况下；只需要Link可以被选中，从而用
户可以选中并删除它。    _
    每个项都有一个（x，y）坐标，以及一个z值，指定它在场景中的前后位置。因为我们打算从一
个节点的中心向另一个节点的中心画线，所以给直线一个负的z值，这样它就会被绘制到所连接
的节点的下面。这样，Link就是它所连接的节点与最近边框之间’的线。
第8章  二维图形‘    153
在构造函数的末尾，会初始化线的颜色，然后调用tackNodes()设置线的端点。
Link::~Link( )
                       '.
      myFromNode->removeLink(this) ;
      myToNode->removeLink(this) ;
}
当线被销毁时，它将从其连接的节点中删除掉。
void  Link: :setColo r( const  QColo r &colo r)
{
  setPen(QPen(color, 1.0》;
                              '
当设置Link的颜色时，只需要用给定的颜色和宽度为l的线设置画笔。setPen()函数继承自
QGraphicsLineltem。color()返回画笔的颜色。
void  Link: :t rackNodes ( )
{.'
           set Line (QLineF ( myF romNode->pos ( ) ,   myToNode->pos;( 》 )
}
QGaphicsltem:：pos()函数返回项相对于场景的位置（针对上层项），或者相对于父项的位置（针
对子项）。
    对于Link类，可以依赖其父类来处理绘图：QGaphicsLineltem在场景的两点之间绘制一条直线
[用pen()函数]。    一：。
    对于Node类，将自行处理所有的给图。节点和Link韵另外一个不同点是：节点更具交互性。
首先来看Node的声明，由于它很长，所以把它分成几个片断。，，j
    ’    -    ‘一‘  +
    class Node:public QGraphicsltem
    t    ．
    Q_DECLARE_TR_FUNCTIONS (Node)
public:
 Node()
    对于Node类，我们用QGaphicsltem作为基类。Q_DECLARE-rIR_FUNCTIONS()宏用来给类添
加一个tr()函数，尽管它不是QObject的子类。这种方法简单方便，可以直接使用tr(b而不是静态
的QObject::tr()或者QCoreApplication::translate().    j
void  setText ( const  QSt ring' &text) ;  .
QString text() const;
void setTextColor(const QColor &color);
QColor t.extColor() const;
void  setOutlineColo r ( const  QColo r &coio r) ,
QColor outlineColor() const;
void  setBackg roundColo r( const  QColo r &colo r)
QColor backgroundColor() const;
    逮些函数只是对私有成员的简单的读取和设置操作。此处提供对文字颜色、节点边缘以及节
点背景的控制。
void addLink(Link *.link); .
void  removeLink(Link .*.link) ;
就像前面看到的，这些函数被Link类调用，会在节点中添加和删除它们自身。
QRectF boundingRect() const; .
QPainterPath shape() const;     .
void paint(QPainter *painter, '   .  .
         const QStyleOptionGraphicsltem.*option, QWidget *widgetJ
当创建QGaphicsltem的子类时j要想自己实现绘图，一般是重新实现boundingRect()和paint()’。
154
C++ GUI Qt 4编程（第二版）
    如果不重新实现shape()，基类的实现将会退而使用boundingRect()。在这种情况下，我们重新
实现了shape()将节点的圆角考虑进去，从而返回更准确的形状。
    视图体系用外接矩形来决定一个项是否需要被绘制。这使得QGraphicsView可以很迅速地显
示任意大的场景，尽管此时只有一小部分项是可见的。shape用来决定一个点是否在项内，或者是
否两个项是重合的。
    protected：
    void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *everlt);
    QVariant itemChange(GraphicsItemChange changet
    const QVariant &value);
    在图表应用程序中将提供一个Properties对话框，用来编辑节点的位置、颜色和文字。为了更
加方便，将允许用户通过双击节点修改文字。    ，
    如果节点被移动了，必须确保与其相连的Link做相应的更新。我们重新实现itemChange()处理
器来做更新，每当项的属性（包括其位置）改变时被调用。我们不用mouseMoveEvent()辜件达到这
一目的，是因为当节点被程式化地移动时，它不会被调用。
p rivate:
   QRectF outlineRect() const;
   int roundness(double size) const;
    outlineRect()私有函数可以返回由节点绘制的矩形，而roundness()可以返回一个基于矩形宽度
和高度的合适的圆度系数。
    如同Link要保存它所连接的节点的信息一样，Node也会保存它的Link信息。当一个节点被
删除了，所有与该节点相连的Link也会被删除。    ．
    现在来看Node类的实现，首先从其构造函数开始。
    Node::Node()    。
    {
  :myTextColor=Qt::-darkGreen;
    myOutlineColor=Qt::da rkBlue;
    myBackgroundColor=Qt::white;
    setFlags(ItemIsMovable l ItemIsSelectable);
    )
    我们初始化颜色，设置节点项可被移动和选取。z的值被默认地设置为0，允许调用者设置节
点在场景中的位置。    ，
    'Node：：―Node()
    {
    foreach (Link木link, myLinks)
    delete link;
    )    ．
    析构西数删除所有节点的Link。当一个Link被销毁了，它将把自己从其连接的节点中删除。
我们迭代（复制）Link的集合，而不是使用qDeleteAll()来避免副作用，因为Link的集合被Link的析
构函数间接地访问。

，  无论何时修改了项，都会影响到它的显示，所以必须调用update()来安排一个重绘。例如项的
外接矩形可能会改变（因为新的文字可能比现在的文字短或者长），必须在做影响项的外接矩形的
修改之前立即调用prepareGeomeUyChange()。
    我们将跳过text()、textColor()、outlineColor()和back~ToundColor(，提取函数；因为它们只是简单
地返回其对应的私有变量。
    void Node::setTextColor(const QColor &color)
    {    ．    ，，  ，，．
    myTextColor=color;  ’
    update()；
    )    ’    一．    ‘‘
    当设置文字的颜色时，必须调用update()来安排―个重绘、，以便使用新的颜色绘制项。，没有必
要调用prepareGeomeU:yChange()，因为项的大小不会受颜色改变的影响。我们将忽略边缘和背景颜
色的设置函数，因为它们在结构上与这个函数是相同的。    ‘’’
    void Node::addLink(Link *linkJ
    {
    myLinks.insert(link);
    )
    void  Node:: removeLink(Link  *link)
    {
    myLinks. remove(link);
    )
逮里只是简单地向节点的Link的集合中添加和删除给定的Linko
    QRectF Node::outlineRect() const
    {
    )    ．
    我们使用这个私有函数来计算一个包围节点文字的矩形，该矩形有8像素的边距。由字体规
格函数返回的外接矩形总是把(0，0)作为其左上角。因为我们想把项的中心点作为文字的居中
    ’_
点，因此移动这个矩形，使它的中心在(0，0)。
    尽管是以像素为单位来进行思考和计算的，但它却是场景中名义上的单位。场景（或者父项）
可能被缩放、旋转、拉伸或者只是受反走样的影响，，因而场景上实际的像素数可能有所不同。
    QRectF  Node:.boundingRect()const    ,’
    {
    const int Margin=1：
    retu rn  outlineRect().adj usted (-Ma rgin,  -Ma rgin,  +Ma rgin,  4+1a rgin);.
    )    r
    boundingRect()函数会由QCfaphicsView调用，以决定是否需要绘制项。我们使用边缘矩形，但留
些额外的边白，因为如果需要绘制边缘，由速个函数返回的矩形必须留出至少半个画笔宽的距离。
    QPainterPath  Node:: shape()const    ?  …    ”’'7
    {
    QRectF rect=outlineRect();
    QPainterPath path;    ，    。
    path.addRoundRect( rect,  roundness( rect.width()),
    roundness{rect.height(》);
    return path;
    )
    -o
    -o
      ro
     .  o-
   x a,
  QC
    T rl
       .-y -o
   - E -O
  -- fV
   {J IJ O-
  C u+
 oo
 A a,0-
  I C C.-
  p-ri  rl -
   o--o -O L
  < C -o a,>
   cr = ra r-
     o o- C
   II -O I  Q
.-     .    u
co cn cn  -
    u u a} iJ
 ii  'rl 'rl  C  u
   L L rl a,>
 gt IJ -O L
C Q CL -O I
-l E E r0 -
-o     o- Q
-o U-  lI   I  IJ
156
C++ GUIot 4编程（第二版）
    shape()函数可以：由QGraphicsView调用，用来做精确的碰撞检测。通常，可以忽略它，由项基
于外接矩形自行计算形状。这里重新实现了它，由其返回一个QPainterPath对象，该对象代表了一
个圆角矩形。因此，如果点击圆角矩形外、外接矩形内的区域则不会选中项。
    当创建圆角矩形时，可以传人一个可选的参数来指定圆角率。利用私有函数roundness()可以
计算出一个合适的值。  ．
void Node::paint(QPainter *painter,
                                                  const   QS\yle.OptionG ra p hicsltem '*optio.n ;
                  ' ' QWid.get: /* w'd:get .*/)
   QPen pen(myOutlineColor); , .
    if (option->state'& QStyle::State_SelectedY'{'    .
     pen,setStyle(Qt::DotLine);        '   .
                pen,setWidth (2) ;
     }    .
         painte r->setPen ( pen) ;
  ':     painte r->setBrush( myBackg roundColo r) ;
QRectF rect = otrtlineRect();
painte r->drawRoundRect ( rect ,   roundness ( rect.width ( 》
 roundness(rect.height(》);
pain.te r->setPen ( myTextColo r) ;
painter->drawText(rect, Qt::AlignCenter, myTextJ
    paint()西数就是绘制项的地方。如果项被选中，就将画笔的风格改为点线型，而且使线更粗
些；否则，默认使用像素为1的实线。还设置了画刷的颜色为背景色。
    然后，绘制一个与边缘矩形大小相等的圆角矩形，其中使用了由roundness()私有函数返回一的
圆角率。最后，在圆角矩形的上面绘制文字，使其居中于边缘矩形。
    QStyleOptionGraphicsltem类型的option参数是Qt的一个不寻常的类，因为它提供了几个公有成
员变量。这包括当前的布局方向、字体规格、调色板、矩形、状态（如选中、“获取焦点”，以及其他一
些状态等）、变换矩阵和细节级别。这里我们检查了状态变量来确定节点是否被选中。
QVariant  Node: :itemChange(GraphicsltemChange change,
                            const QVariant &value)
{
 :  if (change = ItemPositionHasChanged) {
       foreach (Link *link, myLinksJ
                          link->t rackNodes ( ) ;
     }
   return QGraphicsItem::itemChange(change, value);
}:  i
    ～旦用户拖动一个节点，就会调用iternChange()处理器，由ItemPosidonHasChanged作为第一个
参数。为了保证Link位于正确的位置，可以遍历节点的Link集合，通知每一条线更新它们的端
点。最后，调用基类的实现以确保基类也得到了通知。
void  Node: :mouseDoubleClickEvent(QGraphicsSceneMouseEvent  *event)
        QString  text  =  QInputDialog : :getText (event->widget ( ) ,
                        tr("Edit Text"), tr("Enter new text:")
                                          QLineEdit::Normal,  myText) ;
            setText(text) ; . .,
    如果用户双击该节点，就弹出一个显示当前文字的对话柜，并且允许用户修改它。如果用户
点击了Cancel，将会返回一个空字符串。因此，只有当字符串不为空时，这个修改才会有效。稍后
将看到怎样修改其他的节点属性。
w罐避菪嚣鎏铡遵
第‘g章三雄图，形
157
int Node:.:roundness(double size) 'const
{        .
   const int Diameter = 12; :
    return 100 * Diameter / int(size);
}
    roundness()函数返回合适的圆角率，以确保节点的转角是直径为12的四分之一圆。圆角率的
范围必须在0（直角形）到99(满圆形)之间。
    我们已经知道了两个自定义项的类的实现，现在是介绍如何使用它们的时候了。图表应用程
序是一个标准的带菜单和工具栏的主窗口应用程序。我们不会查看所有的实现细节，而是专注于
与视图体系相关的细节。首先来看从QMainWindow子类定义中截取的一部分。：  二
class DiagramWindow : public QMainWindow
{
Q_OBJECT
public:
DiagramWindow()
private slots:
   . void addNode();
       void  addLink( ) ;
    ' void del( ) ;
   void cut();
   void COPY()r
   . 'vojd paste() ;. .     .
        void  b ringToF ront ( ) ,
  void sendToBack();
   void properties();
      . void  updateActions ( )
private:
      typedef QPair<Node *, .Node *> NodePair;
void createAct.ions();  . .  ' .
void createMenus();   . '
void createToolBarsA:);   :':"  . ,
void setZValue(int z).;
void setupNode(Node *node) ;'
Node *selectedNode() const;
Link *selectedLink() const;
NodePair selectedNodePair() const;
QMenu *fileMenu;
QMenu *editMenu;
QToolBar *editToolBar;
QAction *exitAction;
QAction *propertiesAction;    .
QGraphicsScene '*scene;
QGraphicsView *view;
int minZ;
int maxZ;
int seqNumber;
    犬多数私有槽的用途都应当可以清楚地从它们的名字中看出来。propertjes()槽用来在节点被
选中时弹出一个属性对话框，或者在Link祓选中时弹出一个QColorDialog对话框。updateActions()
槽可以根据被选中的项来激活或取消操作。  ．
    。∥    ，  l
    D'iag ramWindowi j Diag ramWindow()
    _    ．    f    ．
    乇    ．．
    scene=new QGraphicsScene(0,O,600, 500);
    -  _．
孚一．¨  “
158    C++ GUI Qt 4编程（第二版）
view = new QGraphicsView;
view->setScene(scene),
view->setD ragMode ( QG raphicsView: :RubberBandD rag ) ;
view->setRende rHints ( QPainte r:  :Antialia sing
                                    I  QPainter: :TextAntialiasing)
view->setContextMenuPolicy ( Qt : :ActionsContextMenu )
setCent ralWidget ( view) ;
minZ = 0;
maxZ = 0;  '
seqNumber = 0
createActions ( ) ;
createMenus ( ) ;
createToolBa rs ( )
connect ( scene,  SIGNAL ( selectionChanged ( 》
              this,  SLOT(updateActions ( 》 ) ;
 sethlindowTitle ( t r ( " Diag ram" 》 ;
updateActions ( ).;
    我们从创建一个图形场景开始，其原点为(0，0)，宽为600，高为500。然后，创建一个视图来显
示场景。在下一个例子中．将用QGraphicsView的子类的方式代替直接使用QGraphicsView来自定
义其行为。
    通过单击，可以选中那些可选项。要想一次同时选中多个项，用户可以在按住Ctrl键时单击
那些项。把拖动模式设置为QGraphicsView:：RubberBandDrag，则意味着用户可以通过圈选选中
它们。
    minZ和rnaxZ数字用在sendToBack()和bringToFront()函数中。序号用来为用户添加的每个节
点提供一个唯一的初始化文字。
信号一槽连接可以确保场景的选取一旦发生改变，就可以启用或者禁用应用程序的那些动作，
以便只让那些有意义的操作才可用。我们调用updateActions()来设置操作的初始可用状态。
void DiagramWindow::addNode( )
{
    Node *node = new Node;
        node->setText (tr( "Node  961" ) .a rg ( seqNumber  +  1》
       setupNode(node) ;
}
    当用户添加了一个新的节点时，就可以创建一个新的Node类的实例，并赋予它默认的文字，
然后把节点传给setupNode()来定位和选取它。我们使用一个单独的函数来完戍一个节点的添加
工作，因为在实现paste()时还需要用到这一功能。
-
void  Diag ramWindow: : setupNode( Node  *node)
{
      node-. >setPos(QPoint(80 +  (100 *  (seqNumber 96 5》,
                      80 + (50 *《seqNumber/ 5) 96 7》》
      scene->addltem(node) ;
++seqNumber;
scene->clearSelection ( ) ;
node->setSelected ( t rue) ;
bringToFront ( ) ;
    此函数可以在场景中定位一个新近添加或者复制的节点。序列号的用途可以确保新节点被
添加到一个不同的位置．，而不是放在彼此之上。我们清除了当前的选中操作，并且将新添加的节
点选中。bringrroFront()调用确保了新节点比任何其他节点都靠前。
void  DiagramWindow: : b ringToF ront ( )
{
++maxZ;
         setZValue ( maxZ) ;
}
void  Diag ramWindow: : sendToBack( J
{          .
--minZ ;
setZValue(minZJ
}
void DiagramWindow::setZValue(int z)
                                                                  .
      Node *node = selectedNode() ;
   if (node)
   .        node->setZValue(z) ;
第8章二维’图形    159
    bringToFront()槽会增加maxZ的值，然后会把当前选中的节点的z值设置为maxZ。sendToBack()
槽会使用minZ，并且具有相反的效果。这两个值都是在setZValue()私有函数中定义的。
Node  *Diag ramWindow: : selectedNode ( )  const
{      ,
QList<QGraphicsltem *> items
if (items.count() == 1) {
   return dynamic_cast<Node
} else {
 .  return O;
=  scene->selectedltems ( )
*>(items.first(》
场景中所有被选中的节点的列表可以遁过调用
QGraplucsScene：：selectedltems()获得。如果仅
有一个节点被选中，selectedNode()函数被用来返回单个节点；如果没有节点被选中，则会返回一个
空指针。如果确实存在一个被选中的项，若该项是一个节点，这个类型强制转换将返回一个Node
指针，若是一个Unk，则会返回一个空指针。
    还有一个selectedLink()函数，如果确实存在一个选中的项并且该项是一个Link，它也会返回
一个选中的Link项指针。
void  Diag ramWir/dow: :addLink ( )           .
{
   NodePair nodes = selectedNodePair()
   if (nodes =- NodePair(》
                  retu rn ;       l
Link '*link = new'Link(nodes.first, nodes.second);
scene->addltem(link);      .            ..
    如果有两个节点被选中，用户就可以添加一个Unk。如果selectedNodePair()函数返回两个被
选中的节点，则创建一个新节点。Link的构造函数将直线的端点设置为从第一个节点的中心到第
二个节点的中心。
Diag ramWindow: :NodePair  DiagramWindow: : selectedNodePair ( )  const
{
    QList<QGraphicsltem *> items = scene->selectedltems();
    if (items.count() = 2) {     .
             Node *first = dynamic_cast<Node *>(items.first(》 ;
             Node *second = dynamic_.cast<Node *>(items.last(》 ;
                                                                                                     .*.
    :  if (first && second)           .   ,
                  return NodePair(first,  second) ;
 rl
 ra
 o-
 -o
 o
 z
  =
  IJ
160
C++ GUI Qt 4编程（‘第二版）
    此函数类似于以前看到的selectedNode()。如果确实存在两个被选中的项，并且它们都是节
点，那么它们都将会返回；否则，将只会返回一对空指针。    ’
    void  DiagramWindow::del()
    {
    QList<QGraphicsltem车>items=scene->selectedltems();
    QMutableListlterator<QGraphicsltem车>i(items)；    一
    while (i.hasNe)ct(》{
    Link  *link=dynamic_cast<Link+>(r,next());、
    if (linkJ{
    delete link;
    i．remove()：
    )
    }    一    、    ．：。
    ．：    。    ．  ，    {．  7．
’’：  一. qDeleteAll(items)-;    ’_:
    )    ．    ~    ．．    t矗
    无论选中的项是节点、Link或者是既有节点又有Link，该槽都可以删除这些选中的任意项。
当删除一个节点时，它的析构函数就会删除与其关联的所有Link。为了避免Link的二次删除，可
以在删除节点之前先删除那些Link项。
    void  Diag ramWindow::p roperties()
    {
    Node *node=selectedNode();
    Link *link=selectedLink();    ?
r:iesDialog
 (linkJ {
r color = oc
olo r.isValid
 in k->s etColo
(nodej th
alog :,: get
r) ;
    '
    加果用户触发了Propertjes动作，并且只有一个节点被选中，就可以调用Properties对话框。这
个对话框允许用户修改节点的文字、位置和颜色。因为ProperUesDialog可以直接操作_个节点的
指针，我们只需将其执行为模态对话框即可，它会自行照料自己的。
：  。如果÷个Link被选中，就可以使用lQt内置的1QColorDialog：：getColor()静态简便函数弹出一个
颜色对话框。‘如果用户选择了一种颜色，就将它设置为’Link的颜色。
    ．  -
    如果节点的4属性或者Link的颜色发生了改变，那么这些改变就可以通过设置的那些函数生
    ‘    ，  j
效，它们会调用update(．)拳确保节点和unk使用自己的新设置来重绘自己。    ，
    在这样的应用程_中，用户常常希望能够使用剪切、复制和粘贴项，而能够支持这些功能的办
法就是以文本的方式来显示这些项，这一点会在讨论相美代码时看到。我们只处理这些节点，是
    ’    k
因为复制或者粘贴UIlk并没有什么意义，它们只存在于各个节点之间。
void DiagramWindow::cut()
{
   Node *-node = selectedNode();
   if(’！nodeJ
 return;
    copy()；
    delete node：
    }
    Cut操作是两部分操作：把被选中的项复制到剪贴板，然后再将该项删除掉。复制使用copy()槽
实现，该槽用于Copy操作，且删除使用C++的标准deleie操作符，依靠节点的析构函数可以删除
    ．    ．    ．
与节点相连的Liiilc，并且从场景中删除该节点。
o  Or
r   LO
rv      o _- u
rl     r -~
-o o r\}    o        '
O L _1 q) U f
C o- -o cn a-+
.+-                .
rl    }         r.
一譬连“鬟爆臻臀囊落搿
    第8章二维图形    161
    _.___J-________________________.-_一
yoid  D.iag ramWindow: : copy ( )
   Node *node = selectedNode();
  if (!node)
 return;
QString str = QString("Node %1 %2 %3 %4".)
                               ,a rg ( node->textColo r( ) .name ( 》
                                    .a rg (node->outlineColo r ( ) .name ( 》
                                    .a rg ( node->backg roundColo r.( ).. name ( 》
 .arg(node->text(》;
QApplication : : clipboa rd ( ) ->setText ( st r) ;
    QColor:：name()函数返回一个QString，包含一个HrfML风格的颜色字符串，格式为“#RRGGBB”，
每个颜色元素由一个从Ox00到OxFF(0到255)的十六进制值来表示。我们把字符串写到剪贴板
中，该字符串是一个以“Node”开始的单行文字，接着是节点的三个颜色值，最后还有节点的文字用
    ．  ‘’    t
空格彼此隔开。例如：    e  ，-    。
    ，：    ‘    ‘
Node #aa0000 #000080社ffffff Red'hefring
达段文字可以由paste()函数解析：
yoid DiagramWindow::paste()          .3
        ost ring  str  =  QApplication: : clipboa rd ( ) ->text ( ) ;
   QStringList parts -' str.split(" ");
   if (parts.count(》= 5 && parts.first() H "Node.") {       . ,
     . Node *node = new Node;      .
                        node->setText ( QSt ring List ( pa rt s . mid (4
                    node->setTextColo r (QColo r (pa rts [1J 》 ;
                    node->setOutlineColo r (QColo r ( pa rts [ 2 J
                  node->setBackg roundColo r(QColo r(parts
             setupNode(node) ;
      }
}
)
)
3
oin(””))；
    我们把剪贴板中的文字拆分到一个QSUingList中。使用前面的例子，将得到列表[“Node”，“#
    --
aa0000”，“#000080”，“}}ffffff'’，“Red'’i“herring”]!要成为一个有效的节点，列表中就必须至少存茌5
    1    t…
个元素：单词“Node”、三个颜色值，以及至少一个单词作为文字。如果情况确实如此，就可以创建
    ．    ．
一个新的节点，设置显示的文字为以空格分隔符串联的字符串的第5个单词以及其后面的单词的
组合。我们设置颜色值为串联字符串的第2、第
    J    ．．：一
够接受由QColor:：name()函数返回的颜色名称。
    Z。r  ，    _1
3和第4部分，使用Q'C olor的构造函数，该函数能
 cutActiorc->setEnabled (is Node) ;
 copyActio ri- >setEna bled (isNode) ;
addLin kAction->set Enabled (isFlodePair) ;        .
deleteAction->setEnabled ( hasSelection ) ;
b ringToF rontAction->setEnabled (isNode) ;
sendToBackAction->setEnabled(isNode) ;
propertiesActiort->setEnabl'ed(isNode)-; '  .     . .
foreach ('QAction术action, view->actions(j)  ./. .   'L
   view->removeAction(action);           .  :   .  . ,   . '
l～  ．
t．一    ^    、
    ～  ．
162    C++ GUI Qt.4编程（第二版）
foreach (QAction *action, editMenu->actions(》 {
        if  ( action->isEnabled( 》              .
           view->addAction(action) ;
    }
    '
    现在，就完成了对图表应用程序的介绍，可以将注意力转移到第二个图形视图方面的例子上，
即Cityscape。
    如图8.17所示，Cityscape应用程序显示了城市中的建筑物、街区和公园的虚拟地图，最为重要
的那些建筑会用它们的名字加以标注。它可以让用户通过鼠标和键盘来移动和缩放地图。首先
介绍Cityscape类，它提供了应用程序的主窗口。
public:
       Cityscape( ) ;
图8.17具有两种不同显示比例的Cityscape应用程序
private;
   void generateCityBlocks()
QGraphicsScene' *scene
CityView *view;
  此应用程序没有菜单栏和工具栏，它只是简单地使用CityView窗口部件来显示有标注的地
图。CityView类从QGraphicsView类派生过来。    。
Cityscape::Cityscape( )
           .         ..
   scene = new QGraphicsScene(-22.25, -22.25, 1980, 1980);
   scene->setBackgroundBrush(QColor(255, 255, 238》; .
        generateCityBlocks ( ) ;
view = new CityView;
view->setScene(scene),
setCentralWidget(view)
setWindowTitle ( t r( "Cityscape" 》 ;
    杓造函数创建了一个QGmphicsScene，调用generateCityBlocks()生成一幅地图。这幅地图包含
2000个街区和200个标注。
    首先将看到的是图形项的子类CityBlock，然后是图形项的子类Annotation，最后是图形视图的’
子类CityView。
3
o
-o
o
u.
-o
=
o
o
r。
i-  '  -,
“毪罐，4耩罐臻越搿魏潮滔冯国鬻裳豢；}
翁蕊溺爨潮
第8章二维图形
1;63
class CityBlock : public QGraphicsltem
public:
   enum Kind { Park, SmallBuil.ding, Hospital, Hall, Building, Tower
            LShapedBlock, LShapedBlockPlusSmallBlock, TwoBlocks,
              .BlockPlusTwoSmallBlocks };
   CityBlock(Kind kind);
QRectF boundingRect() const;
void  paint ( QPainte r  *painte r,
         const QStyleOptionGraphicsltem'*o'ption, QWidget *widget)
private:
 . int kind;   .
   QColor color;
       QPainterPath ,shape
};      .       :
    一个城市的街区会有类型、颜色和形状属性。因为城市街区是不可选的，所以不用担心像前
面例子中Node类那样去重新实现shape()函数：．
    ：    ‘
    CityBlock::CityBlock(Kind kind)    .
    {
    this->kind=kind：    j
int
int
int
col
 green = 96 +
 red = 16 + gr
 blue = 16 + (
or = QColor( re
 ( std: : rand ( )  %  64) ;
een + (std::rand()1% 64) ;
std::rand() % green); .
d, green, blue);
if (kind == Park) {
   color = QColorl(192 + (std::rand() % 32), 255,
                   192 + (std::rand() % 16》; '
           shape .addRect ( bounding Rect ( 》 ;
 else if (kind == SmallBuilding) {
 else if (kind == BlockPlusTwoSmallBlocks)
   int wl
   int hl
   int w2
   int h2
   int w3
   int h3
std::rand()
std : : rand( )
std::rand()
std::rand()
std::rand()
std::rand()
int y = (std::rand() % 4) - 16; .
shape.addRect(QRectF(-16, -16, wl,
shape.addRect (QRectF(-16 + wl + 4,
shape.addRect(QRectF(-16 + wl + 4,
y, w2, h2》
(std::rand()%4).w3,h3));
杓造函数设置了一种随机颜色，可以根据需要显示的街区的类型生成一个合适的QPainterPath。
QRectF  CityBlock: : boundingRect ( )  const
{
   return QRectF(-20, -20, 40, 40);
}
每个街区都会占用一个40×40的正方形空格，其中心点是(0，0)。
void CityBlock::paint(QPainter *painter,
                    const QStyleOptionGraphicsltem *option:
                      .   QWidget * /* widget */)      .  .  .
co co oo oo .- .-
          oo co
++++
    ++
c, m c) c) ^-
rl 2 + + 6 6
do do do do o\o 'do
  ,    +
          .    0
        +
        IJ
        .+
        o
      o-
 .o
                                                       I
                    .      I
   A  IJ
    L   C:
    o  .+
    __ r      O
  c, n  o_
  .u o
  ^叶   -
       N   IJ
   v, aJ   C
  - m   rJ
   rJ _C   -O
   ro \n    ro
   v -C  g
oJ
   H- ro    iJ
  o o_   C
 rr O
   V r    .+
   > rJ   -O
   O f    ro
 -A  L
  IL  L
  C v  ro
  o IJ   v
  .+ C   C
   c:t (o o -l
   o c:- tn o
-r
  r   J-
  164    ．  C++ GUIQt4编程（第二版）
    ，    ’    ．
___.--____-_―‘‘‘‘‘一―’―‘‘‘‘‘‘‘‘‘‘一
int
ra
ra
al
  coeff =  105 +  int (std::lcg(option->levelOfDetail - 4.0》 i
dient-,setColorAt(O.O, -'color:l'ighter(coef.f》;t --   . . :  '.
 dient. setColo rAt (1.0,   color.da rke r (coeff》 ;
nter->fillPath(shape, gradient); '         . .
    )
    )
在paint()函数中，我们用给
    ●如果缩放因子比4.0
    ●如果缩放因子是4.0
定的．QPainter绘制图形。需要区分两种情况：
小，则使用纯色填充图形。
或者更大，使用QLneaIGradient填充图形，以产生一种奇妙的光照效果。
    QStyleOpdonGraphicsltem类的levelOfDetail成员函数存储一个浮点值，该值就是缩放因子。1.0
意味着以原始大小显示场景，0.5意味着以原始大小的一半显示场景’，2.5表示显示的大小是原始
尺寸的2.5倍。使用“详细程度”信息可以让我们在那些放得太大似至于不能显示细节的场景中‘
    ’    ，    ’‘r、    ，
使用更快的绘图算法。
    CityBlock类很好用，但事实上，当场景缩放时造成项也被缩放，这样就给显示文字的那些项带
来了问题。一般情况下，我们不希望文字随着场景缩放。视图体系为这一问题提供了通用的解决
方式，即使用Iten，IgnoresTransfonnadons标识。Annotatjon类中就使用了此标识：。    ，1
class Annotation : public QGraphicsltem
{
public: .
   Annotatio.n(const QString &text, bool major = false);
 ; ;vo/,d set,Text(const ostrjng &text);
 . _QString..text() const;
QRectF boundingRect() const;
void paint(QPainter *painter,
          const QStyleOptionGraphicsltem *option, QWidget *widget)
    private:
    ’  QFont font;
    QString str;
    bool major;
    double threshold;
    int Yr
    )；
    构造函数使用丈字以及称作major的布尔型标识作为参数，这规定亍该注解是主注解还是辅
    ．    1
注解，还将影响到字体的大小。    ，．
    Annotation::Annotation(const QString &text,: bool major)    .‘
    t
    font=qApp->font()；    ？
    font.setBold(true)；
    if (major)t
    ，h
    .      font .setPointSize( font. pointSize()+2);
    ’    ，
    font .setSt retch (QFont::SemiExpanded);
}
if (major)
thresho
} else {
thresho
str = text;
thrs->major
y = 20 - (s
t
ld
0.01  *'(100 +  (std:: rand( )  96..100》 ;
= major, . .
td::rand() g6 40)
setZValue(1000) ;
set Flag (Itemlgno resTransformations ,   t rue) ;
242。1 7_鲁Ⅵ量麓时谱肫錾埘曛罄穰霎侮盘镜嚣龌臻臻嬲嚣
    ．第8章二维图形    165
    在构造函数中，假设主注解代表一个重要的建筑物或者地标，则首先可以把它设置成较大而
且加粗的字体。阈值是通过伪随机方法计算出来的，比它小的注解不会被显示出来。主注解有较
小的阈值，当场景缩小时，不太重要的注解会消失。
    我们设置z的值为1000，以确保注解显示在最上面，而且使用ItemIgnoresTran。formations标识来
    ，  ．    )
确保无论场景被如何缩放，注解的大小都可以保持不变。’
void  Annotation: : setText ( const  QSt ring &text)
 prepareGeometryChange(》 - .
     str = text; '
       update( ) ;
    如果注解的文字需要修改，它可能比以前更长或者更短了，因此必须通知视图体系修改该项
的尺寸。    二
QRectF Annotation::boundingRect() const
      QFontMetricsF metrics(font) ;
   QRectF rect = metrics.boundingRect(str);
       rect.moveCenter(QPointF(O,  y》 ;
   rect.ad    l, 0, +4, 0);
   retur~djrll:('4, c
}
    找们从注解的字体中取得字体规格信息，使用它们计算出文字；的外接矩形。j然后移动矩形的
    f    ．
中心点到注解的y值的偏移位置，并且使矩形稍微大一些。外接矩形左边和右边的额外像素使文
字相对于边框还有一些空间。
void  Annotation : : paint (QPainter  *painter,      '
                    const QStyleOptionGraphicsltem *option
{                '    QWidget */丰 widget丰/)
   if (option->levelOfDetail <= threshold)
 return;
painter->setFont(font)
QRectF rect = boundingRect(); '
int alpha = int(30 * std::log(option->levelOfDetail》; .       .  ~
if (alpha >- 32)
        painter->fillRect ( rect,  QColor( 255 ,' 255,'  255,  qMin ( alp.ha,  63》 ) ;
painter->setPen(Qt::white) ;
painte r->drawText ( rect.translated (+lr  +1) ,   st r,
                                                    QTextOption ( Qt : : AlignCenter》 ;             .
painter->setPen(Qt::blue) ;
painter->drawText( rect,  str, QTextOption(Qt::AlignCente.r》
    知果场景缩小的尺寸超过了注解的阈值，就不再绘制该注解。如果场景被放得足够大，就事
先绘制一个半透明的白色矩形，这有助于在黑色的块上显示文字j
    我们绘制文字两次，一次用白色，一次用蓝色j’白色的文字在水平和竖直方向上平移一个像
素来创建．个阴影效果，使文字更容易被读出来。
    介绍完了块和注解是怎样完成的之后，下面继续介绍Cityscape应用程序的最后一个方面，即
用户自定义的QGraphicsView子类：
class CityView : public QGraphicsView
{
Q_OBJECT
  166    C++吼ⅡQt 4编程（第二版）
    ________._1_-二__.____________一
-_．，―――――――一
public: ,
   CityView(QWidget *parent = 0);
protected:                       '  . .
 .     void wheelEvent (QWheelEvent  *event) ;
};
8.5打印
    Qt中的打印与在QWidget、QPixmap或者QImage上的绘制非常相似。它包括以下步骤：
    1．创建一个当作绘制设备的QPtinter。
    2．弹出一个QPtintDialog对话框，以允许用户选择打印机并且设置一些选项。
    3．创建一个在QPrinter上操作的QPainter。
    4．使用QPainter绘制一页。  ，    ’
    5．调用QPainter:：newPage()来进行下一页的绘制。
    6．重复步骤4和步骤5，直到所有页都被打印为止。
    在Windows和Mac OS X上，QPrinter会使用系统的打印机驱动程序。在UNIX上，它会产生
PostScript并且把它发送给lp或者lpr命令[或者是由QPtinter:：setPtintProgram()设置的其他程序]o
QPtinter也可以通过调用setQutputFormat( QPtinter：：PdfFormat)来生成PDF;文件①。
    我们先从一个只有单页打印的简单实例开始。这里的第一个例子可以打印一个QImage，如
图8.18所示。    ．
    void PrintWindow::printlmage(const QImage &image)
    {
    QPrintDialog printDialog(&printer, this);
①有望在Qt 4.4中引入一些打印预览类。
辙    骺一
啊    ．    子～
娜    胭～
一一    j    _黜～
    适一一一～一
赫黼    廿～
一一    ～一
器    ．
    啼～
删琰    ，。，埘叭    我一
一一，    一，一一岫一    一～
可型训    ；    ～～一    燃～
类警~咄一一3  il  cn IJ Om
一一一～一，，    一一一一
    V    t t
    L    S Il S C
    L    e    a
    i  。。，．    一一一如承
    w  e t o一  晰    ～卅雠
慨洗…帅．蜥。一一一一～一～  渤一一～驴燧
    叫珊  胪    ～实可
默．舫删：t。一，嘲时“d d d s，剀嘶嫦删式也。
    一  薪瓯掘
  墉    'lt一    ，翻_~‘醛几动示
第8章二维图形
167
paint
ialog. exec ( 》  {
er painter(&printer) ;
rect = painter.viewport
size = image.size() ;
cale(rect.size(), Qt::K
r.setViewport(rect.x(),
  size.widt
r.setWindow(image.rect(
鼎涮酏拍）；
)，size.height(
    painter,drawlmage(0,0,image);
    )
    )
    假设PrintWindow类已经有了类型为QPrinter、名字为
printer的一个成员变量。可以简单地在printlmage()的栈
里创建QPrinter，但是在打印完之后再打印另一个的时候，
将不会记得用户的设置。
    可以创建一个QPrintDialog，并且调用exec()来显示
它。如果用户单击OK按钮，它就返回true；否则，它就
返回false。在调用exec()之后，QPrinter对象就准备好
了。（不调用QPrintDialog也是可以的，可以通过直接调
用QPrinter的成员函数来设置它。）
    接下来创建一个QPainter，在QPainter上进行绘制。
谩置窗口为图片大小的矩形，并且视口也为同样比例大
小的矩形，并在位置(0，0)处绘制一个图片。
    默认情况下，QPainter的窗口会被初始化，这样就可
以让打印机和屏幕具有相似的分辨率（通常是每英寸①
72到100点之间的某个值），这样使得把窗口绘制代码
图8.18打印QImage
重新使用到打印中变得非常简单。这里不用考虑此问题，因为我们会自行设置自己的窗口。
    在本例中，我们选择打印一个图片，但打印图形视图场景也同样很简单。为了打印整个场景，
可以调用QGraphicsScene:：render()或者QGraphicsView:：render()，QPainter作为第一个参数。如果
只想打印部分场景，可以使用render()函数的可选参数指定绘制的目标矩形（在页的什么地方绘制
场景），以及源矩形（需要绘制的部分）。
    打印不超过一页的项是非常简单的，但是很多应用程序通常都需要打印多页。对于这些情
况，需要一次绘制一页并且调用newPage()来前进到下一页。这将会导致一个问题，也就是如何决
定可以在一页上打印多少信息。在Qt中，有两种方式处理多页文档：
    o可以把数据转换为HTML，并且使用Qt的富文本引擎QTextDocument迸行显示。
    ●可以执行绘制并且手动分页。
    下面将依次讲述这两种方法。作为一个实例，我们将会打印一个花的说明：一个用文字描述
花的名称的列表。在这个说明中的每一项都存储了_个格式为“名称：描述”的字符串，例如：
    Miltonopsis santanae:A most dangerous orchid species,.
    因为每一种花的数据都由一个单一字符串进行表示，所以可以使用一个QSngⅡst来代表这
    Qt    、’
个说明中的所有花。在这里使用Qt的富文本引擎来打印一个花的说明：
    void  PrintWindow:: printFlowerGuide( const  ost ringList &ent.rjes)    .
    {    。
    QString html;
1    ①1英寸=2.54 cm。
168    C++ GUI Qt 4编程（第二版）
foreach (QString entry, entries) {                .   ' -矗．..." :
   QStringList fields = entry.split(": ");          .'.
         QSt ring  title  =  Qt: :escape ( fields [OJ ) ;
   9irr\{ing bo~aybleQXgd旋芒c<p:O(g'~ldbso[rldle)r=l cel
                                    " kt r>Std   bg colo r-\ "lightg ra y\ " ><cfeolrilts ?ajCzieng\  01\\n- "' ,,
           "<b><i>" + title + "</i></b></font>,\n<tr><td>" + body
                                                                                                                                                                   '                   .
p rintHtml ( htcrrl) ;
    第一步是把QStringList转换为HTMLo每种花都变成了一个‘HTML表格中的两个单元。我们
使用Qt：：escape'()来把特殊字符“&”、“<”、“>”替换为相应韵HTML项（‘‘&砌p；”，“&t；”，
“&gt;”）i然后调用pnntHtml().tJ印这个文本争  t  ‘    ‘
void PrintWi      :p.rintHtml(const QString &html)     '
   ltWindow'::plr    . .
  QPrintDialogpr;ntDialog(&pr.inter, th's);   .  .
    if (printDialog.exec(》 {  ' "
      QTextDocument textDocument;
           textDocument.setHtml(html) ;'
                    textDocument . p rint (&p rinter) ,                .               .
printHtml()面数弹出一个QPtintDialog，负责打印iTrML文档。它可以在Qt'的应用程序中不做
改变地重新
页如图8.19所示。
图I8 .;19使用'QTextDocument打印花的说明
’  转换文档为HTML并使用、
最方便的选择。如果需要更多
使用这个方法打印花的说明。以下是新的pnntFlowerGuide()函数：
 void   PrintWin dow:  .! p rintFlowe rGi/ide'( con s t'i ost ringList.r &ent ries )
   QPrintDialog printDialog(&printer, th'is)';  .  '
    if (printDialog.exec(》 { '               , '. .
         QPainter painter(&printer); .  . .      .
       QList<QStringList> pages;
4蓬鹚纂濑嚣幽
    一j’第8章j二维图形    169
    paginate(&painter, &pages,  entries);    i  ?    :    ”
    printPages(&painter, pages);    二
    )
    }    ：    ，  ．
    。    L‘    ，
    在设置完打印机并且构造完绘图器后，就可以调用paginate()帮助函数来决定哪一个条目将
要在哪一页出现。这样做的结果就放在一个QStringList的列表中，每一个:QStringList保存的是一页
中的所有条目。我们将此结果传给printPages()。
    例如，假设花的说明包含6个条目，分别是A，B，C，D，E和F。现在假设A和B在第1页；C，D
和E在第2页；F在第3页。pages列表将会是这样的：0位置是一个￡A，’B]列表，1位置是一个[C，
D，E]列表，而2位置是_个[F]列表。。-．：    ‘  、    ，：‘
    void  PrintWindow:: paginate (QPainter车painter, QList.<QStringList>车pages,    ‘
  .{    :.const QStringList &entries)  ‘
    ．    -1，  ．，    、  ．
    QStri.ngList currentPage;    ,.:    .    ,.
    int pageHeight=painter->window().height() -2术4 La rgeGap';    、    ！    ．
    int y=0；
foreach (QString e
   int height = e
  . if (y + height
pages->app
currentPag
ntry, entr
ntryHeight
 > pageHei
end(curren
e,clear{ ) ;
es) {
painter, entry);
ht && !currentPage.empty(》
Page) ;
    currentPage.append(entry);
    y+= height"+ MediumGap;
    }
    if( !currentPage.empty(》    ‘
    pages->append( currentPage);    ;    ?‘r一  ，
    }    ．    ，．    ；
    +}    1
    paginate()函数把花的说明的条’目分配到页中。它依赖于entryHeight()函数，后者计算了一个
条目的高度。它也把页面顶部和底部页眉和页脚也计算进去了，也就是LargeGap的大小。
    我们遍历这些条目并且把它们添加到当前页中；，直到已经无法在当前页放下条目为止。然
后，把当前页添加到pages列表中并且开始新的二页。    ’    ’
    int PrintWindow::entryHeight{QPainter *painter, const..QString &entry)    。    .,
    {    ：    -    ．  ：，    ：-．
    ,QStringList fields=entry.split(":“);    ”
    QString title=fields[0];    ,    :    ?  ～..  ,
    QString body=fields【1】；
    int te×tWidth=painter一>window().width()一芝；SmallGap;
    int maxHeight=painter一>window().height();    :
    Dainte产二>setEont{titleFont）；，．。    ．  ~：‘J    ’  ，，  、．毋二t。‘‘．-j一  二吃奢了、+1曲’
    QRect titleRect.painte’一>60“掣1“gR8c‘(o-o,‘8x'wid‘“,…8““?1g“‘，
    .    .Qt::TextWordW陀p,title);
    painter一>setFont(bodyFont);
    Q8ec'6州yRec'2 0aln托r一>60un毗naR86‘‘0，o J‘笛群{嚣孙？”瑟鼢；警i 2
    Ot：：TeX
    '  retUrn titleRect．h每ight（刁+bodyRect。height，（y+‘4，S币言llGap；：、  ’
    }    ‘    一：    ，：jj j．    ．，    。    ．  ‘．一
．  entryHeight()函数使用Q蹦mer：：bourIdingRect()来计算一个条’目所需的垂直空间。图8.20显
示了花的条目的布局并且也说明了SmUGap和MediuIIlGap常量的意义。：
    void P rintWindow::printPages(qPainter车painter,
    const口List<QSt ringList>＆pages)
    {
    int firstPage=printer.fromPage()一1j
ii_ti:.
   .       .
         .. .
 '  .
 ./    .
                 .
      170                                               C++ GUI Qt 4编程(第二版)
--- N -
          if, (firstPage >= pages.size(》                       . /      .   .
                            retu rn;
       if (firstPage == -1)
           firstPage = 0;
       int lastPage = printer.toPage() - 1;          '  ' .
       if (lastPage == -1 11 lastPage >= pages.size(》  .  . .
           lastPage = pages.size() - 1;
        int numPages = lastPage - firstPage + 1;
      ' for (int i = 0; i < printer.numCopies(); ++i) {
          for (int j = 0; j < numPages; ++j) {  .
              if (i 1= 0 11 i != e)  .
                                             p rinte r. newPage ( ) ;
              int index;
               if (printer.pageOrder() = QPrinter::FirstPageFirst) {        -
                    index -. firstPage + j;
             } else {  '
                    index = lastPage - j;
                      }
                             printPage(painter.,  pages [indexJ ,  index +  1) ;
                }
图8.20 -种花的条目的布局
    printPages()函数的作舟就是使用printl，age()，并按照正确的顺序和正确的次数序号打印每一
页。结果如图8.21所示。使用QPrintDialog，用户可能要求几个副本，指定打印范围，或者倒序打
印。提供这些选择是我们的责任――也可以用QPrintDialog：：setEnabledOptions()使它们失效。
    首先确定打印的范围。QPrinter的fromPage()和toPage()函数返回被用户选择的页码：或者没
有被选中的就返回0。减去1，因为页列表是从0开始的。如果用户没有设置任何范围，则设置
firstPage和lastPage为整个范围的值。
    然后打印每一页。外面的循环按照用户所需要生成的副本的份数进行循环。绝大多数打印
机驱动程序都支持多份副本，所以对于它们，QPtinter：：numCopies()总是返回．1。如果打印机驱动
程序不支持多份副本，numCopies(')返圊用户所需的副本数，并且应用程序会负责打印全部。[在前
面QImage的例子中，为了简单忽路了numCopies()。]
    里面的for循环按页数循环。，如果不是第1页，就调用newPage()跳过旧的一页并且在一个新
的空白页开始绘剞。我们调用pIintPage()绘制每一页。    ？
    void PrintWindow::printPage(QPainter *painter,
    const QStringList &entries, int pageNumber)
    {    ．    。
    ．    painter->save()；
    ’    painte r->t ranslate (0,   La rgeGap);
j。‘2窖登“誊馕蔼镦涮嗡搿
第8章二维图形    171
foreach (QString entry, entries) { .
   QStringList fields = entry.split(": ");
   QString title = fields[OJ;
   QString body = fields[ll;
   printBox(painter, title, titleFont, Qt::lightGray);
   printBox(painter, body, bodyFont, Qt::white);  .
J painter->translate(O,MediumGap);  '
painter->restore() ;
painter->setFont (footerFont) ;
painte r->d rawText ( painte r->window ( ) ,
                               Qt::AlignHCenter  I Qt': :AlignBottom
                                       QSt ring : : numbe r( pageNumber》 ;'
    printPage()函数遍历所有花的说明条目并且调用两个printBox()打印它们：二个用于标题（花
    ・    一    ，    ‘，    I
的名字），一个用于体（它的描述）。它也会在页的底部中央绘制页编号。页面的布局如图8.22
所示。
La rgeGap
pageHeight
La rgeGap
囹8.21使用QPainter打印花的说明
图8.22花的说明的页面布局
窗口
     172                                               C++ GUI Qt 4编~z(第二版)
     -
                                                                                                                                                                                     .
    . void PrintWindow::printBox(QPainter *painter, const QString &str,
                              const QFont &font, const QBrush &brush)       '
      {
              painter->setFont(font) ;     ,  :
int boxWidth = painter->window() .width() ;
int textWidth = boxWidth - 2 * SmallGap;
int  maxHeight  =  painter->window( ) .height ( ) ;
QRect textRect = painter->boundingRect(SmallGap, SmallGap,
int boxHeight = textRect.height().-十-2踣 SmallCap;     -
painter->setPen (QPen (Qt: :black,   2.0,
painter->setBrush(brush) ;   , .
painter->drawRect(0, 0, boxWidt
painter->drawText(textRect, Qt:
painter->translate(0, boxHeight
-Qt: :SdlidLirie》）?
h,  'boxHeight;Y! .- .
:TextWordWrap, str)
);
printBox()函数绘制了一个框的边缘，然后绘制框里的文本。
    至此，就完成了对二维图形打印的介绍。第20章将介绍三维图形。
j N~一  ##4瑚~堪t信朔诌州袖州鋈
第9章拖，  放
    拖放是在一个应用程序内或者多个应用程序之间传递信息的一种直观的现代操作方式。除
了为剪贴板提供支持外，通常它还提供数据移动和复制的功能。
    在这一章中，将首先介绍如何为Qt应用程序添加支持拖放的功能以及如何处理自定义格式。
然后，将介绍如何复用拖放代码来实现对剪贴板的支持。之所以能够复用这些代码，是因为拖放
与剪贴板的功能机理均是以QMimeData类为基础的，而QMimeData是一仑可以提供不同格式数据
的类。    j一。。’    ’    1
9.1  使拖放生效    ，    ：    一  二-
    t一’f
    j    ．  i+_    ‘  ：，  ‘  ‘i‘’
    拖放操作包括两个截然不同的动作：拖动和放下。Qt窗口部件可以作为拖动点(dug site)、放
下点( drop site)或者同时作为拖动点和放下点。
    本节的第．个实例介绍了如何让一个Qt应用程序接受由另．一仑应用程序执行的一个拖动操
作。该Qt应用程序是一个以QTextEdit作为中央窗口部件的主窗口程序。当用户从桌面上或从文
件资源管理器中拖动一个文本文件并且在这个应用程序上放下时，该应用程序就会将文本文件载
入到QTextEdit中。
    以下是这个实例中MainWindow类的定义：  。
    class MainWindow:public QMainWindow
    {
    0 0BJECT
    public:
    MainWindow()；
    protected:    ：
    void dragEnterEvent(QDragEnterEvent *event);
    void dropEvent(QDropEvent *event);
    ．private:    ’
    bool readFile(const QString &fileName);
    QTextEdit *textEdit;
    '；    ：
    MainWindow类重新实现了来自QWidget的dragEnterEvent()和dropEvent()函数。由于该例子的
主要目的是想说明拖放操作，所以一个主窗口类应该具有的很多功能在这里都被省略了。
    MainWindow::MainWindow()
    {
    textEdit=new QTextEdit;
    .   setCent ralWidget( textEdit);
    textEdit->setAcceptDrops (false);
    ‘setAcceptDrops(true);
    setWindowTitle(tr("Text  Editor'l));
    '
    在构造函数中，创建了一个QTextEdit并且把它设置为中央窗口部件，默认情况下，QTextEdit
可以接受来自其他应用程序文本的拖动，并且如果用户在它上面放下一个文件，它将会把这个文
麟麟麟麟黔雠黔醚懿黔阶∽黔黔黟。i曩。≯；，一≯。蠢；曩i。÷；；；_
174
C++ GUI Qt4编程（第二版）
件的名称插入到文本中。由于拖放事件是从子窗口部件传递给父窗口部件的，所以通过禁用
QTextEdit上的放下操作以及启用主窗口上的放下操作，就可以在整个MainWindow窗口中获得放
下事件。
void  MainWindow: :d ragEnterEvent:(QD ragEnte rEvent  *event)
{
          if   ( event->mimeData ( ) ->hasFo rmat ( "text/u ri-list " 》
                       event->acceptP ro posedAction ( ) ;       :
}
    当用户把一个对象拖动到这个窗口部件上时，就会调用dragEnterEvent()o如果对这个事件调
用acceptProposedAction()，就表明用户可以在这个窗口部件上拖放对象。默认情况下，窗口部件是
不接受拖动的。Qt会自动改变光标来向用户说明这个窗口部件是不是有效的放下点。
    这里，我们希望用户拖动的只能是文件，而非其他类型的东西。为了实现这一点，我们可以检
查拖动的MIME类型。rvnME类型中的texturi-list用于存储一系列的统一资源标识符(Universal Re-
source Identifier．URI)，它们可以是文件名、统一资源定位器（Uniform Resource Locator，URL，如rrIIP
或者FIP路径），或者其他全局资源标识符。‘标准的MIME类型是由国际因特网地址分配委员会
(Intemet Assigned Numbers Authority，IANA)定义的，它们由类型、子类型信息以及分隔两者的斜线组
成。MIME类通常由剪贴板和拖放系统使用，以识别不同类型的数据。可以从下面的网站得到正
式的MIME类型列表：http：//www．iana．org/assignments/media- types/。
    void Ma/nWindow':-    ：    ’  ‘    ：    。    ．
    void HainWindow::droptvent(QDropEverit *event)
    {  ‘    -    ．    。。
    ?Lis,t‘QUrl>urls 2 event-》mimeData() ->u rls();
    if (urls,isEmpty(》    ‘.,.
    return：
QSt ring  fileName  =  urls . first( ) .toLocalFile ( ) ;
if (fileName.isEmpty(》  .
return;
    if(readFile(fileName))
    setWindowTitle(tr(“%1-%2“).arg( fileName)
    .a rg (tr(”Drag File“)））；
    )
  、当用户在窗口部件上放下一个对象时，就会调用dropEvent()。我们调用函数QMimeData:：urls()
来获得QUd列表。通常，用户一次只拖动一个文件，但是通过拖动一个选择区域来同时拖动多个
文件也是可能的。如果要拖放的URL不止一个，或者要拖放的URL不是一个本地文件名，则会立
即返回到原调用处。  j
    QWidget也提供dragMoveEvent()和dragLeaveEvent()函数，但是在绝大多数应用程序中并不需
要重新实现它们j
    第2个实例描绘的是如何初始化一个拖动并且接受一个放下j我们将创建一个支持拖放的
QListWidget子类，并且把它作为如图9.1所示的Project Chooser应用程序的一个组件。
    Project Chooser应用程序为用户提供了两个由姓名组成的列表框。两个列表框分别代表一个项
目。用户可以在两个项目列表框之间拖放这些姓名，将一个项目中的成员移动到另一个项目中。
    拖放代码都放在QListWidget的子类中。以T是这个类的定义：
’    class P广ojectListWidget:public QListWidget
    {
    Q_OBJECT
    public:    。
    ProjectListWidget(QWidget车parent=0);
1 1 7 7 7 i‘，…，7'48 58孥孽麓屈罐满藿
                      .    第9章拖  放                    175
              -- ----
protected:
   void mousePressEvent(QMouseEvent *event);
        void .mouseMoveEvent ( QMouseEvent  *event ) ;
   void dragEnterEvent(QDragEnterEvent *even
 . void dragMoveEvent(QDragMoveEvent *event)
   void dropEvent(QDropEvent *event);
p rivate:
      void  performDrag ( )
QPoint startPos
ProjectListWidget类重新实现了在QWidget中定义的S个事件处理器。
图9.1  Project Chooser应用程序
 P roj ect ListWidget : : Proj ectListWidget ( QWidget  *pa rent J
   : QListWidget(parent)
{
       setAcceptDrops (true) ;
}
在构造函数中，我们使列表框上的放下生效。
void ProjectListWidget::rnousePressEvent(QMouseEvent *event)
{
   if (event->button() == Qt::LeftButton)
       startPos = event->pos();    ,       .
            QLis tWidget: :mouseP ress Event (event) ;
    刍用户按下鼠标左键，就把鼠标位置保存到st.artPos私有变量中。我们调用QLjstWidget中
mousePressEvent()的实现，以确保QListWidget可以像平常一样有机会处理鼠标按下的事件。
void  Proj ectListWidget : :mouseMoveEvent (QMouseEvent  *event)        .
{
   if (event->buttons() & Qt::LeftButton) {
      int distance = (event->pos() - startPos).manhattanLength();
       if (distance >= QApplication::startDragDistance(》  .:  ,'
          }                pe rfo rmD rag ( ) ;
         QListWidget: :mouseMoveEvent ( event) ;       '
               .
    当用户按住鼠标左键并移动鼠标光标时，就认为这是一个拖动的开始。我们计算当前鼠标位
置和原来鼠标左键按下的点之间的距离～―这个“曼哈顿长度”(Manhattarl Length)其实是从坐标原
点到该矢量长度快速计算的近似值。如果这个距离大于或等于QApplication推荐的拖动起始距离
值（通常是4个像素），那么就调用私有函数
手握鼠标抖动而产生拖动。
performDag()以启动拖动操作。这可以避免用户因为
       .176                                                         C++  GUI Qt 4编程 (第二版)
______』.________________              , '
               void   ProjectLis tWidget : : pe rfo rmD rag ( )
       QListWidgetltem *item = currentltem();      .                        ' . .
      if (item) {
           QMimeData *mimeData = new QMimeData;
                          '     mimeData->setText ( item->text ( 》 ;
    QDrag *drag - 'new
  ' drag->setMimeData
drag->setPix.map(Q
'. . if (drag->exec(Qt
 ' .: del,ete.'item-j    二
mages/person.png"》;
n)- - Qt::MoveAction)
    }    ，+．    ．
    在per~ormDrag()中，创建了一个类型为QDag的对象，并且把this作为它的父对象。这个QDrag
对象将数据存储在QMimeData对象中。在这个实例中，我们利用，QMimeData!：secText()提供了作为
text/plain字符串的数据。QMimeData提供了一些可用于处理最常用拖放类型（诸如图像、URL、颜色，
等等）的函教，同时也可以处理任意由QByteAnays表示的’rvfIME类型j QDag：：setPixmap()调用则可以
在拖放发生时使图标随光标移动。    ．  i  ．’．    '_．  ‘    一    +
  I、|QDrag;i:exec()调用启动并执行拖动操作？直到用户放下或取消此次拖动操作才会停止。它把
所有支持的“拖放动作”(如Qt": CopyAction，Qt:：MoveAetjon!’和Qt:：：LinkAction)的组合作为其参数，
兼且返回越热衙的拖放动熊‘妻曝
执行任何动作j则返回研：.:IgnoreAction)。至于执行的是哪
个动作，取决于放下发生时源窗口部件是否允许、目标是否支持及按下了哪些组合键。在exec()
调用后，Qt拥有拖动对象的所有权并且可以在不需要它的时候删除它。
         void  P roj ectListWidget: :d ragEnterEvent (QDragEnterEvent  *event)
      {
 .. ,'  ProjectListWidget *source,= .  '
                                               qobject_cast<Proj ectLis tWidget   *> ( event->s ou rce ( 》 ;
       if (source && source != this) {
                          event->setD ropAction ( Qt: :MoveAction) ;
                                                                                                                                                                                                                  .'
ProjectListWidget *source =
                       qobj ect_cast<P roj ectListWidget   *> ( event->source ( 》
if (source && source != this) {
    DragMoveEvent()申的代码与dragEnterEvent()中编写的代码基本相同。这样是必要的，因为需
要重写QListWidget的函数实现（实际上是QAbstractItemView的函数实现）。
void  P roj ect ListWidget: :d ropEvent (QD ropEvent章e
   ProjectListWidget *source =
                          qobject_cast<Proj ectListWidget  *>( event->source ( 》 ;
   if (source && source != this) {                  . ' . .
' cn .- rl O
-IJ IJ : :u
. o,o  n- ci.
L mEO
o aXH
o.E -l ..
    峨珥
    个C
    _峨
    彤一
    啭碗
    螋一
    一誓粉
    甥肛
，睦_辜・
裟
一
勰
脚批
篙．
嚣一
撼”
蒜一
轰一
嚣岫
嚣．，一
嚣一
伽帮嘶
抛倬P
伸登
o
rl
IJ
u
>
o
E
..
J.
C
o
rl
IJ
u .-
< _-
o IJ
oo
Ju
ou
cn ro
AA
  I     I
IJ J
c: c:
aJ aJ
》
            f A-.
            :  第9 ,  放'         . 177
      --
                      .  addltem(event->mimeData ( )->text ( 》 ;                                                       '.:   :, .    - ... ' '.        .
                                      event->setDropActio n (Qt : :MoveAction) ;
            }
    在dropEvent()中，我们使用QMimeData：：text()重新找回拖动的文本并随文本创建一个拖动项。
还需要将事件作为“移动动作”来接受，从而告诉源窗口部件现在可以删除原来的拖动项了。
    拖放是在应用程序之间传递数据的有力机制。但是在某些情况百，有可能在执行拖放时并未
使用Qt的拖放工具。如果只是想在一个应用程序的窗口部件中移动数据，通常只要重新实现
mousePressEvent()和mouseReleaseEvent()函数就可以了。
9.2支持自定义拖动类型  7
    目前为止所讲过的实例中，都是依靠QMimeData来支持通用的蜩唧：类型。因此，我们调用
QMimeData:÷setText()来创建一个文本拖动，并且使用QMimeData:urls()来重新找回exU uri-.IisE拖动
的内容。虫口果想拖动纯文本、超文本、图像、URL甚至颜色，则可以只使用,QMnielhta类而不必采
用其估的手段。但如果想拖动的是自定义数据，劂蟛须选择如下三种方式之一：一_：，j一一誉i二7．’
  ，1.使用QMimeData：：setData()，可以提供任意数据作为QByteArray的内容；1并且茬随信~iJ角
    QMimeData:：data()提取这些数据。  。    ．    ’  ’，一：一  』.+。’_毫，    、一
    2.可以通过子类化QMimeData并且重新实现fonnats()和reUieveData()采殛理自定-义鼓据
    类型。    。  ‘    ．．i一  ,.。，’+．二．．  j
    3．对于在简单应用程序中的拖放操作，可以子类化QMimeData并且利用我们所需要的任意数
    r    ’    ．    。
    据结构来存储数据。    ．：：一，．一．  ．、
    ‘    ：    0    。v-t。’。    ．．，一
    第1种方法虽不涉及任何的子类化，但它也有一些缺点：即使这个拖动没有被最后接收，仍需
将数据结构转换为QByteArray。另外，如果想提供几个MIME类型与应用程序在更广的范围内进
行良好的交互，则必须对每一个MIME类型的数据进行存储。_．虫口果数据较大，这将不必要地减缓
应用程序的运行速度。第2种和第3种方法则可以避免或者使这种问婴睁髭？嗵零少化，它们不仅
将控制权完全交给用户，而且还可以～起使用。    ，    ÷二；-、  、，  一
    为了说明这些方法是如何运作的，我们将给出一个如何给QTableWidget，透加挚蓼瑰能的,子．o
拖动将支持以下的IvnME类型：text/plain、texU htrnl和texU csv。使用第1种方法，按虫pT的代码万始
一个拖动：
void MyTableWidget::mouseMoveEvent(QMouseEvent *.event)   .      : ;:.'-.   .: . . :-.
{
   if (event->buttons() & Qt::LeftButton) {   .           - /{.   ;  .':
       .  int distance = (event->pos() - startPos).manhattanL:ength(); '一'..~' i;
       if (distance >P QApplication::startDragDistance(》  .
                 performDrag() ;
     }
        QTableWidget: :mouseMoveEvent ( event ) ;       .       .
void MyTableWidget::performDrag() .    ' '
{
   QString plainText = selectionAsPlainText();
      if (plainText.isEmnpty(》
                  retu rn ;
  178    C++ GUI Qt 4编程（第二版）
    ___.___________.-.___-一‘‘’！‘’’‘’’’’’‘’一
mimeData->setText
mimeData->setHtml
mimeData->setData
plainText); .
toHtml(plainText》 ;             . .
"text/csv" ,  toCsv ( plainText) :toUtf8 (》
QDrag *drag = new QDrag(this);
drag->setMimeData(mimeData) ;
if (drag->exec(Qt::CopyAction I Qt::MoveAction) == Qt::MoveAction)
         deleteSelection ( ) ;
    )
    在mouseMoveEvent()中调用performDrag()私有函数，可以拖拽出一个矩形选择框。我们使用
setText()和setHtml()设置text/plain和text/html的lVflME类型，同时使用setData()设置text/csv类型，
这些都可以采用任意的lVflME类型和QByteAnay。selectionAsSUing()的代码或多或少地与笫4章中
介绍的Spreadsheet:：copy()函数的代码相似。
QString MyTableWidget::toCsv(const QString &plainText)
{
   ostring result
result,replace
result.replace
result.replace
       result. replace
result.prepend
result.append(
 , return result;
}.
QSt ring
{
= plainText;
MyTableWidget : :toHtml ( const  QSt ring  &plainText )
result
replace
replace
prepend
append(
result;
= Qt::escape(plainText);
    函数toCsv()和toHtml()将一个由制表符和换行符构成的字符串转换为一个CSV字符串(以逗
号分隔的值，Comma-Sepa工ated yalue)或者一个HTML字符串。例如，数据：
    Red
    Cyan
可以转换为
Green
Yellow
Blue
Magenta
"Red':, "Green", "Blue"
"Cyan", "Yellow", "Magenta"
成者转换为
    <ta ble>
    <tr><td>Red<td>Green<td>Blue
    <t r><td>Cyan<td>Yellow<td>Magenta
    </table>
    利用QSUing:：replace()，可以用最简单的方式执行这个转换。另外，为了转义HTML中的特殊
字符，还可以使用Qt':：escape()。
void MyTableWidget::dropEvent(QDropEvent *event)
{
         if  ( event->mimeData( ) ->hasFormat ( "text/csv" 》  {
                 QByteArray  csvData  =  event->mimeData ( ) ->data ( "text/csv" )
                 ost ring  csvText  =  ost ring : : f romUtf8 ( csvData) ;
event->acceptProposedAction( )
C IJ IJ IJ IJ C
Hrrrr L
i- cn cn U) U) lJ
cn a) a) r 'a) a)
OLLLLL
                    ' -.
第9章拖  放    179
 }  else.  if   ( event->mimeData ( ) ->hasFo rmat ( "text/plain " 》
         QSt ring  plainText  =  event->mimeData ( ) ->text ( ) ;        .
         event->acceptP roposedAction ( ) ;
}
    尽管提供了三种不同格式的数据，但是在dropEvent()事件中只接受其中的两种格式。如果用
户从一个QTableWidget向某- HTML编辑器拖动单元格，我们将会希望这些单元格被转换成一个
HTML表格。但是如果用户从任意的HTML向某-QTableWidget拖动，我们就不希望接受它。
    为了完成这个例子，还需要在MyrLableWidget构造函数中调用setAcceptDrops( true)和
Mode( ContiguousSelection).?
setSelection-
    我们将重做这个实例，但是这次将子类化QMin，eData以延迟或者避免QTableWidgetltem与QByte-
Array之间（潜在耗时的）转换。下面是对子类的定义：
public:
 .  TableMimeData(const QTableWidget *tableWidget,
                          const QTableWidgetSelectionRange &range) ;
const QTableWidget *tableWidget() const { return myTableWidget;
QTableWidgetSelectionRange range() const { return myRange; }
QStringList formats() const;       .
protected:
    QVariant retrieveData(const QString &format,     .
                    QVariant::Type preferredType) const
private:
    static QString toHtml(const QString &plainText)
    static QString toCsv(const QString &plainText);
QString'text(int row, int colum:i) const;
QString rangeAsPlainText() const,
const QTableWidget *myTableWidget;
QTableWidgetSelectionRange myRange;
QStringList myFormats;
    找们存储一个QTableWidgetSelectionRange以取代存取实际的数据，QTableWidgetSelectionRange
详细说明了正在拖动的是哪些单元格，并且会始终保持二个指向QTableWidget‘的指针。来自
QMimeData中的fonnats()和retrieveData()函数则会被重新实现。
TableIHimeData : :Ta bleMimeData ( const
        const
                    ,
QTableWidget *tableWidget,
QTa bleWidgetSelectionRange &range)
   myTableWidget = tableWidget;    .
   myRange = range;
  myFormats  "text/csv"  "text/html" . 'text/plain"
在构造函数中，按上面代码段中的方法初始化私有变量。
ost ringList  TableMimeData: : fo rmats ( )   const
{
   return myFormats;
}
fonnats()函数返回一个由MIME数据对象提供的MIME类型列表。各种格式之间的排列顺序
IJ
o
E
.+
o
u
rl
-o
=
o
IJ
o
E
r         LU .
a  J
ro
180
C++ GUI Qt 4编程（第二版）
通常是无关联的，但是把“最好的”格式放在最前面是一种不错的习惯。支持多种格式的应用程序
有时将使用第一个与其匹配的格式。
    QVa riant  TableMimeData:: ret rieveData( const  QSt ring &fo rmat,
    QVariant::Type preferredType) const
    {
    if (format=="text/plain"){
    return  rangeAsPlainText();
    )  else if (format'== "text/csv"){
    return  toCsv( rangeAsPlainText());
    ) else if (format==    ml"){
    return  toHtml( rangeAsPlainTExt());
    ) else{
    return  QMimeData:: ret rieveData( fo rmat: p referredType);
    }
    }
    reUieveData()函数为给定的MIME类型返回一个数据作为其QVaIiant。fonnat参数的值通常是
由fonnats()返回的字符串之一，但是我们并不能这样假设，因为并不是所有的应用程序都对照’for-
mats()采检查mME类型。由QMimeData提供的获取函数(getter function)，诸如text()、html()、
urls()、imageData()、colorData()以及data()，都可以根据retrieveData()而重新实现。
    preferredType参数提示我们在QVariant中应该插入哪种类型。此处，如果有必要的话，我们将
忽略preferredType参数而任由QMimeData将返回值转换为想要的类型。
void MyTableWidget::dropEvent(QDropEvent *event)    .
   const TableMimeData *tableData -
                              qobj ect_ca s't<const  TableMimeData  *> ( event->mimeData ( 》 ;
if (tableData) {
  . const QTableWidget *otherTable = tableData->tableWidget();
   QTableWidgetSelectionRange otherRange = tableData->range()
          event->acceptP roposedAction ( ) ;
} else if (event->mimeData()->hasFormat("text/csv"》 {
        QByteArray  csvData  =  event->mimeData ( )->data ( "text/csv")
        ost ring  csvText  =  QSt ring: :fromUtf8 (csvData) ;
          event->acceptP roposedAction ( ) ;
}  else  if  (event->mimeData ( )->hasFormat ( "text/plain"》
   QString plainText = event->mimeData()->text();
          event->acceptP roposedAction ( ) ;
}
QTa bleWidget : :mouseMoveEvent ( event)
    dropEvent()画数与本节早先曾提到的那个相似，但是这次首先检查是否可以成功地将QMime-
Data对象强制转换为TableMimeData来优化这个函数。如果qobject_cast<T>()有效，则意味着在同
一个应用程序中，拖动是由MyTableWidget发起的，这样就可以直接读取表格数据而不必经过
QMimeData酌应用程序编程接口。如果强制转换失败，就以标准规定的方式提取数据。
    在这个例子中，我们利用UTF-8格式编码CSV文本。如果想确信使用了正确的编码方式，则
可以利用texU plain的MIME类型的charset参数来指定一个明确的编码方式。下面是几个明确指
定编码的例子：
text/plain;charset=US-ASCII
text/plain ; cha rset=150-8859-1
text/plain;charset=Shift_JIS
text/plain;charset=UTF-8
  』
  i
  ／
  ，。jj1翻j___―卅刊F捌翻翱弱剥瀚溺
第9章拖  放
181
9.3剪贴板处理技术
    多数应用程序都通过某一种或者几种方式来使用Qt;的内置剪贴板处理技术。例如，QTextEdit
类除了提供快捷键支持外，还提供cut()、copy()和paste()槽，所以几乎不需要其他额外代码。
    当编写自己的类时，‘町以通过QApplication:：clipboard()访问剪贴板，它会返回一个指向应用程
序QClipboard对象的指针。处理系统剪贴板是很容易的：调用setTexf() <setlmage()或者setPixⅡ．ap()
把数据放到剪贴板中，并且调用text()、image()和pixmap()来重新获得数据即可。已经在第4章中
的Spreadsheet应用程序中看到了一些剪贴板应用的例子。’一  。    ，
    对于某些应用程序，仅使用内置的功能可能是不够的。例如，也许我们想提供的数据不是文
本或者图像类型；或者也许我们想按几种不同的格式提供数据以最大限度地与其他应用程序进行
协同工作。这个问题和之前在拖放中所遇到的问题一样，并且解决方案堪很相似：必须子类化
    ．    ．    ．    1_
QMirrieData，并且重新实现一些虚函数。
  ’如果应用程序通过_个自定义QMimeData于类支持拖放：则可以只复用QMimeData子类并且
利用setMimeData()函数把它放到剪贴板中：可以对剪贴板调用mimeData()来获得数据。
    在Xll上，通常可以点击÷个三键鼠标的中键来粘贴选项。这个操作可以通过-f角二爷单独
的“选定”剪贴板完成。如果希望窗口部件像支持标准剪贴板二样也支持这种“选项”剪赔板：，那么
必须将QClipboard：：Select/on作为一个额外的参数传递给各种剪贴板的调用。饲茹：改苄建如何在
文本编辑器中重新执行mouseReleaseEvent()以支持鼠标中键粘贴功能的代码0+_。。
    void  MyTextEditor::mouseReleaseEvent (QMouseEvent车event)
    {oriQCli    +  ’
    旺Lipboa rd  *clipboa rd=QApplication:: clipboa rd()≯    ’。
    if (event->button()Qt::M/dButton    、    ‘1
    lf(event一>button()==Qt::HidButto“
    ＆＆clipboard->supportsSelection()){
    QString text=clipboard->text(QClipboard::Selection)；  7  一  一一一
    pasteText( text)；    _
    j    _，
    )    ．    、
    )
在X11上，supportsSelection()函数会返回true值；而在其他平台上，它返回false。    ’
    如果想在剪贴板中的内容发生改变时就立即得到通报，那么可以通过建立QClipboard：：data-
Changed()信号和自定义槽的连接来实现。
    ±。。
第10、章  项视图类
    许多应用程序允许用户搜索、查看和编辑属于某个数据集中的一些个别项。这些数据可能保
存在文件中、数据库中或者网络服务器上。处理像这样的数据集的标准方式是使用Qt的项视图
类(item view class)。
    在早期的Qt版本中，项视图窗口部件总是由一个数据集的所有内容组装而成的。用户在这
个窗口部件的数据上进行所有的查询和编辑操作，并且在某些情况下，对数据的改变还会被重新
回写到数据源中。尽管这种方式很容易理解和使用，但是在使用非常大的数据集的时候，这种方
式就不能很好地工作了，并且如果我们想在两个或者更多的窗口部件中显示同一个数据集的时
候，这种方式就不能很好地适应。    。  ．
    Smalltalk语言普及了一种非常灵活的对于大数据集的可视化方法：模型一视图一控制器(Model-
View- Controller，MVC)。在MVC方法中，模型(model)代表数据集，它对需要查看数据的获取以及任
何存储的改变负责。每种类型的数据集都有自己的模型，但不管底层的数据集是什么样子，模型
提供给视图( view)的API都是相同的。视图代表的是面向用户的那些数据。在同一时间，任何大
数据集只有有限的部分足可见的，所以这个有限的部分就是视图所请求的那部分数据。控制器
(controller)是用户和视图之间的媒介，它把用户的操作转换为浏览或者编辑数据的请求，这部分数
据是根据需要由视图传送给模型的数据。
    根据MVC方法的启示，Qt提供了一种模型／视图架构，如图10.1所示。在Qt中，这个模型和
它在经典的MVC中的行为是完全相同的。Qt使用的不是控制器，而是使用了一种稍微有些不同
的抽象：委托(delegate)。委托用于对项的如何显示和如何编辑提供精细控制。Qt对每种类型的视
图都提供了默认的委托。对于绝大多数应用程序，这已经足够了，所以我们通常不需要注意它。
一…．．…………．
1  数据源
二，…………．………，，，
    图10.1 Qt的模型／视图体系结构
    利用Ql的模型／视图架构，我们可以只从模型中获取实际在视图中显示所需要的数据。这样
在处理非常大的数据集的时候，可以更加快速，而不至于降低性能。通过把一个模型注册到两个  、；
或者多个视图，就可以让用户使用不同的方式查看数据以及和数据交互。Q对于多个视图会自动  l
地保持同步，从而使对一个视图的改变会影响到全部视图，如图10.2所示。模型／视图架构的另外  熏
一个好处是：如果决定改变底层数据集的存储方式，则只需要修改模型，而视图仍将能够继续正常  囊
工作。    萋
    在很多情况下，只需要把一小部分的项呈现给用户。在这些常见的例子中，可以使用Qt提供  霭
的那些方便的项视图类(QListWidget、QTableWidget和QTreeWidget)，并且可以把它们和项直接组装  ，鬻
起来。这些类和一些以前的Q版本中提供的项视图类很相似。它们把数据存储在“项”中(例如，  霎
QTableWidget就包含了一些QTableWidgetltem)。实际上！在这些方便的类的内部，使用了自定义的  翼
模型，这样就可以让这些项在视图中变为可见的了。／蹙
、
第10章项视图类
183
图10.2适用于多种视图的模型
    对于大数据集，数据复制通常不是一种好方法。这时可以使用Qt的视图(QListView、QTable-
View和QTreeView)，把它们和一个数据模型连接，而这个数据模型既可以是自定义模型，也可以是
Qt的预定义模型。例如，如果数据集被保存在一个数据库中，就可以把QTableView和QSqlTableM-
odel组合在一起使用。
10.1  使用项视图的简便类
    使用Qt的项视图中那些方便的子类通常要比定义一个自定义模型简单得多，并且如果我们不需
要由区分模型和视图所带来的好处时，这种方法也是比较合适的。在第4章中，当我们继承QTable -
Widget和QTableWidgetltem来实现电子制表软件的功能的时候，就已经使用了这_技术。
    这一节将说明如何使用这些方便的项视、图子类来显示项。第一个例子演示了一个只读的
QListWidget(如图10.3所示)，第二个例子演示了一个可以编辑的QTableWidget(如图10.4所示)，第
三个例子则演示了一个只读的QTreeWidget(如图10.5所示)。    ’
    图10.3流程图符号选择器应用程序    ’囹10.4坐标设置器应用程序
    先从一个允许用户在列表中选择流程图符号的简单对话框开始。每个项都由一个图标、一段
文本和一个唯一的ID组成：
    先从这个对话框的头文件中截取的代码开始：

    当构造这个对话框时，我们必须给它传递一个QMap <int，QSt．ing>，在它运行之后，可以通过调
用selectedld()获得一个选中的ID(或者如果用户没有选中任何一项，就返回一1)。

图10.5设置查看器应用程序
这个done()函数是由QDialog重新实现的。当用户单击OK或者Cancel按钮时，就会调用它。
如果用户单击OK，就获得相应的项并且使用data()函数提取ID o_，如果对项的文本感兴趣，则可以
通过调用item一>data( Qt：：DisplayRole)．toString()或者更为方便的，item一≥；：text()来获取文本。
    默认情况下，QUstWidget是只读的。如果想让用户编辑这些项，则可以使用QAbstIactltem-
View:：setEditTriggers()设置这个视图的编辑触发器(edit trigger)。例如，QAbsUaaltemVjew:：AnyKey-
Pressed这个设置值的意思是：用户只要一开始输入就进入项的编辑状态。类似地，也可以提供一
个Edit(编辑)按钮（还可以提供Add按钮和Delete按钮），同时使用信号一槽连接，这样就可以使用
程序来控制编辑操作了。    ．  ’．
    现在已经看到了如何使用方便的项视图类来查看和选择数据，接下来将会看一个可以编辑数
据的例子。再次使用一个对话框，它显示的是用户可以编辑的一对（戈，y）坐标。，
    正如前面例子中所做的那样，这里也从构造函数开始，并着重讲解有关项视凰的代码~。
    。：    ‘~．    ’    ，：哪，-
    Coo rdinateSetter::Coo rdinateSette广(QList<QPointF> *coords,    、,    :、
    QWidget *parent)
    ：QDia! og（parent）    +一    。’
    t
    coordinates=coords：    ‘    ．  ‘，’    7    :
    ’一j  '  7    7i    ：
    tableWidget=new QTableWidget(0, 2);
    tableWidget->setHo rizontalHeade rLabels(    :’  二  一’:    ’:.‘
    QStringList()<<tr(”X”)<<t广(”Y”))；    ’：1.    _i    ’-’一
    for (int row=0;‘row<coordinates->count(); ++row)t
    QPointF point =.coordinates->at( row);
    addRow()；
    tableWidget->item‘广ow,o’一>setText(QString：：number(point.x(一’t；；；  -j    ．，
    . tableWidget->item(row,1)->setText (QSt ring::number( point.y()
    ．    )
    )
    1    ．
    这个QTableWidget构造函数得到要在这个表格中显示的行和列的初始数字。在QTableWidget
中的每一个项都使用一个QTableWidgetlt。m表示，包括水平方向和垂直务rj．的表头项。setHorizon-
ta正IeaderLabels()函数则设置每一个表窗口部件的水平表买项的文本为所传递的字符串列表中酌
相应文本。默认情况下，QTableWidget会提供一个垂直表头，这个列的标签从1开始，这正是我们
想要的，所以不需要手工设置垂直表头的标签。    ：    ∥、j：：    ‘
    一旦创建完列标签，就可以遍历传递进来的坐标数据。对于每一个(，，，，2坐枥；对，都添加一个
新行[使用私有函数addRow()]，同时在每一行的列中设置合适的文本。’
    默认情况下，QTableWidget‘允许编辑。+用户可以在遍历-个表的时候，、按下F2或者任意简单
的输入，来编辑这个表的任意单元格。用户在这个视图中所做的任何修改都会自动影响这些
QTableWidgetltem。为了防止编辑，可以调用setEdifrriggers( QAbst;:aciltemViewij NoEditTriggeI-.)or
    j．’，：？  ，  r’：+    ．、
    void  Coo rdinateSette F::addRow()
    t    ‘
186
C++ GUI Qt 4编程（第二版）
int  row = tableWidget->rowCount( ) ;
tableWidget->insertRow( row) ;
QTableWidgetltem *item0 = new QTable/lidgetltem;   .
 itemO->setTextAlignment (Qt : :AlignRight  I  Qt: :AlignVCente rJ
tableWidget->setltem( row,  0,  item0) ;       .
QTableWidgetltem *iten,l = new QTableWidgetltem;
iteml->setTextAlignment (Qt: :AlignRight  I  Qt: :AlignVCenter)
tableWidget->setltem(row, 1, iteml);     .    .   . .
to bleWidget->setCu rrentltem ( item0 ) ;
一  当用户单击Add Row按钮时，就会调用这个addRow()槽，这种方式在函数构造中也经常使用
到。我们使用QTableWidget:：insertRow()插入一个新的行，然后创建两个QTableWidgetltem()项，井
利用QTableWidget:：insertRow()把它们添加到表中。除了该项外，QTableWidget:：setltem()还需要一
行及一列。最后，我们设置当前项，这样用户就可以开始编辑新的一行的第一项了。
void  Coo rdinate5etter: :done (int  result )
if (result == QDialog::Accepted) {
      coordinates->clear() ;
   for (int row = 0; row < tableWidget->rowCount(); ++row) {
       double x = tableWidget->item(row: O)->text().toDouble();
              double  y = tableWidget->item( row;  l)->text( ) .toDouble( ),;
.    coordinates->append(QPointF(x, y》, .
     }
}
QDialog::done(result);
    最后，当用户单击OK时，就清空传递给这个对话框的坐标，并且根据这个QTableWidget的所
有项创建一个新的坐标集。
    在关于Qt的简便项视图窗口部件的第三个也是最后一个例子中，我们将会查着一些应用程
序的代码片段，它使用QTreeWidget显示Qt应用程序设置。QTreeWidget默认是只读的。
    以下是构造函数的一部分：
Settin g s Viewe r :': Setting s Viewe r ( QWidget   *pa rent)
   : QDialog(parent) .
   organization = "Trolltech";
      application = "Designer" ;
treeWidget = new QTreeWidget;
t reeWi.dget->setColumnCount ( 2) ;          1
treeWidget->setHeaderLabels (
       QStringList()<< tr("Key”)<< tr("Value"》;
t reeWidget->header ( ) ->setResizeMode ( 0 ,   QHeade rView: : St ret ch )
t reeWidget->header ( ) ->set Re sizeMode (l,   QHeaderView: : St ret ch )
setWindowTitle (t r( "5ettings  Viewer" 》 ;
read5ettings ( ) ;
    为了访问应用程序的设置，必须使用组织名称和应用程序名称怍为参数创建QSettings对象。
我们设置了默认的名称(Trolltech的Designer)，然后构造一个新的QTreeWidget。树形窗口部件的头
视图控制了树形列队的大小。我们设置两列的重定义模式为Stretch。这就告诉了头视图总是确
保列能够填充有用的空间。在这种模式下，用户或者程序都不能重新调整列的大小。在构造函数
的最后，我们调用这个readSettings()函数来构成树形窗口部件。
                   ' '.
    "\
、
第10章项视图类    187
void  SettingsViewer: : readSettings ( )
{.
   QSettings settings(organization, application);
t reeWidget->clea r( ) ;
addChildSettings ( settings,  0,  " " ) ;
treeWidget->sortByColumn(0) ;
t reeWidget->setFocus ( ) ;
setWindowTitle(tr("Settings Viewer - 961 by %2") .
                                .a rg ( application) .a rg ( organization 》
    应用程序的设置会存储在一个由键和值组成的分层结构中。addChildSettings()私有函数需要
一个设置对象、一个父对象的QTreeWidgetltem和当前“组”(group)o QSetUngs群组相当于文件系统
目录o addChildSetUngs()函数可以递归调用自己来遍历任意一个树状结构。readSettings()里是初始
调用，并且传递一个作为父项的空指针，表示这是根。
void  SettingsViewer: :addChildSettings (QSettings &settings
         QTreeWidgetltem *parent, const QString &group)
{
       if  ( ! parent)
          . parent = treeWidget->invisibleRootltem() ;
    QTreeWidgetltem *item;
settings.beginGroup(group)
foreach (QString key, settings.childKey.s(》 {
      item = new QTreeWidgetltem(parent) ;
  item->setText(0, key); '
          item->setText (1,   settings . value ( key) . toSt ring ( 》 ;
}
foreach (QString group, settings.childGroups(》 {
      item = new QTreeWidgetltem(parent) ;
      item->setText(0,  group) ;
   addChildSettings(settings, item, groupl,   .
}         .
settings.endGroup();
    '
    addChildSettings()豳数用于创建所有的QTreeWidgetltem，它在设置树的当前层次中遍历所有
键并且为每个键创建一个QTableWidgetltem。如果空指针被作为parent项传递进来，就创建一个以
QTreeWidget：：invisibleRootltem()为父对象的项，这样它就成为了顶层项。第一列设置为键的名称，
第二列设置为相对应的值。
    接下来，这个函数在当前层中遍历每一个组。对于每一个组，都会创建一个新的QTreeWidget-
Item，并且把它的第一列设置为这个组的名称。然后这个函数会把这个群组项作为父对象递归调
用自己，这样就可以用这个组的子项来构成这个QTreeWidget了。-
    在这一节中所显示的项视图窗口部件允许我们使用和以前的Qt版本中类似的方式进行编
程：读取要被设置到一个项视图窗口部件中的所有数据、使用项对象呈现数据元素并且回写数据
源（如果这些项是可编辑的话）。在后面的几节中，我们将不再局限于这种简单的方式，并且会充
分利用Qt模型／视图架构的所有好处。
10.2使用预定义模型
Qt提供了几种可以在视图类中使用的预定义模型，见下表。
188
C++‘GUI Qt 4编程（第二版）
┏━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┓
┃ QStringListModel  ., ',-   : ┃存储j个字符串列表    ．     ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QStandaIdlteruModel  ．       ┃存储任意的分层次的数据。    ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QDirModel                     ┃封装本地文件系统。．        ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QSqlQueryModel    .  :        ┃封装一个SQL结果集           ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QSqlTableModel      :         ┃封装一个SQL表               ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QSqiRelaLionalTableModel      ┃利用外键封装一个SQL表       ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━┫
┃QSortFilterProxyModel         ┃排序和，或筛选另一个模型’  ┃
┗━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━┛
    这一节将看到如何使用QStringListModel、QDirModel和QSortFilterProxyModel。SQL模型将会在
第13章中讲到。
    我们从一个简单的对话框开始，用户可以使用它添加、删除和编辑一个QStringList，其中每个
字符串都代表一个团队领导。对话框如图10.6所示。
图10.6团队领导应用程序
以下是从构造函数中提取的警譬胡关代码：    ’
    L  ．    ，
    ’  ？  、-
TeamLeadersDiatog；卉套箍；a/e:,rsOiafto'g const  ost ringList  &leade rs,
    。    ，    ，    QWidget  *pa rent）
    ：QDialog (pa rent)
{    ，
    w.odel=new ostringListModeljthis);
    model->setSt ring List (leade rs);
listView = new QListView;
listView->setModel(model); .
listView->setEditTriggers (QAbst ractItemView: :AnyKeyPressed
                 '  .  I qAbstractItemView::DoubleClicked);
    我们从创建并且组装一个QStringListModel开始。接下来创建一个QListView并且把刚才创建
的那个模型作为它的模型：、述设置了一些编辑触发器以允许用户简单地通过开始输入或者双击
进入编辑字符串的状态。默认情况下，QllstView中没有任何编辑触发器，这样就使这个视图只读。
~toid  TeamLeade rsDialog : :insbrt.( ) j : .
{'
         int   row  =  listView->cu rrentlndex( ) . row( ) ;
        model->insertRows ( row,  1) ;
QModellndex index = model->index(row)
lis t View->setCu r rentlndex (index) ;
listView->edit(index) ; .   .  _ '
第10章  项视图，类    189
    当用户单击Insert按钮的时候，insert()槽就会得到调用。这个槽从获得列表视图的当前项的
    j    ．
行数开始。模型中的每一个数据项都对应一个“模型索引”，它是由一个QModellndex对象表示的。
会在下一节中看到有关模型索引的细节，但是现在我们需要知道一个索引有三个主要组成部分：
行、列和它所属的模型的指针。在一个一维的列表视图中，列总为0。
    ’；
    一旦得到行数，就可以在那个位置插入一个新行。这个插入是在模型中完成的，并且模型会
自动更新列表视图。然后我们设置刚刚插入的空白行为列表视图的当前索引。最后，设置列表视
图在当前行进人编辑的状态，就好像用户已经按下一个键或者双击进入编辑状态一样。
    void TeamLeadersDralog::del()    ’    ，  一~:’    ’
    { model-> removeRows (listView->currentlndex( row(    ．．：。
    mod乩一>remoVeRows(listView一>currentIndex().row(),1);    .
    }  ．=。    ．    ：．  ：    1．  “．  2    1．，：
    在构造函数中，Delete按钮的clicked()信号会连接到这个del()槽；因为我们只是想删除当前
行，所以可以使用当前索引位置调甩璋moyeRoy:s()．，并县把摹删除的行数设置为1。就像刚才的插
入操作一样，我们需要依赖于模型才能够相应地更新：这个税函：j
    ost ringList  TeamLeadersDialog::leaders()const
    {
    retu rn  model->st ringList();
    ‘}
最后，当关闭这个对话框的时候，leaders()函数提供了一种读回这些被编辑的字符串的方式。
    通过简单地改变TeamLeadersDialog的窗口标题，它就可以成为―÷个通用的字符串列表编辑对
话框。我们通常所需要的另外一个通用对话框是向用户显示二个文件或者目录的列表。下一个
实例（如图10、7所示）就使用了QDirMode1类，它封装了计算机的文件系统并且可以显示（或者隐
藏）不同的文件属性。可以为这个模型应用过滤器，这样就可以根据自己的需要显示不同类型的
文件系统条目，并且使用不同的方式对这些条目进行排序。
    图10.7  Directory Viewer应用程序．0-．基。
    ・    。    ．
我们将从Directory Viewer对话框的构造函数开始，看看是如何创建和设置这个模型和视图的；
Directo ryViewer：：Directo ryViewer(QWidget   *pa rent)    ．  ，
    ：QDialog(parent)    ．
{
    model寻new QDirModel;
    model->setReadOnly(false);
    model->setSorting(QDir::DirsFirst l QDir::IgnoreCase f QDir::Name:);    ,
    treeView=new QTreeView;
190    C++ GUI Qt4编程（第二版）
treeView->setModel(model).; ..
t reeView->header ( ) ->setSt retchLastSectjon ( t rue) ;
t reeView->header ( ) ->setSortlridicato r(0,  Qt: :AscendingOrder) ;
t reeView->header ( ) ->setSortlndicato rShown (t rue) ;           .   '   .
t reeView->heade r ( ) ->setClic ka ble ( t rue) ;
QModellndex  index  =  model->index(QDir: :currentPath ( 》 ;
treeView->expand (index) ;
treeView->scrollTo(index) ;
t reeView-> resizeColumnToContent s ( 0 ) ,
    一旦模型构造完成，我们就让它可编辑并且设置不同的初始排序属性。然后创建用于显示这
个模型的数据的QTreeView。这个QTreeView的头可以用来提供用户控制的排序功能。通过让头
可以点击，用户就能够按他们所点击的列进行排序。当这个树祝图的头被设置完毕之后，就得到
了当前目录的模型索引，然后通过调用expand()，如果需要就打开它的父对象一直到根节点，并且
调用scrollTo()滚动到当前项，这样就确保它是可见的。然后我们确保第一列足够宽，可以显示它
所有的条目，而不是使用省略号。
    这里没有给出的构造函数中的部分代码中，把Create Directory和Remove按钮和实现这些操作
的槽连接起来。我们不需要Rename按钮，这是因为用户可以通过按下F2键并键入字母来直接进
行重命名。
    void  DirectoryViewer::c reateDirecto ry()
    {
    QModellndex index=treeView->currentlndex();
    if( !index.isValid())    ’
    return;
QString dirName = QInputDialog::getText(this,   .
                                     tr("Create Directory") ,
                     tr("Directory name"》;
if (!dirName.jsEmpty()-) { .
         if   ( ! model-. >mkdir (index,  dirName) .isValid ( 》       .              .
                   "QMessageBox: :info rmation (this ,   tr ( "C reate  Directo ry " )
           .  tr("Failed to create the directory"》;
加果用户在输入对话框中输入的是一个目录名称，就试图会在当前目录下用这个名称创
个子目录。QDirModel:：mkdir()函数可以使用父目录的索引和新目录的名称，然后返回它所创建的
目录的模型索引。如果操作失败，就返回一个无效的模型索引。
void  DirectoryViewer: : remove ( )        .
{
        QModellndex  index  =  t reeView->currentlndex ( )
        if  ( !index,isValid ( 》
 return,
bool ok;  '
if (model->fileInfo(index).isDir(》 {
      ok = model->rmdir(index) ;
} else {
      ok = model->remove(index) ;
}
if (!ok)
          QMessageBox: : info rmation ( t his,   tr( " Remove" ) ,
                          t r( "Failed  to  remove  %1" ) .a rg (model->fileName (index》 ) ;
    如果用户单击Remove．就试图移除当前项所对应的文件或者目录。也可以使用QDir来完成
这项操作，但是QDirModel提供了一些对QModellndex起作用的方便函数。
z，，
？3=爱餮膳槐嘲迥酒
    ，／
    7，厂
第10章项视图类
    本节的最后一个实例（如图10.8所示）显示了如何使
用QSortFilterProxyModelo和其他预定义模型不同，这个模
型封装了一个已经存在的模型并且对在底层模型和视图
之间的传递的数据进行操作。在我们的实例中，底层模型
是一个由q所认识的颜色名称[通过调用QColor:：color-
Names()得到]初始化的QStringListModel。用户可以在
QLineEdit中输入一个过滤器字符串并且使用组合框指定
这个字符串被如何解释（作为正则表达式、通配符模式或
者固定字符串）。
  ’以下是ColorNamesDialog构造函数的一部分：
    Colo rNamesDialog:: Colo rNamesDialog( QWidget  *pa rent)
    ：QDialog（pa rent）    ，
    {
    sourceModel=new QStringListModel(this);
    sourdeModel->setst ring List( QColor::colo rNames());
    proxyModel=new QSortFilterProxyModel(this);
    .     proxyModel->setSourceModel( sourceModel);
    p roxyModel->set Filte rKeyColumn(0);
囹10.8颜色名称应用程序
191
    )
    我们使用常规的方式创建并且组装这个QStringListModel。接下来就是对QSortFilterPtoxyModel
的构造。我们使用setSmuceModel()传递底层模型并且告诉这个代理过滤器被应用在初始模型的
第0列。QComboBox：：addltem()函数接受一个类型为QV矗t的可选“数据”参数。我们使用它存
储和每一个项文本对应的QRegExp：：PattemSyntax值。
    void  ColorNamesDialog::reapplyFilter()
taxComboBox->itemData (
 rrentlndex( 》 .tolnt( 》 ;
t( ) ,  Qt: :Caselnsensitive,
 l.
    只要用户改变过滤器字符串或者模式语法组合框，就会调用这个reapplyFilter()槽。我们使用
行编辑器中的文本创建一个QRegExp，然后设置它的模式语法为保存在组合框中当前项中保存的
值。当调用setFilterRegExp()时，会激活新的过滤器并且会白动更新视图。’‘
10.3实现自定义模型
    Qt的预定义模型为数据的处理和查看提供了很好的方法。但是，有些数据源不能有效地和预
    定义模型一起工作，这时就需要创建自定义模型，以方便对底层数据源进行优化。
    在介绍如何创建自定义模型之前，让我们先看看在Qt模型／视图架构牛的一些重点概念。在
…．模型中，每一个数据元素都有一个模型索引和一套属性(attribute)，称为角色(role)，这些角色可以
、、、    {    1
         . a-  -
   xo
         LU   t=
    g   rl
        aJ   L
                   .. -- -o
           a_ho aJ
  XLX
            LU n, rl
          o u LL
            aJ h0 ..
        o.+ a-
                N i. LU
          - .. Ol
           :  a- aJ
          O LU Q
          rl g
        Ln O -
               Ln o: -
          aJ Q:
         a- ~c
                   x _ -ri
               aJ :   L
           -O t
        L L cn
           ro ro
    1~ u h0
           = -o o
   .-    .- 01~ x
   -     x o '/-l rl
 1      0 0: W 11
  -o    o vvv
 o  -a L L L
3: y   Ovvv
a) x  U E E E
> L    t t t
t  a_    3: H H H
cn(    O -o -o -o
rllL     t= -O -O -O
-i aJ      tD (V tD
0r-o    Il A A A
-o      II
aJ t    O O. O O
c: aJ    co co ca ca
  A  n o o_a
  J   EEEE
3: 3:    o o o ,o
aJ aJ   u u u o
 C = x a_
  yU aJ X
   Ln At LU
lI v I  A Oi
XX10
X tD O +. L
tD t CO  rl v
  +. C o o a-
   {= y_0 LU X
  y L/l  E  O LLl
   Ln {= o c g
     L C rl aJ
    X aJ x -l O:
 " n, t tD L L
  t t t aJ aJ
   C tD t= t t
   Lr) .. cn rl rl
    L a_(+L
  . aJ x    a a)
  t LU   x Ln
  t Ol  LU A
   tD O  g I
   o- o:    a) l
    .. o     L aJ
   a      a- o
  LU .    LU y
   o    g x
 o   oo
  Q     o a
\-r、'
192
C++';'GUI Qt 4编程（第二版）
保存任意值。本章的前面部分审已看到过最常用的角色'Qt.:：DisplayRole和Qt:．：EditRole。其他角
色都是用来补充说明数据的（例如，Qt:：ToolTjpRole、QL:：StatusTipRole和Qt:': WhatsnusRole），还有
一些是用来控制基本显示属性的(例如，Qt：：FontRole、Qt:：TextAlignmentRole、Qt:：TextColorRole和
Qt:: BackgroundColorRole).
    对于列表模型，唯一和索引部分相关的就是行号，可以通过QModellndex:：row()得到。对于表
模型，与索引部分相关的就是行号和列号，分别可以通过QModellndex':：row()和QModellndex:：col-
umn()得到。对于列表模型和表模型，每一个项的父对象都是根，通常由一个无效的QModellndex
表示。本节的前两个实例就是如何实现自定义表模型。。  _    。
    树模型和表模型类似，但有如下不同之处：像表模型一样，最顶层项的父对象是根(一个无效
的QModellndex)，但是其他每一个顼的父对象都是继承树中的其他一些项。这些父对象可以通过
QModellndex：：parent()得到。每一个项都有自己的角色数据，都有O个或多个子对象，每一个项都
有属于自己的东西。因为项可以拥有其他项作为子对象，这样它就可以用来显示递归（树形的）的
数据结构，本节的最后一个例子将会讲述这一部分。图10:9给出了不同模型的示意图。
列表模型    表模型
    根，  行
行    O
0
    1
1
    2
2
行
O
                                   t      .
    ':::
  , .  -1-----" '1
列   0  1  2
                            2
树模型
  ．    L  。    I
    1―1。  、  图10.9 Qt模型示意图
    ・    _    ’
    _’    、
本节的第一个例子是一个显示各个货币之间汇率关系的只读表结构，如图10.10所示。
图10.10汇率应用程序
    本可以用一个简单的表模型实现这个例子，但是我们想使用一个自定义模型，它可以使我们
得到数据的常用属性并且节省存储空间。如果要在二个表中存储162个货币单位之间的汇率，则
需要存储162×162= 26 244个值。利用本节的自定义CurreneyModel模型，只需要存储162个值（每
一个货币和美元之间的汇率值）。    ，
    CuIrencyModel类将和一个标准的(yableView -同使用。CurrencyModel由QMap <QString．double>
第10章一颐视图类、‘    193
组装而成，每一个键都是一个货币编码，并且每一个值都是以美元为单位的货币值。下面的这段
代码显示的就是如何组装这个映射和如何使用这个模型：
QMap<QString, double> currencyMap;   ".
currencyMap.insert ( "AUD" ,  1.3259) ;
currencyMap,insert ( "CHF" ,  1.2970) ;
currencyMap.i.nsert("SGD", 1.6901j;".  .
currencyMap.insert ( "USD':,  1: 0000) ;      .  .
CurrencyModel currencyModel;  ". 1 ' .
cu rrencyModel. setCurrencyMap ( cur rencyMap) ; ,
QTableView tableView;       ' . .
to bleView . s etModel ( &cu r rencyMod el) ;
tableView.setAlternatingRowColors(true) ;一.  .
现在查看一下这个模型的实现。从头文件开始：
class Cur"rencyModel:public.QAbstractTableModel
{    ‘
public:
    CurrencyModel(QObject *parent=0);
void setCurrencyMap(const QMap<QString, double> &map);
int rowCount(const QModellndex &parent) const;    .       .
int columnCourit(const QModellndex &parent)--cons't-; '.   .
QVariant data(const QModellndex &index,  int-. role)' const;' .
QVariant headerData(int section, Qt::Orientation urientation
             . int role) const; ' ..
private:
   QString currencyAt(int offset) const;
QMap<QString, double> currencyMap
找们选择QAbstractTableModel作为模型的基类，这是因为它和数据源最为接近。Qt提供了几
型基类，其中包括QAbsUacLListModel。QAbstractTableModel和QAbstractItemModel．见图10.11。
QAbstractItemModel类用于支持很多种模型，其中包括那些基于递归数据结构的模型，而.QAbsUact-
    ，    、1    ，  ，
ListModel和QAbstractrableModel两个类主要用于提供一维和=|维数据集：
      ' QAbstractItemModel
.  r---------l-
   -1
QAbstractListModel        QAbstractTableModel '
图10.11抽象模型类的继承树
    对于只读的表模型，必须重新实现三个函数：rowCount()、columnCount()和data(.)。在这种情况
    J    ，    ‘    ，、
下，还需要重新实现headerData()，并且还提供了一个初始化数据的函数[setCurrencyMap()]。
CurrencyModei::CurrendyModeic'oObject'*parent) ' ' ."";:' :,.i. r.
   : QAbstractTableModel(parent)               -. :.
{         .
}                                               J
在构造函数中，除了要把parent参数传递给基类之外，不需要再做其他任何事情：
int CurrencyModel::rowCount(const QModellndex & /* pa'rent+，) const
   return currencyMap.count();  . ' .    .-  :  .
194    C++ GUI Qt 4-编程（第二版）
int CurrencyModel::columnCount(const QModellndex.& /* pa'rent. */) const
{         .
   return currencyMap.count();
    对于这种表模型，行号和列号就是这个汇率映射中货币的种类。parent参数对于表模型没有
任何意义。之所以在此处保留这个参数，是因为rowCount()和columnCount(’)都是从更加通用的
QAbstractItemModel这个基类中继承的，在这个类中支持层次结构。
QVariant CurrencyModel::data(const QModellndex &index, int role) const
t  if (!index.isValid'(J)  .            .  '
                                                                               '.,.
                  retu rn  QVariant ( ) ;
if (role = Qt::TextAlignmentRole) {   . .  .
   return int(Qt::AlignRight I Qt::AlignVCenter);
 else if (role == Qt::DisplayRole) { .    .    ,    .
       ost ring  rowCurrency  =  currencyAt (index. row( 》 ;
       ost ring  columnCurrency  =  currencyAt (index.column ( 》
if (currencyMap.value(rowCurrencyJ - 0.0)
double amount = currencyMap.value(columnCu'rrencyJ
                      .   / currencyMap.value( rowCurrency) ;
    data()卤数返回一个项的任意角色的值，这个项被指定为QModellndex。对于表模型j QModel-
Index中有意义的部分是它的行号和列号，可以通过调用row()和column()得到它们。
    如果角色是Qt：：TextAlignmentRol，就返回一个与数字相匹配的对齐方式；如罘角色是Qt：：Dis-
playRole，就查找每二种货币对应的值并且计算出兑换汇率。
可以返回double类型的计算结果，但是那样就无法控制显示的精度（除非使用的是。一个自定
义的委托）。所以，我们返回字符串类型的
值，这个字符串已经按照我们的想法进行了格式化。
QVa riant .Cu rrencyModel: : heade rData ( int  section,
                                              Qt::O.rjentation /* orientation */,
                        int role) const
{
if  ( role  != Qt::DisplayRoleJ
         retu rn  QVa riant ( ) ,
return currencyAt(section);
肖视图组装水平表头和垂直表头时，就会调用headerData()函数。section参数是指行号或者列
号（这取决于实际方向）。因为这里的行和列都是相同的货币代码，所以不需要考虑方向，只需简
单地根据给定的序号返回相应货币的代码即可。
void CurrencyModel::setCurrencyMap(const QMap<QString, double>&mapJ
{
   currencyMap = map;    .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .
    调用者可以使用setCunencyMap()函数改变货币映射。QAbstractltemModel:：reset()调用告诉任
何一个使用这个模型的视图，它们所有的数据都无效了，这样就会强制它们为可见的项刷新数据。
IJ
=
o
E
n,
n,
=
rl
d\a   .
N
 g  .-
 C .       --
1上 _
L  lJ
IJ   C
S   n,
07   rJ
C   n,
L>
= 07
IJ
oc
LL
    =
    IJ
    o
   J-. L
4”冀馕《臻∞涵调
    第10章项视图类    195
    ’’’’’’.‘’’o-.____-_._______-_-一
    QString CurrencyModel::currencyAt(int offset) const
    {
    return (currencyMap,begin()+offset).key();
    )
    currencyAt()函数返回在货币映射中给定位移的键（即货币代码）。我们使用STL风格的迭代
器查找这个条目并且对它调用key()。    ，
    正如现在所看到的，依赖于底层数据的实际情况创建只读模型并不困难，而且具有良好设计
的模型还可以节约内存，提升速度。下一个实例，即图10.12所示的城市应用程序也是基于表的，
但是这一次所有的数据都是由用户输入的。
图10.12城市应用程序
    这个应用程序用于存储任意两个城市之间的距离的值。像前一个实例一样，也可以简单地使
用QTableWidget，并且为每一个城市对存储一个项。但是，一个自定义的模型将会更加有效率，因
为无论从任意城市A到另外任意一个不同的城市B，或者是从B到A，两者之间的距离都是相同
的，所以这些项将会是按主对角线而对称。    ，
    为了查看自定义模型和简单表之间的区别，我们假设有三个城市：A、B相C。‘如果为每一个
组合存储一个值，就需要存储9个值。而一个仔细设计过的模型只需要三个项：(A，B)、(A，C)和
(B，C)。    。
    下面的代码建立并使用这一模型：    、
ost ringList  cities ;
cities<< "Arvika”<< "Boden"   "Eskilstuna"《..F6tunl,
    '《 "Filipstad"   "Halmstad"   "Helsinc《 "Karlstad"
    .. "Kiruna"<. "Kramfors"<. "MotaJzij~boSr9ndwken"    .
《 "Skara"<< "Stockholm'   "Sundsvall"#:= "Trelleborg";
CityModel cityModel;
cityrlodel.setCities(cities),     .   '   . /
QTableView tableView; .   del); ;'.  .    ’：.
tableView,setModel(&cityModel
tableView.setAlternatingRowColors{;trru~
    和前一个实例一样，我们必须重新实现一些相同的函数。另外，为了使模型可以被编辑，还必
须重新实现setData()和fla)s()，下甭是粪的定义：
    class CityModel:public QAbstractTableModel    .
    {    ．
    0 0BJECT
public:  .
 '     CityModel(QObject *parent = 'OJ ;
  196    C+士CU Qt分编程（笫二版）
__―――_,―鼻_.――一――――――――.――,―――7―.―――――'.――――――――――――_._--_―一
'  yoid set'ities(const QStringList"&c'ty'P'a::;slt;   1  1:   '   . "
   int rowCount(const QModellndex&parentJ cor    ;  /.:L' . ',; ;  .
    int columnCount(const QModellndex &pa'rentJ colist, '
    QVariant data(const QModellndex &index, int role).ci
    bool setDa'ta(const QModellndex &index,∈？nst QVa)'i;:t~~~j&,illuer '.'
           int role);       "   '.  .
   QVariant headerData(int section, Qt::Orientation orientat.ion,  '
                int role) const;'    ' : .
    Qt::ItemFlags flags(const QModellndex &ind7x.) co:sy;;:  : '  ; ' .
private:                      .   .
   int offsetOf(int row, int-column.) const;    ' .
  财于这个模型，使用了两个数据结构：类型为QStringList的cities保存了城市的名称，类型为
QVector <int>的distances保存了每一对城市之间的距离。
CityModel: :(          iel(QObj ect'r
         :  QAbs'tC:t{:o:flModel( pt':.';P,,t) ent)
}
构造函数除了把parent参数传递给基类外，就没有其他任何的操作了。
int CityModel:.:rowCount(..const"QModellnliex:&;/* parent */) const
     retdrn:ciiies.coudt()．； ,; '     ? "  ' .
                   ,
}nt City~de}:r.c;olumnCount(const'.QModellndex &,/* parent */) const
！。 . r,e:tutB cities-.countn;    /, ,.
因为是一个正方形的城市列表，所以行总数和列总数就是列表中的城市总数。
QVariant CityModel::data(const QModellndex &index, int rolle) con.st
{    ..
    . .if  ( !index.isValid (》    、…
      return.QVariant();   .                    . .   . .
if  ( rol
  ret
} else
if
(
= Qt::TextAlignmentRoleJ {
rn int(Qt::AlignRight I Qt::AlignVCenter);
  (role = Qt::DisplayRole) {    '  .
ind
ret
    1int;off
    return
)
return QVar
urn 0;
 set  -:- of.fsetOf(index. row( ) , l:/ndex:column ( 》
distances[offsetl; .   . ~
iant();
    这个data()函数和我们在CurrencyModel中所做的类似。如果行和列相同，它返回0，因为它对
应当两个城市相同的时候的情况。否则，它在distances矢量中查找给定的行和列所对应的条目，
并且返回这个特定城市对的距离。
_  ov. a riant  CityMo_del/: heade丁Data (int'
                                  . ..'
section, . .    :   . }
Orientation /* orientat;~n */,
role) const .    '  '.." j,':-r
     ..:.
         .  ..
  u.
.- C
.+ cn
4J rl.
rl O
  A
4J 4J
rl rl
JV
co
rl 4J
LU
aa
  0 .-
r-
 oc
  y rl
  ra J
rU
   a- o)
     rlrl .-
   o cn -
   .. 0 u
    .. rl 4J
 JJC
  a.ri a,
    U rl
   II    L
    II  C a,
  L>
  0 =a
 rJ
  o Q) C
LLL
         J
  rl   L
第10章tj项视图类
197
    headerData()函数非常简单，因为表是正方形的，它的水平表头和垂直表头一样。我们可以简
    ．  ’一
单地返回在cities字符串列表中给定偏移量的城市名称。    。
bool CityModel::setData(const QModellndex &index,
                              const QVariant &value, int role) '.  '  '       .'
{
    if (index.isValid() && index.row() != index.c'o/umn() .  . '     '
          && role == Qt::EditRole) {            ,         .   .
      int offset = offsetOf(index.row()., index;column(》;  .    -
               distances loffset J  =  value.tolnt () ;
                 QModellndex  t ransposed.lndex  =  createlndex (index. column ( ) ,
                                                                                                            index: row( 》 ;
           emit dataChanged(jndex,  index) ;
    ;. emit dataChanged(transposedlndex, transposedlndex);
.    ' return true;
    当用户编辑一个项昀时候，就会调用setData()函数。提供的模型索引必须有效，两个城市必
须不同，并且当修改的数据元素是Qt:：EditRole时，这个函数会把用户输入的值存储到distances
矢量中。
    createlndex()函数用于产生一个模型索引。+我们需要使用它获得在主对角线另外耋ollj和当前
正在被设置的项所对应项的模型索引，因为这两个项必须显示相同的数据j     'createlndex()函数中的
参数顺序是行号在列号之前。这里调换这两个参数，这样就可以获得由index-,指定的项所对应项
的模型索引j
    我们用被改变的项的模型索引作为参数发射dataChanged()信号。，’这个信号使用两个参数的
原因是：它可以用来表示对一个矩形范围影响的改变，而不仅仅是一个项，所以这里传递的是被改
变区域的左上角和右下角两个项的索引。我们还对另外一个对应的项发射dataChanged()信号，以
确保视图刷新它。最后，返回true或者false‘表明编辑操作是否成功。一一‘0，，÷…、  -_  ‘‘一
    Qt::ItemFlags CityModel::flags(const QModellndex-&index) eonst jj.!    .,、  ’    ‘j,
    {
    Qt::Itemrlags  flags=QAbst ractItemModel::flags (index);    1:    _    一    。1
    if (index.row()I-index.column(》
    flags  I=Qt::ItemIsEditable;
    return flags;    ‘j‘．二：’  ～.  s    ?
    }    一    ‘
    ，j  ．：    ：
    模型会使用llags()函数得到该如何对一个项进行相关的操作（例如，是否可以编辑）。在QAb-
sUactTableModel中的默认实现是返回Qt:：ItemIsSelectablelQt:，：ItemIsEnabled。对于所有不在主对角
    ，    、
线上的项（它们总是0），都会添加这个Qt:：ItemIsEditable标记。
void CityModel::setCities(const Q5tringList &cityNames)
I
t.
   cities = cityNames; . .
  . distances..resize(cities,count() * (cities.countC) - i) / 2);
 . distances.fill(0);    .
    ’    j    +
    如果给定一个新的城市列表，就设置私有的QStringList为新昀列表，重新定义distances矢量的
    一    _    _一-
大小，清空所有的值，并且调用QAbstracdtemModel:.: reset()通知所有视图，它们的可见项必须被重
新获取。
int CityModel::offsetOf(int row, int column) const
{
   if (row < column)
198
C++ GUI Qt4编程（第二版）
    qSwap（row，column）；
    return(row幸(row -1)／2)+column;
    }
    offsetOf()私有函数用于计算给定的城市对在distances矢量中的索引。例如，如果有城市A、B、
C和D，并且用户更新第3行第1列，也就是从B到D，则偏移量应该是3x(3-1)／2+1=4。如果
用户要更新第1行第3列，也就是从D到B，则要归功于qSwap()的调用，它会执行相同的计算，并
且也将返回同样的偏移量。图10.13阐明了城市、距离及其相应表模型之间的关系。
城市
rcFr丁T百]i
距离
表模型
┏━━━━┳━━━━┳━━━━┳━━━━┳━━━━┓
┃        ┃骥糕冀  ┃豢鹑鬻  ┃褫纛戮  ┃鬓瓣囊  ┃
┣━━━━╋━━━━╋━━━━╋━━━━╋━━━━┫
┃蒸蒸    ┃  O     ┃ AHB    ┃ At…}C ┃ AHD    ┃
┣━━━━╋━━━━╋━━━━╋━━━━╋━━━━┫
┃鬻骥    ┃At叶B   ┃    0   ┃ B‘~}C ┃ BHD    ┃
┣━━━━╋━━━━╋━━━━╋━━━━╋━━━━┫
┃戮鬻    ┃AHC     ┃ BHC    ┃    0   ┃ CHD    ┃
┣━━━━╋━━━━╋━━━━╋━━━━╋━━━━┫
┃鬻囊蘩  ┃A《斗D  ┃ BHD    ┃ C++D   ┃  '0    ┃
┗━━━━┻━━━━┻━━━━┻━━━━┻━━━━┛
图10.13城市和距离的数据结构以及表模型
    本节的最后一个例子是显示给定布尔表达式的解析树的模型。布尔表达式可以是一个简单
的包含文字和数字的标识符，如“bravo”，也可以是一个利用“&口’、“II”或“！”等算子连接简单表达
式的复合表达式，还可以是括号表达式。例如“aI I(b＆&!c)”就是一个布尔表达式。
    如图10.14历示的布尔解析器应用程序由4个类组成：
    ●BooleanWindow是一个让用户输入布尔表达式并且显示相应解析树的窗口。
    ●BooleanParser从一个布尔表达式生成一个解析树。
    ●BooleanModel:是一个封装解析树的树模型。
    ●l\To．de代表解析树中的一个节点。
    图10 .14布尔解析器应用程序
让我们从Node类开始：．
class Node    .  '
{
public:
   enum Type { Root, OrExpression, Andcxpression, NotExpression, Atom
                  Identifier, Operator, Punctuator };
第10章．项视．图类    199
Node(Type type, const QString &str = "");
Type type;
ost ring  st r;            .
Node *parent;
QList<Node *> children;
    每一个节点都有一个类型、一个字符串（可以为空）、一个父对象（可以为nuu）和一个子节点的
列表（可以为空）。
Node::Node(Type type, const QString &str)
{
   this->type = type;
 .  this->str = str;
    parent = O;
}
    构造函数只是简单地初始化这个节点的类型和字符串，并将父对象设置为null(即没有父对
象)。因为所有数据都是公有的，使用Node的代码可以直接操作类型、字符串、父对象和子节点。
Node: :~Node( )  '
qDeleteAll(children)
}
    qDeleteAⅡ()函数遍历一个容器的所有指针并且对每__个指针都调用delete。但是它并不把这
些指针设置为nuu，所以在一个析构函数外面使用这个函数时，通常在它之后需要调用clear()，以
清空这个容器中保存的所有指针。
    现在我们已经定义了数据项(每一个都表示为一个Node)，已经力创建二个模型做好了准备：
    f    -
    class BooleanModel+: public QAbstractItemModel
    {
    public：  、    ．
    BooleanModeicoObject *parent=0);
    ―BooleanHodel()；  ．
void setRootNode:(Node *node)';
QModellndex index(int row, int column,
           .       const QModellndex &parent) const;
QModellndex parent(const QModellndex &childJ const;
int' rowCount { cons.t  QModellndex &pa rent)  const ; '
int columnCount{const QModellndex &parent) const;.      .
QVariant data(const QModellndpx &index, int role) const;
QVariant headerData(int s'ettion, Qt::Orientation orientation
                int role) const;
private:
    Node *nodeFromlndex(const QModellnaex &index) const
Node *rootNode;
    迭一次使用QAbsUacⅡtemModel作为基类，而不是它的方便的子类QAbstractTableModel，这是
因为我们想创建一个分层模型。必须重新实现的最基本的函数仍然相同，除此之外还需要实现
index()和parent()。为了设置模型的数据，还有一个setRootNode()函数，调用这个函数的时候，必
须使用解析树的根节点作为参数。
C+4: GUI：Qt 4编程C第二版）
    eanModel::BooleanModel( QObj ect  *pa rent)    、    .,,:i.
1    :QAbstractitemModel(parent)
    {
    rootNode=0：
    }    一‘
    在模型的构造函数中，只需要把根节点设置为一个安全的null值并且把parent传递给基类。
    BooleanModel:：―BooleanModel()
_  c“delete rootNode：
    }    ．    、
    在析构函数中，我们删除根节点。如果根节点有子对象，每一个子对象也都会被删除，并且依
次递归往下删除，这是由Node的析构函数完成的。  。
void BooleanModel::setRootNode(Node *node)
{    .
   delete rootNode;
   . rootrlode = node,  . .  .
    当设置新的根节点设置时，我们从删除任何之前的根节点（和它所有的子对象）开始。然后设
置新的根节点并且调用reset()通知所有视图，它们必须为任何一个可见的项重新获取数据。
  QModellndex BooleanModel::index(int row, int column,     .
' {    .                   const QModellndex&parent) const
  . .  if (lrootNode lI row < 0 1[ column ;< O)   :   . .  t... ::'.
         Node *parentNode - nodeFromlndex(parent) ;
          Node *childNode = parentNode->children:value( row) ;
,.    。‘return QModellndex(j;    .                     .
     return createlndex(row, column, childNode);
    index()函数是由QAbstactItemModel重新实现的。只要模型或者视图需要为一个特定的子项
（或者如果parent是一个无效的QModellndex时为顶级项）创建一个QModellndex的时候；这个函数
就会被调用。对于表模型和列表模型，不需要重新实现这个函数，因为QAbstractListModel和QAb-
stractTableMoclel默认的实现已经足够了。    ．
    在index()实现中，如果没有设置解析树，就返回L个无效的QModelhdex。否则，就根据给定
的行和列以及一个Node*为被请求的子对象创建一个QModellndexo．X于于层次模型，已知一个项相
对于宦的父对象的行和列并不能够唯一确定它，还必须知道它的父对象是谁。为了解决这个问
题，可以在QMoclellndex中存储一个指向内部节点的指针。除了行号和列号之外，QModellndex还为
我们提供了存储一个void*或者int的选择。    ‘
    可以通过父节点的children列表获得子节点的Node*。我们使用nodeFromlndex()私有函数从
parent模型索引中提取父节点：
', .if. (index.isValid()j) '{
              return  statjc=cast<Node  *>(index,internalPointer( 》 ;
 . ' 'et{rn,rootNgde;  .
   }   ''
}
第10章项视图，类．    201
    nodeFromlndex()i萄数把给定索引的void*强制转换成为Node*，或者如果这个索引是无效的，
就返回根节点，因为在模型中，一个无效的模型索引用来表示根。
int  BooLeanModeL: : rowCount ( const  QModellndex &pa rent)  const
{
      if .(parent.column(》 0)
       return 0;
         Node  *pa rentNode  =  nodeFromlndex ( pa rent) ;
  if (lparentNode)
      return 0;
           retu rn  pa rentNode->child ren, count ( ) ;
一个给定项的行总数就是它有多少个子对象。
int BooLeanModel::columnCount(const QModellndex & /* parent.*/) const
   return 2;
    )
列总数被固定为2。第一列用来保存节点类型，第二列用来保存节点值。
QModellndex BooleanModel::parent(const QModellndex &childJ const
Node *node = nodeFromlndex(child);
if (!node)
      return QModeLIndex( ) ;
Node .*parentNode = node->parent;
if  ( ! parentNode)
         retu rn  QModellndex ( )
Node *grandparentNode = parentNode->parent;
if (!grandparentNode)
      return QModellndex( ) ;
  3    int  row 2 grandpa rentNode->child ren.indexOf( pa rentNode);    ,j
    .returri createlndex(row,0,parentNode);
    J
    从一个子节点获得父节点的QModellndex，要比查找一个父节点的子节点多做一些工作。我们
可以很容易地通过使用nodeFromlndex()得到一个节点，然后通过使用这个Node的父指针获得父节
点，但是为了获得行号（父节点在它的层次中的位置）；还需要继续向上到祖父节点并且查找这个
父节点在它的父节点（也就是这个子节点的祖父节点）中的索引位置。  ．，    ’’
QVari.ant BooleanModel::data(const QModellndex &index, int -rolef codst "': '
{
   if (role != Qt::l    yRole)
                                                                                                                                                                                                                                                                                                                                                                                                                                               .
   .  return QV:lr:j:D:tp(},yRj                   . . ' : ..  .
  ' Node *node = nodeFrornlnde?c(jridex);  .  ; .              . .       .
 '. ,   return QVariant();         '         '
if (index,column() == 0) {
.  switch (node->ty,pe) {
   case Node::Root:k'
     .  return tr("Root");     .
 ' case Node::OrExpression:
  .    return tr("OR Expression")).;
   case Node::AndExpression:
    .  return tr("AND Expression");
   case Node::NotExpression:    .
   . . return tr("NOT Expression");
   case Node::Atom:
            return tr( "Atom") ;
       case  Node: :Identifier:
             return tr( "Identifier") ;
   case Node::Operator:
C++ GUI Qt 4编程（第二版）
              ,  return tr("Operator".) ;
      case Node::Punctuator:
                   return tr( "Punctuator") ;
 default:
         return tr("Unknown");
            }
   } else if (index.column() = 1)
      return node->str; .
      }
   return QVariant();
}
    在data()中，可以获得请求的项的Node*，并且我们使用它访问底层的数据。如果调用者想
得到Qt：：DisplayRole之外的其他任何角色的值，或者如果不能从给定的模型索引中获得一个
Node，就返回一个无效的QVariant。如果列为0，就返回这个节点类型的名称；如果列为1，就返回这
个节点的值（也就是它的字符串）。
QVariant BooleanModel::headerData(int section,
                    . "   Qt::Orientation orientation,  .
                       int role) const   ' . .   .
{           .
    if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
       if (section == 0) {
                  return tr("Node") ;
       } else if (section == 1) {
 I        return tr("Value");
  .        }
      }
          retu rn  QVa riant ( ) ;
    '
    茌headerData()的重新实现中，我们返回合适的水平表头标签。在用于可视化层次模型的
QTreeView类中，没有垂直表头，所以可以忽略它了。
    现在已经完成了Node和BooleanModel两个类，让我们看看当用户在行编辑器中改变文本的时
候根节点是如何创建的：  ，．
void BooleanWindow::booleanExpressionChanged(const QString &expr)
   Boolear,Parser parser;   .
      Node卓rootNode = parser.parse(expr) ;
         booleanModel->setRootNode ( rootNode) ;                      .
    用户改变这个应用程序的行编辑器的文本时，会调用主窗口的booleanExpression()槽。在这个
槽中，用户的文本被解析并且解析器返回这个解析树的根节点的指针。
    这里没有讲解BooleanParser类，是因为它和GUI或者模型／视图编程无关。随书的示例中给出
了这个实例的完整深代码。
    当实现像BooleanModel之类的树模型时，很容易出错，从而导致QTreeView出现奇怪的行为。
为了帮助并解决自定义数据模型中的问题，Trolltech实验室提供了一个ModelTest类。这个类对模  一7
型执行一系列测试，以发现常见的错误。如果想使用ModelTest，可以从网址http：//labs．trolltech．
com/page/Ptoj ects/ltemview/Modeltest下载，并按照README文件哞f给定的说明进行操作。
    在这一节中，我们已经看到了如何创建三种不同的自定义模型。很多模型要比这里显示的更
为简单，只要在项和模型索引中做好一一对应即可。Qt中还提供了更多的模型／视图的实例以及  ．
大量的文档资料，具体请查阅附录或者帮助文档。    ！
    《
／7
第10章’项视图类
10.4实现自定义委托
    委托( delegate)用来渲染和编辑视图中不同的项。在大多数情况下，视图中默认的委托已经足
够了。如果想更好地控制有关项的显示，通常可以通过使用自定义模型很简单地实现我们所想要
的：在data()重新实现中，我们可以处理Qt:：FontRole、Qt:：TexLAlignmentRole、Qt:：TextColorRole和
Ql:：BackgroundColorRole，并且它们会被默认的委托使用。例如，在之前所显示的城市和汇率例子
中，我们已经为了得到向右对齐的数字的效果处理了Qt：：TextAlignmentRole。
    如果想得到更多的控制，则可以创建自己的委托类并且把它设置在我们想要使用它的视图
中。下面显示的音轨编辑器对话框就使用了一个自定义委托，它显示了音轨的标题和持续时间。
模型中保存的数据是非常简单的QStning(标题)和int(秒)，但是持续时间将会被分隔成分钟和秒两
部分，并且会通过QTimeEdit来让它变得可以编辑。
图10.15音轨编辑器对话框
    音轨编辑器对话框使用了一个QTableWidget，这是一个可以在QTableWidgetltem土操作的方便
的项视图子类。提供的数据是一个Track列表：
class Track
{
public:
    Track(const QString &title=””.int duration=0);
    QString title;
    int  du ration;
}；
下面显示的是TaskEditor构造函数中的一部分，它用来创建和组装这个表窗口部件：
T ra ckEdito r::TrackEdito r(QList<Track>丰t racks,   QWidget   *pa rent)
    ：QDialog(parentJ
{
    this->tracks=tracks;
    tableWidget=new QTableWidget(t racks->count(),2);
    tableWidget->setItemDelegate( rlew  TrackDelegate (1));
    tableWidget->setHo rizontalHeade rLabels(
    QSt ringList()<<tr( "Track")<<tr( "Duration));
    for (int row=0:row<tracks->count(); ++row){
    Track track=tracks->at(row);
    QTableWidgetltem *item0=new QTableWidgetltem(track,title);
    tableWidget->setltem( row,0,item0),
204    C++‘GUI Qt 4编程（第二版）
QTableWidgetltem *iteml .
             =  new  QTableWidgetltem ( ost ring : : number(t rack.duration 》 ;
iteml->setTextAlignment(Qt::AlignRight); '          ' : '
tableWidget->setltem( row,  1,  iteml) ;       '
    这个构造函数创建了一个表窗口部件，并没有简单地使用默认的委托，而是设置了自定义的
TrackDelegate，传递保存时I司、数据的列作为参数。我们由设置列的表头开始，然后遍历数据，利用
每一个音轨的名称和持续时间组装各行。
    构造函数中的其余部分以及TrackEditor对话框的其余部分中没有什么特别的地方；所以现在
我们将直接查看TrackDelegate是如何处理音轨数据的显示和编辑的。    ，
class TrackDelegate : public.QItemDelegate
{
Q_OBJECT
public :
   TrackDelegate(int durationColumn, QObject *parent = 0)
void paint(QPainter *painter, const QStyleOptionViewltem &option,'
            const QModellndex &index) const;         :r  .    /'   .
QWidget *createEditor-(QWidget *parent, .    .
                                   const QStyleOptionViewltem &option, .       '
                           const QModellndex &index) const; '      ,
void setEditorData(QWidget *editor, const QModellndex &indexJ const
void setModelData(QWidget *editor, QAbstractItemModel *model,    '
                    const QModellndex &index) const;
p rivate  slots :
       void  commitAndCloseEditor( )
p rivate:      .
  'int durationColumn
+  我们使用'QIterriDelegate作为基类，所以可以从默认的委托实现中获益。如果想从头开始做，则可
以使用QAbshacdtemDelegate作为基类①。为了提供一个可以编辑数据的委托：必须实现create-
Editor()．setEditorData()和setModelData()。还要实现pa/nt()，它用于改变持续时间这一列的显示。
T ra c kDelegate: :TrackDelegate ( int  du rationColumn,   QObj ect   *pa rent)
   : QItemDelegate(parent)
   this->durationColumn = durationColumn;  .
构造函数中的durationColumn参数告诉这个委托，哪一列保存的是音轨的持续时间。
void 'Trac.kDelegate: : paint {QPainte r  *painter,
    . ".  '                                     ;Viewltem &oI
                       .   - const QStyleOptionVic      &option,
                              const QModellndex &indexJ const       .
 ' .if (index,column<) == durationColumn)-.{
            int secs = index.model( )->data(index,  Qt::DisplayRole) ,tolnt()
       QString text = QString(“%l:ga2")
                               .arg(secs / 60, 2, 10, QChar( -0-》 '       .
                    .arg(secs as 60, 2, 10, QChar('0').);
QStyleOptionViewltem myOption = option
④
Qt 4.4有望引入一个QStyledltemDelegate类并把它作为默认的委托。与QItemDelegate不同，QStyledIt,emDelq\ate将依赖于
当前风格以绘制出它的项。
    第10章项视圈类‘t 205
    __.__-_-_‘_____-_____-___-一
myOption.displayAlignment = Qt::AlignRight I Qt::AlignVCenter
         d rawDisplay ( painter,  myOption,  myOption. rect,. text ) ;
   drawFocus(painter, myOption, myOption.rect);    i
} else{
       QItemDelegate: :paint ( painter,  option,  index) ;
}
    因为我们想使用“分钟：秒”的格式显示持续时间，所以需要重新实现这个paint()函数。，两个
arg()调用中的参数分别为：’要显示为字符串的整数、需要的字符串有多少个字符、整数的基数
（10代表十进制）和填充的字符。    ，  。  。    ，    一
    为了右对齐文本，我们复制当前的风格选项并且覆．盖默认的对齐方式。然后调用QItemDel-
egate：：drawDisplay()绘制这个文本j然后跟着的是QItemDelegate：：drawFocus-()，如果当前项具有焦
点，它就绘制一个焦点矩形，否则什么也不做。使用drawDisplay()菲常方便，特别是当使用了自定
义的风格选项的时候。还可以使用绘图器直接绘制。    一．
QWidget . *T rackDelegate: : c reateEdito r (QWidget  *pa rent
         const QStyleOptionViewltem &option,
     .  const QModellndex &index) const
if (index.column() == durationColumn) {
    QTimeEdit *timeEdit = new QTimeEdit(parent
          timeEdit->setDis playFormat ( "mm: ss'/ ) ,     .
          connect ( timeEdit ,   SIGNAL ( editingFinis hed ( )
                             t his ,   SLOT ( commitAndCloseEditor ( 》
   return timeEdit; .   .
    我们只想控制音轨持续时间的编辑，所以把音轨名称的编辑留给了默认的委托。这是通过检
查要求委托提供一个编辑器的是哪一列实现这一点的。如果是持续时间所在的列，就创建一个
QTimeEdit，设置正确的显示格式，并且把它的
editjngFinished()信号和commitAndCl_oseEditor)樯连接
起来。对于其他任何一列，都把有关编辑的处理传递给默认的委托。
void  TrackDelegate: :commitAndCloseEditor ( )
{            .
   QTimeEdit *editor = qob
     emit .commitData(editor)
   emit closeEditor(editor
}
ct_cast<QTimeEdit *>(sender(》
    如果用户按下Enter键或者把焦点移动到这个QTimeEdit之外（但不是按下Esc键），ediUngFin-
ished()信号就会被发射并且就会调用commitAndCloseEditor()槽。这个槽会发射commitDala()信号，
通知视图用被编辑的数据替换已经存在的数据。它还发射．clo：；eEditor()信号，通知视图已经不再
需要这个编辑器了，这时模型将会把它删除。编辑器可以使用QObject：：sender()获得，这个函数返
回发射了触发这个槽的信号的对象。如果用户取消编辑（按下Esc键），视图将会简单地删除编
    ：    ：
辑器。
void  TrackDelegate: : setEdito rData ( QWidget  *edito r;
                                  .         const QModellndex &index) const
{
                                                                                                                                                         .'.'
 .  if (index.column() == durationColumn) {
                 int  secs  =  index.model( ) ->clata (index,  Qt : : DisplayRole) ,tolnt ( )
           QTimeEdit *timeEdit = qobject_cast<QTimeEdit *>(editor) ;
       . timeEdit->setTime(QTime(0, secs / 60, secs %'60》;         .  .
   } else {
  x
 ,o
 -o
  e
  rl
 .' C
  o
  .+
  IJ
  a
  o
  IJ
  o
  L
  rr,
  o
  o
  .  IJ
  .+
 -o
 LU
  o
  IJ
  L
  IJ
  rr,
  o
  o
 o
  o
  IJ
 H
 o
  IJ
rH  rH
麟黪黟匿卜l卜．L
  206    C++ GUI Qt 4编程（第二版）
.-_-_.-______-_.__’_.。一
    当用户初始化编辑的时候，视图会调用createEditor()创建一个编辑器，然后利用这个项的当前
  数据调用setEditorData()来初始化编辑器。如果编辑器是用于持续时间列的，就按秒提取这个音轨
  的持续时间，并且设置QTimeEdit的时间为相应的分钟数和秒数；否则，就让默认的委托处理这个
  初始化。
void TrackDelegate::setModelData(QWidget *editor,
                                         QAbstractItemModel *model, .
                                      const QModellndex &index) const
ex,column() =
n/eEdit *timeE
me time. = tim
 secs = (time
el->setData (i
{
~mDelegate: :s
 {'.
t<QTimeEdit
time.second
(edito
X);
    )
    如果用户完成了编辑（例如，在这个编辑器窗口部件外面按下鼠标左键，或者按下了Enter键
或E。c键），而不是取消编辑，模型就必须使用编辑器的数据进行更新。如果持续时间被编辑了，
就从QTimeEdit申提取出分钟数和秒数，并且设置数据为相应的秒数。
。  我们完全有可能创建一个可以很好地控制模型中任何一个项的编辑和显示的自定义委托，尽
管在这种情况下不是必需的。我们已经选择控制特定的列，但是因为QModellndex会被传递给重
新实现的所有QItemD。legate的函数，所以可以按照行、列、矩形区域、父对象或者它们中的任意组
合进行控制，如果需要还可以控制每一个单独的项。
    在这一章中，我们已经为Qt的模型／视图搭建了一个总体的框架，演示了如何使用视图方便的
子类、如何使用Qt预定义的模型和如何创建自定义模型和自定义委托。但是模型／视图架构是如
此的丰富，以至于没有足够的空间讲解它所能做到的一切。例如，可以创建一个自定义视图，并它
把它的项呈现为列表、表和树以外的形式。在Qt的examples/itemviews/chart目录下的Chart实例讲
解了这种用法，它显示了如何自定义一个把模型数据显示为饼状图形式的视图。
    另外，也可以使用多个视图查看同一个模型，而不需要繁琐的工作。通过其中一个视图的任
何编辑操作都会自动并且立即影响其他视图。在查看大型数据，当用户希望能够同时查看逻辑上
截然不同的几个部分的教据的时候，这种功能非常有用。这种架构也支持选择：当两个或者多个
视图正在使用同一个模型时，每一个视图都可以被设置为拥有自己独立的选择，或者可以在不同
的视图中共享选择：    ‘7
    Qt的在线文档对于项视图的形成以及它的类实现提供了很详尽的介绍。所有与项视图相关
的类的列表，可以参考http：//doc．troll.tech．com/4. 3/model- view'. htmlj有关其他信息以及Qt中所包
含的相关实例的链接，请参考http：//doc．troll.tech．com/4. 3/model- view- programming．html。
／
x
o
-o
rl
L
o
IJ
rl
-o
o
ra
IJ
ra
o
L
o
IJ
rl
-o
LU
IJ
o
o
IJ
ro
o
o
o
E
o
IJ
H
o
=  l--o
r IJ -6
o u-  .N
C r.E   cn
o b rl- U
rl O lJ - O
l- CT A a> cn
ro     I  IJ
L II=IJ =  -
=   rl C X
-O IJ -O.-rl a)
    rl LU E -O
第11章  容  器  类
    容器类通常是用于在内存中存储给定类型的许多项的模板类。C++已经提供了很多容器，作
为标准模板库( STL)的一部分，它们都包含在标准的C++库中。’
    Qt提供了属于自己的容器类，所以在编写q程序时，既可以使用Qt容器也可以使用STL容
器。Qt容器的主要优点是它们在所有的平台上在运行时都表现得一致，并且它们都是隐含共享
的。隐含共享(implicit shaning)，或者称为“写时复制”，是一个能够把整个容器作为不需要太多运
行成本的值来传递的最优化过程。Qt容器的另一个主要特征就是易于使用的迭代器类，这是从
Java中得到的灵感，它们可以利用QDataSUeam变成数据流，而且它们通常可以使可执行文件中的
代码量比相应的STL类中的要少。最后，在Qt/Embedded Linux支持的一些硬件平台上，通常只能
使ffg..Qt容器。
    Qt既提供了诸如QVector <T>、QLinkedList<D和QList<D等的连续容器，也提供了诸如QMap
<K，T>和QHash<K，T>等的关联容器：从概念上分析，顾名思义，连续容器连续地存储项，而关联
容器则存储键值对。
    Qt还提供了在任意容器上执行楣关操作的通用算法。例如，qSort()算法对一个连续容器进行
排序，qBinaryFind()在经过排序的连续容器上执行一个二进制搜索。这些算法与STL所提供的算
法类似。：
    如果你已经非常熟悉STL容器并且在目标平台上srL是可用的，就没有必要再使用Qt容器
了。有关STL类和函数的更多信息，对初学者来讲，SGI的STL网站http：//www. sgi:c011n/tech/stl/是
一个好地方。    ：
    在这一章中，我们还将关注QString、QByteArray和QVariant，因为它们与容器有很多相似之处。
QString是贯穿Qt应用编程接口的一个16位Urucode字符串，QByteArray是一个用来存储原始二进
制数据的8位字符数组，QvaaIlt类则可以存储绝大多数C++和Qt值类型。
11 j 1  连续容器
    QVector<D是一种与数组相似的数据结构，它可以把项存储到内存中相邻近的位置，如图11.1
所示。向量与普通C++数组的区别在于：向量知道自己的大小并且可以被重新定义大小。在向量
末尾添加额外的项是非常快速有效的，而在向量前面或者中间插入项则是比较耗时的。    ‘
    如果能预先知道需要使用多少项，劂在定义向量时，就可以初始化向量的大小，并使用[]操
作符为它的项赋值；否则，可以稍后重新定义向量的大小，或者在向量的末端增加项。下面是一个
指定向量初始大小的例子：    ‘
    QVector<double> vect(3);
    vect [0]=1.0;
    vect[1】=0,540302;
    vect[2】=-0.416147;
C++ GUI Qt 4编程（第二版）
  、下面这个例子与上面的例子功能相同，只不过它是以一个空向量开始并使用append()函数在
这个向量的末端增加项：
    QVector<double> yect;    ,    .
    vect.append(l.0)；
    vect,append(0.540302);
    vect.append(-0.416147):
也可以使用<<操作符来代替append()：
    vect((1.0<<0.540302((-0.416147;
而遍历向量的项的方式之一就是使用[]操作符和count()函数：
    double sum=0.0;
    for (int i=.0;i<vect.count(); ++i)    .、    、，
    sum+=vect[i】；
    所创建的向量元素如果没有赋以确切的值，就会被使用这个项的类的默认构造函数进行初始
化。基本类型和指针类型都会被初始化为00
    对于较大的向量来说，在QVector <I'>的开头或者中间插入项，或者在这些位置去除项j都是
非常耗时的。因此，Qt还提供了QLinkedList<T>，这是一种把项存储到内存中不相邻位置的数据
结构，如图11.2所示。与向量不同，链表不支持快速的随机访问，但它提供了“常量时问”(constant
time)的插入和删除。
    ―、▲／――1r-、■
i_一？，_震羹霪？糜3糜霜蓊Ill誓l、，■童l
    v-_-/v一／V__／￥嗝一／
    1  √    ‘  i    图11.2双精度链表
：’二‘一：：；』．    -    一    ．
    链表并未提供[]操作符，所以必须使用迭代器来遍历项。迭代器还可用来指定项的位置。
例如，下面的代码给出了如何在“Clash”和“Ramones”之间插入字符串“Tote Hosen”：    、
_.QLinkedList<.ostr;1ng> list,;  。    ．    ：
    ，    ，
    list.apperid(“Clash“);
  ¨  Iist．a[nones“)；    ．+  。    +
QLinkedList<QSt ring>: :iterator  i  = list. find ( "Ramones") ;
list.insert(i, "Tote Hosen"):. .
在本节的稍后部分，还将详细地研究迭代器。．    ．、
    QUst<rr>连续容器是一个“数组列表”（array-list），结合了单一_类中QVector <T>和QLinked-
List <1>的最重要的优点。它支持随机访问，而且它的界面与QVector的一样是基于索引的。在
QList <r>的任意一端插入或着移除项都是非常快速的，并且对含1000项以上的列表来说，在中间
插入项也是很快的。除非我们想在一个极大的列表中执行插入或者要求列表中的元素都必须占
据连续的内存地址，否则QUst <r>通常是最合适采用的多用途容器类。
    QStringList类是被广泛用于Qt应用编程接口的QList <QSt/I]g>的子类。除了从它的基类中继
承的函数以外，QStringList还提供一些特别的函数，以使得这种类对字符串的处理方式更通用。
QStringList将会在本章的最后一节中讨论到。
    QStack<T>和QQueue<D是这些方便的子类中的另外两个例子。1 QStack<T>是一个可以提供
push()、pop()和top()的向量i QQueue <T>是一个可以提供enqueue()、dequeue()和head()的列表。
    对于目前所讲过的所有容器类，值类型T可以是一个与int、double、指针类型、具有默认构造函
数的类（没有参数的构造函数）、复制构造函数或者赋值操作符相似的类。符合这个条件的类包
括：QByteArray、QDateTime、QRegExp、QString和QV商aIlt。派生自QObject昀QL类不具备资格，因为
第111章容：器  类
它们没有复制构造函数和赋值操作符。这在实际应用中并不是问题，因为可以简单地存储指向
QObject类的指针而不是对象本身。
’值类型T也可以是一个容器。在这种情况下，必须记得用空格分开连续的尖括号；否则，编译
器将会把连续的尖括号认作是>>操作符而停止工作。例如：
    QList<QVector<double>>list;    +‘’
    除了刚刚提到的类型，一个容器的值类型可以是符合之前所描述标准的任意自定义类。下面
是这种类的一个例子：    1  '
class Movie                                        .   ,    , . '
{
public:
   Movie(const QString &title = "", int duration = O);  .
              .
    void setTitle(const QString &title) { myTitle = title; }
  , QString title() const { return myTitle; }
    void "setDuration(int duration) { myDuration = duration; }
    QString duration() const { return myDuration;. }
private:
    QString myTitle;    一
    ．    ，  ；．    Lr：
    int myDuration;    ．  ？，    ．
    )；    ‘    -    ．    ．    ．    ，  。
    J．'  。    ．
    这个类有一个不需任何参数的构造函数（尽管它可以占用到两个参数）。它也有一个复制构
造函数和一个赋值操作符，两个都是由C.++隐含提供的。对于这个类≈逐琢穆冬制就足够了，所
    r^t+
以这里没有必要实现自己的复制构造函数和赋值操作符。
    Qt提供的两类迭代器用于遍历存储在容器中的项：Java风格的迭代器和STL风格的迭代器。
Java风格的迭代器易于使用，STL风格的迭代器则可以结合Qt和STL的一般算法而具有更加强大
    、    0    'j 7’
的功能。
    对于每个容器类，都有两种Java风格的迭代器类型：只读迭代器和读一写迭代器。‘它们的有效位置
如图11.3所示。只读迭代器廷有QVectorlterator <T>、QLinkedListlterator<T>和。QLisOterator拯。相
应的读一写迭代器则在其名字中都含有“Mutable”的字样（例如，QMutableVectorlteratof 4r> k在讨
论中，我们将重点关注QUst的迭代器，针对链表和向量的迭代器都有相同的应用编程接口。j
图11.3 Java风格迭代器的有效位置
    当使用Java风格的迭代器时．必须首先牢记的是：它们本身并不是直接指向项的，而是能够定
    ．    ‘
位在第一项之前、最后一项之后或者是两项之间。一个典型的迭代循环如下所示：
    QListlterator<double> i(list);
    whiLe  (r.hasNext(》.{    ，一    ：
    do_something(i.next());
    )
    迭代器通过容器遍历来初始化。在这一点，迭代器在第一项之前就被定位了：如果迭代器的
右边有一个项，则调用hasNext()函数会返回true。next()函数返回迭代器右边的项并且将迭代器
提升至下一有效位置。    。i  ：
’  向后迭代与此类似，但必须首先调用toBack()：以将迭代器定位到最后一项之后的位置。
210
C++ GUI Qt 4编程（第二版）
QListlterator<double> i(list) ;
i.toBack( ) ;
while (i.hasPrevious(》 {
do_something(i.previous(》
    如果迭代器的左边有一个项，则hasPrevious()函数将返回true。previous()函数返回迭代器左
边的项并且将迭代器住前移一个位置。其实可以以另一种方式来认识riext()和previous()迭代器，
即它们返回迭代器跳过的项，如图11:4所示。
图11.4 previous()和next()对Java风格的影响
    Mutable迭代器（即Java风格的读一写迭代器）在遍历时提供了插入、修改以及删除项的函数。
下面的循环删除了一个列表中所有的负数：    ．
    QMutableListlte rato r<double>  i(list);
    while(i．hasNext()){
    if (i,next()<0.0)
    1．remove()；
    )
remove()函数总是对最后被跳过的项进行操作。在向后迭代时它也同样有效：
    QMutableListlte rato r<double>  i(list);
    i．toBack()；
    while (i.hasPrevious(》{
    if(i．previous()<0.0)
    i．rerriove()；
    )
    与此类似，Java风格的读一写迭代器提供setValue()函数以修改最后被跳过的项。下面是使用
绝对值来代替负值的代码：
    QMutableListlte rato r<doubte>i(list);    ’
    while(i．hasNext()){
    icit val=i.next();
    if (val<0.0)
    i．setValue(-val)；
    ’)
    通过调用insert()，可以在当前迭代器位置插入一项。然后，迭代器就被提升到新的项和随后
的项之间的位置。
    除了Ja\ra风格的迭代器，每一个连续容器类C<T>都有两个STL风格的迭代器类型：C<T>：：
iterator和C<D：：const_iterator。这两者的区别在于constjterator不允许修改数据。
    容器的begin()函数返回引用容器中第一项的STL风格的迭代器（例如：list[0]），而end()函数
返回引用“最后一个项之后的”项的迭代器（例如，对于一个大小为5的列表取'list[5]）。图11.5给
出了STL风格的迭代器的有效位暨。如果某个容器为空，则begin()等价于end()。这可以用来检
查容器中是否有项，尽管以调用isEmpty()函数的方式可更方便地达到这个目的。
    STL风格的迭代器的语法是模仿C++数组的指针。我们可以使用++和一一操作符来移动下
一项或者前一项，而使用一元操作符*来获得当前项。对于QVector <T>，iterator和const_iterator类
型都只是Tx和const T*的类型定义。（因为QVector <T>在连续的存储单元中存储它的项，所以
这样做是可以的。）
。jj胡9翻霸翻期溺霸溺翔酒
    ，，，
第11章容器类
211
begin()
    图11.5  STL风格迭代器的有效位置
    1
下面的例子采用绝对值取代了QList <double>中的每个数值：
   .    vect[i] = std::sin(i / (2 * M_PI》
   return vect;
    须的
    必回
    则返    。
    ，
    值“
    回cn    一一～一  徘    翱剥倾  任
    一个  的
    棚  ．    缺张毯  损
    返溜    t翱
    一    碚堤
    黼‰    制    一叭一  黝：
    ¨处  不函
    函印    ，新粼～  讲    耵摧～  需数
    个Q    如糟    恍    髁榭一
    某由    包馒
    历历
    遍遍    州般
    器何
    代如    一一
    迭了
    的出    。
    ・l
    格给    一
    。    耥一+一一一    一～一一一一
    风码    6
    几代    o虾
    S的    ；    z
    ・1上
    用面    s
・l
 g
b    )t
。    一～  ；一    IO -ra -o    潮积
    e    e{
    b    n，
    ・1上、J
    t
    S    。(
    ・l    pd
。    搬u    。。    ．s一一一一  卜    一一～
    ．，
・1rl    =  ．
【    i lI
=    糯眠  s-1-
    。    ～瓣
    r    ．e
'rl -r    e 0-r    o Z
 r)    t t    t i
。，    个个  n ro -    2  8 5
t(    )．r  i m（：    }  e一；    （一i h f自2([e  M}5 i，U j'1
 a a    一这
r n
托七n    回历“
・1 t．1
躲鬈一
曲rl lI 0  q器~
V  ．1+
n k++  些容
・1上．1上
-n    一此
。w    ，    眦    ，
    制一～一～一一  一呲～O rl
    。，  嘞㈨
    ’T一托q
    t}L(
    S．1 g
    C S h
    ==lI吼
    A! E
    。  。    一一一一一一一-r O
    ．H  一
    ~“t舱
    ，^．．  容着¨
    吐“吖  个味4
    ．l X n
    v a-rl  一意¨
    ～阳叫吣批    瑚吼    ~a e  制这“
    面帐mr    翩材    ～一哪  黻秘墩暾婷耐
    这过△
    ，下∥吡舭  ，这-眠擞一一～眦，像化一删船瓿
    优^
    复    舭    最一
      rl
     .- t
    o .-
- LOQ
C    rri LO
 o  C rri
-o  u v
mo
}-   > rl
o
C   A .-
rl    a> 0.
Ln    b II
A=
o   O rl
r  -O
D   V iJ
=  LC
o  O rl
o   }J C
o >o
}J    af
u
o
>,
212    C++'：GUt Qt 4编程（第二版）
该函数的调用看起来如下：    ．
QVector<double> table=sineTable();
    比较起来，STL鼓励我们将向量作为一个非常量参数来传递，以避免当函数返回值被存储于变
量中时发生复制：    j-    一
    void  sii.eTa ble( s.td.:vecto r<double>  &vect)    .,,:
    {    ’
    vect.resize(360);
    for (int i=0:i<360; ++1)
    vect[i]=std::sin(i／(2幸M_PI》;
    ‘    巳    ．．
  i  ’)
于是，这个调用程序就变得更加冗长，、并且可读性较差：
    std::vector<double> table;    ’
    ‘    ’
  ‘+sineTable(table)；
    Qt对所有的容器和许多其他类都使用隐禽共享，包括QByteArray、QBrush、QFont、QImage、QPix-
map和QStnng。这使得这些类不论是作为函数参数还是作为返回值，都可以非常有效地传递。
    隐含共享是Qt对不希望修改的数据决不进行复制的保证。为了使隐含共享的作用发挥得最
好，可以采取两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读荐取
时，使用at()函数而不用[.]操作符。因为Qt的容器类不能辨别[]操作符是否将出现在一个赋值
的左边；丕喜著边，它假设最坏的情况出现并且强制执行深层复制，而at()函数则不被允许出现在
    ^    -
    ’    ：    。
一个赋值的左边。
    当使用STL风格的迭代器遍历容器类的时候，类似的问题也将出现。只要在非常量的容器类上
调用begin()或end()函数，并且如果数据是共享的，Qt就会强制执行深层复制。‘为了防止这种低效
操作的发生，二种解决的办法是无论何时都尽可能地使用const iterator、constBegin()和constEnd()。
  ？'Qt还提供了最后一种在连续容器中遍历项的方式-foreach循环，如下所示：    ．
一‘1QLinkedList<Vlovie>. lrs.t;    ．  ，，    ’    i:    1    一．、
    QLjnkedLjst刘吖ip+ujt；    ．
，  …一i、:、,.j...,:._..j..    +    .
    foreach (Movie f『iovie,Usty{    i  。    一  ，‘    ‘二    ？
    if (movie.title()==“Citizen Kane“).{    .  -_    ’    '.
    std::cout<<“Found Citizen Kane“<<std::endl;
    。break：
    ，
    )    -    ．    、
    foreach伪关键字按照标准的for循环实现。在循环的每一次迭代中，迭代变量(movie)都被设
置为÷个新项，从容器中的第一项开始向前迭代。foreacli循环会在进入循环时自动复制一个容
器，因此即使在迭代过程中修改了容器类，也不会影响到循环。，
‘break和continue循环声明也是支持的。如果主体部分只由一个声明组成，则花括号是多余
的。就如同for循环的声明语句-样，可以在循环体外定义迭代变量，具体如下：
    QLinkedList<Movie> list;
    Movie movie;
    ，    ．    1．    ‘_    ，    ‘
    foreach (movie, list){    ~
    if (movie.title()=="Citi/en Kane"){、
    std:: cout<<”Found  Cit/ze:n _ Kane" ~  std: :endl;
    break;
    )
    }
    在循环体外定义迭代变量只对那些支持含有一个逗号的数据类型的容器类才适用(例如，
QPair <QString,int》 。
第11章．容器，：类
213
11.2关联容器
    关联容器可以保存任意多个具有相同类型的项，且它们由一个键索引。：Qt：提供两个主要的关
联容器类：QMap <K，D和QHash <K，D。    。。    ’
    QMap <K，D是一个以升序键顺序存储键值对的数据结构，如图/11.6所示。这种排列使它可
以提供良好的查找和插入性能以及键序的迭代j在内部，QMap <K，B是作为一个跳越列表( skip-
list)来实现执行的。    ：
    ：、熬鬻卜―縻塑豳
    鹰蘩溺―《蘩瞳圈
    匿纛雾―叫黧逐圈
i、。！}  。  ，    ，  、  图11.6 QStnng到int的映射．，．    。
  214
C++ GUI Qt4编程（第二版）
在映射中插入项的一种简单方式是调用insert()：
QMap<QString, int> map;
map.insert("eins", 1);       .
map.insert("sieben", 7); .
map.inse rt ( "d reiundzwanzig " ,   23) ;
另外，也可以像下面一样，给一个指定的键赋值：
map["eins"] = 1;
map["sieben"] = 7;
map["dreiundzwanzig"] = 23;
    []操作符既可以用于插入也可以用于检索。如果在非常量映射中使用[]为一个不存在的键
检索值，则会用给定的键和空值创建一个新的项。‘为了避免意外地创建空值，可以使用value()函
数代替[]操作符来获得项。
    如果键不存在；则利用值类型的默认构造函数，将返回一个默认值，同时不会创建新的项。对
于基本类型和指针类型，将返回0值。我们可以指定另一默认值作为value()的第二个参数，例如：
这相当于：
int seconds = 30;  .
if (map.contains("delay"》
      seconds = map.value( "delay");
    ‘QMap <K，T>的K和T数据类型酉以是与int、double、指针类型、有默认构造函数的类、复制构造
函数和赋值操作符相似的基本数据类型。此外，K类型必须提供operator<()，因为QMap <K，T>要使
用这个操作符以升键序顺序存储项。
    QMap <K，T>有一对方便的函数keys()和values()，它们在处理小数据集时显得特别有用。它
们分别返回映射键的QList和映射值的Q【jst。    ，
    映射通常都是单一值的：如果赋予一个现有的键一个新值，则原有的旧值将被该新值取代，以
确保两个项不会共有同一个键。通过使用insertlVkdti()函数或者QMultiMap <K，T>方便的子类，可
以让多个键值对有相同的键。QMap <K; T>重载了values(const K&)，返回一个给定键所有值的
QList列表。例如：
QMultiMap<int, QString> multiMap;  .
multiMap.insert(l, "one"),
multiMap.insert(l, "eins"); .
multiMap.insert(l,  "uno") ;
                                                                                                                               '                             .
QList<QString> vals = multiMap.values(l);
    QHash<K，T>足一个在哈希表中存储键值对的数据结构。它的接口几乎与QMap <K，T>相
同，但是与QMap <K，T>相比，它对K的模板类型有不同的要求，而且它提供了比QMap <K，T>更
快的查找功能。
    除了对存储在容器类中的所有值类型的一般要求，QHash<K，T>中K的值类型还需要提供一
个operator==()，并需要一个能够为键返回哈希值的全局qHash()函数的支持。Qt已经为；qHash()
函数提供了整型、指针型、QCllu、QString以及QByteArray。
    QHash <K，T>为它内部的哈希表自动分配最初的存储区域，并在有项被插入或者删除时重新
划分所分配的存储区域的大小。也可以通过调用reserve()或者squeeze()来指定或者压缩希望存
第11章  容  器  类
215
储到哈希表中的项的数目，以进行性能调整。通常的做法是利用我们预期的最大的项的数目来调
用reserve()，然后插入数据，最后如果有多出的项，则调用squeeze()以使内存的使用减到最小。
    虽然哈希表通常都是单一值的，但是使用insertMulti()函数或者MultiHash <K，T>方便的子类，
也可以将多个值赋给同一个键。
    除了QHash <K，T>之外，Qt还提供了一个用来高速缓存与键相关联的对象的QCache <K，T>类以
及仅仅存储键的QSet <K>容器。在内部，它们都依赖于QHash <K，T>，且都像QHash <K，T> -样对K
的类型有相同的要求。
    最简便的遍历存储在关联容器中所有键值对的方式是使用Java风格的迭代器。因为迭代器
必须能同时访问键和值，针对关联容器的Java风格的迭代器与连续容器的在运作方式有些差异。
主要的区别在于next()和pre+ious()函数返回一个代表键值对的对象，而不是一个简单的值。我们
可以使用key()和value()分别从这个对象中获得键和值。例如：
QMap<QString, int> map;
int sum = 0;
QMapIterator<QString,  int> i(map) ;
while  (i, hasNext ( 》
    sum+= i,next().value();   .
    如果需要同时存取键和值，可以先忽略nex-t()或previous()的返回值并使用迭代器的key()和
value()函数，它们都是针对最后被跳过的项进行操作的：
    QMapIterator<QString,  int> i(map);
    while (i.hasNext(》t
    i．next()；
    if (i.value()>largestValue)t
    largestKey=i.key()；    ．
    largestValue=i.value();
    )
    )
    ：    、
  Mutable迭代器（即Java风格的读一写迭代器）拥有可以修改与当前项相关联的值的setValue()
函数：    ．  ．
    QMutableMa pIt.e rato r<ost ring,   int>i(map);
    while (i.hasNext(》t  ．
    i．next()；    一
    ‘    if (i.value()<0,0)
    STL风格的迭代器也提供了key()和value()函数。对于非常量迭代器类型，value'()返回一个
允许在迭代时改动其数值的非常量参数。需要注意的是：尽管这砦迭代器都被称为STL风格，它
们却与基于std:：pair <K，T>的std:：map <K，D迭代器有很大差别。
    foreach循环也可以用在关联容器中，但是它仅对键值对上的值分量有效9如果同时需要项中
的键和值，可以在如下的嵌套式foreach循环中调用keys()和values(const K＆)函数：
    QMultiMap<QString, int> map;
    foreach (QString key; map,keys(》t    :
    foreach(i“‘”81“8 J…ap.”81“es(key)_)t.
    do_something( key,  value):    ‘
    )
    )
  ':216    C++ GUI Qt 4编程（第二版）
―――=―。．；．．―二．．二．．，―=―．=―二=二-――。――二―――――――――――‘一
1 1.3．通用算法    ，  ．
    <QtAlgorithms>的头文件声明了在容器类上实现基本算法的一套全局模板函数。这些函数中
的大部分都是在STL风格上的迭代器上工作的。
：STL的<algoriLhm>头文件提供了一套更为完整的通用算法。这些算法既可以在STL容器类上
使用，也可以在Qt容器类上使用。如果STL。的实现代码在所有平台上都可以得到，那么在没有对
应的Qt算法时，就没有理由不使用STL算法。这里将引入最重要的Qt算法。    、
    qFind()算法在容器类中查找一个特定的值。它接受一个“begin”和一个“end'’迭代器，并且返
回一个与其匹配的指向第一项的迭代器；如果没有匹配的项，则返回“end”。在下面的例子中，将i
    list.begin()list.end(    ．    ’
设置为ljst．k百n()+1，而j设置为list．end()。    ；’-．．
QStringList list,
list《 "Emma"《 "Karl"《 "James"《 "Mar.iette";
ost ringList::iterator  i  =  qFind (list,begin ( ) ,  list.end ( ) ,  "Ka rl" ) ;
ost ringList: :iterator  j  =  qFind (list.begin ( ) ,  list.end ( ) ,  "Pet ra")
    qBinayFjnd()箅法执行的搜索操作与qFmd()算法相似，其区别在于qBinayFind()算法假设项
都是以升序的顺序存储的j并且使用了快速二分搜索而不是qFind()算法的线性搜索。
    qFiU()算法采用一个特定的值组装一个容器：    ~，．    ．？
    QLinkedList<int> list(10);
    qFill( list. begin(),list.end(),1009);
+    ’    ‘    ‘    。
    与其他基于迭代器的算法类似，也可以通过变化参数以在一部分容器类上使用qFiu()。下面
摘录的代码将一个向量的前5项初始化为1009，将后5项初始化为2013：
、    ．    ‘    ．’
    QVecto r<int>  vect (.10)i    .
    /qFill(vect. begin(),vect_ begin()+5,1009);
?qFill<ve.ct.end()‘-5,vect.end()7 2013);    ,
第U章二容  器  类
，217
    qStableSmt()算法与qSoIt()很相似，但qStableSort()算法还可以保证进行对等比较的项在排序之
后表现出与之前相同削顺序。如果排序标准仅仅考虑值的二部分并且用户可以看到结果，这就非常
    i  ．    ．
有用了。第4章曾使用了qStableSoIt()在Spreadsheet应用程序中实现了排序：
，  qDeleteAⅡ()算法对每一个存储在容器类中的指针调用delete。这仅对于那些为指针类型的容
器类才有意义的。在调用之后，这些项仍然作为悬摆指针存在于容器类上，因此我：们通常也应该
在容器类上调用clear()。例如：    ’’    i。  ‘
    qDeleteAll(list):-    ’    ，    一f 1:’  L  、    r    1    :    ,
    list.clear();    1=    ’
    list.clea r();    .    、    +    ,    j.’,.
    qSwap()算法可以交换两个变量的值，例如：    ，．'
    int xl=line.xl();
    int x2=line.x2();
    if (xl>x2)
    qSwap( xl，x2)；    1’    、’
    -    _
    最后，被所有其他的Qt首部都包括的<QtGlobal>的头文件，为我们提供了_些有用的定义，其
中包括返回参数绝对值的qAbs()函叛，以及返回最大、最小值的qMin()和qMax()固攀。，，  、
11.4字符串、字节数组和变量
    QStringi QByteArray和QVari枷这三种类与容器类在许多方面都有相，同之处，在_些情况下都
可以用来代替容器类的使用。与容器类相似，这些类也是使用隐含共享来最优化内存和速J-。
    我们将从QString开始。每一个图形用户界面(GUI)程序都会用到字符串，不仅仅是为用户界
面，更多的是为数据结构所用。C++本身提供两种字符串：传统的C语言型的以“＼o”结尾的字符
数组和std：：。tring类。与这两种字符串不同，QString支持16位Unicode值。Unieode码以ASCII码
和Latin-l码为子集，具有它们常用的数字值。但由于QStririg是16槿酗J：它可以表示数千种其他字
符以表达世界上绝大多数的语言。关于Unicode的更多信息，可以参考第18章。    一、i
    当使用_QStdng时，我们不必担心那些诸如如何分配足够的内存空间或确保数据以“＼0”结尾等晦
涩难懂的细节。从概念上说，可以将QString看成QChar向量j QString可以嵌入“＼0'’字符。lerigth()函
数舍返回包括被嵌入的“＼0”字符的整个字符串的大小。    ？    +  j。．…    ‘
    QString为连接两个字符串提供了一个二进制+操作符，还为在字符串后追加字符串提供了
+：操作符。因为QSting在行数据的末端自动预分配内存空间，因此通过重复添加字符来建立字
    ，    』。
符串就相当快捷了。下面是一个结合使用+和+=的例子：    ，
    ost ring  str;“User:”;    i.,    .    -
    str+=userName+”＼n”：
    ．  '    一    、  ‘‘
以下的QString:：append()函数与+P操作符的功能相同：
    ’    j    ：    r―
    str="User：“：
    'str.append(userName):  .    :,;    ,    ‘
    str.append(”＼n”)；
    .『__    ．    ¨
使用QString的sprintf()函数则是连接字符串的另一种完全不同的方法：
    str.sprintf(“%s%,lf%%“,“perfect competition“,100.0);
    这个函数支持与C++库sprintf()函数相同的格式说明符。在之前的例子中，str被赋值为“per-
fect competition l00.0% " o
    C
   J
    Q>
    >
    rl
    IJ
    rl
    C
    C
    rl
   -o
    C
    IJ
    rl
IJ   C
cn    rl
rl   O)
r  Q>
  -a
IJ
cn    lJ
rl    cn
J  rl
rl    lJ
L-L
IJ  . o
cn  . cn
o .q
218
C++ GUI Qt 4编程（第二版）
从其他字符串或者数组来建立一个字符串的另一种方法是使用arg()：
st r=QSt ring( "%1%Z(%3s-%4s)”）
    .a rg(”pe rmissive").a rg( "society").a rg (1950).a rg (1970);
    在这个例子中，“pennissive”会取代“%1”，“society”会取代“%2”，“1950”会取代“%3”，而“1970”
会取代“%4”。相应的结果为“pemussive society(1950s-1970s)”。arg()的重载可以处理各种数据类
型。对于控制字段长度、数值基数或者浮点精度等，一些重载有额外的参数。相较于sprintf()而
言，arg()通常是一个更好的解决方案，因为是它类型安全的，完全支持Unicode编码，并且允许译码
器对“%n”参数进行重新排序。
    通过使用QString:：‘number()静态函数，QString可以将数字转换为字符串：
或者也可以使用setNum()函数：
    str.setNum(59.6)；
    还可以使用tolnt()、toLongLong()、toDouble()等来完成从字符串刭数字的逆转换。例如：
    bool ok;
    . double d- str.toDouble(&ok);
    这些函数接受一个任选的指向bool变量的指针，并且根据转换成功与否来将变量值设为true
或false。如果转换没有完成，这些函数将返回0。．
    一旦有了字符串，我们通常都希望从字符串中提取出所需的部分。mid()函数返回在给定位
置（第一个参数）开始且达到给定长度（第二个参数）的子串。例如，下面的代码在控制台上打印
出“pays”①：  ~
    QString str=“polluter pays principle”：
    qDebug().<<str.mid(9, 4);
    如果省略第二个参数，mid()函数返回在给定位置开始到字符串末端结束的子串。例如，下面
的代码在控制台上打印出“pays' principle”：
    QString str=”polluter pays principle”；
    qDebug()<<str.mid(9);    ’
    也可以使用left()和nght()函数来完成相似的任务。它们俩都可以接收字符的娄嘻．n，并且返回
字符串的前n个字符或最后n个字符。例如，下面的代码在控制台上打印出“polluter pnnciple”：
    QSt ring st r=1‘polluter pays principle“：
    ・qDebug()<<str.left(8)<<““<<str.right(9);
    如果想查明一个字符串是否包含一个特定的字符、子串或者正则表达式，可以使用QString中
    l    ’
的indexOf()函数：
    QStrina str=”the middle bit“；
    int i=str,indexOf(”middle“);
这会将i设置为4。在失败时，indexOf()函数返回-1，并且接收一个可以的开始位置和区分大小写
的标记。
    如果仅仅想要检查字符串是否以某个字符（串）开始或者结束，则可以使用startsWith()和ends -
With()函数：
①这里用到的方便的qDebug()<<arg语法要求包含头文件（<QtDebup），而qDebug(“…”，arg)语法在任意一个包含至
    少一个Qc首部的文件中都是可用的。
第11章容  器  类
219
    if (url.startsWith(“http:“)＆＆url.endsWith(“.png“))
上面的代码就比下面的代码更简单、快捷：
    if (url.left(5)==“http:”＆＆url.right(4)==”.png“)
    ・t．
    利用：：操作符进行字符串比较是区分大小写的。如果要比较那种用户可见的字符串，locale-
AwareComl，are()函数通常是一个不错的选择；如果比较并不区分大小写，则可以使用toUpper()或
toLower()函数，例如：
    if (fileName.toLower()==”readme.txt”)
    如果想使用一个字符串来代替另一个字符串中的某一部分，可以使用replace()：
    QString str=”a cloudy day”；
    str.replace(2,6,“sunny“);
字符串的结果是“a sunny'day”。上面的代码可以用remove()和insert()重新写为：
    str. remove(2，6);    ，…
    str,insert(2,“sunny“);
    首先，我们去掉从第二个位值开始的6个字符，字符串因此变为“a day”（含有两个空格）．然
后在第二个位置插入“sunny”。1
    replace()函数的重载版本让第二个参数代替所有第一个参数出现的地方。例如i下面是使用
“&amp；”代替字符串中所有的“&”：
    str. replace（”＆”，‘‘&amp;’：）；    、
    我们经常需要删除一个字符串中空白处的空格（比如空格符、制表符、换行符等）。QString有
一个可以从字符串的两端删除空白处的空格的函数：    ’    1：
    -QString str=“  BOB＼t THE \nDOG＼n“;    ’    、
    qDebug()<<str.trimmed();    j
字符串str描述如下：
  厂]厂]厂1圆圈翮]可]两甄同厂]-]硐网可可1涧
由trimmed()返回的字符串为：
‘网可可可矿可丽碡r]n研丽羽
、  当处理用户输入数据时，除了从字符串的两端删除空白处的空格符外，通常还想用简单的空
格符代替字符串内部每一连续空白处的空格：
    QString str=“  BOB＼t THE \nDOG＼n”；
    qDebug()<<str.simplified(-);
由simpMed()返回的字符串为：
  阿两盯1丽眶r圈    ‘    一
  使用QString：：split()，可以把一个字符串分成一些QStringList子串：
  QString str="polluter pays principle“；
  QStringList words=str.split(”.“);    ?
  在上面的例子中，我们把字符串“polluter pays principle”分成了三个子串，“polluter”、“pays”和
“principle”。split()函数有一个可选的第二参数，用来指定是否空的子串应该被保留（默认为保留）
还是被删除。
    使用join()函数，QStringLi。t中的项可以连接起来形成一个单J的字符串。：在每一对被连接的
220    C++ GUI Qt 4编程（第二版）
字符串之间都要插入join()的参数。例如，下面是如何创建一个由1 QStringList包含的所有字符串组
成的、按字母表顺序排列且由换行符分隔的简单字符串：
    当对字符串进行操作时，通常需要判断字符串是否为空。这可以通过调用isEmpty()或者检查
lengffi()是否为O来完成。
    大多数情况下，从const char*字符串到QSU:ing的转换是自动完成的，例如：    +
    这里，我们采用无格式形式为QString加上一个const char*。为了明确地将QString转换为
const char-x，可以只使用一个QString强制转换，或者调用fromAscii()或fromLatlnl()。（关于其他编
码中的文字字符串处理的说明，可以参见第18章。）
    要将QSU:ing转换为const char*，可以使用toAscii()或toLatlnl()函数，它们返回QByteArray，而
利用QByteArray：：data()或QByteArray：：constData()，可以将QByteArray转换为co矗st char-x。例如：
为了方便起见，Qt提供了qPrintable()密用来执行与序列toAscii() .constData()相同的功能：
    当在QByteArray上调用data()或constData()时，返回的字符串属于QByteArray对象j这就意味
着不必为内存泄漏而担心了，Qt将为我们重新收回内存。另一方面，必须注意不要太长时间地使
用指针1。如果QByteArray没有存储在一个变量中，那么它将在声明的末端自动删除。
    QByfeArray类有-个与QString很相似的应用编程接口o诸如left.()、right()、mid()、toLower()、
toUpper()、trimmed()和simplified()等函数，在QByr:eAnay中的语义形式与在QString中的相同。
QByteArray对于存储原始的二进制数据以及8位编码的文本字符串非常有用：二般说来i我们推
荐使用QStnllg而不是QByteArray一来存储文本，因为QSU:ing支持Unicode编码。  。    ：
    为方便起见，QByteArray自动保证“最后一个项之后的项”总为“＼O”，这使得利用const char*可
以很容易地将QByteArray传递给一个圜数。QByteArray还支持嵌入的“＼o”字符，以允许我们存储任
意的二进制数据。    ．
    在某些情况下，我们需要在同-个变量中存储不同类型的数据。。种方法是像QByteArray或
QString -样，对数据进行编码。例如，字符串可以支持文本值或者以字符串形式支持数字值。这
些方法很灵活，但是它抛弃了C++的一些优点，尤其是类型的安全性和效率。Qt提供了一个更加
灵巧的方法，也就是QVariant，来处理那些能够支持不同数据类型的变量。
    QV撕叭类可以支持许多种Qt类型的值，除了基本的C++数字类型(如double和int)，还包括
QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、QPalette、QPen、QPi nap、QPomt、QRect、QRe-
gion、QSize和QString。QVa血ht类也支持容器类，如QMap< QString，QV商枷>、QStringList和QList
<Qvariant>.    ~    i-  一N.7.    .
    在项视图类：数据库模块和．QSettings。中广泛使用了变量，变量允许我们读写项数据、数据库数
据以及任意与QVariant蒹容的用户首选参数。第3章：已经看到了这样的一个例子；在那个例子中，
我们将QRect、QStringList和一对bd}l：值以变量的形式传给了QSeffings：：setValue()，并在之后以变
量的形式将它们取回。    _：，’    ，    ，    ，，，%i
通过容器类的嵌套值，可以利用QVmiant创建任意复杂的数据结构：  +
第n章‘容  器，类
221
    QMap<QSt ring,  'QVa riant>  pea rMap;    +    ，    二‘  i
    pearMap【“Standa rd“】=1.95;
    pea rMap【”Organic”】=2.25;    ,    、
    QMap<QString, QVariant> fruitMap;
    f ruitMap[”Orange”】=2.10;
    fruitMap[”Pineapple“】=3.85;
    fruitMap[”Pear”】=pearMap;    -    .    .    r‘  .  ’
    这里，我们利用字符串键（产品名）和浮点数c价1格）或者映射的值创建二个映射。7顶级映射包
括三个键：“Orange”、“Pear”和“Pineapple”。与‘‘Pear'’键相关联的值是一个包含两个键（“SLandanl”和
“Organic”）的映射。当遍历一个支持变量值的映射时，需要使用type()来检查变量保存所支持的类
型，以便做出适当的反应。    -
  ．创建这样的数据结构是非常吸引人的，因为能够以任意方式组织数据。但是QVanam的便利
性是以降低效率及可读性为代价的。通常，定义≮个适当的C++类来存储随时可能的数据，是值
得的o．    ，．    ，
    Qt的元对象系统使用QV撕龇，因此它乜是QtCore模块的一部分。但是，当与QtGui模块相连
时，QVan孤t可以存储与图形用户界面相关的类型，例如QColor、QFont、QIcon、QImage和QPixmap:
    QIcon icon(“open.png“);
    QVariant variant;icon;    .  r  .‘}
    为了从QVariant中获得与图形用户界面相关的值，可以使用如下的QVariant:': val.ue'<T>()模
板成员函数：
    ．    _    ．    一    f，J    “
    QIcon icon=variant,value<QIcon>();
    +    ：    ，
    value<D()函数也可以用在非图形用户界面数据类型和QV撕t。之间进行转换，但实际上，
对于非图形用户界面类型，通常使用to．．．()作为非图形用户界面数据类型．的转换‘函数-例如
    toString    ’    ，  ，。    ，…
toS试ng()]。    。
    如果自定义数据类型提供了默认的构造函数和副本构造函数的话，QV面ajlt也可以用来存储
它们。为此，必须首先使用Q_DECLARE_METATYPE()宏注册数据类型，尤其是在类定义下的头文
    ，：
件中：    ．
    Q_DECLARE_METATYPE (BusinessCard)
这使我们可以使厢如下的方式来编写代码：
    BusinessCard businessCard;
.QVa riant  variant=QVa riant::f romValue( businessCard);
    if( va riant.canConve rt<BusinessCa rd>()){
    BusinessCa rd  ca rd=va riant .value<BusinessCard>();
    }    ．
    由于编译器的局限性，在MSVC 6中，这些模板成员函数并不可用。，如果需要用到这个编译
器，可以用qVariantFromValue()j qVariantValue <T>()和qVariantCanConvert<D()全局函数来代替。
  如果自定义数据类型采用<<和>>操作符来完成从QDataStream的读写，就可以使用qRegis -
terMetaTypeStreamOperators<侈()来注册这些自定义数据类型。，这就可以利用QSettings在其他类型
    ’    ：
之中存储自定义数据类型的首选参数。例如：    ‘    一一  ，
    除了讨论QStriing、QByteArray和QVariant外，本章还重点论述了Qt容器类。除了这些类以外，
Qt还提供了一些其他的容嚣类。QPair<Tl，．I2>是其中之一，它与std：：pair<Tl，T2>很相似，可以
C++ GUI Qt 4编程（第二版）
简单地存储两个值。另外一个就是QBitArray，21.1节将用到它。最后，还有QVarLengthAnay <T，
PreaUoc>，它是QVector <I'>的另一低级候选方案。因为QVarLengthArray <T，Prealloc>在堆栈中预分
配内存空间且它不是隐含共享的，所以它的系统开销比QVector <T>更少，这使它更适合于紧凑的
小循环。
    Qt的所有算法，包括一些这里没有介绍到的qCopyBackward()和qEqual()等等，都在Qt的在线
文档资料中有相关的描述。要想知道更多的关于Qt容器类的信息，可以参考http：//doc．troll-
tech．com/4. 3/algortllms．html;而那些关于它们的空间复杂度和增长策略的信息，可以参考http：／／
doc.  trolltech. com/4.  3/containers. html.
第12章  输入与输出
    从文件或者其他设备读取或者写入数据几乎是每个应用程序共有的特点。Qt通过QIODevice
为输入输出提供了极佳的支持。QIODevice是一个封装能够读写字节块“设备”的强有力的提取
器。Qt包括如下的QIODevice子类：
┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃QFile           ┃在本地文件系统和嵌入式资源中存取文件  ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QTemporaryFile  ┃在本地文件系统中创建并存取临时文件    ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QBuffer         ┃从QByteArray中读取或者写入数据        ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QProc ~s        ┃运行外部程序并处理进程间通信          ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QTcpSocket      ┃利用TCP在网络上传输数据流             ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QUdpSocket      ┃在网络上发送或接收UDP数据报           ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QSslSocket -J   ┃利用SSUTLS在网络上传输加密数据流      ┃
┗━━━━━━━━┻━━━━━━━━━━━━━━━━━━━┛
，．QProcess、QTcpSocket、QUdpSocket和SslSocket都是顺序存储设备，这意味着所存储的数据从第
一个字节开始到最后一个字节为止只能被读取一次。QFile、QTempmmyFile和QBuffer则是随机存
取设备，因此可以从任意位置多次读取字节位所存储的数据。这些随机存取设备还提供了QIODe-
vice:：seek()函数以重新配置文件指针。    +
    除了设备类，Qt还捉供了两个更高级别的流类，使我们可以从任意的输入输出设备读取或写
人数据：QDataStleam用来读写二进制数据，QTextStleam用来读写文本数据。这些类考虑了诸如字
节顺序与文本编码等方面的问题，以保证运行在不同平台或者不同语言环境下的Qt应用程序可
以相互读写文件。这就使得Qt的输入输出类相较于对应的标准C++类来说，变得更加方便了，后
者通常是将字节排序与文本编码等问题留给了程序员来处理的。
    QFile使存取单个文件变得简单，不论它们是在文件系统中还是作为资源嵌入在应用程序的
可执行文件中。对于需要依靠整个文件组集一同运作的应用程序，Qt提供了QDir和QFilelnfo类，
它们分别用于处理目录地址和提供内部文件信息。
    QProcess类允许启动外部程序并通过标准输入、输出以及标准错误通道(cin、cout和cerr)与外
部程序交互。可以设置外部程序的环境变量和工作目录。在默认情况下，交互的执行过程是异步
的（不阻塞的），但是不排除在某些操作上发生阻塞的可能。
    网络与XML的读写，都是非常重要的主题，关于它们的内容将在专门的章节（第15章和第16
章）中分别介绍。
12,1  读取和写入二进制数据
    Qt申载入和保存二进制数据的最简单方式是通过实例化一个QFile打开文件，然后通过
QDataStream对象存取它。QDataStraam提供了一种与运行平台无关的存储格式，它不仅支持QUst
<D和QMap <K，D等Qt容器类，还支持整型和双精度型等基本的C++类，以及其他许多种Qt数
据类型，诸如QByteArray、QFont、Qlmage、QPixmap、QString和QVariant。
224
C++ GUI Qt 4编程（第二版）
  下面是如何在一个名为facts．dat的文件中存储一个整型数据、-_个QImage'd以及一个QMap
<QString，QColor>的代码：    一    ．
    QImage image(”philip,png“);
QMap<QString, QColor> map; '
map.insert("red", Qt::red+),;
map.insert ( "g reen",   Qt : : g reen) ;
map.insert("blue", Qt::blue);
QFile file( "facts.dat") ;
if  ( !file.open(QIODevice::WriteOnly》 {
    std::cerr<< "Cannot open file for writing: "
    <<  qP rintable ( file.erro rSt ring ( 》“  std: :endl
}
QDataStream out(&file);
out.setVersion(QDataStream::Qt_4_3) ;   . .
out<< quint32(Ox12345678)<< image<< map;
    如果不能打开文件，就通知用户并返回。qPrintable()宏将为QString运回一个const char*。
[另外一种方法是使用QString:：toStdSUing()，它返回std:：sUing，<iostream>将为其重载一个<<。]
  ‘如果成功打开文件，就创建QDataStream，同时设置它的版本号。版本号是一个整数，它会影响
Qt数据类型的表示方式（基本的C++数据类型的表示方式总是相同的）。在Qt 4.3中，最全面的
版本号是第9版(version 9)。我们可以手动输入常数9或者使用QDataStream:：Qt_4_3符号名。
    为了确保数字Ox12345678在所有平台上都是按照无符号32'位整数形式写入的，我们将它强
制转换为quint32，这是一个严格保证为32位的数据类型。为了保证互通性，QDataStream会默认将
高字节在后的顺序( big-endian)作为标准，这可以通过调用setByteOrder()来改变。，
    我们不必明确地关闭这个文件，因为当QFile变量离开它的作用域时，文件会自动关闭。如果
想检验数据是否被真正写入，可以调用flush()并检查其返回值（若返回值为true，则表示成功写入
数据）。    ‘
    读回数据的代码借鉴了用以写入数捃的代码：
    quint32．n；    ’    1
    ,QImage image;
    QMap<QStrlng: QColor> map‘;    ,    ,    :
    ’  QFile file(“facts.dat”);
    if(!file. open( QIODevice:: ReadOnly)){
    std::cerr<<”Cannot open file for reading:;”
    <<  qP rintable (file.erro rSt ring()).《std::endl;  7    、
    return：
    }
QDataStream in(&file) ;
in . setVe rsion (QData S.t ream : :Qt_4_3 ) ;
in 》 n 》 image 》 map;
    用于读取数据的QDataSUeam版本与用于写入数据的QDataStream版本一样。必须保证这一
点。通过手动编写版本号，可以确保应用程序可以正常读写数据（假设它是由Qt 4.3或者更新的
Qt版本进行编译的）。  ：：  一  -  ．一一：    ‘  r。。
    QDataStream这种存储数据的方式使我们可以完全连续地读回数据。例如，QByteArray表示一
个由它们自己字节数尾随的32位的字节计数。利用readRawByces()和writeRawBytes()iQDataStream
乜可以用来读写一些原始的二进制数据而不需要任何的字节计数首部。
    当从QDataStream读取数据时，错误处理相当容易。流有一个status()值，可以是QDataStream:：Ok、
    ，_
第12章j输入与输出225
QDataSUeam:：ReadPastEnd或者QDataStream:：ReadCorruptData。如果错误发生，则>>操作符总是读
取0值或者空值。这表示通常可以简单地读取一个文件而不用担心出错，并在最后检查status()值
以确定读取的文件数据有效。
    QDataSU:eam可以处理多种C++和q数据类型，完整的列表可以从网站http：//doc．troⅡtech．com/
4.3/datasGeamformat.html.获得。还可以通过重载<<和>>操作符为用户的自定义类型增加支持。
以下是可用于QDaLaStream的自定义数据类型的定义：
class Painting
public:  .
   Painting() { myYear = 0; J                  .:.'7
   Painting{const'QString &title, const QString &artist, int year) {
   .   myTitle = title;
      myArtist = artist;
  .    myYear = year; .                                              : '        .
     }    .
void setTitle{const QString &title) { myTitle = title;
QString title() const { return myTitle; }    .
private:
   QString myTitte;
   QString myArtist
   int myYear;
QDataStream &operator《{QDataStream
QDataStream &operator》(QDataStream
&out, const Paint'ing &painting);
&in,  Painting &paintingJ ;    .
丁面的代码说明了如何实现<<操作符：
QDataStream &operator《{QDataStream &out, const Painting &painting)
{    .
   out《 painting.titte()《 painting.artist()
《 quint32(painting.year(》;
   return out;
    为了输出PainUng，我们简单地输出两个QString和一个qLunt32。在函数的最后，返回这个流。
这是一个常见的允许以一个输出流来使用一系列<<操作符的C++习惯用法j
out《 paintingl《 painting2《 painting3
operator>>()的实现与operator<<()的宾现相似：
QDataStream &operator》(QDataStream &in, Painting &painting)
title;
artist
year;
为自定义数据类型提供流操作符有几个好处。其中之一是允许流输出使用自定义类型的容
～器类。例如：
QList<Painting> paintings = ...;
out《 paintings; .
还可以在容器类中轻松读取：
_1    如
    ’-
   rl rl lJ
LLC
       IJ . IJ  rl
  cn cn =
  L
      ra .
  cn
  rl
._ IJ
LL
ra ra .
 y N -
   (u .
A -,
AP
  rl
IJ IJ
: a~ .
IJ C
L rl
ro rJ
  C
A -l
A ro
o
r  il  .-
r< O)-r<
IJ C .
  r< C
A l- L
AC=
   r< lJ
c rD (L
r< O L
C++ GUI Qt 4编程（第二版）
    如果PainUng不支持<<或>>操作符，则将产生编译器错误。为自定义数据类型提供流操作
符的另一个好处是：可以将这些数据类型的值存储为QVariant的形式，这便于它们在更大的范围
内使用，例如通过QSetUngs。这些工作都是假设预先使用qRegisterMetaTypeStreamOperators<1’>()注
册了数据类型，如第11章（见221页）中所说明的。
    当用到QDataStream时，Qt考虑了读取和写入的每一个数据类型，包括具有任意多的项的容器
类。这使我们不必再组织排列所写入的数据，也不必再对所读入的数据进行勰析。我们唯一的任
务是确保读取各种数据类型时的顺序与写入时的严格一致，而细节上的问题就留给Qt去处理了。
    QDataStream对用户自定义应用程序文件格式和标准二进制数据格式都是有用处的。我们可
以使用流式操作符或者readRawBytes()和writeRawBytes()在基本数据类型(如quint16或float)上读
取和写入标准二进制数据格式。如果QDataStremu仅仅只用于读写基本C++数据类型，甚至都不
必调用setVersion()卤数。
    到目前为止，我们使用硬编码的流版本号QDataStream:：Qt_4_3'来载入和保存数据。这种方式
是简单可靠的，但是它也有一个小缺点：不能利用新的版本或者更新的格式j例如，，如果Qt的一
个更新版本为QFont添加了一个新的属性（即除了它的点大小、族属性等之外的属性），而硬编码的
版本号为Qt_4_3，那么将不能保存或者载入这个属性。针对这个情况，有两种解决方案。第一种
解决方案是把QDataSUeam版本号嵌入到文件中：
（其中，MagicNumber表示唯一一个标识文件类型的常数）。这种方法可以确保在任何情况下都使
用最新的QData^Stream版本来写入数据。当读取文件时，将读取流版本：
quint32 magic;
quint16 streamVersion;
QDataStream in(&file) ;     .
in 》 magic 》 streamVersion;       ,
if (magic != MagicNumber) {  .
   std::cerr<< "File is not recognized by this application'
} else if (streamVersion >'in.version(》 {
   std::cerr<< "File is from a more recent version of the "
             "application"<< std::endl;
         retu rn  false ;
}
县要流版本小于或等于应用程序所使用的版本，就可以读取数据；否则报告一个错误。’j
    如果文件格式包含一个它自己的版本号，则可以利用它来推断出流版本号而不是明确地存储
它。例如，假设文件格式是针对应用程序的1.3版本，然后可以如下编写代码：
    QDataStream out(&file);
    out'. setVe rsion( QDataSt ream::Qt_4_3):
    out<<quint32(MagicNumber)<<quint16(Ox0103);
当回读数据时，可根据应用程序的版本号来决定所使用的QDataStream版本：
    QDataStream in(&file);
    in>>magic>>appVersion;
第d2章输入与输出
 else if (appVersion > Ox0103) {
   std::cerr<< "File is from a more recent version of the "
    << "application"<< std::endl;
   return false;
if (appVersion < Ox0103) {
in.setVersion(QDataStream:
} else {
in.setVersion(QDataStream:
}
    在这个实例中，我们规定由这个应用程序1.3版本之前的版本所保存的任何文件都使用数据
流版本4(Qt_3_0)，而由这个应用程序的1.3版本保存的文件使用数据流版本9(Qt_4_3)。
    总之，一共有三种处理QDataStream版本的策略：硬编码的版本号、明确地写入并读取版本号
以及根据应用程序版本号使用不同的硬编码版本号。这些策略都可以用来确保由应用程序的较
老版本写入的数据可以被新版本成功读取，即使这个新版本的应用程序与更新的Qt版本关联。
一旦选择了一种处理QDataStream版本的策略，使用Qt读取和写入二进制数据时就变得简单且
    一    j
可靠。
    如果想一次读取或者写入一个文件，可以完全不用QDataSUeam面使用QIODevice的write()和
    ．    ‘
readAll()函数。例如：    。，，∥    ．
bool copyFile(const QString &source; const QString &dest)
              ,                      ;
      QFile sourceFile(source) ;   '
          if   ( ! sou rceFile. o'pen ( QIODevice: : ReadOnly) J .                 .
   , return false;   '
   QFile destFile(destj;
        if  ( ! destFile;.open (QIODevice: :WriteOnly》
      return false;
    retu rn  sou rceFile.error()==QFile::NoError
    ＆＆destFile.error()==QFile::NoError;    ’    ，
    ’    ¨  ‘    ．
  ：在调用readAll()的那一行中，输入文件的所有内容都被读人到一个QByteArray中，然后将它传
给write()函数以写到输出文件中。虽然获得QByteArray中的所有数据比逐项读取数据需要更多
的内存，但是它也带来了一些方便。例如，在这之后可以使用qCompress()和qUncompress()函数来
压缩和解压数捃。与qCompress()和qUncompress()功能相当的另外一个不占内存的方法是使用Qt
解决方案中的QtIOCompressor。QtIOCompressor．压缩它写入的数据流，解压它要读人的数据流，而并
不将整个文件存储在内存中。    ‘    I    、
    其实还有比使用'QDataStream更加合适的直接读取QIODevice的方案。除了一个字节都不能
读( unread)的ungetChar()函数，QIODevice还提供了peek()函数，它能在不移动设备位置时返回下一
个数据字节。这不仅对随机存取设备（诸如文件）有效，同时也对顺序存储设备（诸如网络套接）有
效。另外，还有一个seek()函数用来设置设备的位置，它主要用以支持随机存取的设备。
    二进制文件格式提供了数据存储最通用最紧凑的方式；而且QDataStream也使得存取二进制
数捌}常容易。除了本节中的例子，我们已经在第4章看到使用QDataStream来读写电子数据表格
文件，而且第21章将再次看到QDataStleam在这方面的应用，那里将使用QDataStrealn读写Windows
、指针文件。
.-
o
    31  4l
       -l
     .  IJ     {J
 oo
C++.GUI Qt 4编程（第二版）
12.2读取和写入文本
    虽然二进制文件格式比通常基于文本的格式更加紧凑，但是它们是机器语言，无法人工阅读
或者编辑。在二进制文件格式无法适用的场合，可以使用文本格式来代替。Qt提供了QTextStream
类读写纯文本文件以及如HTML、XML和源代码等其他文本格式的文件。第16章将单独讨论如何
处理XML文件。
    QTextStream考虑了Unicode编码与系统的本地编码或其他任意编码之间的转换问题，并且明
确地处理了因使用不同操作系统而导致不同的行尾符之间的转换（在Windows操作系统上行尾符
是“＼r＼n”，UNIX和Mac OS X操作系统上是“＼n”）。QTextStream使用16位QChar类型基本数据单
元。除了字符和字符串之外，QTextStream还支持C++基本数字类型，它可以进行基本数字类型和
字符串之间的转换。例如，下面的代码将“Thomas M. Disch:334＼n”写到文件sf二book. txt中：
    ：    ．
    QFile file(“sf-book.txt”);    ,.    、    ．
    if(!file:open corODevice::W riteOnly)):{
    std::cerr<<"Cannot open file for writing:“  ，
    <<  qPrintable (file.errorSt ring())“std::endl;
    return；  ．
    )    ．  。_    ．
    QTextSt^ream out (&file);  .    ,    .
    out<<¨Tho.mas H.Disch:..<<334<<endl;
    r    ^
    写入文本数据非常容易，但读取文本却是一个挑战。因为文本数据（与使用QDataStream写入
的二进制数据不同）从根本上说就是含糊而不确定的。让我们来看看下面的例子：
out《 "Denmark"《 "Norway
    如果out为QTextStream，则实际上被写入的数据是字符串“DenmarkNorway”。我们真的不能期
望下面的代码能够正确地读回数据：
    实际上，str1获得了整个词“DenmarkNorway”，而str2什么也没有得到。使用QDataStream则不
会发生这个问题，因为它在字符串数据前面保存了每个字符串的长度。
    对于复杂的文件格式，成熟的解析器也许是必需的。解析器通常通过在QChar、上使用>>来
-一个字符一个字符地读取数据，或者通过使用QTextStream:：readLine()宋逐行读取数据。在本节的
最后，将给出两个简单的例子，其中一个是逐行地读取输入文件，另_个则是一个字符一个字符地
读取。对于一个处理全部文本的解析器，如果不考虑内存的使用大小或者已经知道所读文件很小
的话，可以使用Q TextStream:：readAll() -次读取整个文件。
    在默认情况下，QTextStream使用系统的本地编码(例如，在美国以及欧洲的大部分地区都可使
用IS0.8859-1或IS0 8859-15)进行读取与写入。当然这可以通过使用如下的setCodec()而改变：
    本例中使用的UTF-8编码是●种与ASCⅡ兼容的编码方式，它代表整个Unicode字符集。关于
Unicode以及QTextStrea支持的更多编码信息，请参见第，18章。。
    QTeodStream有各种各样的模仿</ostream>的选项。这些选项可以通过传递专门的对象，也称
为流操作器，在流上设置以改变它的状态，或者是通过调用列在图12.1中的函数。下面的例子是
在整型数12 345 678输出前设‘置了showbase、uppercasedigits以及hex选项，生成的输出文本为
“OxBC614E”：
第12章输入与输出
out《 showbase《 uppercasedigits《 hex《 12345678
也可以通过成员函数来设置这些选项：
out .setNumberFlags ( QTextSt ream: :ShowBase
                                                        I   QTextSt ream : : Uppe rcaseDigit s):
out.setIntegerBase(16) ;
out《 12345678;
┏━━━━━━━━━━━━━━━━━━━┓
┃                                      ┃
┣━━┳━━━━━━━━━━━━━━━━┫
┃O   ┃基于前缀自动检测（读取数据时）  ┃
┣━━╋━━━━━━━━━━━━━━━━┫
┃2   ┃二进制                          ┃
┣━━╋━━━━━━━━━━━━━━━━┫
┃8   ┃八进制                          ┃
┣━━╋━━━━━━━━━━━━━━━━┫
┃10  ┃十进制，                        ┃
┣━━╋━━━━━━━━━━━━━━━━┫
┃16  ┃十六进制                        ┃
┗━━┻━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                              ┃
┣━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ShowBase        ┃如果基数是2(“Ob”)、8(“0”)或者16(“Ox”)，则显示前缀，． ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ForceSiEp       ┃在实数中总是显示符号    ~                                   ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ ForcePoin t    ┃在数字中总是显示十进制分隔符                                ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃UppercaseBase   ┃使用基数前缀的大写版本(“OB”、“ox”)                      ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃UppercaseDigits ┃在十六进制数中使用大写字母                                  ┃
┗━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                                          ┃
┣━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃FixedNotation Fixa! r     ' ┃定点表示法（例如，“0. 000123”）    一  ：                 ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃Sciert/ficNotation  .       ┃科学计数表示法（例如；“1.234568e - 04”）、．1             ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃SmartNotat;on       .       ┃定点或者科学计数表示法，自动选用最紧凑的表示法  一    二。  ┃
┗━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃鬻麟灏黧缀隧獭戮獭鬻缀糕缀缫黧懑鬻瓣懑鬻滋蘩鬻瓣麟麟              ┃
┣━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┫
┃AliWLeft                ┃填充字段的右边                          ┃
┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃从印斑曲t               ┃填充字段的左边                          ┃
┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃AliEpCenter             ┃填充字段的两边                          ┃
┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃All~17iAccountinf~tyle  ┃在符号和数字之间填充                    ┃
┣━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃ setPadChar( QChar)     ┃设置用于填充字段的字符（默认为空格符）  ┃
┗━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━┛
    图12.1设置QTextStream选项的函数
    与QDataStream相似，QTextStream也是在QIODevice子类上运作的，它可以是QFile、QTemporEuy-
File、QBuffer、QPtocess、QTcpSocket或者QUdpSocket。此外，它还可以直接在QStnng上使用。例如：
    、    '
OSt ring  st r;
QTextStream(&str)<< oct《 31<< " l,<< dec《 25℃< endl
・  这就使str中的内容为“37 25＼n”，因为十进制数的31表示八迸制中的37。这种情况下，就不
必再为流设置编码，因为QString总是Unicode编码。
C++ GUI'Qt 4编程（第二版）
    让我们看一个简单的基于文本文件格式的例子。在本书第一部分中所介绍的Spreadsheet应
用程序中，使用了二进制数格式存储电子数据表格的数据。这种数据类由一个三元序列（行、列、
公式）组成，每一非空单元都有同样的数据类型。以文本格式写入数据是显而易见的，下面是如何
从一个修改的Spreadsheet:：writeFile()版本中提取数据的例子：
void tidyFile(QIODevice *inDevice, QIODevice *outDevice)
{        .
  .QTextStream in(inDevice);             .     ;
        QTextStream  out (outDevice) ;                     : . .  .
   const int TabSize = 8;  .              .    .
   int endlCount = 0;
   int spaceCount = 0;    '
   int column = 0;   .
   QChar ch;   '
   while (lin.atEnd(》 {
       in 》 ch;
oOnt,  '
unt = 0;
= 0;
e = TabSize -
unt += size;
+= size;
    晤    “怖  黠的o
    黼慨    衄肌    何山  ～撕
    救    8馓  涵任吼
    ，  一一’、_    行n
    -E
    闰
    专
    ．    丰
    八
    JJ
    一一一    ～一  一一～  ㈣腿
    R    撙一
    …
    别
    k    JJ
  州  一    涵期
  。  一    一一f    _  ～一一．～一～
  U    ^
  儿  蛀    lI    眨影
  。    ．腓一一一。～一-一一‘
  +  ．    ～橙
  +  “  酷    ；    为脂
  ；  i    个书    ．  ，  舢一
    t    ．，+L．
    。  i    ．  ．。蚴附潞
    。；    ¨n吖
    ・8们“    扣摧    吐印儿    据阜    一一一一一・一
    ，。吧    缸_。    数绽嗾蹴
    w““  一    ”L    t C s
    m¨儿  一    一    ．卜n u    勺玉
    ¨‘3 c  一    ～．V    j n  (r e
    ，，．T    舶“
  ；V W    ；l  S F f
  t  o  一l    ，。r e    刻㈣
  n n r  “    每舍    c s．T x，
  U m C    e．  F a n
  0 U a  i
  怔吼儿，i    斗
  胁6 m¨。    枷
  .--v咄娟呐～    一
  lUⅣ咖cn．s^II rJ N一
  ．。．，！！．  一一～‰～一e t m  搪一一瓶
    k．U
    l a S 1
    。．。。  毂照俪必一一一一一
    -1L C
    麓哆，纂
    ・l=m 1L
t  o gt l    n n t．w¨叫
U=C n S    E．1 S S 0 0 r
 0    .1 1
。叫吐”‘    7
a r'l Sf    、1.1.1f
。．。．    。肌链哪眦叭呲川¨n饷．
    ．U茅g。姆一
r E    -．r r(
t“，    市
S．1 0
t(f
x    ，、  h
；    翥～
T。    ，弼～一川眦瞅Ⅱ  ．，  卜一一一一一一一一一
。，    眦    ，粼嘴9；暇黜一～一一
    馘    啦Ⅵ  挣错一
。置2置一：8。8芋z-肇露铡8禹掣|：≈W碳……筠搏勰燃僦㈣燃㈣黝遴
    第12章输入与输出    231
if (ch ==
paceCount;
olumn; i
le (endlCo
,out《 en
--endlCou
 colurrin =
    )
    \ut<<endl;
    )    ’
    我们基于传递给函数的QIODevice来创建一个输入和输出rextStream。除了当前的字符外，
还支持三个状态跟踪变量：一个计算新行数（换行数），一个计算空格数，一个标记当前所在行的当
    1I
前列位置（用于将制表符转换为恰当数目的空格数）。
    通过在while循环中对输入文件的每个字符进行迭代来完成整个解析过程。在某些地方的代
码非常巧妙。例如，尽管将TabSize设置成了8，但只是用正好足够的空格数来代替到下一制表符
边界的制表符，而不是粗略地用8个空格来代替每一个制表符。如果获得一个换行符、一个制表
符或者一个空格，仅仅只更新或修正状态数据。只有在获得另一种字符时才输出，并且在写出这
种字符前，我们先写出未决的换行符和空格（以考虑空行和保留缩进）并更新状态数据。
    ’  inFile.open (stdin,  QFile::ReadOnly);
    out File.o pen( stdout,  QF ile::W rit eOnly);
    tidyFile(&inFile, &outFile);
    return 0；
    )
    ，  j一。，．    ’
    这个例子不需要使用QApplication对象，因为我们只是使用Qt的工具类。有关这挚类的列表，
请查看http：//doc．troUtech．com/4. 3/tools．h缸nl。我们已经假设这个程序是被用作过滤器的：例如：
    tidy<cool.cpp>cooler.cpp
    如果给出了文件名，这个程序可以很容易地扩展用来处理命每行上的文件名，另外还可以过
滤an到cout。
    因为这是一个控制台应用程序，它的．pro文件与我们所见过的用于图形用户界面应用程序的
略微有些不同。
TEMPLATE
CONrIG
CONF'IG
SOURCES
 = app
. = core
+= console
-= app_bundle
 = tidy.cpp
       .,
o
A
 IJ .- .-
C r IJ .-
= -o c o
r   'r
r--        r--
 --
  0 .
  A
        IJ         . N
  C   IJ
  = .- C
 o- =
   CI, v u =
  o-V rD O  fc
 ..cn  cr8   E
-叫T/ Yo
)W           r-- O t
          r--
C++ GUI Qt 4编程（，第二版）
    我们只关联QtCore，因为没有使用任何的图形用户界面功能。然后指定我们想在Windows系
统下实现控制台输出，并且不希望在Mac OS X系统下同时存在许多应用程序。    ，
    对于读取和写入纯ASCII文件或者IS0 8859-1 (Latin-l)文件，可以直接使用QIODevice的应用
编程接口来代替使用QTextSUeam。但这样做并不很明智，因为大多数应用程序都会在某处需要对
其他编码的支持，而只有QTextSUeam对这些编码提供了完全连续的无缝支持。如果仍然想将文本
直接写入QIODevice，那么必须为open(，)函数明确地指定QIODevice．：Text标记，例如：
    file.open( QIODevice::WriteOnly.1  .QIODevice::Text);    ’’i.i.
    j'I，    ’
    当写入的时候，这个标记将通知QIODevice将“＼n”字符转换为WindoWs下的“＼r＼n”序列。当读
取的时候，这个标记将告知设备忽略所有平台环境中的“＼n”字符。然后我们就可以假设：不管操
作系统采用哪种行尾符转换，每一行结束都将使用-个“\n”换行符表示。
12.3遗历目录
一．    ．    -    、    r    ，
  ．QDir类提供了『_种与平台无关的遍历目录并获得有关文件信息的方法。为了看看QDir是如
何使用的i我们将编写．个小的控制台应用程序，它会计算一个特定目录以及这个目录下任意深
度的子目录中所有图片所占用的空间。
    应用程序的核心是imageSpace()函数，它递归计算出给定目录中所有图片累加的大小总和：
qlonglong iatageSpace(const QString &path)
   QDir dir(path);    . '
 . .-qlonglon.g'.size = O; .:    .     .  '
  .';QSt;ringList filters,' rmat, QImageReader::supported
              fo reac h;.  ( QByteA r ra/y /ofromi                                                                   tedImageFo rmat s .(.》
,;'. ,  '-fitters *=       format; . ! .
   foreach (QString file, dir.entryList(filters;'QDir::Files》 .
   foreach (QString subDir, dir.entryList(QDir::Dirs  .    '.
                                                                    I QDir::NoDotAndDotDot》         .
        size += imaaeSpace{path + QDir::separator() + subDir);.
    return size;    7    、    ．
    }
    ’    ：    ’，
  ：我们从使用给定的路径创建_个QDir对象开始，这个给定路径可能与当前；目录或者绝对地
址有关系：我们传递给、entrLi。t()函数两个参数。第一个参数是文件名过滤器的一个列表，它们
可以包含“*”和“？”这类的通配符。在这个实例中，将只选出含有QImage可以读取的文件格式。
第二个参数指定所要的条目类型（普通文件、目录、驱动器等）。
    我们遍历这个文件列表，把它们的大小累加起来。QFilelnfo类可以访问文件的属性，如文件的
大小、权限、属主和时间戳，等等。
．+第二个entrList()调用获得这个目录下所有子目录。j我们遍历它们（不包括．和．一）并且递
归调用imageSpace()以累计图片文件的大小。  ’7    ．
    为了创建每二个子‘目录的路径，我们把当前目录的路径和子目录名称组合起来，然后用斜线
把它们分隔开。除了在WindowS操作系统上认可“＼”之外，QDir在所有平台上都把“＼”认作是目录
分隔符。在把路径呈现给用户的时候，可以调用QDir:：convertSeparators()．这个静态函数把斜线转
换为针对具体平台的正确的分隔符。    ，    L    ‘
    下面把rIlain()函数添加到小程序审I。    -．。
萄调11111.11 g翻到澍溺■翻习劐鞠翻鞠潮翻翊蓊溺鞫溺溺翻渊
    i  、  』i≥_ts≤^¨萼t莲￡毒鼍潮鳓煳捌绷潮剽稠溯溯捌劂渤渊翱翔矧捌嬲期渊渊渤铡渊测溯渊矧蝴删溯黝删渊渊喇删嬲僦罐
第12章输入与输出
int main(int argc, char *argv[J)                    t   .
{
   QCoreApplication apP(argc, argv); '   :. .
   QStringList args:= QCoreApplication::arguments();   ,
  . QString'path = QDjr::currentPath(); .
  ' if (args.count(》 1)
   std::cout<< "Space used by images in ".<< qPrintab卫e(path)
    << " and its subdirectories is il
         .    <<. (imageSpace(path) / 1024)《 'II KB"<< std::endl;
    我们使用QDir：：currentPath()将路径初始化为当前目录：、作为备用选择，也可以使用QDir:：
homePath()将它初始化为用户的主目录。如果用户在命令行中指定了一个路径，就使用它来替代
前面的目录。最后，调用imageSpace()函数来计算所有图片总共占用了多少空间。i j．，    ’
  'QDir类提供了其他一些与文件和目录相关的函数，如entryInfoList()（它将返回QFilelnfo财象
的列表）、rename()、exists()、mkdir()和nndir()。QFile类提供了一些方便的静态函数i包括remove()
和exi。ts()。同时；QFileSy。teinWatche。可以通过发送directoryChanged(~)和'fileChanged()信号：，在目录
或者文件发生任何改变时通知我们。    1。    j  i．，…．-’¨t  一：
    ．    ．    7    +{i“．  j j、★':!
12.4  嵌入资源    √  一j羔一√’．？-一
    7__．  ’；。
    到目前为止，本章已经讨论了如何在外部设备中存取数据，然而利用Qt还可以在应用程序的
可执行文件中嵌入二进制数据或者文本。这可以通过使用Qt资冁系统来誊銎善亨其他的章节
中，将使用资源文件将图片嵌入到可执行文件中，当然也可以嵌入其他种类白    与文件系统
中的普通文件一样，嵌入的文件也可以通过QFile读取。．    ．．
    通过Qt资源编译器rcc，可以将资源转换为C++代码。还可以通过把下面一行代码加到．pro
文件中来告诉q．nak。包括专门的规则以运行rcc：  j    t’一  ~：    ．  ’一
    RESOURCES=myresourcefile.qrc    .
myresourcefile．crc丈件是一个XML文件，它列出了所有嵌入到可执行文件中的文件、o…’
    假设我们正在编写一个保持联系细节信息的应用程序。考虑到用户使用的方便。眭，我们想在
最后的可执行文件中嵌入国际拨号代码。如果文件在应用程序所建目录的datafiles'目录下，那么
    、、,    ,    ..,    .    1    , -,7.’:.1    ’-    -
资源文件将会如下所示：    ．
<RCC>
  <file>datafiles/phone-codes,dat</file> .      .. '-' .    .   . :
</q resource>
                                                                                                                                                        -       ' ..
    在应用程序中，资源是通过：，路径前缀识别的。．在这个例子中，拨号代码文件的路径为：/data-
files/phone-codes.dat，它可以像其他任何文件一样通过QFile读取J：一、．~，  ．i  。
    在可执行文件中的嵌入数据具有不易丢失的优点，而且也有利于创建真正独立的可执行文件
（如果也采用了静态链接的话）。它的两个缺点是：第一，如果需要改变嵌入数据，则整个可执行文
件都要跟着替换；第二，由于必须容纳被嵌入的数据，可执行文件本身将变得比较大。  、
    Q资源系统所具备并提供的特征远不止本例中所介绍的这些：；它还包括对文件名别名的支持
和本地化的支持。在http: //doc。trolltech. com/4.3/resources．htnil网站上有关于这些特性的文档。
234    C++ GUI Qt 4编程（第二版）
12.5进程间通信
    QProcess类允许我们执行外部程序并且和它们进行交互。这个类是异步工作的，且它在后台
完成它的工作，这样用户界面就可以始终保持响应。当外部进程得到数据或者已经完成时，QPro-
cess会发出信号通知我们。
    我们将查看一个小应用程序的代码，它为一个外部图片转换程序提供用户界面。对于这个实
例，我们使用ImageMagick中的convert程序，它对于所有主要平台都可以免费得到。用户界面如
图12.2所示。
图12.2图片转换器应用程序
    用户界面是在Qt设计师中创建的。：ui文件就在本书的网站上中。这里，我们将主要查看由
1UC生成的Ui:：ConvertDialog类派生的子类。开始的头文件如下：
#ifndef CONVERTDIALOG_H
#define CONVERTDIALOG_H
#include <QDialog>
#include <QProcess> '     .
群include "ui_convertdialog.h"
class ConvertDialog : public QDialog, private Ui::ConvertDialog
{         .
Q_OBJECT
public:
           Conve rtDialog ( QWidget . *pa rent  =  0)
private slots:
   void on_browseButton_clicked();
   void convertlmage();
        void  updateOutputTextEdit () ;
 . void processFinished(int exitCode, QProcess::ExitStatus exitStatus)
           void  processErro r ( QP rocess: :ProcessError  erro r) ;
private:
   QProcess process;
   QString targetFile
Jr
#endif
遘谢建蘸籀绷㈣溷
第12章输入与输出235
    头文件后面是Qt设计师窗体常见的子类模式。与我们见过的其他例子有些不同的是，这里
已经私有继承了Ui：：ConveItDialog类。这就防止了从外部窗体函数读取窗体控件。由于Qt设计
师的自动关联机制，on_browseButton_clicked()和on_convertButton_clicked()槽会被自动连接到Browse
按钮的clicked()信号。
    ，。？
ConvertDialog ; :Conve rtDialog ( QWidget  *pa rent)
   : QDialog{parent)  '
setupUi(this) ;
QPushButton *convertButton =
               buttonBox->button (QDialogButtonBox: :OkJ
convertButton-> s etText ( t r( "&Convert " } ) ;
convertButton-> s et Enabled ( false) ;
connect (conve rtButton,  SIGNAL ( clicked ( 》 ,
C
C
C
ect
ect
ect
ect
this, SLOT(
buttonBox,
&p roces.s ,  S
this r  SLOT(
&process, S
this ,   SLOT (
&process,
this, SLOT(
nvertlmage( 》 ) ;
GNAL( rej ected ( 》 ,  this ,  SLOT( rej ect ( 》 ) ;
NAL ( readyReadStandardError( )') ,               '   .
dateOutputTextEdit ( 》 ) ;
NAL ( finished (int,  QProcess: :ExitStatus 》 ,
ocessFinished (int,  QProcess: :ExitStatus》 ) ;
NAL (erro r (QProcess: :ProcessError》 ,          :
ocessError(QProcess::ProcessError》 ) ;  '
    )
    setupUi()凋用不仅创建并布置所有的窗体部件，还为on_objectName_signalName()槽建立了信
号一槽的连接。我们得到一个指向按钮框的OK按钮的指针，并给它赋上一个更合适的文本值。我
们还使它失效，因为起初并没有需要转换的图像。同时，我们将它与covertlmage()槽相连。然后将
按钮框的rejected()信号（通过Close按钮发送）与对话框的reject()槽相连接之盾，手动将QProcess
对象的三种信号与三种私有槽进行连接。只要外部进程在其cerr中有数据，就将在updateOutput-
TextEdit()中对其进行处理。
void
{
Conve rtDialog : : on_b rowseButton_clic ked ( )
QStrina  initialName = sourceFileEdit->text ( ) ;          .
if (initialName.isEmpty( 》
        initialName  =  QDir: :homePath ( ) ;
QString fileName =
                 QFileDialog: :getOpenFileName ( this ,  t r ( "Choose  File" ) ,
                         . initialName);
fileName  =  QDir: :toNativeSepa rato rs ( fileName) ;                           .
if  ( ! fileName.isEmpty( 》  {
          sou rceFileEdit->setText ( fileName ) ;
         buttonBox->button (QDialogButtonBox: :Ok) ->setEnabled ( t rue )
}    ,
    通过setupUi()，Browse按钮的clicked()信号被自动违接到on__browseButton_clicked()槽。如果用
户之前已经选择了一个文件，就用这个文件名来初始化对话框；否则，使用用户的主目录。
void
{
ConvertDialog::convertlmage()
QString sourceFile = sourceFileEdit->text( ) ;
targetFile  =  QFilelnfo ( sourceFile) .path ( )  +'QDir: :sepa rator( )
              + QFileInfo(sourceFile).baseName() + " 'l  '
                                +  to rgetFo rmatComboBox->cu rrentText ( ) .to Lowe r ( ) ;
buttonBox->button ( QDialogButtonBox: :Ok) ->setEnabled ( false) ;
outputTextEdit->clear() ;
QStringList  a rgs ;
 if  ( enhanceCheckBox->isChecked ( 》
O H G O (D L (D L
U UIH = H OH O-
  236    C++。GUL Qt 4编程（第二版）
   args《 "-enhance";
if  ( monochromeCheckBox->isChecked ( 》
   args《 "-monochrome'/;
args<< sourceFile<< targetFile;
process . start ( "conve rt " ,   a rgs) ;
    当用户单击Convert按钮时，就复制源文件的名称并且根据目标文件格式改变它的扩展名。
因为文件名对用户来说是可见的，所以使用针对特定平台的目录分隔符(“／”或“＼”，如QDi．：：。epa-
rator() -样可用）代替手写的斜线。
    然后，使Convert按钮失效，以避免用户意外启动多重转换，接着清空用于显示状态信息的文
本编辑器。
    为了启动外部进程，我们利用想运行的程序名称( convert)以及它所需的参数来调用QProce。S．，：
start()。在这种情况下，如果用户勾选了正确的选项，就传递出由源文件名和目标文件名尾随的
-enhance和-monochrome标记。convert程序从文件扩展名来推断所要求的转换。
  . void'ConvertDialog:;updateOutputTextEdit()’.    +
    {    f  -    ．    ．
    QByteAr ray  newData= 'p.rocess. readAllStanda rdEr ror(‘】;    :
  -QS蔓rm.gitext.outputTextEdit->toPlainText.()  ..  .
    ¨  ‘    +  OSt ring::f romLoca18Bit (newData):    :
．  ，。‘outpu fl-e)tt Erlit->setPl.ainText( text)；：
    }  ‘
  ，只要外部进程cerr写奎i就会调用updateOutputTextEdit()槽。我们读取错误文本并且把它添
加到QTextEdit的现有文本中：    …7
    ‘    ~    ‘    +-    ^
:processFinished(int exitCode,
                      .                 QP rocess : : Exitstatus  exitStatus )
-= QProcess::CrashExit.)'{
     outputTextEtiit->append ( t r( "Conve rsion  p rog ram  c rashed " 》 ;
else if (exitCode.,!-. 0). {
- ' outputTextEdit->append (tr( "Conversion 'failed" 》 ;   .
else {                      .   -    .  '
     .  outputTextEdit->append ( t r( "File
buttonBox->button(QDialogButtonBox: :
961 created").arg(targetFile》
Ok)->setEnabled(true) ;  .
刍进程已经完成时，会将结果通知用户然后激活Convert按钮：
   void  Conve rtDialog:              ssErro r(QP rocess : : P rocessError  erro r)
 l  .  og::processE
,' ,  if (error == QProcess::FailedToStart) i .
                 outputTextEdit->append (tr( "Conversion  program  not  found" 》 ;
,  '        .        buttonBox->button.( QDialogButt_onBox :':Ok) ->setEnabled ( t rue ) ;
       }
                                                                             ...
    如果进程不能开启，QProcess就会发出error()而不是fnished()。我们将报告所有的错误并激
活Click按钮。
    这个例子异步地执行了文件的转换，也就是说，我们告知QPtocess去运行convert程序并立即
将控制权返回给应用程序。詈进程在后台运行时，这可以让用户界面始终保持响应。但在某些情
况下，在自己的应用程序进一步执行前，必须先完成外部进程。这时需要同步操作QP roce。。。
    利用用户首选的文本编辑器，支持纯文本编辑的应用程序，是一个需要用到同步状态的常见
的例子。采用QPtocess就可以直接实现。例如，假设在QTextEdit中有纯文本，并且提供用户可以
点击的连接到edit()槽的Edit按钮。
o    :=
r      .    t
ra     . ra
o   . cn
IJ       IJ
L    'r
C-
o  .
u    '，
           ./ .+
-o   . //
.+   .
o   ,
／    ~j ti!毫”骶餐-赣赣落∞粼Ⅷ搿
第12章  输入与输出
237
void ExternalEditor::edit()
{
   QTemporaryFile outFile;
       if  ( !outFile:open ( 》
      QString fileName = outFile,fileName( ) ;     .
      QTextStream out(&outFile) ;
      out<< textEdit->toPlainText( ) ;
      outFile.close() ;     .
   QProcess::execute(editor, QStr/ngList-()<< options<< fileName)
   QFile inFile(fileName);. .                    ' ' .
  if (!inFile.open(QIODev/ce::ReadOnly》  .          ,
 return;
    我们使用QTempoimyFile创建一个具有唯二文件名的空文件。不给QTempomIyFile一：：open()指定
任何参数，因为它在读／写模式下默认是打开的。我们给临时文件写入编辑文本的内容：，然后关闭
文件，因为一些文本编辑器不能在已打开的文件中运行。  ．    一  o
    QProcess：：execute()静态函数运行外部进程并当该外部进程完成时停止。editor;.参教是具有编
辑器可执行文件名的QString（例如，“gvim”）。options参数则为一个QStringList（如果正使用gvim，则
包含一项，“一f”）。
    在用户关闭文本编辑器后，进程结束且。xecute()函数的调用也将返回o：凑茸÷打开临时文件
并将临时文件的内容读到QTextEdit中。当对象超出作用范围时，QTempomIyFile将自动删除临时
    一i    ，    一！
文件。    ．    ，
    当QProcess同步使用时，并不需要信号一槽之间的连接。如果需要比execute()静态函数所提
供的更好的控制，可以使用另一种方式。这就涉及到要创建QIJ．roce。。对象并莳它调南。tart()，然后
    ．．    ．    r
通过调用QPtocess：：waitForStarted()强制使它停止。如果成功，再调用，QProcess．:：waitFjorFinished()。
可以查阅QProcess的参考文档，看看使用这种方法的例子。
    ．，
    在本节中，使用了QProcess让我们有权使用先前已经存在的功能。使用已有的应用程序可以
节省开发时间，同时也使我们逸离了那些与主应用程序‘目的不太相关的细节问题。j使用先前已经
存在的功能的另一种穷法是连接到一个提供这些功能的数据库。但若没有_个合适的数据序时，
    ．，    ，  ．'’    ‘
采用QPtocess包装一个控制台应用程序也是很有用的。
    QProces。的另一个用处是：还可以启动其他的用户图形界面应用程序：然而，如栗目标是建立
应用程序之间的关联，而不是简单地从一个应用程序中调用运a另一个，贝f最好采f 'ot的网络类
或其在Windows下的ActiveQt扩展程序，让应用程序之间能够更好地实现直接通信。而如果想启动
用户喜欢的网页浏览器或者电子邮件客户端程序，仅仅只需要调用QDesktopServices:.:openUrl()。
第13章  数据  库
    QtSql模块提供了与平台以及数据库种类无关的访问SQL数据库的接口。这个接口由利用Qt
的模型／视图结构将数据库与用户界面集成的一套类来支持。本章内容是以假设读者已经熟悉掌
握了第10章所讲到的Qt中的模型／视图类为前提的。
    QSqlDatabase对象表征了数据库的关联。Qt使用驱动程序与各种数据库的应用编程接口进行
通信。Qt的桌面版(Desktop Edit/on)包括如下一些驱动程序：
┏━━━━┳━━━━━━━━━━━━━━━━━━┓
┃瀵黼糍  ┃                                    ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QDB2    ┃ IBM DB2 7.1版以及更新的版本        ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QIBASE  ┃BorLand InterBase                   ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃ QMYSQL ┃ MySQL                              ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃ QOa    ┃甲骨文公司(Oracle Call Interface)   ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QODBC   ┃ ODBC(包括微软公司的SQL服务器)      ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QPSQL   ┃ Post~TeSQL的7.3版以及更高级的版本  ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QSQLrnC ┃ SQLite第3版                        ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QSQLrn0 ┃SQLite第2版                         ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━┫
┃QTDS    ┃Sybase自适应服务器                  ┃
┗━━━━┻━━━━━━━━━━━━━━━━━━┛
    由于授权许可的限制，Qt的开源版本无法提供所有的驱动程序。当配置Qt时，既可以选择Qt
本身就包含的SQL驱动程序，也可以以插件的形式建立驱动程序。公共领域中不断发展的SQLite
数据库将向Qt提供支持①。
    对于那些习惯了SQL话法的用户，QSqIQuery类提供了一种直接执行任意的SQL语句并处理
其结果的方式。对于那些喜欢更高级、更友好的数据库界面以避免SQL语法的用户，QSqlTable-
Model和QSq]Relat/onalTableModel提供了合适的抽象。这些类以与Qt其他模型类（见第10章）相同
的方式来表示一个SQL表。它们可以被单独用来遍历和编辑程序代码中的数据，也可以添加最终
用户能够查看并修改数据的视图。
    Qt使对常见数据库特性的编程变得简单易懂，例如对主从数据库（master-detail）和下钻型
( drill-down)数据库的编程；另外，Qt也让利用窗体或图形用户界面中的表查看数据库表的过程变
得简单易行，例如本章中将要演示的几个实例。
13.1  连接和查询
    为了执行SQL查询，首先必须建立与数据库的连接。通常情况下，是在应用程序开始时所调
用的一个单独的函数中建立数据库连接。例如：
    . bool createConnection()
    {
    QSqlDatabase db=QSqlDatabase::addDatabase(¨QMYsoL");
①在构建q时，必须启动SQL的支持。例如，通过在conf.gure踯本中传递-qt-sql-sqlite命令行选项，或者在Qt安装器中
    设置适当的选项，可以构建出对SQLite提供内置支持的q。
第13章数据库
r( "Database
    return false：
    )
    return true：
    '
√  首先，调用QSqlDatabase：：addDatabase()来创建QSqlDatabase对象。addDatabase()的第一个参数
指定了Qt必须使用哪一个数据库驱动程序来访问这个数据库，这里使用的是MySQL。
‘  接下来，设置数据库的主机名、数据库名、用户名和密码，并且打开这个连接。如果open()操
作失败，将显示出错信息。
    通常情况下，是在main()中调用createConnection()的：
    int main(int argc, char *argv【】)
    {
    { QApplication app(argcy  argv);
    if(!createConnection())
    return 1：
  ．    return app.exec();
    )
    一旦连接建立，就可以使用QSqlQuery执行底层数据库支持的任何SQL语句了。例如，以下是
如何执行SELECT语句的代码：
    QSqlQuery query;
    query.exec("SELECT. title, year FROM cd WHERE year>=1998");    .1
    在exec()调用之后，可纵遍历查询的结果集：
    只要调用next()．一次，就可以把这个QSqlQuery定位到结果集中的第一条记录。随后的next()
调用，每次都会把记录指针前移一条记录，直到到达结尾时next()才返回false。如果结果集为空
（或查询失败），那么next()的第一次调用将返回~alse。
    value()函数把字段值作为QVaIi舭t返回。字段是按照SFF,CT语句中给定的顺序从编号0开
始的。这个QVadant类可以保存许多C++和Qt数据类型，包括int和QString。可存储于数据库中
的不同数据类型都可以映射为相应的C++和Qt类型并且存储到QV面舭t中。例如，VARCHAR代
表着QString，而DATETIME代表着’QDateTime。
    QSqlQuery提供了一些可以遍历结果集的函数：first()、last()、previous()和seek()。这些函数都
很方便，不过对于某些数据库，它们可能会比next()更慢或者更加耗费内存。在操作一个大数据集
时，为了便于优化，可以在调用exec()之前调用QScIIQuery：：setForwardOnly (1/ue)，然后只使用next()遍
厉结果集。
    之前，我们把这个SQL查询指定为QSqlQuery：：exec()的参数，然而还可以直接把它传递给构
造函数，构造函数会立即执行SQL查询：
    oSqiouery query(“SELECT title, year FROM cd WHERE year>=1998“);’    一
1rl    o ro
-o N-    Ql
ro -ro ra o c a)
z -o z ? a) o
IJ tU L cn O_ ra
H D U P b e
     ro
 --  v
 C:
      .rl .
 .  L    ..
   ;J .  :
  CJ .
o-v
   IJ - v
   -- C -
  OH Q)
-Or
 rJ
   ra r -
   > - a)
    . a) r
  y :J -o
     - ca
   a) ra rJ
-r = > C
_-  y L
-- II L O_
-    a) CT '
IJ Q) =
x -q V
a) t   v
C ,_l II .
 JL
q L   ..
-4  J -o
  S c rJ
Q) Q.,-i cn
-
J=
3      J-
240    C++ GUI Qt 4编程<第二版）
可以通过对查询调用isAct/ve()来检查是否有错误发生
if  ( ! query.isActive ( 》     .
        QMessageBox:':wa rning (this,  tr( "Database  Error" j
 query.lastError().text'(》;
如果没有错误发生，则查询会变成“激活”状态，然后就可以使用next()来遍历结果集。
：执行INSERT的代码与执行SFIF,CT的一样容易：  ．
QSqlQuery query("INSERT INTO cd (id, artistid, title, year) "
            .   "VALUES (203, 102, 'Living in America', 2002)")
在这之后，numRowsAffected()返回受、SQL语句影响韵行数（如果发生错误，就返回，1）。、
    如果需要插入多条记录，或者想避免将数值转换成为字符串（并且正确地转义它们），可以使
用prepare()来指定．个包含占位符的查询，然后赋值绑定想插入的数值。Q对所有数据库都支持
Oracle风格和ODBC风格的占位符语法，如果它们可甩，就使用本地支持；如果不可用，就模拟它的
功能。以T是使用Oracle风格语法及命名占位符的实例：
QSqlQuery query;
query,prepare("INSERT INTO cd (id, artistid, title, year)
         "VALUES (:id, :artistid, :title, :year)");
query,bindVaLue(":id", 203);
que ry. bin. dValue ( " :a rtistid " , . 102) ;     , .
query.bindValuel":titte", "Living id'America--); '  =
que ry. bindVal'ue ( " : year" ,   2002) ;
query,exec() ;
                          -"
以下是一个使用ODBC风格位置占位符的相同实例：
QSqlQuery query;
query.prepare("INSERT INTO cd (id, artistid, title, year)
que.ry.addBindValue(203); . .   .   .
query.addBindValue(102) ; '
query,addBindValue ( " Living  in  America " ) ;
query.addBindValue(2002) ;
？  在axec()词用之后，可以调用bindValue()或者'addBindValue()来赋值绑定新值，然后再次调用
exec()并利用这些新值执行查询。j。’~  ．  一：    ’_  j    ：
  ．占位符通常用于指定二进制数据或者包含非ASCII码或者非Latin字符的字符串。在底层，Qt
对支持Unicode的数据库使用Unicode编码，而对于不支持Unicode的，Qt会明确地把字符串转换为
合适的编码方式。
    如果数据库中SQL事务处理可用的话，Qt就支持它。为了开始事务处理，需对代表数据库连
接的QSqlDatabase对象调用transaction()。为了结束事务处理，可以调用comnut()或者rollback()。
例如，以下是如何查询外键并且在事务处理中执行INSERT语句的代码：    ．一，    ‘
QSqlData base: :database ( ) .t ransaction ( ) ;
QSqlQu.ery que.ry;  .       .
query,exec("SELECT id FROM'artist WHfRE name = 'Gluecifer“‘)
if (query.next(》 {  '
         int  a rtistld  =  query. va'lue(0) , tolnt ( ) ;
                NSERT INTO cd (id, artistid, title, year)
       .  quel-y.exec ( "";~tijES . (201,  ,1  +  QString: : number( artistld)
              + ", 'Riding the Tiger', 1997)");        ;
}
                                    :r
QSqlDatabase: :database ( ) . commit ( ) ; '
    QSqlDatabase:：database()函数返回_个表示在createConnection()中创建的连接的QSqlDatabasc
对象。如果事务处理不能启动，QSqlDatabase:：transaction()就返圊false值。一些数据库不支持事
第13章’数’据库
241
务处理。对于这类数据库，transaction()、commitC）和rsollback()几个函数就什么也不做。可以使用
hasFeature()对数据库相关的QSqlDriver进行测试，看看这个数据库是不是支持事务处理。
    QSqlDriver  *drive r=QSqlDatabase::database().d river();  +    -    ¨：
    if(d rive r->hasFeature (QSqlD river::Transactions))
    还可以测试其他的一些数据库特征，包括数据库是否支持，BLOB（二进制大对象）、Unicode以
及经过处理的查询。    ，    。一    。
    使用QSqlDriver:：handle()和QSqlResult:：handle()函数，还可以读取低级数据库驱动程序句柄
和查询结果集的低级句柄。但如果不清楚其使用目的与细节的话，这两个函数的使用非常容易出
错。读者可以看看有关它们的一些资料中的实例放其L险说明叠  ~
    目前为止，在我们研究的实例中，都是假设应用程序所使用的是单一的数据库连接。如果想
创建多个连接，可以把数据库名作为第二个参数传递给addDa/abase()。倒如：  ‘    7．．、
    QSqlDatabase db=QSqlDatabase::addDatabase("QPSQL“,”OTHER”);    i
    db. setHostName(“saturn.mcmanamy.edu”);
    db.setDatabaseName(”starsdb“);
    ..db.setUserName(”hilbert”);    ’  、’
    ．    ，
    db.setPassword(“ixtapa7”);
    ．    -：
然后，可以通过把数据库名传递给QSqlDatabase：：database(，)得到指向QSqlDatabase对象的指针；
    QSqlDatabase db=QSqlDatabase::database(“OTHER“);    ’    ;  ‘一‘  r
    ‘.■j．：？㈠一
    为了使用其他连接执行查询，我们把QSqlDatabase对象传递给QSqlQuery魄构造函数：
    ．    、
    QSqlQuery query(db)；
    query.exec(”SELECT id FROM artist WHERE name=‘Mando Diao‘”);    j  ’    。
    如果想一次执行多个事务处理，多重连接是很有用的，因为每个连接只能处理一个有效的事
务处理。当使用多个数据库连按时，还可以有一个命名的连接，而且如果没有具体黄定的话，
QSqlQuer)r就会使用这个未命名的连接。    ’    √
    ．  二：．。…    一
    除了QSqIQuer)r之外，Qt提供了QSqlTableModel类作为一个高级界面接口，让我们不必使用原
始的SQL语句来执行大多数常用的SQL操作(如SELECT、INSERrr、UPDAIE和DELEIE)c．这个类可
以用来独立处理数据库而不涉及任何的图形用户界面，它也可以用作QListView或、QTableView的
数据源。    ‘  。，．t．，  ：一，  “  ？一  。
以下是使用QSqlTableModel执行SELECT操作的实例：。    ，
QSqlTableModel model;
model.setTable( "cd");
model. setFitter( "yeb r^>=1998");、    t、J1
model.select()；
    ．    ．    手
这等价于如下的查询：    ：    ．    。
    SELECT丰FROM cd WHERE year>=1998
    利用QSqlTableModel:：record()获得某一给定的记录，或．者il/fl.varue()读取单独的字段，我们
可以遍历这个结果集：
    …  ，    ≈    、，：，  ．
    for (int i=O;i<model.rowCount(); ++i){
    1 tJ  一
    QSqlRecord record=model.record(j);    :、    +；一：
    QString title=record.value("title").toStrin|g();:‘  ！,.:.  ,.:  ¨
    int yea广=record.value( "yea r“).tolnt();
    std::cerr<<qPrintable(title)<<”:’‘<<year<<std::endl;
    '    ‘
    )
    QSqlRecord:：value()函数既可以接收字段名也可以接收字段索引。在对大数据集进行操作
    ．    ’    ：  、
时j建议利用索引来指定字段。例如：‘‘‘．  -1  ：    f    ~，
242    C++ GUI Qt 4编程（第二版）
int  titlelndex  =  model. record () .indexOf ( "titlev) ;         ,
int  yea rlndex  =  model. record ( ) .indexOf( "yea r" ) ;
for (int i = 0; i < model.rowCount(); ++i) {
   QSqlRecord record = model.record(i);
   QString title = record,value(titleIndex).toString();
      int year =  record.value(yearlndex) .tolnt() ;
   std::cerr<℃ qPrintable(title)《 ": il<< year<< std::endl
    为了在数据库表中插入记录，可调用insertRow()来创建一个新的空行（记录），然后使用setData
设置每一个列（字段）的值：
QSqlTableModel model
model.setTable( "cd")
int row = 0;
model.insertRows( row,  1) ;
 model. setData (model . index ( row,
model. setData (model.index( row,
 model .'s e tData ( model.index ( row,
model. setData (model, index ( row,
model. submitAll ( ) ;
 113 ) ;
"Shanghai My Heart")
224) ;
2003) ;
    茌调用submitAⅡ()之后，记录可能会被移动到一个不同的行位置，这取决于表是如何排序的。
如果插入失败，submitAⅡ()调用将返回false。
    SQL模型与标准模型之间最大的区别在于：对于SQL模型，必须调用submitAJI()以将发生的更
改写入数据库。
    为了更新某一记录j首先必须把QSqlTableModel定位到要修改的记录上[例如使用。elect()]。
然后提取这条记录，更新想改变的字段并将更改过的数据回写到数据库中：
QSqlTableModel model;
model.setTable( "cd") ;
model.setFilter(--id = 125");
model. select ( ) ;
if (model.rowCount() == 1) {
  . QSqlRecord record = model,record(0);
       . reco rd . setValue
record.setValue
_ model.setRecord
model.submitAll
}
"title", "Melody A,M.") ;
 "year",  record.value( "year") .tolnt ( )  +  1) ;
O, record);
).
/.
    加果有一条记录与指定的过滤器相匹配，就利用QSqlTableModel:：record()获得这条记录。并
用修改后的记录复写原始的记录。
    正如对非SQL模型所作的处理一样，也可以使用setData()来执行更新。我们获得的模型索弓
都是针对给定的行与列的：
model.select ( ) ;
if (model.rowCount() == 1) {      .
     model,setData(model.index(0, 1) r "Melody A.M."); .    .
         model.setData ( model.index ( 0,  3) ,
                                        model. data (model,index (0,  3》 .tolnt ( )  +  1) ;
 modei.submitAl{no(); .
}
删除记录与更新记录的过程很相似：
    ~    ^
model.setTable( "cd");
model,setFilter( "id=125");
model.select()；
if (model.rowCount()==1){
    model. removeRows(0,1);
    model,submitAll()；
)
．罐兹霭㈣锶凇渤
一p7
    第13章数据库243
    removeRows()调用删除了第一条记录的行号以及记录号。下面的实例则删除了所有与过滤器
匹配的记录：
    model.setTable("cd");
    model.setFilter(“year<1990”);
    model. select()；
    if (model.rowCount()’>0)t
    model.removeRows(0,.mode:,rowCount());
    ’model．submitAll(')；
    }
    QSqlQuery和QSqlTableModel这两个类提供了Qt和SQL数据库之间的接口。利用这些类，可以
创建显示用户数据以及让用户插入i更新和删除记录的表单。
    对于使用SQL类的应用程序，需要将如下的命令行添加到其．pro文件中：  i
    QT+=sql
这将确保应用程序可以连接到QtSql库。
13.2查看表
    在前一节中，我们看到了如何使用QSqlQuery和QSqlTableModel与数据库进行变互。在本节
中，将看看如何在QTableView窗口部件中显示QSqlTableModel。    ，一
    如图13.1所示的Scooters应用程序，给出了踏板车(scooter)的型号表。孩实例基于单一的
scooter表，其定义如下：    ．
    CREATE TABLE scooter(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(40) NOT NULL,
    maxspeed INTEGER NOT NULL,
    maxrange INTEGER hlOT NULL,
    weight INTEGER NOT NULL,
    description VARCHAR(80) NOT NULL);
图13.1 Scooters应用程序
    在这种采用SQUte的情况下，id字段的值都是由数据库自动生成的，而其他类型的数据库可
能会使用不同的语法来完成。
     244                                               c++, GUr Qt 4编程(第二版)
 -
为了便于维护，我们利用枚举类型变量enum为表的列索引号给出有具体含义的命名：
enum {
    Scooter Id :=
 '  Scooter Name
Scooter_MaxSpeed = 2,
Scooter_MaxRange = 3,
Scooter_Weight = 4,
ScooterpDescription = 5
如下给出了建立QSqlrrableModel以显示scooter表所需的代码：
model = new QSqlTableModel(this)
'model->setTable( "scooter" ) ;
model->setSo rt ( Scoote r_Name,   Qt : :AscendingO_rde r) ;
model->setHeade rData (Scoote r_Name,   Qt: : Ho rizontal
model->setHeade rData (Scoote r_MaxSpeed,   Qt : :Ho rizont
model->setHeade rData (Scoote r_MaxRange,   Qt : :Ho rizont
model->setHeade rData (Scoote r_Weight,   Qt : :Ho rizontal
model->setHeade rData (Scoote r_Des c ription,   Qt : :Ho riz
                              tr("Description"》 ;
model->select ( )
al,  tr("Miles"》
ontal,    .
    刨建模型的过程与上节中所述的过程相似。不同之处在于，这里使用了我们自己的列标题。
如果不这样做，则列标题将采用原始的字段名。我们还使用setSort()指定了二个排序，它在后台运
行的程序中通过ORDER BY子句实现。
    我们已经创建了模型并利用select()将其以数据组装，还可以创建一个视图来显示它：
view = new QTableView;
view->setModel(model) ;
view->setSelectio nMode (QAbst ractItemView: : Sin gleSelection )
view->setSelectionBehavio r ( QAbst ractItemView: : SelectRows } ;
view->setColumnHidden ( Scoote r_ld ,   t rue) ;
view-> resizeColumnsToContents ( ) ;
yjew=>set EditTrigge rs .( QAbst ractItemView:  :NoEditT rigge rs ) ;
QHeaderView *header. = vZew~>horizontalHeader()
header->setStretchLastSdcition (t rue) ;   '
    茌第10章中，我们看到了如何使用QTableView在一个表中显示来自QAbstractltemModel的数
据。因为QSqITableModel(间接)派生自QAbstractItemModel，它可以很容易地作为QTableView数据源
使用。setModel()调用是连接视图和模型唯一必需的调用，其余的代码仅用来定制表以使其具有
更加友好的用户界面。
．  选择模式指定了用户可以选用的所有可能模式，这里我们使单独的单元格（字段）可选。被选
中的单元格通常用一个带点的轮廓线包围。选择状态指定了被选项如何在考虑整行的情况下实
现可视的效果。被选项通常由不同的背景颜色来表示。这里选择了隐藏ID列，因为对于用户来
说，ID并无意义。此外，还设置NoEditTriggers以使表视图具有只读属性。
显示只读表的另一方式是使用QSqlLableModel酌基类-QSqIQueryModel。该类提供setQuer()
函数，因此它可设置复杂的SQL查询以提供含一个或多个表的专门视图――例如，使用SQL表连
接算法
(join)。
与Scooters应用程序的数据库不同，大多说数据库都存在着大量的表与外键关联（在关系数据
库中，外键表示两表间的引用约束）j：Qt提供了
.QSqlRelaUonalTableModel，它是一个可以利用外键来
  显示和编辑表的QSqlTableModel子类。除了可以为每一个外键将QSqITableModel添加到模型以外，
  QSqlRelationalTa.bleModel与QSqlTableModel的功能非常相似。在许多情况下，外键有一个ID字段和
一一个命名字段。虽然在后台程序中相应的ID字段才是真正被使用的字段，但利用QSqlRelational-
    rl
0 11
 2 q臻H壤镶Ⅲ懑蝴
    ，l_
    ，，f-
第13章数据库
245
TableModel，可以确保用户能看到和更改外键的命名字段。为了让其有效运作，必须对用于显示模
型的视图设置一个QSqlRelationalDelegate类（或者是一个用户自定义的子类）。
    在随后的两节中，将看到如何实现显示功能及外键更改，还将在本章的最后一节给出更多关
于QTableViews内容。
13.3使用窗体编辑记录
    在本节中，我们将看到如何创建一次只显示一条记录的对话窗体。’这个对话框可以用于增
加、编辑、删除单独的记录，也可以遍历崧中所有的记录。
    我们将通过Staff Manager应用程序来阐明这些概念。该应用程序记录了雇员所属的部门、部
门所处的位置以及诸如雇员内部电话分机号码等一些基本信息。应用程序使用了如下三个表：
    CREATE TABLE location(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(40)  NOT NULL》;    .r    ,.
CREATE TABLE department (
   id INTEGER PRIMARY KEY AUTOINCREMENT,       .   ..
   name VARCHAR(40) NOT NULL,  '  "
 .  locationid INTEGER NOT NULL,
   FOREIGN KEY (locationid) REFERENCES location》; '
CREATE TABLE employee (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   name VARCHAR(40) NOT NULL,
   departmentid INTEGER NOT NULL,
   extension INTEGER NOT NULL,
   email VARCHAR(40) NOT NULL,
   startdate DATE NOT NULL,
   FOREIGN KEY (departmentid) REFERENCES department》;
    袁以及表之间的关系示意见图13.2。在每一地点可以有许多部门，而每一部门可以拥有许多
雇员j、指定外键的语法主要针对SQLite3，但可能会随数据库的不同而有所变化。  ‘    ：
    j    图13.2   Staff Manager应用程序中的表．
    ．    。  ．
  本节将重点关注编辑雇员信息用的对话框EmployeeFonn。下一一节讨论的是MainForm，它提供
了部门和雇员的主从关系视图。    ‘  。    一  ，．一。  +
    EmployeeForm类提供了一个从主窗体雇员概要信息到某一雇员的具体细芾信息的下钻型视
图。当调用该类时，如果给出了有效的雇员ID，窗体将显示指定的雇员信息j；否则显示第一个雇员
的信息（窗体如图13.3所示）。用户可以浏览查看所有雇员的信息，编辑或者删除现有雇员的信
息，同时还可以添加新雇员的信息。    。
    employeeform.h文件中已经提供了如下的enum枚举类型变量，为表的列索引号给出有具体含
    ．    ．-    -J    ，：：  ’
义的名称：    j    ．，。  、，i；’    ．：
246
C++ GUI Qt 4编程（第二版）
图13.3雇员信息对话框
    enum{
    Employee_ld=0，
    Employee_Name=1，
    Employee_Departmentld=2,
    Employee_Extension=3,
    Employee_Email=4，
    ’    Employee_StartDate=5
    }；
头文件的其余部分则定义EmployeeForm类：
    class EmployeeForm  :public QDialog
    {  ‘
    0 0BjECT
    DubUC：
    EmployeeForm(int id, QWidget *parent=0)
    void done(int result);
    private：
    QSqlRelationalTableModel *tableModel;
    QDataWidgetMapper *mapper;    .
    QLabel *nameLabel；
    QDialogButtonBox *buttonBox;
    }；
    为了访问数据库，我们使用QSqlRelationalTableModel而不是普通的QSqlTableModel，因为需要解
析表之间的外键关系。QSqlRelationalTableModel是允许将某一窗体中酌窗口部件映射到数据模型
中对应的列的类。
    窗体的构造函数非常长，所以将其分为几个部分，逐段进行分析。至于没有太多实质性用途
的版面布局代码，我们就不去分析了。
EmployeeFo rm: : EmployeeFo rm ( int  id ,   QWidget  *pa rent J
   : QDialog(parentJ
{
   nameEdit = new"QLineEdit; : .
nameLabel  -  new QLabel(tr( "Na&me: "》 ;
nameLabel->setBuddy( nameEdit) ;
departmentComboBox = new QComboBox;
depa rtmentLabel  =  new  QLabel(tr( "Depar&tment : " 》
 depa rtment Label->setBuddy ( depa rtmentComboBox ) ;
 .~.o
^o
 oo
 Or
  y o-
    Q. E
  r LU
     CI o
.. E lJ
{n LU O
IJ -O r
o -o a)
r  n, -o
   -o -o
a) rl rl
IJ O O
cD 》
>
rl
  o- .
    第13章数据库247    7
    ___._.._-._.___-___-__-__-一
部。
extensionLineEdit - new QLineEdit;
extensionLineEdit->setValidator(new QIntValidator(0,  99999,  this》 ;
extensionLabel  =  new QLabel(tr( "E&xtension: " 》
extensio n Label->setBuddy ( extension LineEdit ) ;
emailEdit = new QLineEdit;
emailLabel  =  new QLabel(t r( "&Email: " 》
emailLabel->setBuddy ( emailEdit ) ;
);
dDays (-90 ) ,  today.addDays (90 》 ;
startDateLabel = new Q[abel(tr("&Start Date
sta rtDateLabel->setBuddy ( startDateEdit ) ;
首先为每个字段创建一个可编辑的窗口部件。
还创建了对应的标签，放在每个可编辑的窗口
firstButton = new QPushButton(tr("<< &First"》 ;
previousButton  =  new QPushButton (tr(”< &Previous" 》 ;
nextButton = new QPushButton(tr("&Next >"》;
lastButton = new QPushButton(tr("&Last 》"》;
buttonBox =
buttonBox->
buttonBox->
buttonBox->
ButtonBox中。创建版面布局的代码很简单，这里不再赘述。
    这样，我们就完成了组成用户接口界面的窗口部件，因此现在可以将注意’力转移到如何实现
其内在的功能上。
    tableModel=new QSqlRelationalTableModel(this);
    ta bletlodel->setTa ble(”employee");
    ta bleMod el->s etRelation(Em叶oyee―DepartmentId,
    QSqlRelation(”department”,“id”r“name“)):
    tableHodel一>setSort(Employee―Name,qt::Ascendingorder);
    tableHodel一>select();
QSqlTableModel *relationModel =     '
                        tableMod el-> relatio nModel ( Employee_Depa rtmentld ) ;
depa rtmentComboBox->setModel ( relationModel) ;
de5a rtmentComboBox->setModelColumn(
                     relationModel->fieldlndex ( " name " 》 ;
    棋型的构建与设置过程都与之前介绍的QSqlTableModel的设立过程基本一致。但是这次使用
QSqlRelationalTableModel并设立一个外键关联。setRelation()函数获得一个外键字段索引及QSqlRe-
lation索引。QS。ilRelation构造函数则用表名（外键关系对应的表）、外键字段名以及要显示的字段
名来表示外键字段值。
    ‘    。我们可以
- QCoⅡiboBox与QLi。tWidget很相似，因为它有一个内部模型去保存它的数据条目项
黪蘸隧黪酴墼麟雾a嚣，
警箍。t?。？、7／
  o  -o
  CO rD
 cjo
.- = rD O
 ~J  o- o  ~J
rl 0 4J C
-o o- c o
LU L O O,
OmLe
}J -O L r/,
rD c = o:
oouo
aN.. J
    rD .. rD
3u oo
o ~J ~J ~J
cOmo
   cn o cn
:IAaA
~J ~J I  J
-o o y-0
LU LU m LU
oooo
 ~J ~J o ~J
 rD r  ~J m
oo o
4J ~J o ~J
L  JL
m m ro m
 ~J 4J o ~J
cn m O cn
  玛提
  肟黝．
  贿碑，，
  眠谴艇
  群网嘣
  ～一一．
  一一一．
  。一～一
  一一一一
  靴貅枷悄
  黼  黼舻
 :-
   o --
.- o o
-N cn
-o o
 { -- =
＆ Ll
~J o C
( 4J o
C ~J ~J
O i ~J
4J fD =
~- h ca
 = m _e
o] = cn
-C o- =
 cn a o-
 = -  Q
0- 3 -
~ II C
 C    II
 II g C
  4J o
 C ~J ~J
o = ~J
4J o ca
 = +J o
c:a. o .n
oN o
o o lL
mou
 o-
  -r O
-Or
  o R o
  r C R
  o 0 4J
  R rJ O_
  C ~J 0
ouu
  rJ < U.
  < X ..
  .. o X
    .. fD O
  x C ca
ooc
  ca ~J o
  n t ~J
  o = ~J
  ~- ca =
   ~- o,ca
  = o g
  Ca r O
  O rl m
 No rJ
   rD ao
  rl  a
 o-
.~a c -
X oc
o -4J o
fD C ~J 4J
C o = ~J
o ~- ca =
~J 4J 0 ca
= c:a o .n
ca -O r O
o,-o o l~
O rD -o u
r -- -- --
rD c C C
rl O O O
o ~J 4J ~J
a ~J 4J ~J
===
3 ca 8 ca
o o -o -o
C -o -o -o
     rD CD CD
顺姗
滩帅
一
一删
秕搏
装
～一
献删
@如
淼
愀雕
瓤黼
                                --~-__-__---_-_    -_ --___;_"-i_/ -i
第n章j数、据库
249
    导航浏览按钮都是直接连接到相应的映射器槽的。（如果使用手动提交的策略：，则需要实现
自定义的这些槽，在这些槽中提交当前记录，然后执行导航浏览以避免所做的修改丢失。）数据窗
口部件映射器允许进行编辑和导航浏览。若要增加和删除记录，可使用底层的模型j
    v01d  EmployeeForm::addEmployee()    .    :’    ？
    t    t
    int row=mapper->currentlndex();
    mapper->submit(】；
    tableModel->insertRow( row);    _.
    mapper->setCurrentlndex( row);    .
    nameEdit->clear()    ！    ，  ，  ，。    ，‘  ．
    nameEdit一>clear();    .    .    .    .
.extensionLineEdit->clear();
    sta rtDateEdit->setDate(QDate::cu rrentDate());  -    _    :    -    ’
    ；f．    ’    ’    卜    +
    nameEdit->setFocus();    .?r-、    ,,    .    -:，    一    ：
    }    。    ！    ’
    当用户单击Add按钮时，就会调用addEmployee()槽。我们首先重新找回当前行，因为它在提
交后就遗失了，然后调用submit()以确保对当前记录的修改没有任何遗失。尽管已经设置了自动
提交策略QDataWidgl：dVlapper：．：AutoSribmit，仍必须手动提交。这是因为自动提交仅在用户改变光标
焦点位置时才能使用――这样可以避免在每次用户插入或者删除一个字符时，频繁地对数据库进
行更新操作――因为用户有可能刚编辑完。个字段，但当单击Add按钮时光标隽枣焦罩并没有跳
出该字段。接下来，我们插入一个新的空白行并让映射器导航浏览至该空白行？最后，初始化窗
口部件，并将光标聚焦到用户开始键入的第二个就绪的窗口部件。    ,.L：．．≯．~    。
    void EmployeeForm：：de,leteEmployee()    ，    ：    一，    ’    一j?  ,
    tint rowmapper->currentlndex();    一’
    int row=mapper一>currentIndex();    .    ,:  .?  、一
    tableModel->removeRow( row);
    mapper->submit();    ,  ,、    .    _j’、
    mapper->setCu rrentlndex( qMin( row,  tableModel-> rowCount(j-1)k    .
    )    --  ‘
    对于删陈操作，应从指明当前行开始，然后删除这一行并向数据库提交这个更改。必须手动
提交删除的更改，因为自动提交策略仅适用于对记录做出的更改。最后，让映射器当前索引指向
被删除行的下一行。如果删除的是最后一行，则指向最后一行。    ‘：
    QDataWidgetMapper类使那些采用数据模型显示信息的数据可知型窗体的开发变得容易得多。
在这个例子中，我们使用一个QSqlRelationalrLableModel作为底层的数据模型，而QDataWidgetMapper则
可以与任何数据模型一起使用，包括非SQL模型。另外一个可供选择的方式是直接使用QSqlQuery
在窗体中填写数据，并更新数据库。这个方法要求更多的工作量，但也相应地更灵活一些。
    下一节中，我们将看看Staff Manager应用程序的余下部分，包括在本节中开发的使用Employee-
    orm    ．  。；+：
Fo眦类的代码。    ’．，：    、
13.4在表中显示数据
    在许多情况下，以表格式的视图为用户显示数据集是最简单的方法。本节给出Staff Manager
应用程序的主窗体，它由两个呈主一从关系的QTableView组成：（窗体如图13.4所示）、。主视图是一
个单位部门昀列表，从视图则为当前部门中的雇员列表。两个视图都使用了．QSqlRelational-
TableModels，因为它们呈现出的两个数据库表都有外键字段。相关的CREAIE TABLE声明可以参
见245页的描述。    -。。．
250    C++ GUI Qt4编程（第二版）
图13.4   Staff Manger应用程序
我们依然使用enum枚举类型变量为表的列索引号给出有具体含义的命名：
enum .{   .
   Department_ld = 0,
.  Department_Name = 1,
   Department_Locationld = 2
};
首先看看头文件中MainFonn类的定义：
class MainForm : public QWidget
                                                                                                                                                                               .
   Q_OBJEr.T    .
public:
MainForm()
private slots:
   void updateEmployeeView();
       \toid  addDepartment ( ) ;
       void  deleteDepa rtm.ent ( ) ;
   void editEmployees();
private:
. void createDepartmentPanel();
   \toid createEmployeePanel();
QSqlRelationalTableModel *departmentModel;
QSqlRelationalTableModel *employeeModel;
QWidget *departmentPanel;
    QDialogButtonBox *buttonBox;
    )；
    为了设立主一从关系，必须确保当用户浏览到主视图中不同的记录（行）时，更新从视图中的表
并显示相关的记录。这可以通过私有updateEmployeeView()槽实现。其他三个槽[addDepartment()，
deleteDepartment()和editEmployees()槽]的功能则可望文生义，两个私有函数[createDepartmentPanel()
和createEmployeePanel()]则是构造函数的帮助函数。
“i譬Ⅲ嵌磁i∞誊
    ，，
    第+13章数据库    251
    大多数构造函数的代码都与创建甩户界面接口相关，并且会设立合适的信号二槽联系。而我
们只关注那些与数据库编程相关的部分。
MainForm::MainForm()
       createDepartmentPanel( ) ;
        createEmployeePanel( ) ;
    构造函数首先调用两个帮助函数createDepartmentPanel()和createEmployeePanel()。第一个函数
创建并设立部门模型和视图，第二个函数则创建并设立雇员的模型和视图。在查看完构造函数以
后，我们将看看这两个函数的有关部分。
    构造函数的下一个部分设立了包含两个表视图的切分窗口，同时还设立窗体按钮：我们将省
略所有这方面的代码。
connect (addButton,  SIGNAL ( clicked ( 》 ,  this,  SLOT(addDepa rtment ( 》 ) ;
connect (deleteButton,  SIGNAL:( clicked ( 》 ,
                   this,   SLOT ( deleteDepa rtment ( 》 ) ; .
connect (editButton,  SIGNAL( clicked ( 》 ,  this ,  SLOT(editEmployees ( 》 )
connect (quitButton,  SIGNAL( clicked ( 》 ,  this ,   SLOT( close ( 》 ) ;         .
depa rt mentView->setCu rrentlndex ( depa rtmentModel->index ( 0 ,.  0 》
找们建立对话框中按钮和槽的连接，同时确保第一个部门就是当前的项。
    既然看过了构造函数，接下来就看看createDepartmentPanel()帮助函数中的代码，它设立了部门
的模型和视图：
void  MainFo rm :.: c reateDepa rtmentPanel ( )
{
    departmentPanel = new QWidget;
departmentModel = new QSqlRelationalTableModel(this);
depa rt mentMod el->setTa ble ( "depa rtment " ) ;
depa rtmentMod el- >setRelatio n ( Depa rtment_Locationld ,
               QSqlRelation( "location" ,  "id" ,    name" 》 ;
depa rtmentModel->setSort ( Depa rtment_Name,   Qt : :As cendingo rder) ;
depa rtmentModel->setHeade rData ( Depa rtment_Name,  Qt : :Ho rizontal,
depa rtmentModel->setHeade rData (Depa rtment_Lodationld ,
                                                                   Qt: :Ho rizontal,  t r( " Location" 》 ;
departmentModel->select() ;
d
d
d
d
d
d
d
d
pa
pa
pa
pa
rt
rt
rt
rt
epart
epa rt
epa rt
epart
montView = new QTableView;
mentView->setModel ( depa rt m. entModel) elationalDel
mentView->setItemDelegate( n;ew  QSqlRela           .Delegate ( this》 ;
rrlentView->setSelectionMode(
    QAbst ractItemView: :SingleSelection) ;   .
mentView->setSelectio nBehavio r (QAbst ractlt emView:  : S elect Rows ) ;
mentView->setColumnHidden(Department_ld, true);   '  .
mentView-> resizeColumnsToContent s ( ) ;
mentView->ho rizontalHeade r ( ) ->setSt retchLastSection ( t rue) ;
depa rtmentLabel  =  new  QLabel ( t r( "Depa r&tments
 depa rt mentLabel->setBuddy ( depa rtmentView) ;
connect ( depa rtmentView->s electionMod el ( ) ,
                 SIGNAL( currentRowChanged ( const  QModellrtdex &,
                                        const QModellndex &》
                   t his ,   SLOT( updateEmployeeView( 》 ) ;
)
达段代码与前一节中设立employee雇员表模型时所见到的代码相似j这个视图是一个标准
252    C++ GUI Qt4编程（第二版）
QTableView，但是因为外键的存在，必须使用QSqlRelationalDelegate，。这样外键的文本才能正常出现
在视图中并能通过组合框进行更改，而不只是更改原始的ID号。
    我们已经选择隐藏部门的ID字段，因为它对用户来说没有什么意义。我们也拉伸主视图中
最后一列可视字段，也就是部门地址字段，以填满视图中水平方向上的可用空间。
    部门主视图有它自己的针对QAbstractItemView：：SingleSelection的模式设置选择以及针对QAb-
stractItemView:：SelectRows的状态设置选择。模式设置意味着用户可以浏览到表中单独的单元格，
而状态设置则表示当用户浏览记录项时，整行都是高亮显示的。
    我们从视图的选择模型来建立updateEmployeeView()槽与currentRowChanged()信号的连接。这
个连接是使主一从关系起作用的关键，它同时也确保了雇员从视图总是能显示部门主视图中被高
    f_  ’’  ’_|一    1    ‘
亮选中的部门所对应的雇员信息。
    createEmployeePanel()帮助函数内部的代码与、createDepartmentPanel()希助函数的相似，但是也
有一些重要的区别：
void   Main Fo rm : : c reateEmployeePanel ( )       ,
 . employeePanel:'riew QWidget'j-  ,
  , employeeModel = new QSqlRelationalTableModel(this);  . .       ' ' .'  . .
           employeeModel-> s etTa ble ( " employee" ) ;              .
             employeeModel-> s et Relation ( Employee_Depa rtme ritld ,
                         QSqlRelation ( "department " ,  "id " ,   "name" 》 ;       ,
           em ployeeModel-> s etSo rt ( Employee_Name,   Qt: :Ascendingo rde r) ;
           employeeModel-> s etHeaderData ( Employee_Name,   Qt : : Ho rizontai,                     .
   employeeModel->setHeaderData(Employee_Extension, Qt::Horizonta}, .
        employeeModel->setHeaderData ( Employee_Email,  Qt: :Ho rizontal,            .
                                                         tr( "Email" 》 ;
empl.oyeeView -.. new QTableView;
employeeView->setModel-( employeeModel) ;       .  ,
employeeView->setSelectio nMode ( QAb s t,ractItemView: : SjngleSelection )
employeeView->setSelectio n Behavio r ( QAbst ractItemView:  : SelectRows ) ;
employeeView->setEditT rigge rs ( QAbst ra ctItemView:  :NoEditT rigge rs ) ;
employeeView->ho rizontalHeader( ) ->setSt retchLastSectjon ( t rue) ;  .   .
employeeView->setColumnHidden ('Employee_ld ,   t rue ) ;
employeeView->setColumnHidclen ( Employee_Depa rtmentld,  t rue) ;  I
employeeView->setColumnHidden ( Employee_Sta rtDate,  t rue) ;        .
employeeLabel  =  new  QLabel ( t r( "E&mployees "》 ;        '
employeeLabel->s etBuddy ( employeeView) ;
    庭员视图的编辑触发器被设置为QAbstractItemView：：NoEditTriggers，它能有效确保视图的只读
属性。在这个应用程序中，通过单击Edit Employees按钮，用户可以添加、编辑和删除雇员记录，而
该按钮调用了前一节中开发的EmployeeForm。
    这次，我们隐藏三列，而不是仅隐藏一列。我们隐藏id列，因为它对于用户来说还是没有什
么意义。还需要隐藏department/d列，因为每一次显示的雇员信息都是属于当前选中部门的。最
后，隐藏startdate列，因为它几乎没有任何实质作用，而且还可以通过单击Edit Employees按钮读
取它。
void  MainFo rm : : updateEmployeeView( )
                                                                  .   ., .
     QModellndex index = departmentView->currentlndex(.) ;        ,         .
  if (index.isValid(》 {
                   QSqlReco rd   reco rd  =  depa rtmentModel-> record ( index , row( 》 ;
      int id = record,value("id").tolnt(); .
                    employeeModel->setFilte r(QSt ring ( "depa rtmentid  =  %1" ) ,a rg ( id 》
第13章．数据库    253
         employ.eeLabel->setText (t r( " E&mployees  /n  the  961  Depa rtment " )
                                                                    .arg ( record . va}ue( "name" ), . toSt ring{ 》 ) ;
} else {
   employeeModel->setFilter("departmentid = -1"); ' .
         employeeLabel->setText (t r( "E&mployees”) ) ;            .   .
}                                                J
employeeModel->select ( ) ;
 employeeView->ho rizontalH e a.de r ( ) ->setVisible (            .           '
             employeeModel->rowCount(》 0) ;
    只要当前部门发生更改（包括启动的时候），这个槽就会被调用。如果它是一个有效的当前部
门，函数会重新找回该部门的ID号并且对其雇员模型建立一个过滤器程序。这就迫使雇员信息
只对那些与其匹配的部门ID外键才显示。（过滤器程序就是没有WHERE关键字的WHERE子
句）。我们还需要更新employee表上的标签文本以显示雇员所属部门的名称。
    如果没有有效的部门名（比如数据库为空时），就将过滤器程序设鼍为与一个不存在的部门ID
相匹配，这样就没有与其匹配的记录。    ，
    然后，对模型调用select()函数以应用这个过滤器程序。这将依次发射信号：而视图将通过自
我更新对该信号做出回应。最后，显示或者隐藏employee表的列标题，这取决于是否有任何雇员
信息被显示。
void MainForm::addDepartment()
int  row = departmentModel->rowCount( ) ;            1
depa rtmentModel->insertRow( row) <
QModellndex index = departmentModel->index( row,  Department_Name) ;
depa rtmentView->setCu rrentlndex ( index) ;                                                    J
departcr;entView->edit(index7;      . ' .  -:   . .       . :,1
    如果用户单击“Add Dept.”按钮，就会在departn．ent表的最后插入一个新行：并让这÷行成为当
前行，同时启动部门名那一列的编辑功能，就好像用户按下了F2键或者双击了该列-样j如果需
要提供一些默认值，则将在调用insertRow()后立即调用。etData()耒完成。、  。  0．j
    我们不必考虑为新记录创建独特的键，因为使用的是一个自动增加列。如果这种方法不能或
者不适合使用，则可以连接模型的beforelnseIt()信号。这个信号在用户编辑后将发射，正好在数据
库的插入发生之前。这是放入1D或者处理用户数据的最佳时间。beforeDelete()和beforeUpdate()
信号很类似，它们对创建审计追踪非常有用。    。．  ．．    一，二
void  MainFo rm: :deleteDepa rtment ( )
{
   QModellndex index = departmentView->cu,rren.tlndex();. -      . '
.  if (!index.isValid(》 .
 .  . . return;  .
                                                       .
        QSqlDatabase: :database ( ) .transaction( ) ;                      .  :  .     I
 . .  QSqlReco.rd. record = departmentModel->reCord(index. row()J ;    :
         int  id  =  reco rd . value(Depa rtment_ld) :tolnt( ) ;       '
   int numEmployees = 0;
QSqlQuery query(QString("SELECT COUNT(*) FROM employee " .
                                                    "WHERE  departmentid  =  %1" ) .a rg (id 》 ;
if (query.next(》
         numEmployees  =  que ry.value (0) .tolnt () ;
if (numEmployees > 0) {
         int  r  =  QMessageBox : :wa rning (this ,  tr( "Delete  Depa rtment" ) ,
                     tr("Delete 961. and all its employees?")
                                        ,a rg ( reco rd . value (Depa rtment_Name) ,+oSt ring ( 》 r
             QMossageBox::Yes I QMessageBox::No);        -
    if (r == QMessageBox::No) { '   '
C++ GUI Qt 4编程（第二版）
                 QSqlDatabase: :database ( ) , rollback( ) ;      .
                  retu rn ;
     }
   query.exec(QString("DELETE FROM employee "
                                                  "WHERE  depa rtmentid  =  %1" ) .a rg (id 》 ;
}
    depa rtmentModel-> removeRow( index. row());
    departmentModel->submitAll();
    QSqlDatabase::database() .commit();    r
    updateEmployeeView();
    depa rtmentView->setFocus();
    }
．  如果想删除部门且该部门没有任何雇员记录，这个操作就可以直接执行而没有其他任何确认  j
提示信息。如果该部门中有雇员，就要求用户确认其删除操作。而如果用户确认其删除操作，就  ji
执行级联删除以确保数据库的关系完整性。为了实现这个功能，特别是针对那些芳不会为我们保  ；
证关系完整性的数据库（如SQLjte 3），必须使用事务处理。    ？
    一旦启动事务，就执行一个查询以查明该部门中有多少雇员。只要有一名雇员，就弹出一个  ；
消息框要求其确认操作。如呆用户单击No，就回滚该事务并返回。否则，就删除该部门以及该部  j
门中的所有雇员的信息，并且提交事务。    熹
    ，    }
    void MainForm::editEmployees()    、    ≤
    {i    +i
    int employeeld=一l；
    QMode11ndex index=employeeView.>cj rrentIndex()；    囊
    if(index.isValid()){    薹
    0SqlRecord广ecord=employeeHodel一>record(index．广ow());
    e呻loyeeId：reco广d．v乱ue（Em叶oyee―Id）．toInt()；    萋
    }    襄
    一    鬟
    EmployeeFo广m form(employeeId,this);
    ，  form．e×ei()：    囊
    updateEm叶oyeeview()；，    薹
    }    ’  、    冀
    美
    只要用户单击Edit Employeei按钮，就会调用edi幽ployees()槽。首先分配-个无效的雇员  耋
ID，然后用当前的雇员ID复写这个无效的雇员Ⅲ。接着，构建EmployeeFo珊并让它在形式上显示  霪
出来‘。最后，调用upd如ErrlployeeView()槽，以使主窗体的从表视图自我刷新，因为此时扈员信息可  鬟
能已经发生了更改。
  本章介绍了Qt的模型／视图类如何让sQL数据库中查看和编辑数据的操作变得尽可能翼羞喜囊
当我们想使用一个窗体视图显示记录项时，可以利用QDataWidge洲．apper将用户接口界面中的{
部件映射到数据库记录的字段。主一从关系的设置也相当容易，仅仅要求一个信号一槽连接以及一
个简单槽的实现。下钻型的窗体视图很直观，我们只需要导航浏览到主窗体构造函数中被选中的
记录，就可以在从视图中看到与其对应的具体信息。’如果没有记录被选中，则直接看到的就是第
一条记录。    ，
    r 7    。翥
第14章  多  线  程
    传统的图形用户界面应用程序都只有一个执行线程，并且一次只执行一个操作。如果用户从
用户界面中调用一个比较耗时的操作，那么当执行这个操作时，虽然实际上该操作正在进行，但用
户界面通常会冻结而不再响应。对于这个问题，第7章已经提供了一些解决方案。本章要讲述的
多线程则是另外一种解决方案。
  ’在多线程应用程序中，图形用户界面运行于它自己的线程中，而另外的事件处理过程则会发
生在一个或多个其他线程中。这样做之后，即使在处理那些数据密集的事件时，应用程序也能对
图形用户界面保持响应。当在一个单处理器上运行时，多线程应用程序可能会比实现同样功能的
单线程应用程序运行得更慢一些，无法体现出其优势。但在目前多处理器系统越来越普及的情况
下，多线程应用程序可以在不同的处理器中同时执行多个线程，从而获得更好的总体性能。“  ，
    这一章将首先介绍如何子类化QThread以及如何使用QMutex、QSemaphore和QWfutCondition，同
步线程①。接着，我们将会看到当事件循环运行时，主线程和次线程之间是如何进行通信的。最
后，会回顾一下哪些Qt类在次线程中可以使用，哪些类不可以使用。
    多线程是一个很大的研究谋题，有很多书籍专门介绍这一主题――例如'Bil Lewis和Daniel J．
Berg编著的“Threads Primer：AGLude to Multithreaded Programming”（Prertice Hall，1995）以及Gregor)r
Andrews编著的“Multithreaded，ParaUel，and Distributed Programming”(Addison-Wesley，2000)。在这里，
假设读者已经掌握了多线程编程的基础知识，因此本章的重点将放在如何开发多线程Qt应用程
序方面，而并不过多地关注多线程这个主题本身。
14.1  创建线程
    在Qt应用程序中提供多线程是非常简单的：只需要子类化QThread并且重新实现它的run()
函数就可以了。为了显示这一过程是如何进行的，我们将从介绍一个非常简单的QThread子类的
代码开始，它是一个可以在控制台上重复打印给定字符串的子类。应用程序的用户接口界面如
图14.1所示。
①Qt 4.4有望能提供一种更高级的线程应用编程接口，以完善这里讨论的线程类，从而使编写多线程应用程序时尽量
  少出错误。
-o  }-    -
ra  C    -
0   LU    -O
L   -,     ra
C  c0    0
         I   u .C
 cn     a    .+ l-
-     :,
u \-J     o-
一r．，
第14章÷多  线’程    257
ThreadDialog(QWidget *parent = 0);
protected:
   void closeEvent(QCloseEvent *event);
private slots:
  void startOrStopThreadA(J
        void  sta rto rStopTh readB ( )
private:
   Thread threadA;      '
   Thread threadB;       '
   QPushButton *threadAButton;
   QPushButton *threadBButton;
.  QPushButton *quitButton;.
};
’I'hreadDialog类声明了两个类型为’I'hread的变量和一些按钮，提供基本的用户界面。
Th readDialog : :Th readDialog ( QWidget  *pa rentl
   : QDialog(parent)    '  .   , ..i-
setMessage( "A") ;
setMessage( "B") ;
threadAButton = new QPushButton(tr("Start A"》
threadBButton = new QPushButton(tr("Start B"》
quitButton .=  new  QPushButton (t r( "Quit " 》 ;
quitButton->setDefault(true) ;
connect (th readAButton,   SIGNAL ( clicked ( 》,
                 this,   SLOT(sta rto rStopTh readA( 》 )
connect (th readBButton,   SIGNAL ( clicked ( 》 ,
                 this,   SLOT(sta rto rStopTh readB ( 》 )
茌构造函数中，调用setMessage()让第一个线程重复打印字母“A”，而让第二个线程重复打印
字母“B”。
void  Th readDialog : :sta rto rStopTh readA( )        .
{
   if (threadA.isRunning(》 {  .
                th readA.stop ( ) ;
                  th readAButton->setText ( t r( IlSta rt  A" 》
   } else {
threadA.start().;
                th readAButton->setText (t r( "Stop  A" 》 ;
}
    当用户单击用于线程A的按钮时，如果这个线程正在运行，startOrStopThreadA()就让它停止运
行；否则，就让它开始运行。startOrStopThreadA()闻时还更新该按钮上的文本。    +
void ThreadDialog:
{           .
   if (threadB.is
:startOrStopThreadB()
Running( 》 {
      threadB.stop( ) ; .
          th readBButton->setText (t r( "Sta rt  B'l 》 ;
} else {
      threadB.start( ) ;
        th readBButton->setText (t r( "Stop  B" 》 ;
}
startOrStopThreadB()的代码与startOrStopThreadA()的代码在结构上基本一致。
  < co
   -o -o
   ro ro
  0 Q)
 LL
 -C C
 ' IJ IJ
   258                                  C++ GUI Qt 4编程(第二版)  .
    _---____________________一―__――――――――――
    void ThreadDialog::closeEvent(QCloseEvent *event)   '
       {
             threadA.stop() ;
              threadB.stop() ;
                   th readA.wait ( ) ;        .
                 th readB.wait ( ) ;
                   event->accept ( ) ;      .
    如果用户单击了Q血或者关闭了窗口，就停止所有正在运行的线程，并且在调用函数QCloseEvent：：
ac。ept()之前等待它们完全结束[可使用QThread：：wa/t()]。这样就可以确保应用程序是以一种原
始清空的状态而退出的，尽管在这个实例中是否这样做并不要紧。
    如果运行这个应用程序，并且单击按钮“StartA”，那么控制台终端就会被连续输出的字母“A”
填满。如果再单击按钮“StartB”，那么控制台终端就会被以交替顺序输出的字母“A”和“B”填满。
如果再单击按钮“Stop A，’，那么就将只输出字母“B”。
14.2同步线程
    对于多线程应用程序，一个最基本要求就是能实现几个线程的同步执行。Qt提供了以下这几
个用于同步的类：QMutex、QReadWriteLock、QSemaphore和QWa/tCondition。
    QMutex类提供了一种保护一个变量或者一段代码的方法，这样就可以每次只让一个线程读取
它。这个类提供了一个lock()函数来锁住互斥量(mutex)。如果互斥量是解锁的(unlock)，那么当
前线程就立即占用并锁定(lock)它；否则，当前线程就会被阻塞，直到掌握这个互斥量的线程对它
解锁为止。以上述两种方式中的任意一种对lock()调用返回时，当前线程都会保持这个互斥量，
直到调用unlock()为止。QMutex类还提供了一个tryLock()函数，如果该互斥量已经锁住，它就会
立即返回。
    例如，假设我们想使用QMutex来保护前一节中Thread类的stopped变量，则应当向Thread类中
添加如下的成员变量：
    D rivate:
    …    ；
    QMutex mutex;
    )；
函数run()也需要相应修改：
    void Thread::‘run()
    {
    forever{
    mutex.lock()；
    if (stopped){
    stopped=false;
    mutex.unlock()；    ，
    break;
    )
    mutex.unlock()；
    std::cerr<<qDrintable(messageStr);
    }
    std::cerr<<std::endl;    +    、
    }
stop()函数则需要修改为：
    void  -rhread：：stop()
    {
    mutex.lock()；    +    ‘
    stopped=true,
    mutex.unlock()：
    }
第14章多  线程
    在一些复杂函数或是在抛出C++异常的函数中锁定和解锁互斥量，非常容易发生错误。Qt
提供了方便的QMutexLocker类来简化对互斥量的处理。QMutexLocker的构造函数接受'QMutex作
为参数并且将其锁住。QMutexLocker的析构函数则对这个互斥量进行解锁。例如，我们可以重新
编写之前介绍过的run()和stop()函数如下：
void Thread::run() .
{    ,
   forever j
       '{
        . QMutexLocker locker(&mutex)
        if (stopped) {
               stopped = false; .   .
                      ' break;
                   }
        }    .
    std:: cerr<<qPrintable( messageStr);
    )
    std::cerr<<std::endl;    ‘    ’
    )
    void Thread．：stop()
    {
    QMutexLocker locker(&mutex);    ,    .
    stopped=true；
    )    ．
，  使用互斥量的一个问题在于：每次只能有一个线程可以访问同一变量。在程序中，可能会有
许多线程同时尝试访问读取某一变量（不是修改该变量），此时，互斥量可能就会成为一个严重的
性能瓶颈。在这种情况下，可以使用QReadWriteLock．它是一个同步类，允许同时执行多个读取访
问而不会影响性能。
    在Thread类中，用QReadWriteLock替换QMutex来保护stopped变量毫无意义，因为在任意给定
时刻，最多只有一个线程会试图读取这个变量。一个更为恰当的实例，是在程序中应当包含一个
或多个访问某些共享数据的阅读程序线程，并且还有一个或多个修改这些共享数据的写入程序线
程。例如：    。
MyData data;
QReadWriteLock lock;
void ReaderThread::run().
{
      lock.tockForRead() ;      .
       access_data_without_modifying_it (&data) ;
    . lock.unlock() ;
}.
    void WriterThread::run()
    {
    lock.lockForWrite()；
    modify_data (&data)；
    lock.unlock()：
    )
为简便起见，我们可以使用QReadLocker类和QWriteLocker类对QReadWriteLock进行锁定和解锁。
    QSemaphore是互斥量的另外一种泛化表示形式，但与读一写锁定不同，信号量(semaphore)酉以
用于保护( guard)一定数量的相同资源。下面的两小段程序代码给出了QSemaphore和QMutex之间
260    C++ GUI Qt 4编程（第二版）
的对应关系：。  t
QSemaphore semaphore(l) ;
semaphore.acquire'( ) ;
semapho re. release( ) ;
    通过把1传递给构造函数，就告诉这个信号量它控制了一个单一的资源。使用信号量的优点
是可以传递除1之外的数字给构造函数，然后可以多次调用acqLure()来获取大量资源。  ．
．  一个典型的信号量应用程序是当两个线程间传递一定量的数据( DataSi：e)时，这两个线程会使
用某一特定大小(BufferSize)的共享环形缓冲器(circular buffer)：
const int DataSize = 100000;
const int BufferSize = 4096;
char buffer[BufferSizel;
 x -- -!
o-u
H _! O
=.u J
EOC
IJ o o
= IJ FJ
OEE
第14章多  线’程
    在生产者线程中，每次反复写入都是从获取一个“自由”字节开始的。如果该缓冲器中充满了
消费者线程还没有读取的数据，那么对acquire()的调用就会被阻塞，直到消费者线程开始“消费”
这些数据为止。一旦获取了这一字节，就用一些随机数据（如“A”、“C”、“G”或者“T?’）进行写入，并
且把这个字节释放为“用过的”字节，以便让消费者线程读取到。，    ，
    void Consumer：：run()
    {
    for (int i=0;i<DataSize; ++i){
    usedSpace.acquire();    .
    std::cerr<<buffer[i%BufferSizel;    .
    5pace, release()；
    )freeSpa
    std::cerr<<std::endl;
    )
    t    _
    在消费者线程中，我们从获取一个“用过的？’字节开始。如果缓冲器中没有任何可读的数据，
那么将会阻塞对acquire()调用，直到生产者线程生成一些可读的数据为止。’二旦获取到这个字
节，就打印出它并且把这个字节释放为“自由的”字节，这样生产者线程就可以再次使用其他的数
据复写它。
    int  main()
    {    ’
    Producer    j    ―
    PrOdUCe r producer;
    Consumer consumer：
    producer.start();    ：  ．
    consumer.st.art();
    producer.wait()；
    consumer.wait()；
    return 0：
    卜    ’
    _    _    、t。
    最后，在main()中，我们开启生产者和？肖费者线程。然后，生产者线程把一些“自由曲j’空间转
换成“用过的”空间，而消费者线程则可以把它再次转换为“自由的”空间。    ．
    当运行这个程序时，它会把一个含有100 000个“A-，I、“C”、“G”和“T，’的随机序列写入控制台
中，然后终止．。为了真正理解到底发生了什么，我们可以禁用写入输出数据，而让生产煮线程在每
次产生一个字节时输出一个“P”，让消费者线程在每次读取一个字节时输出一个？c”。为=j_更加简
单地跟踪这一过程，我们可以使用较小的DataSize和BuffetSize值。
    j    7r
    例如，这里给出的是当使用DataSize等于10且BufferSize等于4时的可能的运行结果：
“PcPcPcPcPcPcPcPcPcPc”。在这种情况下，只要生产者线程一产生字节，消费线程者就会迅速读取
它。也就是说，这两个线程的执行速度是一样的。另外一种可熊是，在消囊渚开始读取缓存之前，
生产者线程就已经写满了整个缓冲器，这样输出的结果就会是：."PPPPccccPPPPccccPPcc’：。-还有很
多其他可能的情形。信号为系统特定的线程调度程序提供了很大程度上的自由，利用线程调度程
序可以研究这些线程的行为并且可以用于选择一个适当的调度策略。
    对于使生产者和消费者线程同步的这个问题，另一解决方案是使用．QWaltCondition和QMutex。
QWaitCondition允许一个线程在满足一定的条件下触发其他多个线程。这样就可以比只使用互斥
量提供更为精确的控制。为了说明它是如何工作的，，我们将会使用等待条件来重新完成上述的生
产者一消费者例子。
const int DataSize = 100000;
const int BufferSize = 4096;     . .
char buffer[BufferSizel;   .
QWaitCondition bufferIsNotFull; .    '
QWaitCondition bufferIsNotEmpty;  .
QMutex mutex;
int usedSpace = 0;
  262    C++ GUI Qt 4编程（第二版）
    ------__---=.-__-__.........,,,,．一
    除了缓冲器之外，我们还声明了两个QWaitCondiUon、一个QMutex和一个变量，该变量用来存
储在缓冲器中有多少个“用过的”字节。
void Producer::run()
   for (int i = 0; i < DataSize; ++i) {
      ,      mutex.lock( ) ;
      while (usedSpace == BufferSize)
                                         buf fe rIsNot Full .wait ( &m u't ex )  ;
   .   buffer[i g6 BufferSizeJ = "ACGT"[ui凸t(std::rand(》 96 41
HusedSpace;
             bufferIsNotEmpty,wakeAll( ) ;
  ' mutex.unlock();
     }
    在生产者线程中，首先检查缓冲器是否已经写满。如果它已经被写满，就等待“缓冲器非写
满”这一条件。当满足这个条件时，就向缓冲器中写入一个字节，增加“用过的空间”( usedSpace)，
并且触发任何一个等待“缓冲器非空”条件变为true值时的线程。
    我们使用一个互斥量来保护所有对UisedSpace变量的访问。QWaitCondiUon：：wait()函数可以把
锁定的互斥量作为它的第一个参数，在阻塞当前线程之前它会解锁，然后在返回之前它会锁定。
    对于这个实例，可以把下面的while循环：    ‘’。i
    、    _
    while (usedSpace==BufferSize)    .
    bufferIsNotFull.wait (&mutex);
替换为如下的if语句：
    在目前为止提及的所有实例中，我们的线程都已经访问了这些相同的全局变量。但是在一些
多线程的应用程序中，需要有一个在不同线程中保存不同数值的全局变量。这种变量通常称为线
程本地存储( ffiread-local  storage)或者线程特定数据(thread-specific data)。我们可以使用一个联通线
程ID号[由QThread：：currentThread()返回]的映射来模仿它，但是更好的方法是使用QIhread-
Storge <T>类。
    在  、．    f冲
    可    缓
    者    待
・    鲈氲    等
    个k    疏
    一白    发
    辫，
    件
    条
    的
    空
    岍陶    非
    一一．，    一
    等
    ；e
    ●  ；●    它
    产臣    州  删一
    ・1上
    e S
    r    反
    他跳    rl什  ；    相
・    多斥    ‰蛐
    。，    好
    %  t    正
    L
。  ；    用互    一。¨H A
    [  e    ，
    ，。    者
z  ，    一叶00
    e  a    一
．T t    使个    吩  m t  w  ．
晤  no LUu f    ．
。  。    许这    V  c t u●~；
f  W    a O b  l，
t  ．    允用
U．，L
e)t    被占
  ．。；    圳  ¨蚍脚删v  u-‘
    V：，F k
    v o t u
    C 0 0
IIt u- -u cn伯盯阳州札
Il   u t●  们即
  0 0 k
e t -u cn c  我立
C n S 0
。。，．    ∽  ¨～川Ⅲ～咄叭舢
    ：S f e
。．r．  日=后
n x e X
-o e t O    一之
0g吖g一
。。。。    一．mm眦洲I吖E一．一一
    S―b m
，    ．  飙黼一．伯．    }s  费满
．T    ，    ，消写
    缸    非
    啪    ，    器
第14章多  线程
    QThreadStorge <I~的一种常见用法是用于高速缓存中。通过在不同线程中拥有一个独立的高
速缓存，就可以避免用于锁住、解锁和可能等待一个互斥量的计算开销。例如：
QThread5torage<QHash<int, double> *> cache;
void insertIntoCache(int id, double value)
{
     if ( !cache.hasLocalData(》
                  cache., setLocalData ( new  QHash<int ,  double》 ;
        cache.localData ( ) ->insert (id,  value) ;
}.
void removeFromCache(int idJ
{
   if (cache.hasLocalData(》
                        cache . localData ( ) -> remove ( id ) ;
}
    这里的cache变量在每一个线程中都保存一个指向QMap<int，double>的指针。（因为某些编
译器的问题，QThreadStorage <T>中的模板类型必须是指针类型。）在特定线程中第一次使用高速缓
存时，hasLocalData()就会返回false值，而且我们可以创建一个QHash <jnt．double>对象。  ，
    除了高速缓存之外，QThreadStorage‘4_>还可以用于全局错误状态变量（与ermo相似），这样可
以确保对某一线程的修改不会影响到其他的线程。
14.3与主线程通信
    当Qt应用程序开始执行时，只有主线程是在运行的。主线程是唯一允许创建QApplication或
者QCoreApplicat/on对象，并且可以对创建的对象调用exec()的线程。在调用exec()之后，这个线程
或者等待一个事件，或者处理一个事件。
    通过创建一些lhread子类的对象，主线程可以开始一些新的线程，就像上一节中所做的那
样。如果这些新的线程需要在它们之间进行通信，则可以使用含有互斥量、读二写锁、信号或者等
待条件的共享变量。但在这些技术中，没有任何一个可以用来与主线程进行通信，因为它们会锁
住事件循环并且会冻结用户界面。
    在次线程和主线程之间进行通信的一个解决方案是在线程之间使用信号一槽的连接。通常情
况下，信号和槽机制可以同步操作，这就意味着在发射信号的时候，使用直接函数即可立刻调用连
接到一个信号上的多个槽。    ’  ’
    然而，当连接位于不同线程中的对象时，这一机制就会变得不同步起来[这种状态可以遁过修
改QObject：：connect()中的第5个可选参数而改变]。在底层，实际是通过置入一个事件来实现这
些连接的。这个槽接着就会由线程的事件循环调用，而在该线程中存在着接收器对象。在默认情
况下，QObject存在于创建它的线程中，通过调用QObject：：moveToThread()可．以在任意时刻修改它。
    为了描绘线程之间的信号一槽连接是如何工作的，我们将查看一下在Image Pto应用程序中的
代码。该程序是一个基本的图像处理应用程序，允许用户旋转图片、重定义图片的大小以及改变
图片的色彩深度。这个应用程序（如图14.3所示）使用一个次线程在不锁住事件循环的情况下执
行对图片的操作。在处理非常大的图片时，这样做会在效果上产生很大的差别。次线程具有一系
列的任务，或者是“事务”，可以用来完成事件并发送事件给主窗口以报告进度。
         ImageWindow: :IriiageWindow(J
       {
        imageLabel = new QLabel;
-'-,         ' irnageLabel->setBackgroundRole(QPalette::Dark) ;  ,                                       . . .   . .       :.J,
                                                                                                                                                                                                                                                                                                                                                                  .                            .
黪黪阪盼鼯霞暨费露一㈠■¨√    ／
       264                                                         C++  GUI Qt 4编程 (第二版)
图14.3  Image Pro应用程序
round ( true) ;
:AlignLeft I Qt::AlignTop)
c reateActions ( ) ;
createMenus() ;
statusBa r ( ) ->showFleSSage ( t r ( " Ready'l ) ,   2000 ) ;
connect (&thread,  SIGNAL (t ransactionSta rted ( const  QSt ring &》
                  statusBa r( ) ,  SLOT ( showtdlessage (const  QSt ring &》 ) ;   .
connect ( &th read,   SIGNAL (allT ransactionsDone ( 》 ,
                  this,  SLOT ( allTransactionsDone ( 》 ) ;     .
    setCurrentFile(“”)；
)
茬ImageWindow：构造函数中
值得注意的部分是这两个信号_槽连接。
Thread对象发射的信号直接有关。稍后将介绍TransactionThread对象。
void   ImageWindow: : flipHo rizontally ( )
{         .
addTransaction (
new.  Fl'pTra:nsa ction ( Qt : : Ho,rizontal》 ;
宦们两个都与transaction-
    ：～  J    i
    flipHornontally()槽用来创建二个“翻转”事务并且用私有函数addTransaction()注册它。而flip-
Vertically()  .resizelmage()、convertT032Bit()、convertT08Bit()和convertTolBit()这几个函数都很相似。
void  ImageWindow: :addTransaction (Transaction  *t ransact )
          thread.addT ransaction ( t ransact) ;
          openAction->set Enabled ( false) ,
          saveAction->setEna bled ( false) ;
    saveAsAction->setEnabled(false)'; .  :  .  l   . :  :  .
}
k t r
uo a)
 ra -_ _a
aa r- m
r C _l
r00
r-l E CD
u- C m
O OE
IJ rl rl
ir --
 《 IJ
IJ iJ a)
o a) o.
cn cn -o
 A ' A 'rj
 I  I 3:
a) o m
n _a L
ra m rJ
J -J C
a) a) o
o. o.u
ra r, rJ
EEO
r+ r+ cn
1 2，+2。4∥jw2‘。矗5，碡强21
4蓬2嚣案黉震懈㈣懑燃
    7f／，
266    C++ GUI Qt 4编程（第二版）
T ra nsactio nTh read :  : ~T ransactionTh read ( )
{
     {
           QMutexLocker locker(&mutex) ;
               while  ( ! t ransactions.isEmpty( 》
          delete transactions.dequeue();
                       t ransactions .enqueue ( EndT ransaction) ;
             transactionAdded.wakeOne() ;
      }
       wait () ;
    在析构函数中，我们清空事务队列，并且给队列添加一个专门的EndTransaction标记。然后，在
基类析构函数被隐式调用之前，触发线程并使用QThread: /wait()等待到它结束为止。如果没有调
用wait()函数，则当线程尝试读取类的成员变量时极有可能导致失败。
    在调用wait()函数之前，QMutexLocker的析构函数会在其内部程序模块的末尾解锁互斥量。
调用wait()函数之前解锁互斥量是非常重要的；否则，程序将以死锁的情况结束：次线程将永久地
等待互斥量被解锁，而主线程则在进一步执行之前保持互斥量并等待次线程执行结束。
void  TransactionTh read: :addTransaction (Transaction  *t ransact)
{
    QMutexLocker locker(&mutex); '  .
         t ransactions .enqueue (t ransact ) ;
transactionAdded.wakeOne();
    addTransaction()豳数会把事务添加到事务队列中，并且如果事务线程还没有运行，就触发它。
所有对transactions成员变量的访问都由一个互斥量保护起来，因为主线程或许会在次线程遍历所
有事务的同时通过addTransaction()修改这些成员变量。    ，
        void  T ransactionTh read : : setlmage ( const  QImage &image)
    {
          QMutexLocker locker(&mutex) ;
      currentlmage = image;
    }
QImage  TransactionTh read : :image ( )
                                .
     QMutexLocker locker(&mutex) ;
   return currentlmage;
    sedmage()和image()函数可以让主线程设立一个图片，在该图片上可以执行事务处理，并且可
以在所有事务处理完毕耐找回最终的结果图片。
void TransactionThread::run()
{
   Transaction *transact = 0
   QImage oldlmage;
fo rever  i
     {
       QMutexLocker locker(&mutex)
if (transactions.isEmpty(》
transactionAdded.wait(&mutex)
t ransact  =  t ransactions.dequeue ( )
if (transact == EndTransaction)
 break;
oldlmage = currer.tlmaae
    第14章多线程    ，267
}.
emit  transactionSta rted (transact->message( 》 ;
QImage newlmage = transact->apply(ol.dlmage);
delete transact;
QMutexLocker locker(&mutex) ;
currentlmage = newlmage;
if (transactions.isEmpty(》
   emit allTransactionsDone()
    函数run()会遍历事务队列，并且可以通过对它们调用apply()函数依次执行每一个事务，直到
读到EndTransaction标记为止。如果事务队列为空，则线程在”事务添加”条件下等待。
    在开始执行事务之前，我们会发射tansactionStarted()信号并在这个应用程序的状态栏上显示
相应的消息。当所有的事务都已经处理完毕，会发射allTransa。tionsDone()信号。
class Transaction
{
public:  .
   virtual ~Transaction() {
virtual QImage apply(const QImage &image) -. O
virtual QString message() = O;
    Transac tion粪是一个用户可以对图片进行相关操作的抽象基类。需要通过一个Transaction指
针来删除Transaction子类的实例，因此虚析构函数是必要的。Transaction类有三个具体子类：
FlipTransaction、ResizeTransaction和ConvertDepthTransaction。这里将只查看FlipTransaction子类，其他
两个子类基本与此相似。
class FlipTransaction : public Transaction .
                                   .
public:
          FlipTransaction (Qt: : 0 rientation  o rientation)
QImage apply(const QImage &image) ;
QSt ring  message( ) ;      ,
FlipTransaction的构造函数带有一个参数，该参数用来指定翻转方向（水平翻转或垂直翻转．）。
QImage FlipTransaction::apply(const QImage &image)
{
           retu rn  image . mir ro red (o rientation―  Qt : :Ho rizontal
                                      orientation = Qt::Vertical) ;
}
apply()西数对QImage调用QImage：：mirrored()，它既作为接收参数也是返回值。
ost ring   FlipT ransaction: :message ( )
{
if (orient
       / return
}.else {
return
                                                .
ation == Qt::Horizontal) {
  QObj ect: : t r( " Flipping  image  ho rizontally.
QObj ect: : t r( " Flipping  image  ve rtically. . . " )
  C
  o
  IJ
  IJ
  C
    ' a)   .
  L
  o
  C
  o
  IJ
  ro
  IJ
  C
  L
 o
o ..  ,
IJ IJ
n, o
>
rl
L   .~
C++' GU[ Qt 4编程（第二版）
    message()函数返4回正在处理的操作的消息，这些消息会显示在状态栏中。当发射trarisaction-
Started()信号时，就会在transactionThread:：run()中调用这个函数。    ’
    Image Pro应用程序展示了Qt的信号―槽机制是如何使主线程与次线程之间的通信变得简单易行
的。实现次线程时要谨慎对待，因为必须使用互斥量来保护成员变量，而且必须使用二个等待条件以
在适当的时候停止或者触发线程。Q QuarterLy中“Morutors and Wait Conditions in Qt”系列文章的
http：//doc．trolltech．com/qq/qq21- monitors．html和http：//doc．trolltech.  com/qq/qq22- moru tors2．html，给出了
一些关于如何开发和测试那些使用互斥量和等待条件来保证同步的QThread子类的思想。
14.4在次线程中使用Qt的类
    当函数可以同时被不同的线程安全地调用时，就称其为“线程安全的”( thread- safe)。如果在不
  同的线程中对某一共享数据同时调席两个线程安全的豳数：那么‘结果将总是可以确定的。若将这
  个概念推广，当一个类的所有函数都可以同时被不向的线程调用，并且它们之间互不干涉，即使是
  在操作同一个对象的时候也互不妨碍，我们就把这个类称为是线程安全的。
    Qt中，线程安全的类有QMutex、QMutexLocker、QReadWriteLock、QReadLocker、QWriteLocker、
  QSemaphore、QThreadStoIage <T>以及QWaitCondition。此外，部分QThread应用编程接口和其他某些函
  数也是线程安全的，特别是QObject::connect()、QObject：：disconnect()、QCoreApplicationi：postEvent()以
  及QCoreApplication:: removePostedEvents().
    绝大多数Qt的非图形用户界面类都符合一个并不太严格的要求：它们都必须是可重人的(re-
  entrant)。如果类的不同实例可同时用于不同的线程，那么这个类就是可重人的。然而，在多个线
  程中同时访问同一个可重人的对象是不安全的，而是应该使用一个互斥量来保护这个类的访问。
  一个类是否是可重入酌，在Qt的参考文档中有标记。通常情况下，任何没有被全局引用或者被其
  他共享数据引用的C++类都认为是可重人的。
  ．  QObject是可重人的，但有必要记住它的三个约束条件：
    1．QObject的子对象必须在它的父对象线程中创建
    特别需要说明的是，这一约束条件意味着在次线程中创建的对象永远不能将QThread对象作
  为创建它们的父对象，因为QThread对象是在另外一个线程（主线程或者另外一个不同的次线程）
  中创建的。
    2．在删除对应的QThread对象之前，必须删除所有在次线程中创建的QObject对象
    通过在QThread::run()中的堆栈上创建这些对象，就可以完成这一点。
    3．必须在创建QObject对象的线程中删除它们
    如果需要删除一个存在于不同线程中的QObject对象，则必须调用线程安全的QObject:：
  deleteLater()函数，它可以置人一个“延期删除”(deferred delete)事件。
    一些非图形用户界面的QObject子类，如QTimer、QProcess，以及用于网络方面的类都是可重人
  的。只要任意线程处于事件循环中，就可以在这个线程中使用它们。对于次线程，通过调用
  QThread:：exec()或者其他方便函数，如QPtocess:：waitForFirushed()和QAbsUactSocket：：waitForDiscon-
  nected()，都可以启动一个这样的事件循环。
    由于从那些为Qt的图形用户界面支持提供编译的低级库上继承的局限性，Qyridget和它的子
  类都是不可重人的。这样造成的后果之一就是我们不能在一个来自次线程的窗口部件上直接调
  用函数。打个比方说，如果想从次线程中修改一个QLabel中的文本，则可以发射一个连接到QLa-
    ，f，
    第14章多线程    269
    ____-_______.________________‘___._一
bel:：setText()的信号，或者从该线程中调用QMetaObject,::.invokeMethod()。例如：
    _    ．．．    ‘    ’    【
    QMetaObj ect::invokeMethod (label,  SLOT( setText( const  QSt ring＆)),    ’
    Q_ARG(ostring,“Hello”));    ’
’    …    ：
    )
    ，    ‘
    ‘    ．    ，
    很多ot的菲图形用户界面类，包括Qlmage、QString和一些容器类，都使用了隐式共享作为一
项优化技术。虽然这样的优化通常会让类变成不可重人的，但在Qt中这不是一个大问题，因为Qt
使用原子汇编语言指令(atomic assembly language instructjon)来实现线程安全引用计数，这可Ⅸ让Qt
的隐式共享类变成可重人的。    ”’  ？’    i
    Qt的QtSql模块也可用于多线程的应用程序，但是它埠有其约束条铲，这个条件因数据库的不
同而不同。有关的详细情况，请参考．http.://dgc.trolt矗l1．三面一    ive，．h扛【】l。有关多线程注意
    ：    、；e乎1粤
事项的一个完全到表，可以参考’http：／棚oc，tI棚tech．coⅡ蝉．3／threads二h叫。．．．  ．
    ．    ：一    ．    ．
、
          ..'
     .        '..
第15章  网    络
    Qt提供了QFtp和QHttp两个类与FIP和HTIP协议配合使用。这些协议的使用让文件的下
载和上传变得更加容易。另外，HTIP协议也使向网站服务器发送请求并重新找回结果的过程变
得简单易行。
    Qt还提供了较低级的‘QTcpSocket和QUdpSocket类，它们将实现TCP和UDP传输协议。TCP是
一个可靠的面向连接的协议，它按照网络节点间传输的数据流形式进行操作；UDP是一个不可靠
的无连接协议，它主要基于网络节点间离散信息包的传输。这两个协议都可以用于创建网络客户
端和服务器应用程序。若要创建服务器应用程序，还需要QTcpServer类来处理引入的TCP连接。
我们可以使用QSslSocket代替QTcpSocket来建立安全的SSUTLS连接。
1 5．卜写, FTP客户端
    QFtp类在Qt中实现了FIP协议的客户端程序，它提供了非常多的函数来执行多数常见的FTIP
操作，同时还可，以执行任意的FIP指令。
    QFtp类是异步工作的。若调用一个像get()或者put()这样的函数，它会立即返回并且仅在控
制权回到Qt的事件循环时才发生数据传输。这样就确保了在执行FIP指令时，用户界面可以倮
持响应。    ，
    我们将从如何使用get()函数获取一个单一文件的例子开始讲起。该例子是一个名为ftpget
的控制台应用程序，它可以下载指定命令行上的远程文件。首先看看main()主函数：
                 QCoreApplication app(argc,  argv) ;
                          QSt ringList  a rgs  -. QCo reApplication: :a rguments ( ) ;
          if (args.count() 1= 2) {
             std::cerr   "Usage: ftpget url"<< std::endl
                        "Example:"<< std::endl
《 u   ftpget ftp://ftp.trolltech.com/mirrors'l
                      .    << std::endl;
             return l;
          }                            ,
         FtpGet getter;
                              if   ( !getter.getFile ( QU rl( args [1J 》 )
             return l;
                       QObj ect:: connect (&getter,  SIGNAL (done ( 》 ,  &app,  SLOT(quit ( 》 )
                     return  app.exec( ) ;
           }
    我们要创建一个QCoreApplicaUon而不是它的子类QApplication，以避免连接到QIGui库。
QCoreApplication：：arguments()函数返回命令行参数作为一个QStringList列表，采用第一项作为程序
被调用时的名称，同时删除掉诸如- style型的所有Qt指定的参数。main()函数的核心是构建FtpGet
对象和getFilc()调用。如果该函数调用成功，就会让事件循环一直运行下去，直到下载完毕。
    FtpCet子类完成了所有的工作，其子类的定义如下：
class FtpGet : p'ublic QObject
{
Q_OBJECT
public:
   FtpGet(QObject *parent = 0);
bool getFile(const QUrl &url)
signals :          .
   yoid done()
private slots:   .
   void ftpDone(bool error),
private: .
   QFtp ftp;
   QFile file
J,
    这个类有一个公有函数getFile()，可用来获取由URL指定的文件。QUrl类提供了一个高级接
口，用来提取URL的不同部分，如文件名称、路径、协议和端口。
    FtpGet有一个私有槽ftpDone()，当文件传输完成时，就会调用它；而当文件下载完成后，它将
发送一个done()信号。这个类还有两个私有变量：ftp变量和file变量，前者的类型为QFtp，封装一
个到FIP服务器的连接；后者用来向磁盘写入所下载的文件。
 FtpGet : : FtpGet ( QObj ect  *pa rent)      .
.  : QObject(parent)
{
         connect (&ftp,   SIGNAL ( done ( bool》 ,  this ,   SLOT( ftpDone( bool》 ) ;
}.
在构造函数中，我佃把QFtp：：done( bool)信号与ftpDone( bool)私有槽连接起来。当所有的
都已处理完时，QFtp就发射done( bool)信号，bool参数指明是否有错误发生。
bool  FtpGet: :getFile ( const  QU rl  &u rl)
{
   if (!url.isValid(》 {
Invalid URL"<< std::endl
if (url,scheme() != "ftp") {
    std::cerr<< "Error: URL must start.with 'ftp:"'<< std::endl;
   return false;
}.
if (url.pa.th().isEmpty(》 {  .
   std::cerr   "Error: URL has no path"<< std::endl;
   return false;
ost ring  localFileName  =  QFilelnfo ( u rl.path ( 》 , fileName ( ) ;
if (localFileName,isEmpty(》
   localFileName = "ftpget.out";
file . set FileName (localFileName) ;           '
if  ( ! file.open(QIODevice: :WriteOnly》  {
   std::cerr<< "Error: Cannot write file "
             .    << qPrintablecfile.fileNamec))《“: "
    << qPrintable(file.errorString(》<< std::endl
   return false;
                                                                                             .
ftp, connectToHost ( u rl. host ( ) ,  u rl,po rt ( 21》 ;
ftp.login ( ) ;
ftp.get(url.path(), &file);    .
请求
L
o
L
L
LU
=
V (L
V cn
L L_
uc
.. L
.. =  '
o IJ
4J o
cn L
  th
时返
用户
  口号
  密码
  完成
  C++GUI Qt 4编程（第二版）
  getFile()函数首先检查传人的URL。如果遇到问题，该函数将打印出一条出错信息到cerr，同
  回false以表明下载失败。
    ．Ⅳ    ．  ．    -．    ．
通过对ftpget．out的备份，我们可以试图利用URL自身创建一个合理的本地文件名而不是让
    ：    ，．
自己虚构一个文件名。如果打开文件失败，就会打印出错信息并返回false。
接着，利用QFtp对象执行一个含4+个FIP指令的序列。url.port(21)调用返回在URL中指定的端
；如果在URL中并莱藉楚往椅端口号，则返回端口21。因为没有给login()函数任何用户名或者
，所以此处需要一个匿名登录j get()呼氆糍=个参数指定了输出信号的I/O设备。  ‘
这些兀P指令在Qt’的事件循环中排队并等待执行。QFtp的done( bool)信号表明这些指令的
情况，构造函数中已经把这个信号与ftpDone(bo01)连接起来了。
          void  FtpGet: : ftpDone (bool',e rro r)                   - '
      {
      if (error) {
     ,errorString(》
:, . ::':-". st.d:::cerr,吓rro:r{dt:<<:qPrin:table(ftp,er
          std::cerr   "File downloaded as "
    << qPrintable(file.fileName( 》<< std::endl;
         }    .
             file.close( ) ;
     . emit done();
    逮些FIP指令一旦得以执行，就可以关闭相应的文件并且发射我们自己的done()信号。在此
处关闭文件而不在getFile()函数最后通过调用ftp. close()来关闭文件，显得有些不同寻常；但是请
牢记：在返回getFile()函数之后，兀P指令会异步执行并且整个执行过程会非常顺利。
    QF-'tp提供了一些FIP指令，包括connectToHost()、login()、close()、list()、cd()、get()、put()、re -
move()、mkdir()、nndir()ifU rename()。所有这些函数都可以调度一个兀p指令，并且可以返回一个
标识这个指令的ID号。对于传输模式（默认为被动模式）和传输类型（默认为二进制数据）的控
制，也是可能的。
    使用rawCommand()可以执行任意的FIP指令。例如，以下是如何执行一个SrIE CHMOD指令
的代码：    。
    ftp. rawCommand(“SITE CHMOD 755 fortune“);
    当QFtp开始执行一个指令的时候，它发射commandStarted( int)信号，而当这个指令完成的时
候，它发射commandFinished (int，bool)信号。int参数是标识一个指令的ID号。如果对个别指令的
结果感兴趣，则当调用这些指令的时候，可以保存这些ID号。了解并记录这些ID号可以为用户
提供详细的反馈信息。例如：
    .bool FtpGet::getFile(const QUrl &url)
 connectld = ftp.connectToHost(url.h
 loginld = ftp.login() ;
  getld = ftp.zget (url_,path( ) .  &file) ;
 closeld = ft'p.ctose{);    .. .  : ' .
P,return true,.-.:: ' .   .    . :
void FtpGet::ftpCommandStarted(int id)
{
   if (id == connectld) {
，一。’
-- o
OL
rn rJ
o
UL
.=
o IJ
IJ o
                   r l.
274    C++ GUI Qt 4编程（第二版）
if . ( ! url.isValid.( 》  {       .
   std::cerr<< "Error: Invalid URL"   std::endl;
   return,"false; .
}
if (url.scheme() != ':ftp") {
4  std::-cerr <<<Error: URL must start with 'ftp:"'.《 std::endl;
   return false;
}
ftp. connectToHost( u rl.host( ) ,   u rl. po rt ( 21》 ;
ftp,login ( ) ;
QString path = url.path() ;
if  (path.isEmpty(》
path.=”／¨；
pendingDirs.append(path)
processNextDirectory( ) ;
return true:
    当调用getDirectory()函数时，它首先要做一些检查，如果一切正常，就试图建立一个FI'P连接。
它对必须要处理的路径进行跟踪，并调用processNextDirectory()，以开始下载根目录中的文件。
  :, void  Spider::p rocessNextDirecto ry‘’
    ’if( !pendjngDirs.isEmpty()){
    cu rrentDir=pendingDirs. to keFirst();
    currentLocalDir=”.downloads／‘‘+currentDir;
    QDir(“.”)一．mkpath(currentLocalDir);
ftp.cd(currentDir)
      ftp.list( ) ;
 else {
   emit done();
J
    processNextDirectory()函数从pendingDirs列表中取出第一个远程目录，同时在本地文件系统中
创建一个相应的目录。然后它告诉QFtp对象将目录更改为被取出的目录并列出其中的文件。对
于Lst()处理的每一个文件，它都将发射一个促使ftpListlnfo()槽被调用的Lstlnfo()信号。
    如果没有需要处理的目录了，该函数将发射done()信号以表明下载完成。
void  Spide r: : ftpListlnfo ( const  ou rllnfo  &u rlln fo)
                                        .
  if (urlInfo,isFile(》 {
      if (urlInfo.isReadable(》 {
             QFile *file = new QFile(currentLocalDir + "/"
                                  + urllnfo.nama(》;
if  ( ! file->open (QIODevice: :WriteOnly》  {
   std::cerr<< "Warning: Cannot write file "
    <<  qP rintable ( QDir: :toNativeSepa rators (
                                                      file->fileName ( 》 )
《 ": Il<< qPrintable(file->errorString(》
    << std::endl;
    return
r
                   ftp.get ( u rllnfo, name (') ,   file j ;                  .
               openedFi}es,app.end ( file) ;       .   . .:  . .'
     }
 else if (urlInfo.isDir() && !urlInfo.isSymLink/》 {
        pendingDirs ,append ( currentDrr  +  "/"  +  urllnfo,name ( 》
                         275
     _--__h__________________一  -r-_
    ftpListlnfo()槽的urLlnfo参数提供了有关一个远程文件的详细信息。如染这个文件只是一个可
读的普通文件（而不是目录），就调用get()来下载它。这个用于下载的QFile对象是利用new函数
以及一个指向它在openedFiles列表中存储的指针来分配的。    ：
    虫口果QUrLlnfo持有一个不是符号连接的远程目录的细节信息，就将这个目录加到pendingDirs
列表中。之所以要跳过符号连接，是因为它容易导致无穷递归循环。
    void  Spider::ftpDone( bool  error)
    {
    if (error){
    std::cerr<<‘‘Error:‘‘<<qPrintable( ftp.er ro rSt ring())
    << std：：endl：
    } else{    ．
    std::cout<<”Downloaded‘‘<<qPrintable(currentDir)<<.‘to“    ，
    <<  qPrintable( QDir::toNativeSepa rato rs(
    QDir( cu rrentLocalDir).canonicalPath()));
    }
    qDeleteAll(openedFiles);
    openedFiles-clear()：
    processN苣xtDirectory();    -
    }
    ．    ？    ’
    当所有这些nP指令都完成后，或者如果有错误发生时，就会调用ftpDone()槽。我们删除
QFile对象以防止内存泄漏，同时也关闭每一个文件。最后，调用proceS。№乎tDirecto耐．）三如果还有
需要处理的目录，整个过程将从列表中的下一个目录重新开始；否则，下载过程停止并且发射done()
信号。
  如果没有错误发生，FTIP指令和信号的序列如下：
    ，    ，    _
    co^nectToHost(nost,_Dort)
    login()
    cd（以rectory二1）    -
    Ust()，
    emit UstInfo（nZe一】一】）
    。    ，
    get（nZe―l一】）    一
    ：    ．
    8…it u5tI“fo（nZe一】j）    ，
    get（“Ze一】-2）
cd(directory_N)
list ()
   emit listlnfo(f/Le_N_1)
                           g et ( fi L e_N_1)
  . emit listlnfo(f/Le_N_2)
             get ( fi Le_N_2)
    的“
    中一
    龄一    椰滁
    ，挑撒氩
    引n
    扪”
    幽一一一
    、一
    哩H嬲蝴
    盐矿
    睥盯
    到企
    人比
    ，¨k
    勘“
    将一一～～一
    它薪
    霸州挑晰
    篇  一
    培一一一
    际时
    实完
    件载
    史F一一硼糕
，眈防
一州研姘计一
．吡髁廿    一一
    骺一一劐㈣
276    C++ GUI  Qt.4编程（第-版）
下载一个文件，并且在调用下一个新的GET操作之前等待done( booL)信号。在li,stlnfo()中、，将简单
地把文件名追加到―个QStringList中，而不是立即调用get()，而且在done(bool)中；我们将对下一个文
件调用get()函数以在QSmnust中下载。于是，整个执行顺序看起来可以归结如下i‘  -’’
    connectToHost{host    2 z    ．，    ．：    ：
    connectToHost'nojt,port)  j
    login()    ．、’    _一
    cd(directory_l)    ，    ，．    。．
    list()
cd (djrectory_N)     :
list()
   emit listlnfo(f//e_l_l)     :  .
        emit  listlnfo (f/le_1_2)           '
 emit  listlnfo (f/le_N_1)
'Emit listInfo.(file_N_2.)
'emit done()
:get ( f//e_l_l)
 :emit 'done( T;
get ( f/le_1_2)
emit done()
    get（file__止】）
    emit done()
    get（file_N2）
    emit done()+‘：    ‘
    另外一介解决方案是对每一个文件使用一个QFtp对象。这样可以通过一些单独的FTP连接
来并行下载这些文件。
int main(int argc, char *argv[l)
i   QCoreApplication app(argc,: argv);          :
         QSt ringList  a rgs  =  QCo reApplication: :a rguments.( )
if (args.coudt()
   std::cerr《
《
《
《
   return l;
}
Spider spider,
if   ( ! spider,getDirectory{ QU rl ( a rgs [ 1] 》 )
   return l;
QObj ect: :connect (&spider,   SIGNAL{done( 》 ,  &app,   SLOT ( quit ( 》 )
return  app.exec ( ) ;                .
  。main()函数完成了这个程序。如果用户没有在命令行中指定一个URL，就给出一个出错信息
并终止程序。
    在这两个nP实例中，利用get()函数获得的数据都被写入QFile中。但这样的做法并不是必
需的。如果想把这些数据放到内存中，则可以使用QBuffer，它是_个在QByteArray上操作的QIO-
Device的子类。例如：
／
     .1上
      L
     L_
      u
 cu
   ..    J
  N.  r
 Or
 Jo
   cn    L .~
   Y删 40州
 QJQ
   L -O \ O
      cn O_ u)
 LJ
   Q v L_ y
 ov  v
  rl  L
  a:  o:
    cn .. -o Q
         O  rl -O
   o o- cn c
，g E    L_
II岭欧   2
‘舞、蠢2强潦鹜避蓬锶勰鳓涮潮潮
第15章二网  络
.QBuffer.*buffer = new QBuffer;
'  buffe r->open ( QIODevice: :WriteOnly) ;
  ftp.ge:t ( u rl-lnfo.name ( ) ,  buffe r) ;   .
    也可以省略get()中的输入／输出(I/O)设备参数，或者只传递一个空指针。然后每次当有新数
据可读的时候，QFtp类就会发射二个readyRead()信号，并且可以使用read()或者readAll()来读取
这些数据。    t
15,2  写HTTP客户端
普通
经阅
QHttp类在Qt中实现了砌Ⅲ，协议的客户端程序。它提供了各种各样的函数来执行绝大多数
rrrP操作，包括get()和post()，并且还提供了一个发送任意irrIP请求指令的方式。如果已
读过前面有关QFtp的章节，那么将会发现QFtp和QHttp之间存在很多相似之处。
    QHttp类是异步工作的。当调用一个像get()或者post()这样的函数时，它会立即返回，并且当
控制权回到Qt事件循环时才会开始传输数据。这样就确保了在处理I-nTP请求时，应用程序的用
户界面可以始终保持响应。    一  ，
    我们将查看一个名为httpget的控制台应用程序，以谠明如何利用．rrrP协议下载_个文件。
这里将不再显示出头文件，因为它和前一节所使用的那个ftpget例子，不论在功能上还是实瑰过程
上，都非常相似。    ：：一j-o
    HttpGet::HttpGet(QObject  *pa rent)    j’一。.  ;’7+.
    ：QObject(parent)
    {
    connect (&http    ’  H__'’
    connect(＆http,  SIGNAL (done( bool)),this,  SLOT( httpDone( bool)));    j,..,:    .
    }
在构造函数中，我们把QHttp对象的done( bool)信号与httpDone( bool)私有槽连接起来。．。i
    bool  HttpGet::getFile( const  QUrl＆u rl)
    {
if (url.scheme() l= "http") { .
        std : :ce rr《  "Er ror:  LIRL. w.ust  sta rt. with . ' http: ' ".《 :std: :fendl
   return false;
has no path"<之 std::endl
QSt ring  localFileName  =  QFilelnfo( u rl. path ( 》 . fileName ( ) ;
if  (localFileName.isEmpty( 》
   localFileName - "httpget,out";        ,    .
file . setFileName ( localFileName) ;
if (!file,open(QIODevice::WriteOnly》 { '    '
   std::cerr《 "Error: Cannot write file "
  .       .《 qPrintable(file.fileName(》《 ": "   ,
《  qPrintable (file.e rrorString( 》《  std: :endl
                                                                                                                                                     .     .
    return false;                   .    ',: '.
}
http.setHost( u rl. host( ) ,   u rl. po rt (80》
http.get ( url. path ( ) ,  &file) ;   .:  :      :
http.close(); .
return true;  .  .  '   ..    .   ',
甏黔”嘭黔‰轻≯。i，；■，．
 -O
  C
  o
 -O
  IJ
  v
 'v
    :
 J
 o:
 :J
 -O
  ra
  >
.C
 H
  L
  o
hJ L
  L
- LU
-:
O v a7 .
rl V Ln.
ra L ra
Ln a)
rJ U C
r .. =
L -O IJ
= iJ a)
-. Ln L
.-
    /-l     .
 =
IJ L   .
aL
E LLI
LU :
:v a7
 . v Ln
-C L f
IJ Q
ra u c
a- .. L
 . .. =
rJ -O lJ
L IJ a)
= Ln L
278    C++’：：GIJI Qt 4编程（第二版）
    getFile()函数执行与之前所给出的FtpCet：：getFile()一样可以执行同种类型的错误检查，并且采
用相同的方式来命名文件的本地文件名。‘当从网站获得文件时，由于不必登录，所以只要设置主机和
端口号(如果在URL中没有指定端口号，则采用默认的FrrIP.端口号80)，就可将数据下载到文件中，
因为QHttp:：get()的第二个参数指定了输出信号的输入输出(I/O)设备。’
    这些HrrIP请求在Qt的事件循环中排队并且被异步执行。QHttp的done( bool)信号表明了这
些请求的完成情况，在构造函数中已经把这个信号与httpDone( bool)连接起来了。
  ・    void  HttpGet::httpDone( bool  error)
    {
    if (error){
    std::cerr<<"Error:.‘<<qPrintable( http.errorSt ring())
    i、<< std::endl;    ：．‘
    ) else{    ’
    std::cerr'《 ,"File downtoaded as”    ．
    <<  qP rjntable( file. fileNameI))“std:: endl;
    }
    file.close()；’．    、，。一，  ，一、
    emit done();
    }
一旦完成了这些wrIP请求，就关闭这个文件，并在有错误发生时通知用户。
  i它的ma/n()函数与'ftpget中曾使用过的主函数非常相似：‘    、
    int main(int argc, char *argv【】)
    {
    QCoreAppLication  app(a rgc,a rgv);
    .ost ring List a rgs=QCo reApplication::a rguments();
if (args.count() 1= 2) {
    std::cerr<< "Usage: httpget url"<c stri::endi.
        .    << "Example:"<< std:.:endl
 .   .《 " - httpget http:/Jdoc,tro}ltech.com/index.html"
《 std::endl;     .
   return l;
                          '         ,'       .
}   .
QObj ect: :connect (&getter,  SIGNAL(done C》 ,  &app,  SLOT(quit{-》 ) ;
    retu rn  app.exec()；
    }
    QHttp类提供了多种操作，包括setHost()、get()、、post()c和：head()。如呆站点需要认证，则
setUser()可以用来提供用户名和口令。QHttp可以用程序员自编的套接字装置而不用其内部自带
的QTcpSocket。这就使利用可靠的QtSslSocket来在SSL(加密套接字协议层)或TLS(加密传输协议
层)上实现HrITP成为可能。
    为了向CGI脚本发送一列“name=value”值对，可以使用post'()函数：j
    http,setHost(”www. example. com”);
    http,post(”/cgi/somescript.py“,”x―200&y=320”,&file);
    既可以用8位的字符串来传递数据，也可以像。QFile -样，通过传递一个开放的QIODevice来
传递数据。为了获得更多的控制权，可以使用request()函数，它接收任意_个HrrIP的标题和数
据。例如：
    QHttpRequestHeader header(”POST”,”/search.html“);
    header.    ("Host”,Ilwww.t rolltech ,/com")；    一    ’
 header . s etContentType ( "ap plicatioii/x-www-fo rm-u rlencoded " ) ;
http. setHost ( "www. t rolltech. com",) ;,.  .  .
http. request ( header,   "qt-inte rest=on&sea rch=opengl " ) ;
，／
 o.
'r
 -}
  o
    rl .
 u-
.- IJ
LO
o g .-
IJ  . -
IJ L
ooc
c IJ L
  IJ =
IJ o IJ
o o.o
(D -. L
 o- -
IJ
IJ .+-
Z rl
7 6 p蔓。惩露硼潞溢
第15章网  络
  。当QHttp开始执行请求时，它会发射requestStarted (.int)信号，，而当这个请求完成时，会发射
requestFirushed(int，bool)信号。int参数是标识请求的ID号。如果我们对个别请求的结果感兴趣，
就可以在调用这些指令的时候保存ID号：了解并记录这些ID号可以为用户提供详细的反馈
信息。    ‘    ．，
．  一在绝大多数应用程序中，我们仅仅想知道整个系列的请求是否已成功地完成执行：通过与
done( bool)信号连接，就可以很简单地实现这一点，当请求序列变空时，就会发射该信号。
    当有错误发生时，这个请求队列会被自动清空。但是如果在错误发生之后使用相同的QHttp
对象调用新的请求，这些请求将会照常排队并被发送执行。
    与QFtp -样，QHttp不仅提供了read()和readAll()函数，它还提供readyRead()信号，使我们不
必指定某一输入／输出设备。
15.3写TCP客户／服务器应用程序
    QTcpSocket和QTcpServer类可以用来实现TCP客户端和服务器。TCP是一个传输协议，它构
成了包括vrP和rrIP等很多应用程序层的因特网协议基础，它也可以用于寇制用户自己的协议。
    TCP是一个基于流的协议。对于应用程序，数据表现为一个长长的流，而不是一个大的平面
文件。在TCP之上建立的高层协议通常是基于行的或者基于块的。    一  ，
    ．基于行的协议把数据作为一行文本进行传输，每一数据行都以一个换行符结尾o.
    ‘．基于块的协议把数据作为二进制块进行传输。每一数据块都是由一个大小字段及其包含
    的数据组成的。
    QTcpSocket间接地由QIODevice派生而来(通过QAbstractSocket)，所以它可以使用QDataStream
或者QTextStieam来进行读取和写入。与从文件中读取数据相比，从网络上读取数据会有一个值得
注意的差别：在使用>>操作符之前，必须确定已经从另一端接收了足够多的数据。如果没有接收
到足够多的数据就使用>>操作符，通常会导致不确定的状态发生。    ，
    这一节将查看一个客户端和服务器应用程序的代码，而该客户端和服务器应用程序使用了自
定义基于块的协议。如图15.1所示的客户端称为Trip Planner，它允许用户做出下一次乘坐火车的
旅行计划。而服务器称为Trip Server，它向客户端提供旅行信息。我们将从编写这个Trip Planner
客户端虚用程序开始。
图15.1  Trip Plarner应用程序
280    C++ GUI Qt-4编程【第二版）
    Tip Planner提供了一个From字段、÷个To字段、一个Date字段0●个Approximate Tithe字段以
及两个单选钮来选择火车出发或者到达的大概时间。当用户单击Search按钮，应用程序会向服务器
发送一个请求，服务器返回一个匹配这个用户要求的火车旅行列表。这个列表被显示在Trip Planner
窗口的QTableWidget中。窗口的底部是显示最后一次操作状态的QLabel和二个QProgressBar。
    利用Qt设计师，Tip Planner的用户界面被创建于一个名为tripplanher.; ui的文件中。这里，我
们会把注意力集中在实现应用程序功能的QDialog子类的源代码上：7    ，
#include "ui_tripplanner.h
class QPLrshButton;   :  ' ", .  . . .. :' . .
class -TripPlanner :'pubiit QDralog:-:private Ui,:/Tr.ipPlanner
   Q OBJECT      '
public:
  .  。丁 ripP.lanner(QWidget *parent = 0)
private slots:
   void connectToServer();
        void  sendRe_quest ( ) ;
   void updateTableWidget();
.  void stopSearch();
   void connectionClosedByServer();
   void error();
private:  .
  '     void  closeConnection ( ) ;
        QPushButton  *sea rchButton;
   QPushButton *stopButton;
   QTcpSocket tcpSocket;
 . quint16 nextBlockSize;  -
J,      ,
隙了
成的）。':.tcpS9c ket成员变量封装了TCP连接。
    ’  ，    -
BlockSiize变量。
'; '  ' TripPlanner::TripPlanner(QWidget *parentJ
                  :  QDialog ( pa rentJ
自Ui:：TripPlanner（它是通过IUC从tripplanner.tu牛生
在解析从服务器接收的数据块时，则会使用到next-
setupUi(this).;. .   4
searchButton = buttonBox->addButton(tr("&Search"},  ; '=  f :: .   .
                                                     .            '  QDialogButtonBox: :ActionRole) ;
stopButton = buttonBox->addButton(tr("S&top"),
                                                                  QDialogButtonBox: :ActionRole) ;
 stopButton->setEna bled (false) ;
 buttonBox->button ( QDialogButtonBox: : Close)- >setText (-t r( "&Quit " 》. ;
QDateTime dateTime = QDateTime::cur,rentDateTime();
 dateEdit->setDate ( dateTime. date ().),;
 timeEdit->setTime(QTime (dateTime , time ( ) .hou r( ) ,   0》
 tableWidget->ve rticalHeade r ( ) ->hide ( ) ;
 tableWidget->setEditTrigge rs ( QAbst ractItemView: : No EditT riggers ) ;
connect ( sea rchButton,   SIGNAL ( clicked ( 》
                this,  SLOT(connectToServer(》 ) ;
坐
源
电
类
一
。■
．取
    ''
，外
．乏
-山
X
 q1
  -o .N
   o --
   L -O
,LO
 oc
   i- g
  O_ H
 uu
   ._l rJ
 oo
  a- a-
   r.J r.J
     . _l  rJ
   cn cn
oo
  u
      . _l
  o
 a-
.- o
-- r.J
，-．、 . _l
a) cn
-o J
. _l  o
-C cn
AA
 :   I
co co
cn cn
cn cn
oo
a- a-
第一15章・网  -络
281
connect(stopButton,  SIGNAL( clic. ked ( 》 ,  this. . SLOT( stopSearch ( 》 )'
connect:(buttonBox, SIGNAL(rejected(.》, this: SLOT(reject(》); ..
                                                                                                                                             .     '    :'
connect
connect
codnect
codnect
&tcpSocket
&tcpSocket
this, SLOT
&tcpSocket
this, SLOT
&tcpSocket
this, SLOT
SIGNAL ( connected ( 》 ,  this ,  SLOT( sendRequest (-》 ) ;      .   'j
SIGNAL(discorinected(》,            .  . .      '    '   . '.  .!
connectionClosjzdByServer(》).: . :.,
 SIGNAL( readyRead ( 》.,       .
updateTabLeWidget(》); .: ' : r '
  SIGNAL ( e r ro r. ( QAbst ractSocket : :SocketError》
err6r()))；
构造函数中，我们基于当前的日期和时间来初始化日期和时间编辑器。我们也会隐藏进度
激活时才显示它。在Qt谩计师中，滚动条的nimmum和maxunum-属性都被
QProgressBar会表现得像一个忙碌的指示器而不是一个标准的基于百分比的
在构造函数中，还把QTcpSocket的connected()、disconnected()、readyRead()和.error( QAbstract-
7    。：ketError)信号与私有槽连接起来。
lSocket：：撒
！    void T ripPlanner::connectToSe rver()
tcpSoc ket . connectToHost ( "t ripse rve r, zugbahn .de" ,   6178 ) ;
tableWidget->setRowCount (O) ;
sea rchButton->setEna bled ( false) ;           .
stopButton->setEnabled(true) ;
statusLabel->setText (t r( " Connecting  to  se rver. . . " 》
progressBar->show( ) ;
    ．  ，  j  矗．+?jt，．j‘．．i■
    nextBlockSize=0：    ，，
    ．、    ，：’，‘‘…。一：
，    ，-．．  -；一。
当用户单击Search按钮开始搜索的时候，兢会执行connectToSen er()槽：‘我们萑QTcpSocket对
立起来并运行时，QTcpSocket对象发射connected()信号；如果连接失败，QTcpSocket对象会发射error
    ’    ‘    ．，    r
(QAbstlactSocket::SocketError)信号。    +.
    …，
    _    ^
    接下来，更新用户界面并且将进度条设置为可见。    ；
    最后，将nextBlockSize变量设置为o。这个变量用于存储从服务器所接收的下一个块的长度
    1    一
值。此处选择的是0值，这意味着还不知道下一个块的大小。    ’
 void  T ripPlanner: : sendRequest ( )
{..
   QByteArray block;                            , '    '
      QDataStream out(&block, QIODevicd:':WriteOnly) ;      .
           out. setVe rsion (QDataSt ream: :Qt_4_3 ) ;       .
    out<< quint16(0)<< quint8('S')<< fromComboBox->currentText();
    << toComboBox->currentText()≤< dateEdit->date() .  .  、‘; :'
《  timeEdit->time ( ) ;
if  (departureRadioButton->isChecked(》 {     .
 else {
     out<< quint8('At ) ;
9ut.deVice()->seek(0); . . .  ;l'    . '
out<<  quint16 ( block. size( )  -  sizeof (quint16》 ;
tcpSocket.write(block) ;
statusLabel->setText ( t r ( "Sending  request. . . " 》 ;
●在
282    C++ GUI Qt 4‘编程（第二版）
    当QTcpSocket对象发射connected()信号时，会执行sendRequest()槽，表明一个连接已经被建
立。这个槽的任务是向服务器生成一个请求，其中包含用户输入的所有信息。    ‘
  这个请求是如下格式的二进制数据块：
┏━━━━━┳━━━━━━━━━━━━━━━━━━━┓
┃qLunt16   ┃字节数据中块的大小（不包括这个字段）  ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃qtunt8    ┃请求指令类型（总是为‘S’）           ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QString   ┃出发城市名                            ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QString   ┃到站城市名                            ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃QDate     ┃发车日期                              ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃|QTime  + ┃火车大致运行时间                      ┃
┣━━━━━╋━━━━━━━━━━━━━━━━━━━┫
┃quint8  7 ┃火车发车时间(‘D’)或到站时间(‘A’)  ┃
┗━━━━━┻━━━━━━━━━━━━━━━━━━━┛
    首先把这些数据写到一个称为block的QByteArray中。不能直接把数据写到QTcpSocket中，因
为在把所有数据都放到这个数据块里以前，我们并不知道块的大小，而块的大小必须先发送出去。
    我们一开始写入0值作为块的大小，以及其他数据。然后，对输入／输出设备(在后台是由
QDataStream创建的QBuffer)调用seek(0)以重新移动到字节数组的开始处，同时利用数据块的实际
尺寸值覆盖最初写入的0值。这个尺寸值是通过由数据块的尺寸减去sizeof( qu：/nt16)（即2）计算得
到的，乜就是去掉前面容量字段所占用的空间。在这之后，对QTcpSocket调用write()向服务器发
送这个块。
void   T rip Pla rioe r :.;: updateTa bleWidget ( )
{ QDataStreamin(&tcpSocket);
          in .setVe rsion (QDataSt ream: :Qt_4_3 )
forever {. .
   int row = tabteWidget-.>rowCount()
if
}
if
(nextBlockSize = 0) {
 if (tcpSocket.bytesAvailable() < sizeof(quint16》
 in+>> nextBlockSize;       .
(nextBlockSize == OxFFFF) { .
 closeConnection ( ) ;
  status Label->setText (tr( "Found  %1  t rip Cs)“ )': a rg ( row》 ;
break;
if (tcpSocket.bytesAvailable() < nextBlockSize)
 break;
QDate date;
QTime departureTime;
QTime arrivalTime;
quint16 duration;
quint8 changes;
QString trainType;
in 》 date 》 departureTime 》 duration 》 changes 》 trainType;
arrivalTime = departureTime,addSecs(duration * 60);
tableWidget->setRowCount ( row +  1-) ;
QStringList fields;
fields<<  date.toString (Qt: : LocalDate)
    <<  depa rt u reTime.toSt ring (tr( "hh:mm"》
    <<  ar rivalTime.toSt ring (t r( "hh : mm"》
。+o‘喀鼍“错―筒箍
 --
     --
   . .    >  ,  .《 tr("asl hr %2 min".),arg(duration / 60)  .
                                     'g(duration % 60)
      .    <<QString::number(chalgr!s(C) .
    << trainType;
            for (int i = 0; i < fields.count(); ++i)
             tableWidget->setltem(row, i,
    updateTableWidget()槽被连接到QTcpSocket的readyRead()信号，只要QTcpSocket已经从服务器
收到新数据，就会发射该信号。服务器向我们发送一个和这个用户要求匹配的可能的火车旅行列
表。每一个匹配的旅行都作为一个单独的块发送，并且每一个块的开始都是块的大小尺寸值。
图15.2举例说明了这类数据块流。因为我们不需要每次从服务器得到一整个块的数据，所以
forever循环是非常必要的①。我们也许只是收到一个完整的块、一个块的一部分、一个块和一个块
的一部分，甚至还可能一次收到所有的块数据。  一    ．、  J‘    ．  ’
    ‘51字节}    、．48字节-    ．53字节》    ，
图15.2 Trip服务器的数据块
    forever循环是如何工作的呢？如果nextBlockSize变量力0，则意味着还没有读取到下一个块的
大小。我们尝试去读取它（假设至少已经有两个字节读取）。服务器使用一个大小为OxFFFF的值
来表示没有更多的数据可以接收，所以如果读取到该值，就表明已经读取到数据块的末尾了。
    如果块的大小不是OxFFFF，则尝试去下一个块中读取。首先，我们查看是否有块的容量大小这
么多字节可以读取；如果没有，就先在这里停止。当有更多数据可以读取的时候，readyRead()信号将
会被再次发射，然后就可以再次尝试读取。    ，    ，
    一旦确认一个完整的块已经被读取到，就可以在QDataStream上安全地使用>>操作符以提取
与一个旅行相关的信息，并且可以使用这些信息来创建QTableWidgetltems。从服务器上接收的块
具有如下格式：
┏━━━━┳━━━━━━━━━━━━━━━━━━━━━┓
┃quint16 ┃字节数据中块的大小（不包括这个字段）  ．  ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━┫
┃QDate   ┃出发日期                                  ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━┫
┃QTime   ┃出发时间                                  ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━┫
┃qtunt16 ┃持续时间（以分钟计）                      ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━┫
┃qLunt8  ┃换乘次数                                  ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━┫
┃QString ┃火车类型                                  ┃
┗━━━━┻━━━━━━━━━━━━━━━━━━━━━┛
最后，重新将nextBlockSize变量设置为0，以表示下一个块的大小是未知的并且需要读取。
void  TripPlanner: : closeConnection ( )
{
      tcpSocket.close() ;
         sea rchButton->setEnabled (t rue) ;
         stopButton->setEnabled ( false) ;
progressBar->hide();
}
④foreve.r关键字是Qt自带的，它可以简单地展开为for(；；)。
H
. -l
E
H
. -l
o
'rD
l-
 o
     J[
  N
     . -l
  u
 ca
  IJ
  x
  rH
   rH
C++. GUI Qt;4编程（第二版）
    closeConnection()私有函数关闭到TCP服务器的连接，并且更新了用户界面。，当读到OxFFFF、
时，它会被updateTableWidget()调用，并且在稍候要介绍的几个槽中，它也会被调用到。
void TripPlanner::stopSearch()
{
        statusLabel->setText (t r( "Search  stopped" 》
       closeConnection ( ) ;
)
    ~    ：    ．
stopSearch()槽被连擎到争toP按钽的clicked()信号o-从本质上来说，它只不过是调用closeCon-
nection()而已。
void  TripPla n ne r:  :connectio nClosedBySe rver ( )
                                         .
    if (nextBlockSize' != OxFFFF)
              statusLabel->setText (tr( "Error: Connection closed  by server"》 ;
       closeConnection ( ) ,                                                            .:
}
    connectionClosedByServer()槽被连接到QTcpSocket的disconnected()信号。如果服务器美闭这个
连接且我们还没有收到OxFFFF数据终止符，就告诉用户有一个错误发生了。我们会像往常一样
    ・1j    一  ，    ’
调用closeConnection()来更新用户界面。，，，  ，  ，  。，  ：
void TripPlanner::error( )
{
          status Label->setText ( tcpSocket .erro rSt ring ( 》
   closf;Connection();            , . ::  . *'
    error()槽被连接到QTcpSocket的error(QAbsuactSocket：：SocketError)信号。我们忽略错误代码
而使用QTcpSocket:：errorString），它将为最后一次发生的错误返回一个用户可读的出错信息。
    所有这些都是为了TripPlanner．类。Trip，Planner应用程序的main()函数正如我们派生自预期的
那样：
    int main(int argc, char *argv【】)
t'j t  ,QA:ppi'/c:at;orr/app{:(argc:'.’argv)；：‘，    ．
    TripPlanner tripPlanner;
    tripPlanner.show()；
．：．-.-ret.u:r.n.:app.exec(.)≯    ’n_  。．‘
    ):’.”,、    ≥、、,  .;.v._  i7.    ,．立．  i    ’    ，
    现在来实现服务器。服务器包含两个类：啊pSenrer和ClientSocket。
erver，这是一个允许接收来访的rI℃P连接的类。ClientSoc幽重新实现了
．TripServer类派生自QTcpS-
QTcpSocket，处理一个单独的
连接。在任何时候，在内存中ClientSocket对象的数量和正在被服务的客户端数量都是一样多的。
public:
   TripServer(QObject *parent = 0);
private:
   void incomingConnection(int socketld)
};
tripServer类通过QTcpServer重新实现了incomingConnection()函数。只要有一个客户端试图连接到
服务器正监听的端口，这个函数就会被调用。
TripSe rver: :T ripSe rver(QObj ect  *pa rent )
   : QTcpServer(parent)  .
{
)
，．，∥
>
o
}-
a
u
. -l
_J
=
>
L
a)   }-
a  LU
tripServer'构造函数则非常普通。
void TripServer::incomingConnection{int socketld)
{
   '. ClientSocket *socket = new ClientSocket(this);
         socket->setSocketDesc ripto r( socketld) ;
}
  在incomingConnection()中，创建了一个ClientSocket对象作为tripServer对象的子对象，并且将它
    ：+
的套接字描述符设置成提供给我们的数字。当连接终止时，ClientSocket对象将自动删除。
public:                       .    .
   ClientSocket(QObject *parent = O);
private slots:
 . void readClient()
private: .
   void generateRandomTrip(const
                      .    const
quint16 nextBlockSize;
，一j’  。  j  、-、    ．，一  ．，
j一_0．：一。’．，：一
QString &from, const QString &to:  .
QDate &date, const QTime'&time);'.,e =
ClientSocket粪派生自QTcpSocket并且封装了一个单独客户端的状态。
CljentSocket : : ClientSocket (QObj ect  *pa rent)
 . : QTcpSocket(parent) .
：’。‘~'…t州j；：？j
．：，’”』。j。0 1：矗骑，
o，。囊三。■融并器，。f．  ．7…．
 conr/ect ( this ,   SIGNAL ( readyRead ( 》 ,   t) hj:thiS}OgLC( _a'dClie:;t(1) 》 :).)掌二
 connect (.t his ,   SIGNAL ( dis connected ( 》 ,                  SLsOT ( deleteLater( 》") f_.
nextBlockSize = o
)
    ．  ≯‘
曩．：  ：：．h：
在构造函数中，我们建立了必要的信号一槽的连接，并且将ne)aBlockSize变量设置为0，这表示
    ，’    。  L
还不知道由客户端发送的块的大小。
    discorinected()信号被连接到deleteIJater()，这是一个从QObject继承的函数，邕控翻权返回到Q
的事件循环时，它会删除对象。这样就确保当关闭套接字连接时，ClientSocket对象会被删除。
    。    ’、    ，    ’．，、  “一-，_。‘‘    嚣
    void  ClientSocket:: readClierit()    -    +、’  …+..:j’
   QDataSltream in(this); ' '
in.setVersion(QDataStream:
  t；  。    ，  ．
：Qt-4二3）■
if (nextBlockSize == O) {
   if (bytesAvailable() < sizeof(quint16》
                  retu rn,
   in 》 nextBlockSize;
}
if (bytesAvaitable() < nextBlockSize)
return,
quint8 requestType
QString from;
QString to;  .  .
QDate date;
QTime time;
quint8 flag;
in 》 requestType;
if (requestType =- 'S') {
   'in 》 from 》 to 》 date 》 time 》 flag;
         .,
       :;
         .: .
     ':
IJ
o
u
o
Ul
o-
u
l-
a
rl
-o .
=
o-
IJ        .
o
o
 o      LU .
rl    r)
uo
                                       I
.- "      )
 -    'i
 :>        : 1
   .     .
 ,    N
  .'      : .
彰强酝擎辩黪m黪黪鼗≯豫彬善棼静童誊臻黼辨黪鼢譬F；，￡。0；j．。，i一：i。
    _一，
  286    C++ GUI Qt 4编程（第二版）
std:fsrand(from,length() * 3.600 + .to.length() '* 60
int numTrips = std::rand() 96 8;        "      :
for (int i = 0; i < numTrips; ++i)
   generateRandomTrip(from, to, date, time);
         QDataSt ream ..out ( this ) ;
   out<<'quint16(OxFFFF)
}
close() ;
  readCLient()槽被连接到QTcpSocket的readyRead()信号。如果nextBlockSize为0，就首先读取块
的大小；否则，就表明已经开始读取它了，，并且还要检查是否读取一个完整的块的时机已经到来。
一旦一个完整的块已经为读取做好准备，就一次读取它。我们直接在QTcpSocket( this对象)上使用
QDataSU-eam，并且利用>>操作符来读取各个字段。
    一旦读取了客户端的请求，就生成二个应答。如果这是二个真正的应用程序，我们就会在一
个火车时刻表数据库中查找信息并且试图找到相匹配的火车车次，但是这里我们使用一个称为
generateRandomTrip()昀函数来生成一次随机的旅行就够了。我们任意次地调用这个函数，然后发
送OxFFFF表示这个数据的结束。最后，关闭连接。
void ClientSocket::generateRandomTrip(const QString & /* from */,    .
        const QString & /* to */, const QDate &date, const QTime &timel
                                                                                  .
  QByteA.rraybI:~k<&block::IC . :                . '  .
 ,:- QDataSt.ream ouf{         :',  QIODevice: :WriteOnly) ;
         out. setVe rsion(QDataSt ream: ':Qt_4_3) ;   .
   quint16 du.r.ation = std::.rand() % 200;
   out<< quint16(0)<< date<< time<< duration<< quint8(1)
.    << ostring("InterCity");
:    out.device()->seek(0) ;
   out<< quint16(block.size() - sizeof(quint16》;
      write(-bloc.k) ;
    generateRandomTrip()函数展示丁如何在一个TCP连接之上发送一个数据块。这与客户端程序
    ．．    ’J    ．
的senciRequest）函数中的做法i见281页）非常相似。我们再一次把这个块写入到QByteAnay，这样
就可以在使用write()发送数据之前知道它的大小了。
. int main(int argc, char *argvll).
    {
     QApplication app(argc, argv);
     TripServer server;
     if (!server.listen(QHostAddress::Any, 6178》 { . .  :
         std::cerr<< "Failed to bind to port"   std::endl;
        return l;
          }
QPushButton  quitButton (QObj ect: :tr( "&Quit " 》 ;      .
quitButton: setWindowTitle (QObject: :t r( "Trip  Se rver" 》
QObj ect : : connect ( &quitButton,   SIGNAL ( clicked ( 》 ,
                              &app,  SLOT(quit ( 》 ) ;
quitButton.show() ;
return app.exec();
    在main()中，我们创建了tripServer财象和允许用户停止服务器的QPushButton。我们通过调用
QTcpSocket：：listen()来启动服务器，它将具有我们想接收的连接的口地址和端口号。专门的地址
0.0.0.0 (QHostAddress:：Any)表示在本地主机上的任意的口接口。
、键案《。囊黧v
第15章网  络
    在程序开发中，使用QPushButton来代表服务器是非常方便的。然而，一个配备过的服务器应
该运行于没有图形用户界面的情况下，就像Windows服务或者UND(的端口监控程序一样。为此，
Trol[tech公司提供了一个名为QtSenrice的商用扩展软件来辅助实现这一功能。
    现在就完成了这个客户朋艮务器实例。在这个实例中，我们使用了一个基于块的协议，它允许
使用QDataSUeam来读取和写入。如果想使用基于行的协议，最简单的方式是在一个连接到ready-
Read()信号的槽中使用QTcpSocket的canReadLine()和readLine()函数：
    QStringList  lines；
    while( tcpSocket. canReadLine())
    lines. append( tcpSocket. read Line());    ’
    然后，处理已经读取的每一行。至于发送数据了可以通过在：QTcpSocket上使用qrext;Stream来
完成。    一
    这里使用的服务器实现，在同时有较多连接的时候，不能很好地并行工作。其原因在于：当处
理某一个请求时，并没有同时处理其他连接。一个更好的方式是为每一个连按启动一个新的线
程。位于Qt巾examples/network/threadedfortune senrer目录下的例子Threaded Fortune Senrer，将会给出
这种方法的具体操作步骤。    ，
15.4，发送和接收UDP数据报
    QUdpSocket类可以用来发送和接收UDP数据报(data-
gram)。UDP是一种不可靠的，面向数据报的协议。一些应
用层的协议使用UDP，因为它比TCP更加小巧轻便。采用
UDP，数据是以包（数据报）的形式从一个主机发送到另一
个主机的。这里并没有连接的概念，而且如果UDP包没有
被成功投递，它不会向发送者报告任何错误。
    我们将会通过。Weather Balloon和Weather Station这两个
实例来看看在Qt应用程序中是如何使用UDP的。Weather
Balloon应用程序模拟气象气球的功能，每2秒钟就发送一
个包含当前天气情况的UDP数据报（假设使用无线连接）。
    ^    ．
图15.3．WeAther Station应用程序
Weather Station应用程序（如图15.3所示）接收这些数据报并且使这些信息显示在屏幕上。首先查
看Weather Balloon的代码：
public:
   WeatherBalloon(QWidget *parent = 0)
   double temperature() const;
   double humidity(). const,
   double altitude() const;      .
o
IJ
IJ
=j
co
C
=
o-
a
u
=
a-
o
ro
ca
a)   l-
CU
IJ   UJ
ro    -,
o  co
3:  o
ro
   .N    }
-o
   E      U .'
  ro    o
   L   . cn
   ro      -o .-
  IJ    = L
   (1,         o
.. a       lJ E
cn -o      O rl
IJ C        IJ
o o    LJ
l cn    O L
   -o   .. O_ E
CJ rl   O d rl
IJ o    IJ =J l-
ro >   ro OO
》
L    L     ._
a     a     r^-.
C++ GUI Qt 4编程（第二版）
    WeatherBalloon类派生自QPushButton。它借助
Station进行通信。
QPushButton的QUdpSocket私有变量与Weather
Weathe rBalloon : :Weathe rBalloon ( QWidget  *pa rent )
          :  QPushButton (tr( "Quit " ) ,  pa rent)
         connect (this ,  SIGNAL ( clicked ( 》 ,  this ,  SLOT( close( 》 ) ;
         connect (&timer,  SIGNAL ( timeout ( 》 ,  this ,  SLOT( sendDatag ram( 》 )
    timer.start(2木1000)：
’    setWindowTitle(t r("Weather  Balloon“));
    ’
    ’    1    、
在构造函数中，利用一个QTimer来实现每2秒钟调用一次sendDatagram()。
    void  WeatherBalloon:: sendDatagram()  .
    {    ?  、
QByteArray datagram;    .
QDataStream out(&datagram, QIODevic
out ; setVe rsion (QDataSt ream: :Qtp4_3)
out《  QDateTime: : cu rrentDateTime ( )
《 altitude( J;
udpSo c ket .writeDatag ram( datag ram
WfiteOnly) ;
《 temperature()《 humidity'()
QHostAdd re.ss: : LocalHost ,   5824)
茌sendDatagram()中，生成并发送一个包含当前日期、时间、温度、
    ’’■‘t：，
湿度和高度的数据报：
┏━━━━━━━━━┳━━━━━━━━━┓
┃\QDateTime：      ┃测量的日j朗及时间 ┃
┣━━━━━━━━━╋━━━━━━━━━┫
┃、double’    ．  ┃温度(℃)          ┃
┣━━━━━━━━━╋━━━━━━━━━┫
┃'double：         ┃湿度(%)  ‘       ┃
┣━━━━━━━━━╋━━━━━━━━━┫
┃double            ┃高度(m)           ┃
┗━━━━━━━━━┻━━━━━━━━━┛
／
    这个数据报是利用QUdpSocket:：writeDatagram()发送的。writeDatagam()的第二个和第三个参
数是lP地址和另一端的端口号(Weather Station)。对于这个实例，我们假设Weather Station和
Weather BaⅡoon运行在同一台机器上，所以使用127.0.0.1(QHostAddress:：LocalHost)的口地址，它
是指定本地主机的特殊地址。
    与QTcpSocket:：connectToHost()不同，QUdpSocket:：writeDatagram()不接受主机名称，而只能使
用主机地址。如果想在这里把主机名称解析成为它的口地址，有两种选择：在查找发生时阻塞，
然后使用QHostlnfo：：fromName()静态函数；或者，使用QHosdnfo:.:lookupHost()静态函数。当查找完
成时，它将立即返回，同时利用含有相应地址的QHostlnfo对象传递而调用槽i、  ．
int main(int argc, char *argv[l)
{
   QApplication app(argc, argv)
   WeatherBalloon balloon;
      balloon.show() ;
       return app.exec( ) ;
}     .
    main(.)函数仅仅创建了．个WeatherBalloon对象，它既作为一个UDP端进行服务，也作为一个
QPushButton显示在屏幕上。单击QPushButton，就可以退出应用程序。、
    现在看一下Weather Station客户端的源代码：  ．
class VleatherStation : public QDialog
{
   Q_OBJECT                 . .
public
／    。i。t。，2攀翥《馕鸳壤濑黼辫
第15章网  络    289
WeatherStation(QWidget *. parent = 0) ;
private slots: '
       void  processPendingDatagrams ( )
p rivate:
   QUdpSocket udpSocket
QLabel *dateLabel
QLabel *timeLabel
QLineEdit *altitudeLineEdit
    WeatherStaf/on类派生自QDialog。它监听一个特定的UDP端日，解析任何到来的数据报（来自
    L    ~    ’    ’
于Weather Balloon)，并且把它们的内容显示到5个只读的QLineEdit中：这里唯一需要注意的私有
变量是QUdpSocket类型的udpSocket，我们将利用它来接收数据报。’
 Weat he rStation : :Weathe rStation 'QWidget   #pa rent ).
   : QDialog(parent)   .
{'.:
       udpSocket.bind(5824) ;    '
connect (&udpSocket,  SIGNAL( ready.Read( 》 ,  .:   .
                  this,   SLOT ( processPendingDatag rads ( 》 ) ; "
}
    在构造函数申，首先把QUdpSocket绑定到Weather Balloon所传送的端口。因为我们没有指定
主机地址，套接字将在运行Weather Station的机器上接收发往任意IP地址的数据报。然后，将套接
字的readyRead()信号与提取和显示数据的processPendingDatagrams()私有槽连接起来。
    void  WeatherStation:: p'rocessPendingDatag rams()
    {
    QByteArray datagram;
        . datag ram. resize ( udpSocket. pendingDatag ramSize ( 》 ;.        ,  .
         udpSocket . readDatag ram(datag ram.data ( ) ,  datag ram. size( 》
'}  while  (udpSocket.hasPendingDatag rams ( 》 ;
QDateTime dateTime;
double temperature;    .
double humidity;
double al'titude;  .   " . :    4  :  7一  .    . : '-
QDataStream in(&datagram, QIODevice::ReadOnly),  . .
in . setVe rsion ( QDataSt ream : :.Qt_4_3 ) ;
in 》 dateTime 》 temperature 》 humidity 》 altitude
dateLineEdit->setText (dateTime.date
timeLineEdit->setText (dateTime.time
tempe ratu re LineEdit-> setText ( t r (”%l
 humidity LineEdit-> s etText ( t r (”%19a J' )
altit u deLineEdit-> s etText ( t r( "%1   mu
) .toSt ring ( 》 ;
).toString(》; .
oC").arg(temperature》;
arg ( humidity》 ;
.a rg (altitude》 ;
    当接收到数据报时，就调用pmcessPendingDatagrams()槽。QUdpSocket将收到的数据报进行排
队并让我们可以』次二个地读取它们。通常情况下j应该只有一个数据报，但是不能排除在发射
readyRead()信号前发送端连续发送一些数据报的可能性。如果那样的话，可以忽略除最后一个以
外的其他所有数据报，因为之前的数据报包含的只是过期的夭气情况。
    pendingData8ramSize()函数返回第一个待处理的数据报的大小。从应用程序的角度来看，数据
报总是作为一个单一的数据单元来发送和接收的。这意味着只要有任意字节的数据可用，就认为
整个数据报都可以被读取。readDatagram()调用把第一个待处理的数据报的内容复制到指定的
290    C++ GUI Qt 4编程（第二版）
char*缓冲区中（如果缓冲区空间太小，就直接截断数据），并且前移至下一个待处理的数据报。一
旦读取了所有的数据报，就把最后一个数据报（包含最新气象状况测量值的数据报）分解为几个部
分，并且用新的数据来组装QLineEdit。
    int main(int argc, char *argv【】)
    {
    QApplication app(argc,  argv);
    WeatherStation station,
    station.show()；
    return app.exec()：
    )
最后，在main()中，我们创建并显示WeaffierStation。．
    至此就完成了UDP发送端和接收端的代码。．这个应用程序已经尽可能地简单了，它只是由
Weather Balloon发送数据报，由Weather Station接收它们。在绝大多数实际应用中，这两个应用程序
都需要通过它们的套接字读取和写入。QUdpSocket:：writeDatagram()函数可以传递主机地址和端
口号，所以QUdpSocket可以从用bind()绑定的主机和端口读取数据，并且将其写入到其他的主机
和端口。
第16章  XML
    XMI．（eXtensible Markup Language，可扩展标记语言）是普遍用于数据交换和数据存储的一种多
用途文本文件格式。XML首先是由万维网协会(World Wide Web Consortium，W3C)作为SGML的一
个替代品来开发的。它的语法规则与HTML相似，不过XML是一种用于语言分析的语言，它并没
有要求专门的标记符、属性或者条目。HTML的XML兼容版称为XHTML。    j
    对于比较流行的SVG(可标量化矢量图形)XML格式，QtSvg模块提供了可用于载人并呈现
SVG图像的类。对于使用MathML(数学标记语言)XML格式的绘制文档，可以使用Qt SoluUons中
的QtMmlWidget。
    对于一般的XML数据处理，Qt提供了QtXrnl模块，这是本章的主题@。QtXrnl模块提供了三种
截然不同的应用程序编程接口用来读取XML文档：
    ●QXmlSreamReader是一个用于读取格式良好的XML文档的快速解析器。
    ●DOM(文档对象模型)把XML文档转换为应用程序可以遍历的树形结构。
    ●SAX( XML简单应用程序编程接口)通过虚拟函数直接向应用程序报告“解析事件”。
    QXmlStreamReader粪最快且最易于使用，它同时还提供了与其他Qt兼容的应用程序编程接
口。它很适用于编写单通解析器。DOM的主要优点是它能以任意顺序遍历XML文档的树形表示，
同时可以实现多通解析算法。有一些应用程序甚至使用DOM树作为它们的基本数据结构。SAX则
因为一些历史原因而被得以沿用至今，使用QXmIStreamReader通常会有更加简单高效的编码。
    对于XML文件的写入，Qt也提供了三种可用的方法：
●使用QXmlStreamWriter。
．在内存中以DOM树的结构表示数据，并要求这个树型结构将自己写到文件中。
●手动生成XML。
    使用QXmlStreamWriter是目前最简单易行的方式，同时它也比手动生成XML文档更加可靠。
使用DOM生成XML的方法，在DOM树已作为应用程序的基本数据结构时才真正有意义。本章将
详细介绍这三种读写XML的方法。
16.1  使用QXmIStreamReader读取XML
    使用QXmlStraamReader是在Qt中读取XML文档的最快且最简单的方式。因为解析器的工作
能力是逐渐递增的，所以它尤其适用于诸如查找XML文档中一个给定的标记符出现的次数、诶取
内存容纳不了韵特大文件、组装定制的数据结构以反映XML文档的内容等。
    QXmlStreamReader解析器根据图16.1中所列出的记号(token)工作。每次只要调用readNext()
函数，下一个记号就会被读取并变成当前的记号。当前记号的属性取决于记号的类型，可以使用
表格中列出的getter函数读取当前记号。
①  Qt 4.4有望包含另外的一些高级类来处理XML，以在单独的名为QtXmlPattems的模块中为XQuer和XPa山提供支持。
C++ GUI Qt 4编程（第二版）
┏━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┓
┃麓鬻缫黼醺燃黧蘩      ┃缀辫釉瞩徽        ┃                                              ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃StartOocument         ┃  N/A             ┃isStandaloneOocument ( )                      ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃EndOocument           ┃  N/A             ┃isStandaloneOocument ( )                      ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃StartElement          ┃  <item>          ┃nainespaceU ri( j, name ( ), att ributes ( ), ┃
┃                      ┃                  ┃namespaceOeclarations ( )                     ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃EndElement            ┃  </item>         ┃namespaceUri( ). name( )                      ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Characters          ┃  AT&amp;T        ┃text ( ), isWhitespace( L isCDATA ( )         ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Comment             ┃  <!一一fix一一） ┃  text()                                      ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  DTD                 ┃<!DOCTYPE ...>    ┃text ( ),  nota tionDeclarations t ),         ┃
┃                      ┃                  ┃entityDeclarations ( )                        ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃EntityReference       ┃  ＆t rade;       ┃name(), text()                                ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃ProcessingrnstruCtion ┃  <7aLeit7}一  ． ┃    processinqln s t:ructionTa rget ( ),      ┃
┃                      ┃                  ┃processingInstructionData()                   ┃
┣━━━━━━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Invalid             ┃  )＆<!           ┃error(), errorString()                        ┃
┗━━━━━━━━━━━┻━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━┛
  孝虑如下的XML文档：
  图16,1 QxmlStteamReader的记号
<doc>
    <quote>Einmal ist keinmak/quota>
<／doc>
    如果解析这个文档，则嘲dNext()每调用一次都将生成一个新记号，若使用getter函数还会获
得额外的信息：
StartDocument
StartElernent (name( ) == "doc,:')            .
StartElernent (name ( ) == "quote“)
Cha racters  (text ( ) = " Einmal  ist . keinmal“）
EndElement (name() = "quote")
EndElement (name() == "doc")       ' '    .
EndDocument      .
    每次调用readNext()后，都可以使用isStartEJement()、isCharacters()及类似的函数或者仅仅用
state()来测试当前记号的类型。
    下面将查看一个实例，它告诉我们如何使用QXmlStreamReader解析一个专门的XML文件格式
并在QTreeWidget中显示其内容。所解析的是那种具有书刊索引目录且包含索引条目和子条目的
文档楮式。图16.2是在QTreeWidget中显示的书刊索引文件。
    j．
    <7xml version="l.0¨?>
    <bookindex>
<entry term="sidebearings">
<page>lO</page>
<page>34-35</paga>
<page>307-308</page>
<／ent ry>
<entry 'term="subtfaction"> 4
   <entry term="of:.pictures">
 .        <page>iis乏/page> ';
<page>244</page>
         </ent ry>
   <entr}' term="of vectors".>
<page>9</page>
                  </ent ry>
    <／entry> .
</bookindex>
    首先查看从应用程序的main()函数中提取出的代码，以从中了解XML阅读器在上下文中是
如何使用的。然后，我们将查看阅读器的实现代码。  ，，
    ；7．    々．
／一
第16章XML
int main(int argc, char *ar.gv[J')
{  QApplication app(argc, argv);
         QSt ringList  a rgs  =  QApplication:-:a rguments ( )
   QTreeWidget treeWidget;    .
        ...                                     {
          XmlSt reamReade r  reade r(&t reeWidget) ;         -
   for (int i = 1; i < args.count(); ++i) :
     reader.readFile(args[il); .    '.
   return app,exec(); '
}
    J乙   : 1
    在图16.2中显示的应用程序首先创建一个QTreeWidgeto之后，这个应用程序创建一个Xml-
SUeamReader，并将树形窗口部件值传递给该XmlStreamReader并要求它解析在命令行中所指定的每
一个文件。
图16.2  XML流阅读器应用程序
class XmlStreamReader
public:
   XmlStreamReader(QTreeWidget *tree)
bool readFile(const QString &fileName);
private:
 void
 void
 void
 void
readBookindexElement ( ) ;      '
readEntryElement (QTreeWidgetltem  *pa.rent) ;
readPageElement ( QT reeWidgetlt em   *pa rent ) ;
skipUnknownElement () ;
QTreeWidget  *t reeWidget ;
QXmlStreamReader reader;
    XmlStreamReader粪提供了两个公共函数：构造函数和parseFile()函数。，这个类使用’QXrnlStre-
amReader实例解析XML文件，并组装QTreeWidget窗口以反映其读A购xrvii一数据。通过使用向下
递归的方法来实现这一解析过程。    ．+
    o readBookindexElement()解析一个含有0或0个以上<en扛y>元素的<bookindex>…<／bookin-
    ~一  ’~  r
    dex>元素。    ，
    ●readEntryElement()解析一个含有0或0个以上<page>元素的<enⅡy>…</entrjr>元素，以及
    嵌套任意层次的含有0或0个以上<entrjr>元素。  、
    。readPageElement()解析一个<page>。_</page>'元素。  。。  j”
    1    1  'J    ，  ：    ’’  。
    。skipUnknownElement()跳过不能识别的元素。’
C++ GUI Qt 4编程（第二版）
现在看看XmlStreanReader类的实现，由构造函数开始。
XmlSt reamReade r : :XmlSt reamReade r ( QT reeWidget   *t ree)
{
   treeWidget = tree;
}
    构造函数只用来建立阅读器将使用的那个QTreeWidget。所有的操作都将在readFile()函数中
完成(由main()函数调用），我们将分三个部分来查看它们。
bool  XmlStreamReade r: : readFile ( const  QSt ring &fileName)
{
       QFile  file ( fileName) ;
   if (!file.open(QFile::ReadOnly I QFile::Text》 {
       std::cerr《 "Error:.Cannot read file "《 qPrintable(fileName)
《 .r' : . ii《  qPrintable ( file,errorSt ring ( 》  .
《 std::endl;
     return false;
                                              .
     }
reader,setDevice(&file) ;
    readFile()函数首先会尝试打开文件。如果失败，则会输出一条出错信息并返回false僮；如果
成功，则它将被设置为QXmlStreamReader的输入设备。
reader. readNext ( ) ;     .
while (!reader,atErid(》 {
    ,. if  (ire.ader.isStartElement(》 {
       if' ('r^eader,name() == "bookiridex") {  .
                       readBookindexElement ( ) ;    .
      } else {   '
         reader.raiseError(QObject::tr("Not a bookindex file-'》
-, : . reader.readNext();
 .}
    QXmlStreamReader的readNext()函数从输入流中读取下一个记号。如果成功而且还没有到达
XML文件的结尾，函数将进入while循环。由于索引文件的结构，我们知道在该循环内部只有三种
可能性发生：<bookindex>开始标签正好被读入；另一个开始标签正好被读入（在这种情况下，读取
的文件不是一个书刊索引）；读入的是其他种类的记号。
    如果有正确的开始标签，就调用readBooHndexElement()继续完成处理。否则，就调用QXInl-
StreamReader:：raiseError()井给出出错信息。下一次（在while循环条件下）调用atEnd()时，它将返
还true值。这就确保了解析过程可以在遇到错误时能尽快停止。通过对QFile调用e1Tor()和error-
String()，就可以在稍后查询这些出错信息。当在书刊索引文件中检测到有错误时，也会立即返回
一个类似的出错信息。其实，使用raiseError()通常会更加方便，因为它对低级的妞也解析错误和
与应用程序相关的错误使用了相同的错误报告机制，而这些低级的XML解析错误会在QXInlSUe-
amReader运行到无效的XML时就自动出现。
file, close( ) ;           .
if  ( reader.hasError( 》 {
     std::cerr《 "Error: Failed'to- parse file "    .  .
《 qPrintable(fileName)《 ": "
《  qPrintable ( reader. e r ro rSt ring ( 》《  std :' : endl ;
   return false;
} else if (file,error() != QFile::NoError) {
   std::cerr《 "Error: Cannot read file "<《 qPrintable(fileName)
《 ": "《 qPrintable(file.errorString(》    ,
    << std::endl;
   return faLse;
第16章XML    295
    一旦处理完成，就会关闭文件。如果存在解析器错误或者文件错误，该函数就输出一个出错
信息并返回false值；否则，返回true值并报告解析成功’。    ．
    void  XmlSt reamReader:: readBookindexElement()
．    ．{    ．．
reader. readNext ( ) ;   .
while (!reader.atEnd(》 { '.
' if (reade'r.isEndElement(》
 .   reader,readNext(); .
 break;
if (reader,isStartElement(》 {
   if (reader.name() == "entry") {
             ,   readEnt ryElement (t reeWidget->invisibleRootltem ( 》 ;
   } else {
    skipUnknownElement(); .
     }
} else {
reader.readNext();
}
    readBookindexElement()的作用就是读取文件的主体部分i它首先跳过当前的记号（此处只可
能是<bookindex>开始标签），然后遍历读取整个输入文件。
    如果读取到了关闭标签，那么它只可能是<／bookindex>标签．．否则QXmlStreamReader早就已经
报告出错了( UnexpectedElementError)。如果是那样的话，就跳过这个标签并跳出循环。否则，将应
该有一个顶级索引<entr>开始标签。如果情况确实如此，调用readEntryElement'()来处理条目数
据；不然，就调用skipUnknownElement()。使用skipUnknownElement()而不调用raiseError()，意味着如
果要在将来扩展书刊索引格式以包含新的标签的话，这个阅读器将继续有效，因为它仅忽略了不
能识别的标签。
    _    ，
    readEntryElement()具有一个确认父对象条目的QTreeWidgedtem*参数。我们将QTreeWidget:：
in/sibleRoodtem()作为父对象项传递，以使新的项以其为根基。在readEntryElement()中，用一个不
同的父对象项循环调用readEntyElement()。
void  XmlSt reamReade r : : readEnt ryElement ( QTree/^lidgetltem  *pa re.nt )
{
   QTreeWidgetltem卓item = new QTreeWidgetltem(parent);   .    '.
          item->setText (O,   reade r.att ributes ( ) .vatue ( "te rm " ) .toSt ring ( 》
reader. readNext( ) ;
while ( ! reader.atEnd(》 {
       if  ( reader.isEndElement( 》' {
                 reade r. readNext ( ) ;
          .        b rea k ;
if  ( reade r,isSta rtElement ( 》  {
   if (reader.name() == "entry") {
           readEntryElement(item) ;    .
   } else if (reader,name() == "page")
              readPageElement (item) ;  .            .
   } else {
    skipUnknownElement();  ' ' :,
     }
} else {
       reader. readNext( ) ;
296                                                   C++  GUI.Qt 4.编程(第 -版)
    }    ．    、
    )    j    ：
    }
    每当遇到一个<entIy>・开始标签时，就会调用readEnuyElement()函数。我们希望为每一个索引
条目创建一个树形的窗口部件项，因此创建一个新的QTreeWidgetltem，并将其第一列的文本值设置
为条目的项属性文本。    ，    ’
    一旦条目被添加到树中，就开始读取下一个记号。：如果这是一个关闭标签，就跳过该标签并
跳出循环。如果遇到的是开始标签，那么它可能是<entry>标签（表示一个子条目），<page>标签
（该条目项的页码数），或者是一个未知的标签。如果开始标签是一个子条目，就递归调用readEn-
UyElement()。如果该标签是<page>标签，就调用readPageElement()。
void  XmlStreamReader: : readPageEleme.nt (QTreeWidgetltem  *parent)
{     .
   QString page = reader.readElementText();
       if  ( reader.isEndElement( 》
                reader. readNext ( ) ;
    ・卜    ，7一‘
    只要读取的是<page>标签，就调用readPageElement()园数。被传递的正是符合页码文本所属
条目的树项。我们从读取<page>和</page>标签之间的文本开始。成功读取完以后，readElement-
Text()函数将让解析器停留在必须跳过的</page>标签上。
    这些页被存储在树形窗口部件项的第二列。我们首先提取那里已有的文本。如果文本不为
空值，就在其后添加一个逗号，为新页的文本做好准备。然后，添加新的文本并相应地更新该列的
文本。    一
 void  XmlS t reamReader: : s kipUnknownElerrient ( )
{.
         reader. readNext ( ) ;
   while (!reade.r.atEnd(》 { ' .   .
      '       if  ( reader.isEndElement ('》  {
                        reader. readNext ( ) ;           '.
                              b reak;                  .
            }
  '  . if (reader-.isStartElement(》 {  .
                   skipUnknown阻eme.nt() ;           .
                        reader, readNext ( ) ;
      }
}     .
    最后，当遇到未知的标签时，将继续读取，直到读取到也将跳过的未知元素的关闭标签为止。
这意味着我们将跳过那些具有良好形式但却无法识别的元素，并从ⅪVIL文件中读驭尽可能多的
可识别的数据。
    这里给出的实例可以作为类似的、XML向下递归解析器的基础。然而，有时候实现这样一个
解析器可能是相当棘手的，如果没有调用readNext()或者在不恰当地方调用。一些程序员通过在
代码中使用断言( assertion)来强调这个问题。例如，在readBookindexElement()的开头，我们可以加
上一行代码：
IJ
x
 a)                      . N
IJ     -
A  '        Ln
 I           Q)
IJ '   '    g
C -- .      fD
o --      a-
L_  N
a- iJ :      fD
 a-
 il  E  _     -
    LU :   .~ rl
Ln Ln    (L -
O rl lIgt
 g . + ro x
m Ln    o- a)
a- o Ln .. l-.
r g O  il  lJ'
- ra g+ o
ra O- ra    Ln
  - a- Ln A
gr r O J
c ra r g iJ
.+ -. ra ra c
L_  a_ O
IJ    r L
cn .+-     -  ra
a.r4 .  ra o-
第16章XML
    也可以在readEntryElement()和readPageElement()函数中使用类似的断言。对于skipUn-
knownElement()，我们将仅声明存在一个开始元素。
    QXmlSUeamReader可以从包括QFile、QBuffer、QProcess和QTcpSocket的任意QIODev:ice中获得输
入。一些输入数据源可能无法在解析器需要的时候提供其所需要的数据，例如由于网络等待时间
所造成。但在这种情况下仍可使用QXmlSUeamReader。在“Incrementl Parsing”主题下关于QXrnl-
StreamReader的参考文档中，提供了关于这方面的更多信息。。．    r
    在这个应用程序中使用的QXmlStreamReader类是QtXml库中的一部分。如果想要建立应用程
序和.QtXrnl库的关联，必须在．pro文件中加入如下一行命令：．r    '
    QT+=xml    '    I    r    7
    在接下来的两节中，将看到如何使用DOM和SAX来编写相同酌应用程序。：
蠢  16.2  用DOM读取XML
譬
}：、
    DOM是一种解析由万维网协会(W3C)所开发的XML文档的标准应用程序编程接o"o Qt捉供
一套用于读取、操作和编写XML文档的非验证型二级DOM实现。
    一
    DOM把XML文件表示成内存中的一棵树。我们可以按需要遍历这个DOM树，也可以修改这
个树并把它作为XML文件保存到磁盘中。    。
    ．  ，    ．  奎；，：j：’：¨，、
  让我们考虑如下这个,XML文档：，    。一    ∥  ，
       <quote>Scio me nihil scire</quote>
        <translation>l know that I know nothing</translation>   .
    <／doc>
                                                                                                                                        ..''
       .   . DoLEl;te,t(doc)   .
                                             Element (quote)
                                                            LText ("Scio menihilscire")  .
                                                Element (translation)
                                                                                          LText ("l know that Iknow nothing")
    这个DOM树包含不同类型的节点。例如，Element节点对应打开标签以及与它匹配的关闭标
签。在这两个标签之间的内容则作为这个Element节点的子节点出现。在Qt'中，节点类型（和其
他所有与DOM有关的类一样）具有一个QDom前缀。因此，QDomE】ement就代表一个Element节点，
而QDomText就代表一个Text节点。
    不同类型的芾点可以具有不同种类的子节点。例如，一个Element节点可以包含其他Element
节点，也可以包含EnUtyReference、Text、CDATASection、Processinglnstruction以及Conunent节点。
图16.3给出了节点可以包含在的子节点的种类。。图中显示为灰色的节点则不能拥有它自己的子
节点。
    为了演示如何使用DOM读取XML文件，我们将为前一节（见292页）中提到的书刊索引文件
    ．f_  ．
格式编写一个解析器。    ，，    ‘
class DomParser    '
{
public:
     DomParser(QTreeWidget *tree) ;
曦麟麟隧黼隧麟黪黪黪鬻黪黪臻鬻露鬻黪囊黪隧臻
298    C++ GUI Qt 4编程（第二版）
        bool  readFile( const ,QSt ring &fileName) ;
private:
 .  void parseBookindexElement(const QDomElement &element);
        void  pa rseEnt ryElement ( const  QDomElement &element,
                                                          QTreeWidgetltem  *pa rent ) ;
    void parsePageElement(const QDomElement &element,   '
                                                  QTreeWidgetitem  *pa rent) ;
   QTreeWidget *treeWidget
};      . :
定义了一个称为DomParser的类，它将会解析XML书刊索引文档并且在QTreeWidget中显示结果。
    l
    l Documentl
    一
筐而菡茵两茏
  臣r l
区i运
    En -]
    ___    _二二丁一
图16.3  DOM节点间的父子关系
DomPa rse r: :DomParse r ( QTreeWidget  *t ree)
{
   treeWidget = tree;
}
    在构造函数中，我们仅将给定的树形窗口部件赋给成员变量。所有的解析都在readFile()函数
的内部完成。
bool  DomPa rse r: : readFile ( const  QSt ring &fileName)
                                                  .
       QFik  file( fileName) ;
   if (!file.open(QFile:.:ReadOnly l QFile::Text》 {
       std::cerr<< "Error: Cannot read file "<< qPrintable(fileName)
《 ": "<<'qPrintable(file.errorString(》   .
    << std::endl;
 . '   return false;-  .  .
     }
QString errorStr;
int errorLine;
int errorColumn;
QDomDocument doc;  '
if  .( ! doc ! setContent (&file, . false,  &e rro rStr,  &e rro rLine,                   .
               &errorColumn》 {                '
   std::cerr   "Error: Parse error at line "<< errorLine<( ", "
《 "column "<< errorColumn《 ": il
    << qPrintable(errorStr)《 std::endl;   .     .
 .  return false; .
QDomElement root =
if (root.tagName()
doc.documentElement()
!= "bookindex") {
第16章XML
299
          std::cerr《 '"Error: Not a bookindex file"《 std::endl
      return false;
 ' }.
       pa rseBookindexElement ( root) ;                       .    .         .
   return true;
}
    在readFile()中，首先尝试打开那些文件名已经被传递进来的文件。如果有错误发生，就输出
一个出错信息，并返回false值表示文件打开失败。否则，就设置一些变量用以保存那些需要的解
析出错信息，然后创建一个QDomDocument。当对DOM文档调用setContent()函数时，由QIODevice
提供的整个XML文档将被读取并解析。如果该文档还未打开，setContent()函数将自动打开设备。
setContent()的false参数将禁用命名空间的处理。关于XML命名空间及其如何在Qt中处理，可以
查阅QtXrnl的参考文档。
    如果有错误发生，就输出一个出错信息并返回false值表示解析失败。如果解析成功，就对
QDomDocument调用documentElement()以获得它唯一的QDornElement子对象，同时检查它是否为
<bookindex>元素，如果已经有<bookindex>元素了，就调用parseBookindexElement()来解析它。与
前一节牛介绍的内容相似，解析过程是使用向下递归方法来实现的。
 void  DomPa rse r: : parseBookindexElement { const  QDomElement &element)
'{     .
'  QDomNode chitd = element.firstChild();
       while  ( ! child.isNull( 》  {
      .         if  (child.toElement ( ) .tagName( )  == "ent ry")
                          pa rseEnt ryElement ( child. toElement ( ) , .
                                                                 t reeWidget->invisibleRootltem ( 》 ;
       child = child.nextSibling();
      }
}
    在parseBookindexElement()中，遍历所有的子节点。我们希望每一个节点都是一个<entW>元
素，那样的话，就可以调用parseEntD-()来解析每一个节点。我们忽略那些未知的节点，以使书刊索
引格式在不阻止旧的解析器工作的情况下今后也能被扩展。所有的<entry>节点都是<bookindex>
芾点的直接子对象，在组装的用于反映DOM树的窗口部件中它还是顶级节点。所以当我们想逐
一解析这些节点时，将传递节点元素和树的不可见根项以作为窗口部件树项的父对象。
    QDomNode类可以存储任何类型的节点。如果想进一步处理一个节点，首先必须把它转换为
正确的数据类型。在这个实例中，我们仅仅关心Element节点，所以对QDomNode调用toElement()
以把它转换成QDomElement，然后调用tagName()来取得元素的标签名称。如果节点不是Element
类型，那么toElement()函数就返回一个空QDomElement对象和一个空的标签。
void  DomPa rse r: :pa rseEnt ryElement ( const  QDomElement &element ,
{         ' QTreeWidgetltem*parent)
   QTreeWidgetltem *-item = new QTreeWidgetltem(parent);
        item->setText (0,  element.att ribute( "term" 》 ;     .
   QDomNode child = element.firstChild();
       while  ( ! child.isNull( 》  {          .
        if (child.toElement(),tagName ) == "entry") {      '
                              pa rseEnt ryElement ( child . toElement ( ) ,   item) ;   '
 .    . } else if (child.toElement{).tagName() == "page") {
                          pa rsePageElement ( child ,toElement ( ) ,   item) ;        .
       :}                                                    .
      chi.ld = child.nextSibling{);             .  \ .
      }
                           .
醛戮黪黢”戬曩誊≯i：j。．    ．    ／
  300    C++ GUI Qt 4编程（第二版）
    ―――――二二二――    ~
    ‘~
    在parseEnUyEler―ient()中，我们创建一个树形窗口部件项。传人的父对象项既可以是树的不可见
根项（如果这是一个顶级条目的话），也可以是其他的条目（如果它只是一个子条目的话）b我们调
用setText()，将显示在项的第一列中的文本设置为<enⅡy>标签的tenn属性值。    ‘
    一旦已经初始化了QTreeWidgedtem，就遍历对应于当前<enⅡy>标签的QDomElement节点下的
所有子节点。对于每一个<enⅡy>标签的子元素，我们利用当前项作为第二个参数来递归调用
parseEnUyElement()。然后；利用当前条目作为父对象，创建每一子节点的QTreeWidgetjtem。如果子
元素为<page>，就调用parsePageElement()。
Qs
os
if
al
ring page =
ring allPage
( ! allPages .i
 allPages +=
Pages += pag
lement .text
= parent->
Empty(》.
      Il .
  .   .
QTreeWidgetltem *pa.rent)
    .parent->setText(l,  allPages);    。
    ，
    在parsePageElement()中，对元素调用text()以获得<page>和</page>标签之间文本；然后，将文
本添加到QTreeWidgetjtem的第二列，这是一列以逗号分隔的页码列表。QDomElement：：text()函数
遍历元素的所有子节点并连接存储在Text和CDATA节点中的所有文本。
  。现在看砉j1日搿费用Do．riParse，类来解析文件j  7 i    。
  ‘jint mai  ？：。“r‘-’一j    ，    ．．：    ．
  int main'(’;nt argc,.char'argof】)
  {    ：    ，．，一  ？j、    。：    1
    QApplication app(argc,a rgv);    ≯
    QSt ringList args=QApplication::arguments();
    …    ’  ；．。，‘、．
    QTreeWidget t reeWidget;
    DomPar5er parser(＆treewidget);
    for(int i=1;i<args.count();++i)
    pa rser.readFile(args[1】);
    return app．exec()；    ．
    )
  ‘首先设立一个曲≮赢d舀t，然后再创建一个D响Pa瑙er，对于命令行中列出的每一个文件，都
调用Do矗．Pa哦r：j readFile()来打开并解析它，同时组装树形窗口部件。
    与前面的例子相似，为了连接到Qtxnd库，需要将如下命令行添加到应用程序的．pr0文件中：
    .OT+=xmi  .  ‘    ‘‘+_-  ’  ’_+:.：一{:    .    _
    u．    ‘-．，i i  ‘7．    ，
    就像这个实例所描绘的，尽管并不如使用Q）5砒S溉锄胁der那么方便，遍历一个．DOM树也还
是相当简单和直接的e颦繁使用DoM的程序员会经常编写他们自己的高级封装函数来简化那些
常规需求的操作。，rt    、、：．    ．
16,3使用SAX读取XML
    SAX事实上是公共领域中一种用于读取XML文档的标准应用程序编程接口。Qt，的SAX类是
对基于SAX2的Java实现的模拟，只是在命名上有些不太符合Qt的惯例。与DOR1相比，SAX更加
底层但通常也更加快速。然而，由于在本章前面部分曾介绍过的QXnlSimpleReader类提供了一个
更接近q风格的应用程序编程接口，且比SAX解析器更加快速，因此SAX解析器的主要用途就是
，．t一
第16章XML301
将使用SAX应用程序编程接口的代码导人Qt中。有关SAX更详细的信息，请参看http：//www．sax-
project.org/o    、
    Qt提供了一个各为QXmlSimpleReader的基于SAX的非验证型XML解析器。这个解析器能够
识别具有良好格式的‘XML文档并且支持XML文档的命名空间。当这个解析器遍历文档时，它调
用注册的处理函数中的虚拟函数来表明解析事件。（这些“解析事件”和Qt事件并无联系，就像按
键事件和鼠标事件一样）。我们假设这个解析器正在解析如下的XML文档：  ．    ，．
    <doc>
    .  <quote>Gnothi seauton<／quote>
    <／doc>
    -    ．    √    J
解析器将会调用如下这些解析事件处理函数：  7
    startDocument()
    startElement( "doc")    .    .
    s'tartElement( "quote")    _    .    ‘
    characters("Gnothi seauton")    、…
    endElement( "quote")    :,    ．一
    endElement( "doc")    一    ，一．
    endDocument()
    上述的这些函数都是在．QXmlContentHandler中声明过的：a为了简单，我们省略五startElement()
和endElement()中的一些参数。    ．I  ．．；，…i掣一一．，。二。
    QXmlContentHandle只是可以和QXmlSimpleReader协作使用的鑫多处理程序拳雩赢？≯蓦够的鎏
有QXmlEntityResolver. QXmlDTDHandler. QXmlErrorHandler.:QXmlDeclHandler'和-aQXmlLexieall~andler。
这些类仅仅声明纯虚函数并且给出不同类型的解析事件的相关信息。对于绝大冬憝摩用程序来说，
只有QXmlContend-Iandler和QXmlErrorHandler是必要的。我们用到的类的层级关系如图16.4所示。
    j．、    ’    。  +二．．，
    QXmlContentHandler    QXmlDTDHandler.QXmlLexicalHandler  j::    、..    _
    r ro rHandli    ityRes    XmlDeclHandler
    I一―一--l。’．’一
    QXmlDefaultHandler    ,  ..    j
    l    !
    SaxHandler    ．，    ，    。t。，
    图16.4 SaxHandler的继承树    ，．    、
    为了方便，Qt还提供丁QXmlDefaultH andler，这是一个派生自所有处理程序类并且为所有函数
都提供具体实现的类。含有很多抽象处理程序类和一个具体子类的这种设计构思，在Qt中并不
常用，这里它被用来密切关注模型的Java实现。
    _    ’  ．    _．．    ’    r．    ’
    与使用QXmlStre.amReader或者DOM应用程序编程接口相比，使用SAX应用程序编程接口最
显著的区别在于：SAX应用程序编程接口需要我们利用成员变量手动追踪解析器的状态，而其他
两种采用考虑向下递归的方法则不需要。    ”    f，’c 4 7’。-    -…
    为了阐明如何使用SAX读取XML文件，我们将为本章前面部分提到的书刊索引文件格式编
写一个解析器。这里将使用一个QXniSimpleReader和一个名为SaxHandler的QXmlDefaultHandler子
类来解析。
实现解析器的第一步是定义子类QXmlDefaukHandler:
class SaxHandler:public QXmlDefaultHandler
{    ，、
public:
  SaxHandler(QTreeWidget *tree);    ‘    。
302    C++ GUI Qt 4编程（第二版）
 . protected:
       bool startElement(const QString &namespaceURI,    .
                        const QString &localName, '
                        const QString &qName,  .
       .                             const QXmlAttributes &attributes) ;
       bool endElement(const QString &namespaceURI,
                      const QString &localName,         .
                                    const QString &qName) ;'
               bool  cha racters ( const  QSt ring  &st r) ;
       bool fatalError(const QXmlParseException &exception)
p rivate:
 . QTreeWidget *treeWidget;
   QTreeWidgetltem *currentltem
   QString currentText;
    SaxHandler类派生自QXmlDefaultliandler，并且重新实现了4个函数：stutElement()、endEle/nent()、
characters()和fatalFrror()。前面兰个函数都是在QXmlContend-Iandler中声明的，最后一个函数则是
在QXmlErrorHandler中声明的。
SaxHandler: :SaxHandler ( QTreeWidget  *t ree)
{         .
   treeWidget = tree;
}          .
SaxHandler构造函数接受用存储在XML文件中的信息进行组装的QTreeWidget。
bool SaxHandkr't:readFile(const QString &:fileName)
               .
   currentltem = 0:
QFile file(fileName) ;
QXmlInputSou rce  inputSou rce ( &file)
QXmlSimpleReader reader;
 reade r. setContentHandle r( this ) ;
 reader.setErrorHandler(this) ;
 retu rn   reader, pa rse(inputSou rce) ;
    当获得要解析文件的文件名时，就会调用这个函数。我们为文件创建一个QFile对象，同时创
建一个QXmlInputSource以读取文件的内容。然后，创建一个QXmlSimpleReader来解析这个文件。
我侗设置该类( SaxHandler)的阅读器内容和错误处理程序，接着对阅读器调用parse()来执行解析。
在SaxHandler中，仅重新实现了来自于QXmlContentHandler和QXmlErrorHandler类的函数。如果已
经重新实现了来自于其他处理程序类的函数，则还需要调用相应的setXc/:x Handler()函数。
    我们传递一个QXmlInputSource，而不是传递一个简单的QFile对象给parse()函数。这个类将
打开并凑取给定的文件（考虑了<?ⅪI1l?>声明中指定的任意字符编码）给定的文件，同时它还提供
了一个解析器读取文件的接口。
boo:l SaxHandler:
        '
                                '
:startElement(const
  .   :. .  const
        . . const
   const
QString＆／牢
QString＆／牢
namespaceURI
local.Name */
牢／
QString &qName,
QXmlAtt ributes &attributes)
   if (qName == "entry") {
       currentltem = new QTreeWidgetltem(currentltem ?
                                    cu rrentltem  :  t reeWidget->invisibleRootltem ( 》
                     cu r rentltem->setText ( 0,   att ributes . value( "term " 》 ;
   } else if (qName == "page“) {
     currentText.clear();  .   .
    .}
    return true;
～
第16章XML
    当阅读器遇到一个新的打开标签时，就会调用startElement()函数。第三个参数是标签的名称
（或者更加准确地说，是它的“限定名”）。第四个参数是属性列表。在这个实例中，忽略了第一个
和第二个参数。对于使用XML命名空间机制的XML文件，它们非常有用，这个主题会在参考文档
中详细论述。
    如果标签是<en时>，就创建一个新的QTeeWidgetItem项。如果标签嵌套在另一个<enty>中，
则新的标签将在这个索引中定义一个子条目，并且这个新的QTreeWidgetItem会作为代表包含条目
的QTreeWidgetItem的子对象而创建。不然，就创建QTreeWidgetItem作为顶级项，使用树形窗口部
件的不可见根项作为它的父对象。我们调用setText()，将第0列中显示的文本值设置为这个
<ent珂>标签的tenn属性。
    如果标签是<page>.，就将currentText变量设置为一个空字符串。该变量作为一个累加器，用
于<page>和</page>标签之间的文本。
    最后，我们返回true值让SAX继续解析这个文件。如果想把那些未知的标签也作为错误报
告，这时就需要返回false僮。然后，还可以在QXmlDefaultHandlcr中重新实现errorString()，以返回
一个适当的出错消息。    +
    ‘SaxHa ndler:: cha'racters( const  QSt ring  &str)
    、{
    currentText+=str;
    return true：
    )    ．，
    可以调用函数characters()报告XML文档中的字符数据。我们只把这些字符添加到currentText
变量中。    j
    bool SaxHandler::endElement(const QString＆／斗namespaceURI卓／，
    const QString＆／卓localName牛／，
    const QString &qName)
    {
    ；‘（qName==”entry“）{
    currentltem=currentltem->parent();
    ) else if (qName==“page”){
    if(currentltem){
    QString allPages=currentltem->text(l);    一
    if(!allPages.isEmpty(》
    ges+=“，”；    ，
    . allPagesa:15currentText;    .
    cu rrentltem->setText(1,allPages);    .    :
    )    )    _
    return true;
    )
    肖阅读器遇到一个关闭标签时，就会调用endElement()函数。就像startElement() -样，第三个
参数是标签的名称。
    如果标签是</en时>，就更新currentItem私有变量，使它指向当前QTreeWidgetItem的父对象。
（因为一些历史原因，顶级项返回0值作为它们的父对象，而不是返回不可见的root项。）这样可以
确保currentItem变量能恢复为相应的<entr>标签被读取之前所保存的值。
    如果标签为</page>，则把指定的页码或者页码范围添加到第一列当前项的文本中以逗号分
隔的列表中。
 bool  SaxHandler: : fatalError( const. QXmlPa rseException &exception)
{          ,
    std;:cerr<< "Parse error at line "<< exception,lineNumber() .
《 ", "《 "column "<< exception.columnNumber()《 ":
    <<  qPrintable(exception ; message ( 》<<  std::endl;
   return false;
}
304    C++ GUI Qt 4编程（第二版）
    当阅读器解析XML文件失败时，就会调用fatalError()函数。7如果这种情况发生，我们仅向控
制台输出一条出错信息，给出行号、列号以及这个解析器的错误文本。
    这样就完成了SaxHandler类的实现。它的main()函数与前一节中解析DomPuser．的主函数几
乎一样，唯一的区别在于这里使用的是SaxHandler而不是DomParser。
16.4写入XML
  ．能读取XML文件的大多数应用程序也需要写入XML文件。一般来说，主要有三种由Qt应用
    ~    i．
程序生成XML文件的方法：    、    一
●使用QXinlStreiamWriter。
●构建DOM树并对它调用
‘手动生成XMLo
save()。
    实际上，这三种方法的选取通常与是否使用QXmlStreamWriter、DOM或SAX来读取XML文档
    ．、    -    _  ，    ’    ．’+
并无关系．，尽管数据保留在DOM树中时直接保存这个DOM树是完全说得通的。
    ，  ‘    ：    ．    、
    利用QXmlStreamWrite类来写入XML文件非常容易，因为它将时刻为我们关注那些特殊的转
义字符。如果想利用QXmlStreamWrite从QTreeWidget中输幽书刊索引数据，只需要使用两个函
第一个函数获得文件名和二仑QTreeWidget*，并且将遍历树中所有的顶级项：
一_‘bool:lw蕊{‰t;co【njt Qstring’＆fileName,QTreewidget+t reewidget)
，-…{i‘：j'1：-_．‘#、砖皇；  ：‘一  ’1-。。j、…  ，
    QFile file(fileName);    .
    if(!file.open(QFile::Writeonly I QF儿e::Text)){
    Std::Cerr<<”Error:Cann
QXmlSt rea mWrite r  xmlWrite r ( &file) ;
xmlW riter.setAutoFo rmatting ( t rue) ;  .
xmlW riter,writeSta rtDocument ( ) ;
xmlW riter.writeSta rtElement ( "bookindex -- ) ;   -
for (int i = 0; i < treeWidget->topLevelItemCount{); ++i)
          writeIndexEnt ry ( &xmlWriter,   t reeWidget->topLevellted ( i》 ;
xmlWriter.writeEndDocument ( ) ;                            .   .
if (file.error(》 {   "'. '
   std::cerr<< "Error: Cannot writ.e file " .  .   . .
        ,    <。 qPrintable(fileFtame)《 ",:. 'I       .
           .    << qPrintable(file.errorStringl》<< std::endl;
                                                                                                                                  '     .
}        .
return true;     .
数。
    如果开启了自动格式编辑功能，XML文档将以更友好易读的格式输出，在每一行都有明确显
示数据递归结构的缩进。writeStartDocument()函数则写下xrvⅡJ文档首行i
    <?xml version=“1.0“encoding=’‘UTF-8”?>    .
    writeSLartElement()函数随给定的标签文本生成一个新的开始标签。writeStartDocument()函数则
关闭任何打开的开始标签。对于每一个顶级项，我们调用writeIndexEntry()函数，并将Q）I础S扛e踟一
Writer和要输出的项传递给writeIndexEntry()函数。下面是writeIndexEntry()的代码：
void writeIndexErrtry(QXmlStreamk7riter *xmlWriter, QTreeWidgetltem *item)
          xmlW rite'r->writeSta rtElement ( " ent ry" ) ;
 -o
  o
 -o
  IJ
  v
  v
 o.
.. C
v rJ
v cn
  L
-- o
OL
EL
ra o
z.
oo
rl rl
H- H-
oo
aa
ra rD
IJ IJ
CC
LL
P P
vvo
v v cn
    ra
  H-
    L
    IJ
    o
    L
，√。7
第16章XML
          xmlWriter->writeAtt ribute( "te rm" ,   item->text (O》 ; .
   QString pageString = item->text(l);   ,: , . .
   if (!pageString.isEmpty(》 { '  :
            QStringList pages = pageString.splitC, .") ;.
        foreach (QString page,/ pages)      .
                             xmlWrite r->writeTextElement ( " page " ,   page) ;
      }
   for (int i = e; i < item->childCount(); ++i)    .
                   writeIndexEnt ry ( xmlWriter,   item->child (i》 ;
      xmlWriter->writeEndElement( ) ;
                               '
    WriteIndexEntry()函数创建一个对应于QTreeWidgetltem的<entr>元素并将其作为参数接收。
writeAttribute()函数则为刚刚写入的标签添加一个属性。例如，它可以将．<entr>转变为<entr tenn
=“sidebearings’≥。如果其中有页码，那么页码将以逗号一空格分隔．并且对于每一个页码数，会有
一个单独的<page>…</page>标签对与其间的页码文本一起被写入。这些都可以通过调用write -
TextElement()以及将标签名以及开始和结束标签之间的文本传递给writeTextElement()来实现。在
所有的情况中，QXmlStreamWriter都考虑了特殊的XML转义字符的处理，我们不必为此担心。…
    如果项中有子项，就对每一个子项递归调用writeIndexEntry()。’最后，我们调用writeEndElement()
    。  ：
来输出</entr>。    。  ．，：    ．一，．
    使用QXmlStreamWirter是写入XML文档最容易、最安全的方式，但如果已经在÷仑DOM树中
有XML文档的话，则只需要在QDomDocument对象上调用save(．)函数蓑琴事这爪‘D,OM,j;fl输出相关
的XML即可。默认情况下，savec)使用UTF-8作为所生成文件的编码方式。我们可以通过为DOM
    7瓤：‘．.一
树预先进行<?xml7>声明，而使用其他种类的编码方式，例如；、  ．    。。。一；。
    <?xml version="l.0“encoding=“I50-8859-1"玲
下面的代码段给出了其完成过程：
    const int Indent=4：
QDomDocument doc;
QTextStream  out (&file) ;     '
QDomNode xmlNode = doc.createProcessinglnstruction("xml",   ' .:   . '
                                                                         "ve rsion=\ "1.0\"  encodjng-\ "150-8859-1\ " il) ;
doc ,inse rtBefo re(xmlNode,   doc . firstChild ( 》 ;             .   '
doc.save(out, Indent);                .    .  :        .-::
    从Qt 4.3开始，一个替代的方式就是利用setCodec()对QTextStremn设置编码，并将QDom-
Node：：EncodingFromTextStieam作为第三个参数传递给save()。。  ．    ．
    手动生成XML文件并不比利用DOM生成XML文件更加困难。我们可以使用QTextStream并
且写入字符串，就像写入其他任何文本文件一样。最需要慎重对待的部分就是转义在文本和属性
值中的特殊字符。Qt:：escape()函数可以转义“<”、“>”和“&”等特殊字符。以下是一个使用它的
代码：
QTextSt ream  out (&file)
out..setCodec("UTF-8") ;
《 ii   <quote>"<< Qt::escape(quoteTextJ联 "</quote>\n
《  "        <t ranslation>"<<  Qt : :escape (t ranslationText )
<< "</translation>\n" .   '
    当采用这样的方式生成XML文件时，除了必须写入正确魄<7xml?>声明并设置正确的编码
    r    一  ‘    。
外，还必须记得对写入的文本进行转义。如果使用了属性值，还必须转义其中的单引号或双引号。
不过，使用QXmlStreamWriter就会简单得多了，因为它将为我们处理上述所需注意的一切。
第17章  提供在线帮助
    绝大多数应用程序都为用户提供在线帮助。有一些帮助的内容是相当简短的，例如工具提
示、状态提示和“What's This?”之类的帮助。Qt自然都支持这类简单的帮助。其他帮助可以具有更
多的扩展内容，例如包括很多页的文本。对于这种帮助，可以把QTextBrowser作为一个简单的在线
帮助浏览器来使用，也可以从应用程序调用Qt Assistant或者其他HTML浏览器。
17.1  工具提示、状态提示和“What's This?"帮助
    工具提示就是一小段文本，当鼠标在一个窗口部件上面停留一段时间后会显示。工具提示通
常显示为黄色背景黑色文字，它的主要用途是为工具条按钮提供文本描述。
    可以使用QWidget:：setToolTip()以代码的形式为任意窗口部件添加工具提示。例如：
    findButton->setToolTip(tr(”Firtd  next n));
    为了给一个能添加到主菜单或者工具条的QAction设置工具提示，只需对这个动作调用setTool -
Tip()。例如：    一，    ．
    newAction=new QAction(tr(”&New”),this);
    newAction->setToolTip(tr(“New document“));
如果没有明确地设置工具提示，QAction会自动使用这个动作的文本。
    状态提示也是一小段描述性文本，通常会比工具提示长一点。当鼠标在工具条按钮或者菜单
选项上停留一段时间时，状态提示将会出现在状态栏上。调用setStatusTip()可以为动作或窗口部
件添加状态提示：
图17.1给出了应用程序的工具提示和状态提示。
图17.1显示工具提示和状态提示的应用程序
第17章”提供在线帮助
    在某些情况下，如果能为窗口部件提供比工具提示和状态提示更多的信息，则是最好不过的
了。例如，我们也许想为一个复杂对话框中的每一个字段提供说明性的文本，而不强制用户调用
一个单独的帮助窗口。“What'srllus?”模式是对这个问题的一个理想的解决方案。当窗口处于
“What's This?”模式的时候，光标将会变为啪的形式，而且用户可以在任何用户界面组件上单击来
获得关于它的帮助文本。为了进入“What's This?”模式，用户既可以单击对话框标题栏（在Windows
和KDE中）中的“？”按钮，也可以按下Shift+ Fl组合键。
    以下是一个在对话框上设置“What，。This?”文本帮助的例子：  ，
dialog->setWhat sThis (t r ( " <img  s rc=\" :/images／icon. png\">"  .
                    "&nbsp;The meaning of the Source field depends
                     "on the Type field:"     .  .
                    "<Ui><b>Books</b> have a Publ.isher"  '
                               .         "<li><b>Articles</b> ; have a Journal  name with .."
                    "votume a'nd issue number"
                  .     ."<li><b>Th.eses<，b> have an Institution name "
          !       "and a Department name" .   ,
    可以使用HTML标签来对“What's This?”文本进行格式化。在图17.2所示的实例中，我们包含了
二个图像(它位于这个应用程序的资源文件中)、上个含有项目符号的列表以及一些加粗的文本。Qt
    J    。    。  ，    ‘
所支持的标签和属性在http：//doc．troiltech．com/4. 3/richtext_ html- subset．html：、网页中有详细介绍。
图17.2显示“What's rlhis?”帮助文本的对话框
    当在动作上设置了“What's This?”文本，且用户在“What's This?”模式下单击这个菜单项或者工
具栏按钮或者按下快捷键的时候，这个文本将会显示出来。当应用程序的主窗口的用户界面组件
提供“What's This?”文本帮助时，通常的惯例是在Help菜单中提供一个“What's This?”选项以及一个
对应的工具栏按钮。通过利用静态函数QWhatsThis：：cre.ateAction()创建一个”What's This?”动作并
将它返回的动作添加到Help菜单和工具栏，就可以完成以上的操作。QWhatsrllus类还提供了静态
函数以有计划地进入和退出“What's This?”模式。
17.2利用Web浏览器提供在线帮助
    大型的应用程序需要提供比工具提示、状态提示和“What's This?”帮助更多的在线帮助信息。
    、    、
对于这个问题的一个简单的解决方案是提供HTML格式的帮助文本，并且在适当的页面中启动用
户的Web浏览器。
C++ GUI Qt 4编程（第二版）
    包含帮助浏览器的应用程序通常在主窗口的Help菜单中有一个Help条目，并且在每一个相
应的对话框中也有Help按钮。本节将介绍如何使用QDesktopServices类来为这些按钮提供相应的
功能。    ’。
7  当用户按下Fl键或单击Help~Help菜单选项时，应用程序的主窗口通常会调用一个help()槽。
    void  MainWindow:: help()
    {
    QUrl url(directoryOf(”doc”) .absoluteFilePath(“index.html”));
    u rl. setScheme(“file”);
    QDesktopSe rvices::openUrl(url);
    }
    在这个实例中，我们假设应用程序的HTML帮助文件都在一个名为doc的子目录中。QDir:：
absoluteFilePath()函数返回一个具有给定文件名完全路径的QString。首先创建一个具有帮助文件
路径的QUrl对象。因为这是针对主窗口的帮助，、所以使用自己的帮助系统的index. html文件，在
这个文件中其他的帮助文件都可以通过超链接来访问。然后，我们设置URL的模式为“文件”，这
样设量的文件就只会在本地文件系统中被查找。最后，使用桌面服务的openUrl()静态方便函数来
启动用户的．Web浏览器。
。  由于我们并不知道将使用哪一个Web浏览器，所以必须小心确保我们的HTMI。有效并同时保
持其与用户正使用的浏览器相兼容。大多数Web浏览器将把它们本地工作目录设置为URL路
径，同时还假设任何没有绝对路径的图像和超链接都把I-t~目录作为其根目录。这意味着我们必
须将所有的HTML'文件和图像文件放在doc目录（或者其下的子目录中），同时关联所有索引，但那
些连到外部站点的链接除外。j
    QDir  MainWindow::directo ryOf( const  ost ring &subdir)
    {
    QDir  dir( QApplication::applicationDirPath());
    #if defined(Q_OS_WIN)
    jf  (dir.dirName() .toLower()一"debug'l
    l l  dir.dirName() ,toLower()==“release")
    dir.cdUp()；
    #elif  defined (Q_OS_MAC)
    if (dir.dirName()=="MacOS"){
    dir.cdUp()；
    dir,cdUp()；
    dir.cdUp()；    ‘
    }
    #endif
    dir.cd( subdir)；
    return dir;
    }
    静态directoryOf()函数返回一个对应于与应用程序目录相关的指定子目录的QDiro在Win-
dows中，应用程序的可执行文件通常位于debug或release子目录中，这样我们就往上移动一级目
录。在Mac OS X中，我们主要考虑卷式(bundle)目录结构。
    对于对话框，通常希望在帮助系统内部的某一具体页，或许也可能在某一页面中的某一具体
点上启动Web浏览器。例如：
    void EntryDialog::help()
    {
    ourl url( directo ryOf( "doc") .absoluteFilePath(“fo rms. html"));
    url.setScheme("file");
    url.setFragment("editing");    ‘
    QDes ktopServices::openU rl(u rl);
    }
    第17章提供在线帮助309
    当用户单击对话框的Help按钮时，这个槽是从对话框的内部调用的。除了已经选择了一个
，  不同的开始页面以外，这与之前的实例非常相似。这个专门的页面有针对几个不同窗体的帮助文
    本，同时可以让HTML中的锚定引用（如<a name=“edit/ng”>）指定出每一个窗体的帮助文本从哪
    里开始。为了访问页面中某一具体的位置，我们调用setFragnent()并传递希望页面滚动至的锚定。
／    提供I-]TML格式的帮助文件并且让用户可以通过他们自己的Web浏览器去读取这些帮助文
  件，非常简单且方便。但是Web浏览器不能访问应用程序资源（比如图标等），并且它们并不易于
  被用户定制以符合应用程序的要求。同样，如果我们像处理EntD Dialog时那样跳到了某一页面，
  单击浏览器的Home或Back按钮则无法达到预期的效果。
17.3  将QTextBrowser作为简单7的帮助引擎
    通过使用用户的Web浏览器来显示在线帮助是非常容易的；但正如我们已经提到的，该方法
也确实存在一些缺点。可以通过提供自己的基于QTextBrowser类的帮助引擎来消除这些问题。
    这一节将给出一个如图17.3所示的简单的帮助测览器，并且解释如何在应用程序牛使用它。
这个窗口使用QTextBrowser来显示标记着基于HTML语法的帮助页。QTextB。口wse．可以处理很多
简单的HTML标签，因此对于这个目的，它是相当令人满意的。
    图17.3 HelpBrowser窗口部件
我们从类的定义开始：    ：？
class HelpBrowser:public QWidget    、
{    ：
    0 0BJECT
public:
    HelpBrowser(const QString &path, const QStrino &page,
    QWidget *parent=O);
    static void showPage(const QString &page);
private slots:
  void updateWindowTitle();
_p riva te_;_．、．
    ’-'～~~。
    “’  ～  、、
    ＼、一^。．
    "、～．
    ‘～。
_-
一c    -
r  辱
  310    C+；GUI Qt 4编程（第；版）
)
QTextBrowser *textBrowser;
QPushButton *homeButton;.
QPushButton *backButton;
QPushButton *closeButton;
．  HelpBrow。e．提供了一个静态函数，它可以在应用程序的任何地方被调用。这个函数创建一个
HelpBrowser窗口并且显示给定的页。
    下面是其构造函数：
HelpBrowser::HelpBrowser(const QString &path, const QString &page
                     Widget *parent)
,:QWidget(phrent) QWid
{
         setAtt ribute( Qt : :WA_DeleteOnClose) ;   .        :
            setAtt ribute( Qt : :WA_G ro u p Leader) ;
textBrowse'r - new QTextBrowser
homeButtorl' =  new QPushButton (t r( "
backButton = new QPushButton(tr("
closeButton = new QPus'hButton(tr{
closeButton->setSho rtcut (t r( "Esc "
&Back" )r
i,Closeir
》;
QHBoxLayout *buttonLayout = new QHBoxLayout
buttonLayout->addWidget ( homeButton) ;
buttonLayout->addWidget(backButton); '  .
buttonLayout->addStretch() ;
 buttonLayout->addWidget ( closeButton ) ;
QVBoxLayout *mainLayout = new QVBoxLayout
 main Layout->addLayout ( buttor,Layout) ;
mainLayout->addWidget (textBrowser) ;
setLayout (mainLayout) ;
connect (homeButton,  SIGNAL( clicked ( 》 ,  textBrowser,  SLOT(home( 》 ) ;
connect ( backButton,  SIGNAL( clicked ( 》 ,
               textBrowser,  SLOT( backwa rd( 》 ) ;    '
connect ( closeButton,   SIGNAL ( clicked ( 》 ,  this,  SLOT( close( 》 ) ;
connect (textB rowser,   SIGNAL ( sou rceChanged ( const  QU rl &》 ,
                    this,   SLOT ( updateWindowTitle ( 》 ) ;
textBrowser->setSea rchPaths cost ringList ()<<  path<< " :/images " )
textBrowser->setSource(page) ;
    找们设置Qt：：WA_GroupLeader属性，因为除了要从主窗口中弹出HelpBrowser窗口，还希望从
模式对话框中也弹出HelpBrowser窗口。通常情况下，模式对话框不允许用户和这个应用程序．中的
其他任何窗口进行交互。然而，在请求帮助之后，用户就显然被允许与模式对话框和帮助浏览器
进行交互。设置Qt：：WA_GroupLeader属性才可能实现这种交互。
    我们提供了两种搜索路径，第一种是包含应用程序文档的文件系统中的一个路径，第二种是图
像资源的存储位置。HTML可以在文件系统中以常规方式包含图像资源的引用，也可以通过使用一
个以“：／”开始的路径包含图像资源的引用。page
参数是文档文件的名祢，有一个可选的HTML锚。
    void  HelpB rowser::updateWindowTitle()
    {
    setWindowTitle(tr("Help:  %1").a rg( textB rowse r->documentTitle()));
    )
    只要这个源页面发生变化，就会调用updateWindowTitl.e()槽。documentTide()函数返回页的
<tide>标签中指定的文本。
蓊
第17章提供在线帮助
311
    void  HelpBrowser:: showPage( const  QSt ring &page)
    {    ．
    QString path=directoryOf(”doc“) .absolutePath();
    HelpBrowser *browser=new HelpBrowser(path, page);
    browser->resize(500, 400);
    browser->show()；
    }
    在showPage()静态函数中，创建并显示了HelpBrowser窗口。当用户关闭它时，会被自动删除，
因为在HelpBrowser构造函数中设置了Qt:：WA_DeleteOnClose属性。对于这个实例，我们假设这些
帮助文档都放在应用程序的doc目录下。。所有传递给showPage()函数的页都将取自于这个子
    ．    、
目录。
    现在已经准备好从应用程序中调用帮助浏览器了。在应用程序的主窗口中，可以创建一个
Help动作并把它连接到一个help()槽，其过程如下：
  ’  void  MainWindow:: help()
    {
    HelpBrowser::showPage(“index. html“n
    }
    这里假设主帮助文件的名称为index，html。对于对话框，可以建立Help按钮与help()槽的连
接，其过程大致如下：
    j    ．
    void EntryDialog::help()
    {
    HelpBrowser::showPage(fo rms .html#editing    。。    ．，’_‘’i
    HelpBrowse r::showPage(”fo rms.html群editing“);    、
    }
这里我们还顺便看了一个不同的帮助文件forms．html，并且将QTextBrowser滚动到editing锚。
    也可以使用Qt资源系统将帮助文件以及与它们相关的图像直接嵌入到可执行文件中。实现
这个目的需要做的改变就是为每一个希望嵌入的文件添加条目到应用程序的．qrc文件中，并且使
用资源路径(例如，+:/doc/fonns. html# editing)。
    在这个实例中‘，我们同时使用了两种方法，既嵌入了图标（因为应用程序本身也使用它），但是
同时又保持了HTML文档在文件系统中。这一方法的优点在于帮助文件可以独立于应用程序而
更新，而且可以确保其能够找到应用程序的图标。
17.4使用Qt Assistant提供强大的在线帮助
    Qt Assistant是由rrrUtech公司提供的一介在线帮助应用程序。它的主要优点是支持索引和全
文检索，而且它可以为多个应用程序处理多个文档集。为了使用Qt Assistant，必须在应用程序中加
入必要的代码，并且必须让Qt Assistan意识到帮助文档的存在①。
    Qt应用程序和Qt Assist,ant之间通信是由QAssistantClient类来处理的，它位于一个单独的库中。
为了建立这个库与应用程序的连接，必须在应用程序的.pro文件中添加如下的命令行：
现在查看一个使用Qt Assistant的新HelpBrowser类的代码：
class HelpBrowser
{
public:  ,
  ' static void showPage(const QString &page)
①Qt 4.4有望以不断更新的帮助系统为特色，这使我们的帮助文档更加容易被集成进去。
312
C++ GUI Qt 4编程（第二版）
    private：
    static QDir directoryOf(const QString &subdir);
    二  static QAssistantClient *assistant;
    )；
    以下是一个新的helpbrowser. cpp文件：
    QAssistantClient *HelpBrowser::assistant=0;
    、toid  HelpB rowser::showPage( const  ost ring &page)
    {    ．．
    QString path=directioryOf(.l.doc”) .absoluteFilePath(page);t    .
    if（!assistarit）  ：”    j
    assistant=new-QAssistantClient(““);    r
    assistant->showPage(path):
    )
    QAssistantClient构造函数接收一个路径字符串作为它的第一个参数，它可以用于定位Qt Assis-
tant可执行文件。通过传递一个空路径字符串，表示让QAssistantClient在PATH环境变量中查找可
执行文件。QAssistantClient有一个showPage()西数，它可以接收带一个可选HTML锚点的页面
名称。
  ‘下一步是为文档准备目录和索引a这是通过创建一个Qt Assistant配置文件并且写入一个提
供有关文档信息的．dcf文件实现的。这些在Qt Assistant的在线帮助中都有说明，所以这里就不再
赘述了。    ‘
    除了使用Web浏览器、QTextBrowser或Qt Assistant，还有一种方法就是使用与平台相关的方法
来提供在线帮助。对于Windows/应用程序，创建Windows HTML Help文件并且利用Micro。o矗Intemet
Explorer访问它们，也许是种不错的选择。可以使用Qt的QProcess类或者ActiveQt框架来实现这一
点。在Mac OS X系统上，Apple Help也提供了与Qt Assistant相似的功能。
    现在，本书的第二部分即将结束，而本书第三部分中的章节将包含更多的关于Qt高级特性和
专门特征的内容。总的来说，在第三部分中给出的C++和Qt代码并不会比第二部分所见到的更
难。对于读者而言，那些出现在陌生领域中的某些概念和思想才更具挑战性。
第三部分  ：Qt高级
第18章
第19章
第20章
第21章
第22章
第23章
第24章
国际化
自定义外观
    o    ．
    1．  。    。  ．、
    '    ，i
  ．  ，    、    _    一
  i，    ’，  1  1    ，一  一
  ．    。  一
一，．。    。V．    ．。_
    1    1    ．‘
    ，    _    ～‘
    节    IjI
    ，    。_．  --    ，：  一  ．，
    ：    _一一  ，_  j  1．  j订  -
，^，    Y    一_    _11  r1
  ・    本．性  ，
1    膊特。程  ，
形．件．序：关编
图一插程。，相式  o
维建、用台．入、  t
三  创应平嵌  ．~
第18章  国  际  化
    除了采用英语和许多欧洲语系中的拉丁字符之外，Qt 4也为世界上其他的文字系统提供了广
泛支持：
    ・Qt在整个应用程序编程接口及其内部都使用Unicode。无论用于用户接口的是何种语言，
    应用程序都可以为所有的用户提供类似的支持。
    ●Qt t0文本引擎可以处理所有主要的非拉丁文文字系统，其中包括阿拉伯文（Arabic）、中文
    ( Chinese)、西里尔文(Cyrillic)、希伯来文(Hebrew)、日文(Japanese)、韩文(Korean)、泰文(Thai)
    和印度文(Indie)。
    ●Qt的布局引擎可以为从右到左的文本布局提供支持，比如对阿拉伯文和希伯来文的支持。
    ●一些特定的语言在输入文本时要求使用特殊的输入法。比如像QLineEdit和QTextEdit这样
    的一些编辑器窗口部件，都可以与安装在用户系统中的任意输入法和谐地工作在一起。
    通常情况下，只允许用户使用他们自己的本地语言输入文本是不够的，最好是要让整个用户
界面允许翻译才行。Qt让这些变得非常简单：只需使用tr()函数把用户所有可见的字符串都封装起
来（就像前面章节中所做的那样），并且使用Q的支持工具为所需的语言准备相应的翻译文仵即可。
Qt为翻译人员提供了一个称为Qt Linguist的图形用户界面工具。配上两个通常由应用程序开发人员
运行的命令行语句-lupdate和lrelease，QtLinguist就可以为翻译提供完美支持了。
    对于大多数的应用程序，程序会在一开始启动的时候根据用户的本地设置载人所需的翻译文
件。但是在少数情况下，对用户来说，要求程序在运行的时候也能够切换语言，可能也是很有必要
的。而利用Qt，使这一切都变得完全可能起来，虽然这的确还需要再做一些其他工作。在翻译文
本的长度比原有文本的长度长的时候，也要多亏了Qt的布局系统，使得不同的用户接口部分会自
动进行调整，从而可以为翻译文本腾出空间。
18.1  使用Unicode
    Unicode是一种支持世界上绝大多数文字系统的字符编码标准。U．i/code最初的思想是在存储
字符时使用16位而不是8位，这样它就可以大约具有65 000个字符编码，而不是只有256个①。
Unicode在同样的编码位置以子集的形式包含了ASCII和IS0  8859-1( Latin-l)。例如，字符“A”的
ASCII编码、Latln-l编码和Unicode编码都是Ox41，而字符“？”的Latln-l缟码和Unicode编码都
是OxDl。
    Qt中的QString类用于将字符串存储为U．Iicode。在QString中的每一个字符都是一个16位的
Qcrar，而不是一个8位的char。以下是把一个字符串的第一个字符设置成“A”的两种方法：
    str[0]=‘A’；
    str[0]=QChar(Ox41)；
①新版的Unicode标准可分配的字符数超过65 535。使用两个称为“代理编码对”(surmgate pairs)的16位值序列，就可以
  表示所有这些字符。
第18章  国  际化
315
    如果源文件的编码格式是Latln-l，那么指定Latln-l字符就非常简单：
    str[0]=‘同‘；
如果源文件中还使用了其他，的编码格式，那么使用数字赋值的方式会更好些：    ，
    ．str[0]=QChar(OxDl)；
    我们可以使用任何一个Unicode字符的数字值来指定它。例如，以下给出了如何指定大写的
希腊字符西格玛(“∑”)和欧元货币符号(“￡”)的方法：1
    str【0】=QChar(Ox03A3);
    str[0】=QChar(Ox20AC);
    Unicode所支持的所有字符的数值列表可以在http：//www. unicode．org/standard中找到。如果你
很少需要非Latin-l的Unicode字符，在线查找这些字符就已经足够了。但是，为了在Qt程序中输
入Uni。ode字符串，Qt还是提供了很多简便的方法，正如我们在这一节的稍后部分将要看到的
那样。
    Qt．4的文本引擎在所有平台上都支持以下文字系统：阿拉伯文、中文、西里尔文、希腊文、希伯
来文、日文、韩文、老挝文、拉丁文、泰文和越南文。它也支持所有的Unicode 4.1脚本而不需要任何
特殊处理。此外，在使用Fontconfig酌Xll和新版Qt的Windows系统上，Qt还支持以下这些文字系
统：孟加拉文、梵文、古吉拉特文、旁遮普文、埃纳德文、高棉文、马拉亚拉姆文、叙利亚文、泰米尔
文、泰卢固文、塔安那文、迪维希文和藏文。最后，Qt在Xll上还支持奥里亚文，并且在Windows XP
上还支持蒙古文和僧伽罗文。假设在系统上已经安装好了适当的字体，那么Qt就可以使用这些
文字系统中的任何一种来显示文本。并且，假设已经安装好了适当的输入法，那么用户将可以在
他们的Qt应用程序中使用这些文字系统输入文本了。
    使用QChar编程和使用char编程有一点点不同。为了获得一个QChar的数字值，可以对它调用
UIU。ode()。为了获得一个QChar(作为一个cllai)的ASCII或者Laln-l的值，则要对它调用toLatlnl()。
对于那些非Latln-l的字符，toLatinl()将会返’回“\0'’。
    如果我们知道一个程序中的所有字符都是ASCII字符，那么可以在toLatinl()的返回值上使用
像isalpha()、i_djgit()和isspace()这样的标准<cctype>函数。然而，在执行这些操作时使用QChar昀
成员函数通常会是更好的方法，因为它们可用于任意的Unicode字符。QChar提供的这些函数包括
isPrint()、jsPunct()、isSpace()、isMark()、isLetter()、isNLunber()、isLetteiOrNumber()、isDigit(.)、isSymbol.()、
i。Lower()以及isUpper()。例如，以下给出了测试一个字符是数字还是大写字符的一种方法：
 if (ch.isDigit() l[ ch.isUpper(》
这个代码片断可以用于区分任意的大写或者小写格式的字母，包括拉丁文、希腊文和西里尔文。
    一旦有一个Unicode字符串，我们就可以在Qt的应用程序编程接口中任何需要QString的地方
使用它。然后，就由Qt负责对其适当地加以显示，并且在和操作系统对话时负责把它转换成相应
的编码格式。
    当读取和写入文本文件时，需要给予特殊关注。文本文件可以使用很多种编码格式，并且通
常很有可能需要从文本文件的内容来猜测它的编码格式。默认情况下，QTextStleam对于读取和写
入都使用系统的本地8位编码格式[这可以通过QTextCodec：：codecForLocale()豳数获得]。对于美
国和西欧的本地设置，这种做法通常获得的就是Latin-l。
    如果要设计自己的文件格式，并且希望能够读取和写入任意的Unicode字符，那么可以在开始
写入QTextStremn之前调用以下代码：
316
C++ GUI Qt4编程（第二版）
stream.setCodec( "UTF-16") ;
st ream. setGene rateByteOrde rMa rk(t rueJ
这样就可以把数据保存为Unicode格式。然后，这些数据将会被保存为UTF-16，这是一种每个字符
都使用两个字节存储的格式，并且它会使用一个特殊的16位值(UIucode字节序列掩码，OxFITE)作
为前缀，用于识别该文件采用的是UIucode编码，它也用来识别存储格式是以高字节在前还是高字
节在后。UTF-16格式和QString的内存表示形式一致，所以读取和写入UTF-16格式的UIucode字符
串的速度非常快。另一方面，当我们把纯粹的ASCII数据保存为UTF-16格式的时候，总是会带来
固有的开销，因为它存储每个字符的时候使用的是两个字节，而不是只用一个字节。
    通过使用适当的QTextCodec来调用setCodec()，还可以指定其他的编码方法。QTextCodec是一
个可以在Unicode和给定编码格式之间进行转换的对象。Qt在很大范围的上下文关系上都使用了
QTextCodec。，在Qt内部，把它们用于对字体、输入法，剪贴板、拖放和文件名的支持中。但是当我
们编写Qt应用程序的时候，也可以使用它们。    -  。
    当读取文本文件时，如果这个文件是以字节顺序标记( Byte Order Mark，BOM)开始的，那么
QTextStrearri就会自动检测到UTF-16。通过调用setAutoDetectUIucode( false)，可以关闭这一行为。，如
果假定数据不是以字节顺序标记开始的，那么在读取开始之前最好能够使用“UTF-16”先调用一下
setCodec()。
    UIucode完全支持的另外二种编码格式是UTF-8。相对于UTF:16，它的主要优点在于：它是
ASCII的一个超集。位于Ox00和Ox7F范围之内的任何字符都被表示为一个单一字节。而其他字
符，包括位于Ox7F以上的Latlri-1字符，则都使用多字节序列进行表示。对于以ASCII为主的文本，
UTF-8占用的空间约为UTF-16占用空间的一半。为了在QTextStream牛使用UTF-8，在读取和写入
之前，可以以“UTF-8”作为编码格式的名字先调用一下setCodec()。    、
    如果我们总是希望忽略用户的本地设置而读取或者输出Laun-l字符，则可以把QTextStream
酌编码格式设置为“IS0 8859-1”：’例如：
    QTextStream in(&file);～    、
    in,setCodec(“IS0 8859-1”);  :’  ～    :    ！
    一些文件格式会在文件头指明它们所使用的编码格式。这个文件头通常是普通的ASCII编
码，这样可以确保不管使用什么样的编码格式（这里我们假设它是ASCII的一个超集），都可以正确
地读取这个文件。XML文件格式就是这样一个有趣的例子。XML文件通常编码为IJTF-8或者
UTF-16。读取它们的适当方式是使用带“LITF-8”的setCodec()调用。如果格式是UTF-16，QText-
Stream将会自动检测到该格式并且进行自我调整。XML文件的<?xrnl?>样式的文件头有时会包含
一个encoding参数，例如？。’
    由于QTexiStream不允许在开始读取字符之后再改变这个编码格式，因此i考虑到显式编码的问
题，正确读取文件的方法应当是使用适当的编码格式[可以使用QTextCodec：：codecForName()函数
获得]重新开始读取文件。对于XML的这种情况，通过使用Qt的‘XML类，就可以避免由自己处理
这些编码格式的庥烦了，正如第16章中讲述的那样。
    QTextCodec的另外一个用法是用于指明在源代码中出现的字符串的编码方式。假设有这样一
个例子，有一个日本的程序员团队正在编写一个主要面向日本家庭市场的应用程序。这些程序员
喜欢使用编码方式为EUC-JP或者Shift-nS的文本编辑器编写他们的源代码。这样的编辑器可以
让他们方便地输入日文字符，所以，他们就可以输入像下面这样的程序代码：
，夕／、
第18章  国  际化    317
QPushButton *button = new QPushButton(tr("日嚣“》
    默认情况下，Qt会把tr()的参数当作Latin-l。为了改变这一点，可以调用静态函数QTextCo-
decj：setCodecForTr()。例如：
    QTextCodec:: setCodecFo rTr( QTextCodec:: codec Fo rName(“EUC-JPll));
    这个调用必须在第一次对tr()的调用之前完成。通常，应当在main()函数中来完成它，并且
是在创建完QApplication对象之后就马上来做这项工作。
    而在程序中给定的其他字符串仍将会当作Latin-1字符串。如果程序员想在以上情况下也输
入日・文字符，则可以使用QTextCodec明确地把它们转换成为Unicode：
    QString text=japaneseCodec->toUnicode（‘侮鞋料理¨；    ’    ．一‘
    ．  J    I    ：_
    作为选择，当在const char*和QString之间进行转换的时候，可以通过调用QTextCodec：：setCo-
decFoFCSUings()来让Qt使用某种特殊的编解码器：    、    一  ’
    QTextCodec:: setCodec Fo rCSt rings (QTextCodec:: codecForName(“EUC. JP”】);    ,    .’
以上所述的技术也同样适用于任意的非Latin-l语言，其中包括中文、希腊文、韩变和俄文。1一‘一
    以下列表给出了Qt 4.3所支持的编码方式：    ？    ’．一。i'』：
    ’‘‘
  Apple Roman
Big5
Big5-HKSCS
EUC-JP
EUC-KR
GB18030-0
  1BM 850
  IBM 866
  IBM 874
* IS0 2022-JP
  IS0 8859-1
  IS0 8859-2
  IS0 8859-3
  IS0 8859-4
~ IS0 8859-5
~ IS0 8859-6
~ IS0 8859-7
~ IS0 8859-8
~ IS0 8859-9
~ IS0 8859-10
~ IS0 8859-13
* IS0 8859-14
~ IS0 8859-15
* IS0 8859-16
. Iscii-Bng
.' Iscii-Dev
* Iscii-Gir
* Iscii-Knd
* Iscii-lVDm
~ Iscii-Ori
~ 'Iscii-Pnj
~ Iscii_rflg
~ Iscii-.Tml
~  JIS X 0201
~. JIS X 0208
* K018-R
. K018-U
. .MuleLao-l
. ROMAN8
 *   . SHfi- ns
* TIS-620
* rrscn
 UTF-16BE _ .  . ' .
 UTF-16LE   .
 Windows-1250 .     . .'
 'Windows-1251 ' ,    :: - ' -
                                                                             ....
 Windows-.1252. .  .    .
 Windows-1253  ,
.  Windows-1254 .   .      ,  , .  .
Windows-1255
; rXfindows:12561 ' .:"::.
. Windows-1257 ' .
 Windows-.1258  .. '_
WINSAM12
    财于列出的所有这些编码方式，QTextCodec:：codecForName()总是可以返回一个有效的指针。
通过对QTextCodec的子类化，也可以支持其他类型的编码方式。    ，
1.8.2让应用程序感知翻译    j
    ．t一一：  ，，，。    ∥    ’
    如果想让应用程序能使用多种语言，必须做两件事情：。j一．。．
    N确保每一个用户可见的字符串都使用了tr()函数。：    。
    o在应用程序启动的时候，载入了一个翻译文件（1．c弘）。
    ‘    ’
    对于应用程序来说，以上两者都是必不可少的，否则就无法对共进行翻译。然而，使用tr()通
常并不需要付出太多的努力，并且这样做也为日后的翻译工作做好了准备。
318
C++ GUI Qt4编程（第二版）
    tr()函数是定义在QObject中的一个静态函数，并且可以把它在任何一个定义了Q_OBJECT宏
的子类中重写。在编写QObject子类的代码时，可以不拘泥于任何形式而直接调用tr()。如果有
可以使用的翻译，tr()调用就会返回其翻译；否则，就返回其原有的文本内容。在不是QObject的类
中，可以使用带QObject类前缀的方式QObject：：tr()重写tr()函数，也可以使用Q_DECLARE_TR_
FUNCTIONS()宏把tr()函数添加到该类中，就像第8章所做的那样。
    为了准备翻译文件，必须运行Qt的lupdate工具。这个工具会提取出现在tr()调用中的所有
字符串文字并且产生一些翻译文件，其中包含了所有这些准备要翻译的字符串。然后，这些文件
就可以发送给某个翻译者，由其添加翻译内容。在18.4节中，将会说明这一过程。
    tr()调用一般具有如下语法格式：
这里的Co，ztext部分就是使用Q_OBJECT宏定义的QObject子类的名字。如果我们从正在使用的类
的一个成员函数中调用了tr()函数，那么就不需要再指定这个Context部分。source Text都分是需
要翻译的字符串文字。comment部分是可选的，它可以用来向翻译者提供一些额外的信息。
    下面是一些例子：    ，
    Roc kyWid get:: Ro ckyWidget( QWidget   *pa rent)
    ：QWidget( pa rent)
    {
    QString strl=tr(“Letter“);
    .QSt ring" st.r2、=RockyWidget:':tr(“Letter1‘);
    ost ring_ st r3=Sn.azzyDialog::t r(“Letter“n
    QString str4=SnazzyDialog::tr(’'Letter”,“Us paper size”);    ’
    )
    在前面两个tr()调用中，都是以“RockyWidget”作为它们的上下文，而在后面的两个“）调用
中，则以“SnazzyDialog”作为上下文。这4个tr()调用中，全部都是以“Letter”作为源文本。最后一个
调用还有一个备注说明，用来帮助翻译人员理解源文本所要表达的意思。
    在不同上下文（类）中的字符串可以相互独立地翻译出来。翻译者通常每次只在一个上下文
中进行翻译工作，通常会让应用程序运行并且显示要翻译的窗口部件或者对话框。
    肖从全局函数中调用tr()时，必须明确地指定上下文。在应用程序中，任何QObject的子类都
可以用作上下文。如果没有一个合适，那么总是可以使用QObject自身来当作上下文。例如：
int main(int argc, char *argv[l)
{
   QApplication app(argc; argv);
        QPushButton  buttorl(QObj ect: :tr( "Hello  Qt ! " 》
    button,show()；
    return app．exec();
    )
    在目前为止的每一个例子中，上下文曾经都有一个类名。这是非常方便的，因为我们几乎可
以总是忽略它。但是，并非所有的情况总是如此。在Qt中，翻译一个字符串最常用的方法是使用
QCoreApplication：：translate()函数，它可以最多接受三个参数：上下文、源文本以及可选的注释项。
例如，以下是翻译“Hello Qt!”的另外一种方式：
    QCoreApplication::translate(”Global Stuff”,”Hello Qt!“)
这一次，我们把要翻译的文本放到了“Global Stuff”的上下文中。
    tr()和translate()这两个函数都有～个双重用途：它们既都是lupdate用来找到用户可见字符串
的标记符，同时又都是可以翻译文本的C++函数。因此，这样对我们如何编写代码就产生了一些
§
幕
“、    第18章  国  际化    319
    _______________^_________..________一
    ____-_---__________--.___.-__一
．。    影响。例如，下面的代码就将无法工作：，
//链、谖
const char *. appName = "OpenDrawer 2D"
QString 'translated -. tr(appName) ;
    这里的问题就在于lupdate不能提取这个“OpenDrawer 2D”字符串文字，因为它没有出现在tr()
函数的调用中。这也就意味着翻译者将没有机会翻译这个字符串。在与动态字符串组合使用时，
也会引起这个问题：，
//链、谖
statusBar()->showMessage(tr("Host " + hostName + l, found--》
    在这个例子中，传递给tr()的字符串会根据hostName的值的不同而不同，所以我们就不能想
当然地期望tr()函数可以正确地翻译它。
  这．问题的解决方法是使用QStnng/：arg()：
  注意它是如何工作的：传递给缸()的字符串文本是“Host %1 found”。假设加载的是_'A]法语
翻译文件，那么t()将会返回一个像“Hote %1 trouv6“这样的字符串。然后，再使用h。。tName变量
中的内容替换“0101”这个参数。
    尽管对一个变量调用tr()通常是非常不明智的事情，但的确可以让它正常工作。’在把一个字
符串文字赋值给一个变量之前，为了能够翻译它，必须使用QT_，IR_NOOP()宏先标记它。对于静
态字符串数组来说，这样做是非常有用的。例如：
static const char * const flowers[] = {
   QT_TR_NOOP("Medium Stem Pink Roses"),
   QT_TRHNOOP("One Dozen Boxed Roses"),
   QT_TR_NOOP("Calypso Orchid"),
   QT_TR_NOOP("Dried Red Rose Bouquet"),
     QT_TR NOOP(."Mixed Peonies Bouquet") r
     n
     u
for (int i = 0; flowers[il; ++i)
          comboBox->addltem ( t r( flowe rs [i] 》
    QT_r IR_ NOOP()宏只是简单地返回它的参数。但是lupdate将会提取所有包含在QT_，IR_
NOOP()中的字符串，这样就可以翻译它们了。当在以后使用这个变量对，就可以像平常那来调用
tr()来执行翻译。尽管已经给tr()传递了一个变量，但是翻译仍将可以继续执行。
    还有一个Q'r_rRANSLATE_NOOP()宏，它的工作方式就像QT-rIR_NOOP()宏一样，只是它还带
有一个上下文作为参数。当在类之外初始化它的变量时，这个宏就会显得非常有用：
tic cons
QT_TRAN
QT_TRAN
QT_TRAN
QT_TRAN
QT_TRAN
 0
上下文参数必须与在后面的n．()或者translate()中所使用的上下文一致。
  A N  _- N
    cu cn    a) rJ
  cn o   = o
  o cn  U=
  at o  = U
    at -o =
  k  .-m o
    C -o :     co
    rl a) O a)
   o- x .-i cn u}
 ocoo
    E co u at .-i
   a)   L   C.
   IJ C o -o o
  S o   o o
      N O d o_
   E O U} .
    =o o- o -o
   rl  y O O
ooooo
* ooooo
  z z z.z z
Lllll
rU LU LU LU LU LU
-c l- l- l- l- l-
    J _l _l _l _l
C++ GUI Qt4编程（第二版）
    当在应用程序中使用’扛()时，非常容易忘记对一些用户可见的字符串调用1(．)，特别是在刚开
始使用它的时候。这些遗漏的Ⅱ()调用最终可能会由翻译人员发现，或者甚至更糟，最终可能会
由使用这个翻译过的应用程序的用户发现，因为这样的一些字符串是按照最初开发时的语言形式
显示出来的。为了避免这个问题，可以告诉Qt禁止从const char*到QString的隐含转换。t通过在
包含任意的Qt头文件之前预先定义QT_NO_CAST_FROM_ASCII预处理器符号，就可以实现这一点。
要确保设置过这个符号的最为简单的方式就是在应用程序的．pro文件中添加如下一行代码：
  DEFINES+=QT_NO_CAST .FROM'ASCII．    ：    ，
  这样将会强制每一个字符串文字都需要使用Ⅱ()或者QLatinIString()的封装，这取决于它们是
否应当翻译。没有正确封装的字符串将会在编译时产生错误，从而会强迫我们添加那些被遗漏的
tr()或者QLatinlString()调用。    。    ．
    一旦对所有用户可见的字符串全部使用了11()调用封装，那么要使翻译生效，剩下的最后一
件事情就是加载翻译文件。通帝情况下，应当在应用程序的maln()函数中完成这一步操作。：例
如，下面给出了根据用户的本地设置，我们应当如何试着加载一个翻译文件的代码：
 .  QTranslator app    ator;
.. .;appTrar‘．、;_rd~(~_-lca:;p "'+,Q{o~aolrej:;.isystem().name(),
.: ."pp.V,aXst_iiFt~T[_a.i  (&appTranste
          return  app: exec ( ) ;
    ‘  ，    ^‘
  7这里的QLocale：：system()函数会返回一个‘QLocale对象，用于提供用户的本地设置信息。习惯
上，我,fij使用本地的名称作为’．‘qm文件名的一部分。本地名称可以是更精确的，也可以是不太精
确的；例如，舒可以用来说明-个法语的本地设置；fr_ CA则可以用来说明一个法裔加拿大人的本地
    ‘j
设置，fr_CA.IS08'859-15则可以用来说H卜个使用IS0 8859-15编码方式（一种可以支持“￡”、“(”、
    ce    。    fl、    ’    -    ．
“∞”和“Y”的编码方式）的法裔加拿大人的本地设置。  。
√假设本地设置是fr―CA.IS08859-15，则QTranslator：：load()西数会首先试着加载myapp―fr―
CA..IS08859-15 .qm文件。如果这个文件不存在，那么接下来load()会尝试加载myapp_fr_ CA．qm，然
后再尝试加载myapp_: fr.qm！并且在最后放弃之前再试试myapp. qm文件。通常，我们应当只提供一
个myapp_fr. qm，其中包含着标准的法语翻译，但是如果需要为说法语的加拿大人提供一个不同的
文件，则也可以提供-个田app_fr_CA. qm文件，那么它将会应用到fr_cA的本地设置中。‘
  。QTranslator: -:load()中的第二个参数表示我们希望load()到哪个目录中查找翻译文件的路径。
在这个例子中，我们假谶这些翻译文件位子变量q．，Path给定的路径中。
‘在q库中，包含了2些需要翻译的字符串。Trolltech在Qt的translations目录下提供了法语、
德语和简体中文的翻译文件。它还提供了其他一些翻译语言，但它们是由Qt用户所贡献的，因而
官方对它们不予支持。也可以使用如下方式加载Qt库中的翻译文件：  ．
QTranslator qtTranslator;
qtTranslator.load ( "qt-"  +  QLocale: :system ( ) .name ( ) ,  qmPath) ;
a pp .in st allT ranslato r ( &qtT ranslato r) ;
    白于一个QTranslator对象每次只能保存一个翻译文件，所以我们为Qt的翻译使用了一个单独
的QTranslator对象。让每一个翻译人员只使用一个文件不会是什么问题，因为可以按照需要安装
足够多的翻译文件。当QC0reAppljcation要查找翻译文件的耐候，，它将会用到所有这些翻译文件。
第18章：国  际化
321
    一些文字，诸如阿拉伯文和希伯来文，它们是从右向左而不是从左向右书写韵j对于它们，必
须颠倒应用程序的整个布局，这可以通过调用QApplicaUon:：setLayoutDireaion(Qt:：RightToLeft)来
完成。用于Qt的翻译文件中包含了一个名为“LIR”的特殊标记，它可以告诉Qt这个语言的书写
形式是从左向右还是从右向左，所以通常并不需要我们亲自调用setLayoutDlrection()。
    如果通过Qt的资源系统把翻译文件嵌入到可执行文件中来改变应用程序，那么也许可以为
用户提供更多的方便。此外，这样做不仅减少了作为发布产品一部分的文件数量，而且也避免了
翻译文件丢失或者被意外删除的风险。假设．qrn文件放在资源树中的trzmslations子目录中，于是
我们就应当有一个myapp．qrc文件，它具有如下所示的内容：一
    一    ．；j
    <RCC>    ~．
    ，：  ’    ．
<qresource>
                         <file>t ran slatio ns/mya pp_de . qm</file>
                         <file>t ranslatio n s/myapp_f r. qm</file>          .
    . <file>translations/myapp_zh.qm</file>
                         <file>t ran slation s/qt_de . qm</file>.
                         <file>t ra nslations/qt_f r . q'm</file>
   .  <file>translations/qt_zhrqm</file>           '.  , .
    <，q resource>
    <／RCC>
.pro文件将会如-F-条:               . ..
  最后，在main()中，必须指明“：/translatiuns”作为翻译文件的路径。。前面的枣案嚣萌鬻向资源
文件的路径与文件系统中指向文件的路径是不同的。
    ‘J+  j，：一j
    现在，我们已经讲述了如何让应用程序能够使用翻译文件以其他不同的语言进行操作所需的
全部内容。但是，国与国和文化与文化之间的区别，不仅只表现在语言和文字系统的方向上的不
同。国际化的程序还必须考虑使用本地的日期和肘间格式、货币格式、数字格式以及字符串的结
合顺序。Qt包含了一个QLocale类，它可以用来提供本地化的数字和日，勰阱琢时间格式o，要套词
其他与本地相关的特定信息，可以使用标准C++中的setlocale()和localeconv()函数西j!  -I
    Qt中的一些类和函数可以根据这些本地设置来调整它们昀行为c  、j  ，j。  ；…一，
    * QString：：localeAwareCompare()使用与本地设置相关的方式比较两个字符串。．在对用户的可
    =    .‘.、:..    、  一j’:∥:  ,.！,,.
    见项进行排序的时候，它非常有用。  一
    o由QDate、QTime和QDateTime提供的toS/ring()函数，当使用‘q：、：I/ocalDate作为参数前调用
    它的时候，这个函数可以返回一个具有本地格式的字符串i  。？j_．：‘。‘    t  一
    ・默认情况下，QDateEdit和QDateTin，eEdit窗口部件都使用本地格式来显示日期和时间。    t
    、    ．、  。，    ，  ^  ‘    ，  1
    最后，一个经过翻译的应用程序可能在某些特定的情况下需妻使用和原有图标不同的图标。
例如，Web浏览器上的Back按钮和Forward按钮，在处理一种耸亨字左的语音的时，它们上面的左
    ，    t
右箭头就应该互换一下。可以使用如下的方法来完成这_工    ？：．：：，：，！，
     backAction->setlcon(backlcon) ;                                    :t.; . .: :'   :        .
           fo rwa rdAction->setlcon .( fo rwa rdlcon ) ;
  通常情况下，对于包含字母字符的所有图标都需要翻译，洌如，与文字处理软件中的倾斜
(Italic)字体选项关联在一起的工具条按钮土‘的字符叩…，在西班牙语中就应当替换为“C’！(Cursiw)，
rL C C
-'o o
-- u u
a) ro a,
-l yO
OL
l- o C
IJ .+- o
-C( u
 ol C H
rl O }J
ce u v
ui H Ul
. -l  i-  A
.. v  I
.. m c
CA O
o I  rl
rl C lJ
4J o u.
fV rl <
u IJ -C,
_l u L
-A ra
 p_12 ?
a- u L
<mo
.+-
C++ GUI'-Qt 4编程（第二版）
并且在丹麦语、荷兰语、德语、挪威语和瑞典语中就应该替换为“K"( Kursiv)。以下给出了实现这一
点的简单做法：
r  if'(tr("Italic")[Ol=='CJ){    ’
    italicAction->setlcon (iconC);
    ) else if (tr("ltalic")[0]=='K‘){
    italicAction->setIcon(iconK);
    ) else{
    italicAction->setlcon (iconl);
    )
    还有另外÷种方法，就是利用资源系统对多个本地设置提供支持的特性。！在.qrc文件中，，我
们可以使用lang属性为一种资源指定一个本地化设置。例如：
    <qresource>    j    ：    ：．    ？
    <file>italic.png</,file>
    </qresource>    .    、  ’  ?’:-  ’  ’
    <qresource lang=l'es">
    <file   alias=“italic. png”>cu rsivo. png</file>    :
    </qresource>
    <qresource lang="sv">
    <file  alias="italic. png”>ku rsiv. png</file>
    </qresource>
    加果用户的本地设置是es( Espanol)，那么，“：/italic．png”就成为cursivo．png的图片引用。如果
本地设置是sv( Svenska)，那么就会使用kursiv．png图片。对于其他情况，就会使用italic．png。
18.3动态切换语言
    对于绝大多数应用程序，在majn()中检测用户’的首选语言并为之加载适当的．crn文件，能够
这样做是非常完美的事情。但是在_些情况下，用户也许需要程序具有动态切换语言的功能。一
个由不同人不间断地轮换使用的应用程序，也许就非常需要能够在不重新启动应用程序的情况下
改变语言。例如，由呼叫中心操作员‘、同声翻译人员或者采用计算机系统的收银机操作人员使用
的应用程序通常就需要具备这种能力、。    ‘    ’    ‘
    让应用程序能够动态切换语言，需要比在开始处只加载一个单一的翻译文件要稍微多做一点
工作，但是这并不是什么困难的事情。以下是必须完成的工作：
    o提供用户可以用来切换语言的一种方法。    ．
    ・对于每一个窗口部件或者对话框，把它所有可翻译的字符串放在一个单独的函数[通常称
    为retranslateUi()]中，并且当语言发生改变的时候调用这个函数。
    下画讨论与呼叫中心应用程序相关部分的源代码。这个应
用程序提供了一个IAnguage菜单（如图18.1所示），允许用户在
程序运行时设置它的语言。默认的语言是英语。
    由于不知道应用程序在启动的时候用户将会使用哪一种
语言，所以不必在main()函数中加载这些翻译文件。相反，当
需要这些翻译文件的时候，我们将会动态地加载它们。所以，
需要用来处理翻译的所有代码必须放在这些主窗口和对话框
类的里面。
    让我们来看看这个呼叫中心应用程序的QA正如Window子类。
    MainWindow::MainWindow()
    {    。    ‘    ：，．    ．    ，．．．：    ，
图18.1动态的Language菜单
第18章  国  际  化
journalView = new JournalView;
setCent ralWidget ( j ou rnalView) ;
qApp->installT ra n sla t o r ( &appTransla to r)
qApp->installT ransla t o r ( &qtT ra n slato r) ;
createActions ( )
createMenus{ ) ;
retranslateUi()
    在这个构造函数中，我们把JoumaIView设置为中央窗口部件，它是QTableWidget的一个子类。
然后，在QApplication上安装了两个QTranslator对象：appTranslator对象存储应用程序的当前翻译，
qtTranslator对象存储Qt的翻译。最后，调用createAct/ons()和cr:eateMenus()这两个私有函数来创建
菜单系统，并且调用retranslateUi()（也是一个私有函数）设置程序在第一次运行时用户可见的那些
字符串。
void  MainWindow: : c reateActions ( )
{   ,
   newAction = new QAction(this);
            newA ction->setSho rtcut ( QKeySequence: :New) ;              .
        connect (newAction,  SIGNAL(t riggered ( 》 ,  this ,   SLOT(newFile ( 》 ) ;
exitAction .= new QAction(this);              .            .          '
 connect (exitAction,   SIGNAL( t rigge red ( 》 ,   this ,   SLOT( clo se ( 》 ) ;
aboutQtAction = new QAction(this ;                       .   -  .','t:
 connect (aboutQtAction,   SIGNAL (t rigge red ( 》 ,   qApp,   SLOT ( aboutQt ( 》 ) ;
    createActions()困数像通常那样创建了j些QAction对象，但是它没有设置任何文本。这些工
作将会在retanslateUi()中完成。对于具有标准化快捷键的那些动作，可以在这里使用适当的项设
置它们的快捷键，并在必要时依靠Qt来翻译。对于那些已经有自定义快捷键的动作，比如,Exit动
作，可以在retranslateUi()函数中与它的文本一起设置它的快捷键。
void  MainWindow: : createMenus ( )
1
   fileMenu = new QMenu(this);  ,
 . fileMenu->addAction(newAction);
            fileMenu->addAction ( openActio n ) ;
            fileMenu->addAction ( saveActio n ) ;
            fileMenu->addAction ( exitActio n ) ;
editMenu = new QMenu(this)
createLanguageMenu() ;
helpMenu = new QMenu(this);
helpMenu->addAction ( aboutAction ) ;
helpMenu->addAction ( aboutQtActio n ) ;
menuBar()->addMenu(fileMenu) ;
menuBar()->addMenu(editMenu) ;
menuBa r( ) ->addMenu ( repo rt sMenu) ;
menuBa r( ) ->addMenu (languageMenu)
menuBa r( ) ->addMenu (helpMenu) ;   .
    createMenus()豳数创建菜单，但是没有向菜单条中插入任何标题。再次重申一下，这些工作将
会在retranslateUi()中完成，
    在该函数的中间部分，我们调用createLangr_tageMenu()来使用所支持的语言列表填充Language
324    C+七GUI Qt4编程（第二版）
菜单o稍后将会看到这部分源代码p在此之前,先来看一下 retranslateUj()函数:
    void MairiWindow::retranslateUi()  , .  '                .  ."
                                                                                        :'..
    {                                                       .    ..
         .     . newAction->setText (tr( "&New"》 ;                               . :
       newAction->setStatusTip(tr("Create a new journal"》;
                     exitAction->setText ( t rl " E&xit " 》 ;   .  .                                                                       ,         .
    exitAction->setShortcut(tr("Ctrl+Q"》; . '
          ...
                   aboutQtActiori->setText ( t r ( "About &Qt " 》 ;
 f.    .  aboutQtAction->setStatusTip(tr("'Show th,e-Qt. library's About box"》;  .
           .        fileMenu->setTitle ( t r ( "&File " 》 ,     ..
   .       '      ed.itMenu->setTitle (t r( "&Edit " 》 ;
             .     repo rtsMenu->setTitle ( t r ( "&Reports "jJ ;           ;  . : .  .'   .       .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          '
     .                 la nguageMenu~>setTitle ( t r ( "&Lang uage" 》 ;        '
   :.    helpMenu->setTitle(tr("&Help"》;'        :  , . . ,    '
                                                                                                                                                                                                                                                                                                                                                                                                                 '                                ,
         '  setWindowTitle(:tr{"Call Center"》 ;
    达个retranslateUi()函数就是Ma/nWindow类中所有出现tr()调用的地方。它是在MainWindow
构造函数的最后部分得到调用的，并且在用户每次使用Language菜单改变应用程序语言的时候也
会调用这个函数。
    我们为每一个QAction设置其文本和状态提示，并且为那些县有非标准快捷键的动作设置其
快捷键。我们还为每一个QMenu设置它们的标题，也要设置窗口的标题。
    在前面提到的createMenus()函数调用createLanguageMenu()，用来弹出j个带有语言列表的
Language菜单：
-, void MaipWindow:.:c'reateLanguageMenu(j
   .    :languageMenuT'= 'nevt QMenu(this)/
langlfageActionGroup≮;new QActionGroup(this);   ' .' .  . .
connect(lapguagaActionGroup;. SKNAL{trigger~d(QAction *J ) ,
. '. .  this.,:-SLOT(switchLar/guage(QAction *》);  .
 QDir  qmDir  =  directo ryof( ,,t ranslations ") ;
QstringList fileNames = ;- -  .
                     qmDir,ent ryList cost ringList ( " callcente r_*,qm" 》 ;
for (int i = 0; i < fileNames.size(); ++i) {
   QString locale = fileNames[i];
       locale. remove(0,  locale.indexOf( '-')  +  1) ;
       locale. chop( 3) ;              :  .
                           '...
QTranslator translator;    .
t ranslator.load ( fileNames [i] j  qmDir.absolutePath ( 》 ;
QSt ring  language  =  translato r. t ranslate ( "MainWindow"
                                                                             "English" ) ; '
QAction ;+'action = new QAction(tr("&%1 962")
                             ,arg(i + l).arg(language), this)
action->setCheckable(true) ;
action7>setData(locale) ;     .
languageMenu->addActLon(action) ; , .
la ngua'g eActjonGroup->addAction(jction )
if (language == "Engiishl,)" '
      action->setChecked(true) ;
    第18章  国  际化    325
    ___    _______-__=__‘____一__________________________-
______―．-――――――――一
    和在应用程序中通过硬编码来支持多种语言有所不同，我们在应用程序的translation9目录下
为每一个．qm文件创建一个菜单项。directoryOf()函数就是第17章中用过的那个函数。
    为简单起见，我们假设英文(English)也有一个.qm文件。当用户选择．English的时候，还有一
种方法本应当对这些QTranslator对象调用clear()。
    这里存在一个特殊的困难，就是希望用一个漂亮的名字来表示每一个~．qm一文件所能提供的语
言。如果只是基于每一个，叩文件的名字，即只为“English”显示一个“en”，或者只为“Deutsch”显示一
个“de”，这样的命名方法看起来就会显得有些过于简练，并且容易让用户产生困惑j在createLan-
guageMenu()中使用的解决方法就是在“MainWindow”的上下文中检查“English”这个字符串的翻译。
这个字符串在德语的翻译中就应该被翻译为“Deutsch”，而在一个法语翻译丈件中就应该翻译为
“Frangais”，在一个日语翻译文件中就应当翻译成“日本希”。    j
    我们为每一种语言都创建一个可复选型的QAction，并亘把这个本地名称保存在这个动作的
“data”项中。我们把它们添加到一个QActionGroup对象中，以确保每次只能选中．Language菜单中的
一项。当用户从这个群组中选择一个动作时’，QActionGroup就会发射一个Uiggered( QAction*)信
号，该信号则连接到了switchLanguage.()‘。，    ：    。  ：  一  i
 7.   vo'id MainWindow::switchLanguage(QAction *action)j    ’    .  :  .    ’4  :?.:.’
    {QSt ring  localeaction->data    参．  ．’j。  ．。
    QSt ring locale=action一>data() .toSt ring();
    QString qmPath=directoryOf(“tra'nslations“)..absolutePath();.7:~；一一  i  ,;iij,.j
    appTranslator.load(“callcetlter'!+locale，qmPath)j  、  ．    一    一喜：：j“：二尊  ；．‘
    qtTranslato’.load(“qt-”+locale,q…Path).,    ,-.    ,    ..，一j,≯j-..,.
    retranslateUi()；    1
    }    ．．
    当用户从Language菜单中选择一种语言的时候，就会调用switchLanguage()槽j-我们可以为应
用程序和Qt加载翻译文件，并且可以调用retranslateUi()，由其为主窗口重新翻译所有的字符串。
    在Windows系统上，还有一种方法提供对LocaleChange事件做出响应的Language菜单，当Qt检
测到环境的本地设置发生变化时，它就会发射一个这种类型的事件。'Qt在各个平台上都支持这种
类型的事件，但是实际上只有在Windows上，当用户改变系统的本地设置的时候，才会产生这种事
件（在控制面板中的“地区和语言”选项中）。为了处理LocaleChange事件，可以像下面这样重新实
    f    “，    ：-
现QWidget:: changeEvent():
    void MainWindow::changeEvent(QEvent *event)    ”1    ‘  .  ,,:’0
    ，    {    ‘    ‘    _  ：
    if (event->type()一QEvent::LocaleChange'){    j:
    QString qmPath=directoryOf(。‘translations’‘‘) .absolutePath();    、
    appTranslator.load(”callcenter_”    ：
    + QLocale::system().:.name()、,..qmPath)j  .‘    .,    :  .
    qtTranslator.load(‘‘qt-“+QLocale:-:system() .name('J.  qmPath);’
    ret ranslateUi()；
    }
    QMainWindow:: changeEvent( event)；    一．j  ‘  +=.    、    、
    }    ．    。    ：．
    当应用程序正在运行的时候，如果用户切换了本地设置，那么就会试图为新的本地设置加载
正确的翻译文件并且调用retranslateUi()以更新用户界面。：’无论在何种情况下，都要把这个事件传
递给基类的changeEvent()函数，因为这个基类也许对LocaleChange或者其他发生变化的事件感
兴趣。    ：』。：。一．一
    现在，已经完成了对MainWindow代码的回顾。下一步，将查看应用程序中的一个窗口部件类―一
JoumalView类――的代码．来看看我们为了让它支持动态翻译需要做哪些改变。
C++ GUI Qt4编程（第二版）
    Jou rnalView::Jou rnalView( QWidget  *pa rent)    ．．．
    :QTableWidget(parent)
    {
    ．．．
    1    retranslateUi()；
    )
    JoumalView类是QTableWidget的一个子类。在该构造函数的最后，我们调用retranslateUi()私
有函数来设置该窗口部件的字符串。这与MainWindow中所做过的非常相似。
    void JournalView::changeEvent(QEvent *event)
    {
    ；‘( event->type()一QEvent:: LanguageChange)
    retranslateUi()；
    QTableWidget::changeEvent (event);
    )
    我们还重新实现了cllangeEvent()函数，对LanguageChange事件调用retranslateUi()函数。在安
装到QCoreApplication中的当前QTranslator的内容发生变化时，Qt就会产生一个LanguageChange事
件。在应用程序中，当在Ma/nWindow：：switchLanguage()成者在MainWindow：：changeEvent()中对
appTranslator或者qtTranslator调用load()时，就会发生这种情况。    ．。，
    不应当混淆LanguageChange事件和LocaleChange事件。LocaleChange事件由系统产生并且会告
诉应用程序：“也许应当加载一个新的翻译文件了”。LanguageChange事件则是由Qt产生的，它会
告诉应用程序的窗口部件”：“也许应当重新翻译所有字符串了”。
    当重新实现、lVfainWmdow时，不需要对LanguageChange做出响应。相反，当对QTranslato。调用
load()时，只需简单地调用retranslateUi()就可以了。
    Vuid  Jou rnalView::ret ranslateUi(.)
    {
    QStringList 1吉bels；    +
    +labels<<t r(“Time”)<<tr(‘‘Priority‘‘)<<tr(‘1Phone Number“.)
    <<tr(“Subject“)；
    setHo广izontalHeade广Label s(labels);
    )
    1  -
  re吣1ateUi()函数使用新翻译的交本更新列的首部，完成手写代码的窗口部件中与翻译相关
的代码。  i，  、
18.4翻译应用程序
    翻译一个含有tr()调用的Qt应用程序就是一个由三步构成的过程：
    1．运行lupdate，从应用程序的源代码中提取所有用户可见的字符串。
    2．使用Qt Liriguist翻译该应用程序。
    3．运行Lrelease，生成二进制的．qm文件，应用程序可以使用QTranslator加载这个文件。
    第1步和第3步由应用程序开发人员执行，第2步由翻译人员处理。根据这个应用程序的开
发过程和使用的生命周期的需要，可以多次重复这一循环过程。
    作为一个例子，我们将会演示如何翻译第3章中的Spreadsheet应用程序。在这个应用程序
中，已经对每一个用户可见的文本都包含了tr()调用。    ，
    首先，必须稍微修改一下应用程序的．pto文件，以便说明我们想要支持哪些语言。例如，如果
想除了支持英语之外，还想支持德语和法语，则需要在spreadsheet. pro文件中添加如下的TRANS-
LA肌ONS项：    ，．
                                               .    第 18章  :  国   '际;化                                      327
     N
    这里给定了两个翻译文件：一个用于德语，另一个用于法语。当第一次运行lupdate时，将会创
建这两个文件，并且在以后每次执行lupdate的时候，都会更新这两个文件。
    这些文件通常都有一个．ts扩展名。它们都使用简单的XML格式，并且都没有像可由QTrans -
lato。理解的二进制．qm文件那样紧凑。把人们可读的ts文件转换成高效率的机器可理解的．qm
文件则是lrelease的工作。大家不用好奇，ts文件的名字代表“翻译源”(translation source)，而．qm
文件的名字代表“Qt消息”(Qt message)。
    假设我们现在位于含有'Spreadsheet应用程序源代码的目录中，那么就可以在命令行下执行下
面的命令，以用来在spreadsheet．．pro中运行lupdate：
这里的，。erbose选项告诉lupdate要比平常提供更多的反馈信息。以下给出的是预期的输出结果：
Updating   ' spreadsheet;de.ts I .'. .
   ' Found 98 source texts'(98 new and o already' existingJ
Updating 'spreadsheet_fr,ts'.,.  .
 '  Found 98 source texts (98 new and o already existing)
    左应用程序源代码的每个tr()调用中所出现的每一个字符串，都会存储到这些. ts文．件中，后
    ．    ．
面会跟一个空白翻译。应用程序的.IU文件中所出现的字符串也会包畲在共中。．．，，
    默认情况下，lupdate工具会假设tr()中的参数都是Latln-l字符串7．抄暴否母罄种情况，那么
就必须在. pro文件中添加一个CODECFORIR项。例如：    ，。
除了在应用程序的．nain()函数中调用QTextCodec：：setCodecForTr()之外，还必须完成这_点。
    ，  ‘
    然后，就需要使用Qt Linguist把这些翻译添加到spreadsheet_ de．一ts和spreadsheet_fr.ts文件中。
（图18.2给出了使用中的。Qt Linguist。）    、，  ．．j  ．
图18.2运行中的Qt Linguist
C++ GUI Qt 4编程（第二版）
    要运行Qt Linguist，在Wmdows上，可以在“开始”菜单中单击“Qt by Tmlltech v4.x.y”一“Linguist”；
在UNIX上，可以在命令行中键人linguist命令；在Mac OS X里，可在Finder中双击Linguist。要在一
个．ts文件中添加翻译文本，可以单击File一Open并且选择需要翻译的文件即可。
    在Qt Linguist主窗口的左侧J栏，显示的是L个树状视图。那些顶层项是要翻译的应用程序
上下文。对于Spreadsheet应用程序，这些上下文是“FindDialog”、“GoToCellDialog”、“MainWindow”、
“SortDialog”和“Sp.readsheet”。每．个上下文都有两个或者更多的子项。每_个子项都会占用三列，
第一列显示一个Done标记，第三列显示．个源文本，第三列显示任意的翻译内容。右上区域显示
的是当前源文本以及它的翻译，这就是添加翻译和编辑翻译的地方。右下区域是一个由QtⅡn―
guist自动提供的建议列表。
    一．L．    ‘    ，
    二旦有了2个翻译过的’. ts文件，就需宴把它转换成一个可以由QTanslator便用的二进制，qrn
文件。为了在Qt Lfnguist中完成这L煮j可以单击File-; Release。通常情况下，应当先只翻译几个
字符串，并且让应用程序在运行的时候使用该．qrn文件来确保一切都可以正常工作。    ：
  ’如果想为所有的. ts文件重新生成这些．qrn文件，可以采用下面的方法来使用lrelease工具：
    l    ．  ：，  ，    ’
    lrelease.-verbose spreadsheet.pro一
    ：    j    ．    ～  ．．  ，    ，  。    ‘    ！
    假设我们把19个字符串翻译成了法语，并且为它们中的17个单击了Done标记，那么Lrelease
    -    ’    t
将会产生苄啬蘧棒的输出：’．
-. ; ;Generatea~tcans:tat'ionS
l.      . Ignorec(.98 unt4:aysl_ated s
; ." Updating .  , sp reads h9e4_f r". qm' :
     Generated 19 translations
     Ignored 79 untranslated s
 'finished 'and ' urifinished) '
rce texts        .      ,: . '.
17 finished and 2 unfinished)
rce texts
  当应康攀警篷囊璧鬻；运薮存被莉滓昀字符串将会按最初的语言显示出来。lrelease将会忽
略Done标i西翻译，    【用它来判断哪些翻译已经完成了，同时哪些还必须重新访问。
    当修改应用程岸篆裢鹃的时候，翻译文件就可能过时了。解决这个问题的方法就是再次运行
lupdate，这样就可以为新的学筏亭革新提供翻译，然后再重新生成这些. c文件。一些开发团队
发现经常运行lupdate是非常有用的，而其他一些开发团队则喜欢等到最终产品即将发布时才运
行它。  +毫：：：，，瑶？一号  1；-.．  ：，：．
    ’    F
    lupdate．和Qt Linguist这些工具都非常智、能。那些不再使用的翻译会仍旧保存在，ts文件中，因
为很可能会在以后的发布中用到它们。，在更新．ts文件的时候，lupdate会使用一种智能的合并算
法，它可以为翻谆获员在处理那些不同上下文中具有相同或者相近文本的翻译时节省相当多的
时间。    j!i．-。：j．，‘t，≈≯+’'．  0．    一1‘．~，    ，
    ：    ：+    一
    有关Qt Linguist、lupdate和lrelease的更多信息，请参考http：//doc．trolltech．conl/4.3／lingu/st-man-
ual. htInl中Qt Linguist昀在线手册。这个手册除了包含对Qt Linguist用户界面的充分解释外，还为
程序员准备了一份详细的教程。
    ‘    ：    ’
    ．    ．
第19章  自]定义外观
    在某些情况下，我们可能需要修改Qt内置窗口部件的外观。可能只希望稍微做÷些美学方
面的优化，或者希望实现一种全新的风格，+以便可以为应用程序或者一批应用程序实现统一的、与
众不同的外观。无论是哪种情况；都可以使用三种方法来重新定义Q内置窗口部件的外观：‘
    ！
    ．，子类化个别的窗口部件类，并且重新实现它的绘制和鼠标事件处理器，。：这给我们以完全的
    可控性，但需要付出大量的工作。这意味着必须遍历所有的代码和，Qt设计师的窗体，把Qt
    ?‘。    ’    ‘    -    ．  T    ．
    所有相关的类都改成子类。    ，一，  ．  -    j    ．．．+
    j  f  t    ．
    ・子类化QStyle或者一个预定义的风格，例如QWindowStyleo这种方法很好用，Qt.:本身就是用
    这种方法为它所支持的不同平台提供基于平台的外观的，。
    I_    ．：  ，    ’f．  ，  ：，    二    ：
    。从Qt 4.2开始，可以使用Qt样式表，这是一种从HTML CSS(层叠样式表)获得灵感的机制。
    u因为样式表是一种在运行时解释的普通文本文件，使用它们木需要具备凭翅璺器知镇：  ：
    第5章和第7章已经讲过第一种方法所需要的技术，然而我们强迥韵母自i定义窗￡部件。本
章将介绍后两种方法。我们将展示两种自走义风格：_种是Candy风格；密通过样式表定义；另一
种是Bronze风格，它通过QStyle的子类实现（如图19.1所示）。为了尽面青酾嚣习渣l手的本／Jj，我们
    ，    ，  ：  …．.-c：’、。  ．，，
只选择一部分Qt窗口部件做介绍。
    ．’  0’    二  ：‘j：：  ？  一    ．，：
Candy
19.1  使用Qt样式表
图19:1本章介绍的两种自定义样式’、
    Qt的样式表主要是受到了CSS的启发，但同时也适用于窗口部件。样式表由影响窗口部件绘
制的样式规则组成。这些规则是普通文本。由于在运行时会解析样式表，所以可以通过制定样式
表的方式来尝试设计不同的Qt应用程序：使用-stylesheet  jile，qss命令行参数、使用Qt设计师的样
式表编辑器，或者在开发应用程序时嵌入一个QTextEdit。
C++ GUI Qt 4编程（第二版）
    样式表作用于上层的当前激活的QStyle上（例如，QWindowsVistaStyle或者QPLastiqueStyle）①。
因为创建样式表不引入任何子类，所以它们适合对现有窗口部件做微小的定制。例如j假设我们
想在应用程序中的所有QLineEdit中使用黄色作为背景色，可以通过使用下面的样式表完成：
QLineEdit {
   background-color: yellow
}
按照CSS的说法，QLineEdit可以称为选择器(selector)，background-color就是属性，而yeUow就是值。
    对于这样的定制，使用样式表比修改窗口部件的调色板更可靠些。这是因为QPalette中的实
体（Base、Button、Highlight，等等）在不同样式中的用法是不一样的。例如，QWindowsStyle用Base调
色板实体填充只读组合框的背景，然而，QPlastqueStyle使用Button实体完成这一功能。此外，有些
样式使用硬编码的图像呈现某个元素，从而跳过了调色板。相反，样式表则保证了无论激活的是
哪种样式，都可以使用指定的颜色。
  ．QApplication：，：setStyleSheet()为整个应用程序设置一个样式表：
还可以使用QWidget：：setStyleSheet()设置窗口部件以及其子窗口部件的样式表。例如：
    dialog->setStyleSheet(“QLineEdit{background-color: yellow;)”);
如果直接在QLineEdit上设置样式表，可以忽略QLineEdit选择器以及大括号：
    lineEdit->setStyleSheet（”background-color: yellow;u）；    i
    到目前为止，我们只是在单独一个类上设置了一个属性。在实践中，样式规则通常是组合的。
例如，下面的规则设置6个窗口部件类以及它们的子类的前景色和背景色：
QCheckBox, QComboBox, QLineEdit, Q.ListView, QRadioButton, QSpinBox j
 . color: #050505; . .
   background-color: yellow; '   '
                                                                  .
颜色可以由名称、#RRGGBB格式的HTML样式的字符串、RGB或RGBA值指定：
    ’    ’
    QLineEdit{
    color: rgb(0,88, 152);    .
    background-color: rgba(97%r: 80%, 9%, 50%);
    )    1
    当使用颜色名称时，可以使用任何能被QColor：：setNameColor()函数识别的名字。对于RGB格
式，必须指定红、绿、蓝部分，它们的取值范围是0至255，或者0%至100%区间的值。RGBA额外
需要指定一个透明度值作为颜色的第四部分，它对应着颜色的不透明性。除了统一的颜色，也可
以指定调色板实体或者一个渐变：
QL.ineEdit j
     'color:  palette(Base) ;
   background=color: qlineargrad/ient(xl: 0, yl: 0, x2: 1, y2: 1,
                                 stop: 0 white, stop: 0.4 gray
                                                       stop: 1 green) ;
}
    第8章介绍的三种渐变类型对应着qlineargradient()、qradialgradient()以及qconicalgradient()。
语法在样式表的参考文档上有介绍。
    使用background-image属性，可以指定一个图片作为背景：
①在Qt 4.3中，样式表暂时还不支持QhLacStyle，但有望在以后的版本中得到完善。
第19章  自定义外观
331
    QLineEdit{    ~‘
    color: rgb(0，88, 152);
    background-image:u rl(:/images/yellow-bg. png);
    }
    ・r  ：
    默认情况下，背景图片从窗口部件的左上角（不包含使用margin指定的边缘区域）开始，并且
向水平和竖直方向重复填充整个窗口部件。这可以通过使用back铲ound-position和background- re -
peat属性进行设置。例如：
QLineEdit {
           backg round- image:   u rl ( :/images/yellow-bg;, png) ;
   background-positioci: top right;
\  background-repeat: repeat-y;
                                                                                                                                                                      '                       .
如果指定了背景图片和背景颜色，背景颜色将会在图片的半透明区域中透射出来。
    目前为止，使用的所有的选择器都是类的名字。还有其他的一些可以使用的选择器，它们列
在图19.2中。例如，如果想给OK和Cancel按钮指定前景颜色，可以这样写：
QPushButton[text="OK"] { .
         colo r:  g reen;
}
QPushButton[text="Cancel"l
   color: red;
}
┏━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━┓
┃寨獭熬瓣戮  ┃l壤鬻睡麟鬻       ┃                                ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃全局对象    ┃  *               ┃  任意窗口部件                  ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  类型      ┃  QDial           ┃  给定类的实例，包括子类        ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  类        ┃  ．QDial         ┃  给定类的实例，不包括子类      ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  标识      ┃QDial # ageDial   ┃  给定对象名称的窗口部件        ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  Qt属性    ┃  QDial[y = "0" ] ┃  为某些属性赋值的窗口部件      ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  子对象    ┃QFrame > QDial    ┃  给定窗口部件的直接子窗口部件  ┃
┣━━━━━━╋━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃  子孙对象  ┃  QFrame QDial    ┃  给定窗口部件的子孙窗口部件    ┃
┗━━━━━━┻━━━━━━━━━┻━━━━━━━━━━━━━━━━┛
    图19.2样式表选择器
    这种选择器语法对任何的Qt属性都适用。尽管如此，必须记住，样式表不会注意到属性值的
修改。选择器能以各种方式组合。例如，为了选择所有称作“okButton”的QPushButton，它们的x和
y属性为0，名为“frame”的QFrame直接子对象，可以这样写：
    QFrame#frame>QPushButton[x=‘’0‘’】[y=”0”]#okButton{
    }
    在一个拥有大量窗体和编辑框、组合框的应用程序中，例如那些在各种机构中使用的．，通常必
选字段会使用yellow作为背景色。我们假设将在应用程序中提供这一通用功能。首先，应该使用
这个样式表：
    』‘
    *[mandatoryField=“true“】{
    background-color: yellow;
    }
    屡管在Qt中没有mandator)rField属性的定义，但很容易通过调用QObject：：setProperty()创建一
个。从Qt 4,2开始，动态地设置一个不存在的属性的值可以创建这一属性。例如：
    nameLineEdit->setProperty(”mandatoryField“,true);
    genderComboBox->setProperty(“mandatoryField”,true);
    ageSpin80x->setProperty(”mandatoryField”,true);    ’
C++-.GUI Qt'4;编程（第二版）
    样式表不仅仅在控制颜色时有用，它们也可以用来对窗口部件元素的大小和位置进行调整。
例如，下面的规则可以增加复选框和单选钮的状态指示器的大小为20×20像素，并且确保指示器
和说明文字之间有8像素的间隙：
QCheckBox: :indicator,  QRadioButton::indicator {
   width: 20px;
 . 'height: 20px;
QCheckBox, 'QRadioButton {
   spacing: 8px;
}
  注意第一个规则的选择器语法。如果写的是QCheckBox，而不是QCheckBox：：indicato，，就指定
了整个窗口部件的尺寸，而非指示器了。第一个规则如图19.3所示。  。
    20
    H―――一―■
i工l口
TieX雹
    L一一一-一一一一一
    ………一一
    k――叫
图19.3设置一个QCheckBox指示器的大小
    一些辅助控制器( subcontrol)；如：：indicator，可以跟一些窗口部件一样使用。图19.4列出了Qt
所支持的一些辅助控制器。
┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┓
┃臻瀚骥蕊麟豢鬟      ┃                                                ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃：：indicator       ┃复选框、单选钮、可选菜单项或可选群组框的指示器  ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ : : menu-indicator ┃接钮的菜单指示器                                ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃：：item；          ┃菜单、菜单栏或状态栏项                          ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  : :up-button .    ┃微调框或滚动条的向上按钮                        ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃: : down-button     ┃微调框或滚动条的向下按钮。                      ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃：：up- am,w        ┃微调框、滚动条或标题视图的向上箭头              ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ :  : down- anrow   ┃微调框、滚动条、标题视图或组合框的向下箭头      ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃：：drop-down;;.‘  ┃．组合框的下拉箭头                              ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  ：：tide：        ┃  群组框的标题                                  ┃
┗━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━┛
    ．  ^    ，
    ．  图l9!4最常见的自定义辅助控制器
    除了辅助控制器，样式表还可；以用来指定窗，口部件的各个状态。例如，当鼠标在复选框的文
本上悬停时，我们可能想用白色指定它的：hover状态：    ．
QCheckBox:hover {
   color: white;
}   ,
状态由单个的冒号决定，而辅助控制器由两个冒号指定。我们可以一个接一个地列出几个状，
。第19章咱定义外观
态，它们彼此用冒号隔开。在这种情况下，当窗口部件满足所有的状态时，规则才被使用。例如，
下面的规则只有当鼠标在一个被选中的复选框上悬停时规则才被使用：‘    一  一
    QCheckBox:checked:hover{    一    ’
    color: white：
    }
    如果希望在任何一个状态为true的情况下使用规则，则可以使用多个选择器，用逗号把rC们
隔开：
    QCheckBox:hover, QCheckBox:checked{
    color: white;
    }    ．    ！，．；，，：，+    j-
逻辑否可以用感叹号(!)表示：    ，    ，  。．
    、j
    QCheckBox:！checked{
    color: blue;
    }
状态可以与辅助控制器合用：
    QComboBox::drop-down:hover{
    image:url(:/images/downar row_bright. png);
    }    ；
图19.5列出了可用的样式表状态。
┏━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓
┃鬻鬻鬻麟鬟鬻鬻                    ┃                                ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：disabled                        ┃禁用窗口部件，                  ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：enabled                         ┃启用窗口部件                    ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：locus                           ┃窗口部件有输入焦点’’          ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：hover                           ┃鼠标在窗口部件上悬停            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：pressed                         ┃鼠标按键点击窗口部件            ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃．：checked                       ┃按钮已被选中                    ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：unchecked                       ┃按钮未祓选中                    ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃    : indeternunate          ' .  ┃按钮被部分选中                  ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：open                            ┃窗口部件位于打开或扩展状态；    ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：closed                          ┃窗口部件位于兼闭或销毁状态1     ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：on                              ┃窗口部件的状态是“on”．    ‘  ┃
┣━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━┫
┃：og                              ┃窗口部件的状态是“。口’        ┃
┗━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━┛
    图19.5窗口部件中一些可以访问样式表的状态    _
    4；
    样式表也可以与其他的技术结合实现更复杂的自定义效果。例如，假设我们想在QLineEdit
窗体中安放一个微型“erase”按钮，在QLineEdit文字的右边。这包括创建一个EraseButton类，把它
放在QLineEdit的上方（例如使用布局管理器），但也给按钮留一些空间，这样能够避免输入的文字与
按钮的冲突。通过子类化QStyle实现这一功能是不方便的，因为我们可能需要子类化Qt中任何被此
应用程序使用的样式（QWindowsVistaSfyle、QPlasUqueStyle等）：’使用祥式表，下面的规则是一个窍门：
    QLineEdit{    ’    二“：i
    padding: Opx 15px Opx Opx;
    }
    padding属性允许我们指定窗口部件的上边、右边、下边和左边的填充空间。填窥的位置在
QLineEdit:ft9文字和窗体之间。为了更加方便，CSS同时定义丁padding- top、padding- right、padding-
C++ GUI Qt 4编程（第二版）
bottom和padding-left，它们适用于只想设置一个填充值的情况。例如：    ’
    QLineEdit{
    padding-right: 15px;
    }
    如同大多数的Qt窗口部件都可以使用样式表定制一样，QLineEdit可以支持如图19.6所示的
盒子模型。此模型可指定4个影响布局的矩形，从而绘制_个自定义的窗口部件：
    1．contents rectangle是最里面的矩形。它是绘制窗口部件内容（例如文字或者图片）的地方。
    2．padding rectangle包围contents rectangle。它负责由padding属性指定填充操作。
    3．border rectangle包围padding rectangle。它为边界预留空间。
．4．margin rectangle是最外边的矩形。它包围border rectangle，负责任何指定的边缘空白区域。
对于没有padding、border和margin的普通窗口部件，这4个矩形重合在一起。
    ：………一argin rectangle    ‘j
    Margfn reClangle
图19.6 CSS盒子模型
    现在，介绍一个实现自定义的称作Candy的样式袁。图19.7显示了一个Candy样式窗口部件
的选择器。Candy样式使用如图19.6所示的盒子模型为QLineEdit、QListView、QPushButton和
QComboBox实现自定义的外观。，下面将逐步介绍这一样式表，全部的样式表qss/candy. qss可以在
Candy例子的目录下找到，与本书的例子放在一起。
QPushButton    QComboBox（只读的）
QLineEdit    QComboBox（可编辑）    QListView
    图19.7 Candy风格的窗口部件
    对话框中的窗口部件如图19.1所示。对话框的背景图片使用以下的规则设置：
    QDialog{
    backg round-image:url(:/images/backg round. png);
    }
下面的规则集为这些QLabel设置了color和font属性：
    QLabel{
    font：9pt;
    color': rgb(0,O，’127);
    }
[Rl]
[R2]
第19章  自定义外观
随后的规则集定义了对话框中的QLineEdit和QListView的外观：
QLine
QList
     c
     b
   .s
   .s
     b
 .b
     p
                     .
gb(127, 0,
nd-color: r
n-color: wh
n-backg roun
2px groove
adius: lOpx
2px 4px;
[R3]
    为了使QLineEdit和QListView与众不同，我们需要为普通文本和选中的文本指定前景色和背
景色。此外，我们使用border，属性指定了一个灰色i2像素宽的“凹槽”边框，可以分别设置为
border-width，border- style以及border-color，由其代替border．通过指定border- radius，可以把边框的角
设为圆角，这里的半径为10像素。图19.8提供了一个图示，它是修改窗口部件border和padding
属性的效果图。为了保证窗口部件内容与边框‘的圆角不重合，我们指定了一个竖直方向2像素、
水平方向4像素的内部填充区域。对于QListView，竖直方向的填充看起来不正确，因此可以用以
    、．
下的方法覆盖它：
    QListView{
    padding: 5px 4px;    [R4]
    ’
当一个属性被具有同一迭择器的几个规则同时设置时，那么只有最后一个规则将起作用。
    N2bl<4，i    ，    I●4>142NI
    图19.8. QLincEdit的结构
    对于QPushButton的定制，我们将使用一种完全不同的方式。．用一个准备好的图像作为背景，
代替使用样式表规则绘制按钮的方法。同样，为了使按钮可以缩放，按钮韵背景使用CSS的边界
图(border image)机制定义。
    与使用background-image定义的背景图像不同，边界图被分隔成3x3的小格，如图19.9所示。
当填充窗口部件背景时，4个角（图中的格子见、C、多以及I）保持不变，其他5个格子被拉伸或者
平铺，填充可用空间。
(a)原始图像
    图19.9
    (b)结果图像
边界图的划分
 r-
  .r  o.
        ( -J        r
      -  . -a '
   Ln   ' o,
   Ln   . L '
          ( -J
  _L
  Ln   - .N
 .-2  .N o y
-- o u. ra
3 0 IJ I L
  {     O  rl rl ..  I  O,
 - - .. L 4J 4J L L C
4J 3 L O,U U O O rl
rJ O O Y O O -O -O -O
C++．GUI、Qt 4编程（第二版）
    使用borde,r-image属性可以指定各个边界图，它要求指定_个图像文件名和定义9个格子的4
条“切线”。切线用其到上、右、下和左边缘的距离定义。border: png作为边界图，距离上、右、下和
左边缘的切线为4、8、12和16，应该这样定义：    ‘
    ．、    ．    f
    border-image: url(border,pngJ4 8 12 16;．  一，，
    当使用边界图时，必须显式地设置border．width唐毪0一般情况下，bord。r-width应该与切线的
位置一致；否则，为了与border-width相符合，角上的格子将被拉伸或缩短。对于border. png的例
子，应该这样指定边框宽度：    ．  ’，  ‘．    ：
.:: border-wid.th:.4px 8px、12px 16px;j..,.._‘、i    j    一    ：  ,  .
    |^
    既然已经知道了边界图的工作机制，我们就可以看一下如何：使用它来绘制Candy风格的
QPushButton。下面就是定义在正常情况下绘制按钮的那些规则：    。
    ‘’    。  ‘-    ，、-f_．
    QPushButton{
    color: white;
font: .tlold lOpt;.  :
bo rde r-image:   u rl ( :/im~ges/bu.t"d,: prig)" 16 }
border-width: 16px; '  .. ',: '   .
padding:/-16px Opx;  .          , :
mi:riqiewhtt 32px;  '
min-width: 60px;
    )
    茌Candy样式表中，QPushButton边界图的4条切线位于距离34×34的边界图16像素的位置，
    ：，    ’    ‘
如图19.lO(a)所示。因为4条切线是统一的’，只需要用“16”定义切线：“16px”定义边框宽度。    ’
 16
/L ':
   2.
 ..   :
:; .    :
 16
    -  ：    ：
卜可藩蛰步_面叫
    (a)原始图像
16
16
    16
k―――――+{
    16
阡―-―+|
    ：    ：
・十卜――？―■――一―――――呻i
‘    。：_‘：joi箩？，+i
    '    k    ’
    (b)结果图像
32
    图19.10用于QPUshButton的边界图
    。。-’，’    、
    在图19.10(b)所示的QPushButton例子中，对应于刃、E、和丁睑边界图的格子被丢弃了，因为
缩小的按钮不足以显示，会水平拉伸格子仍和万，以便可以占用余下的宽度。  ’，
    边界图的标准用途是在窗口部件周围提供一个边框，使得窗口部件在边框内。但我们推翻了
边界图的这种机制，用它来创建窗口部仲的背景。结果，格子E被丢弃了，填充矩形的高度变成
了0。为了给按钮的文字留些空间，我们指定一个-16像素的竖直填充空间。图19,11显示了这
种情况。如果用边界图的机制定义一个实际的边框，我们可能不希望让它与文字冲突――因为我
们使用它来创建一个可缩放的背景，想把文字放在它的上面而不是内部。
    可以使用min- width和min- height设置按钮尺寸的最小值。这里选定的值确保有足够的空间留
给角上的边界图，并且确保OK按钮比需要的稍大一些，使得与Cancel按钮相邻的效果看起来更好
一些。    。．  i’’，．+  ’，！o．’．：。，’’，  ’：    “    -。
Content rectangle
图19.11 QPushButton的结构
    前面的QPushButton规则应用于所有的按钮。
在按钮处于特定的状态时才会用到。  --．
Padding rectangle
现在，我们将定义一些额外的规则，这些规则只
    一  J  ，．
    ．    ．．：    ~
  '………~’…‘‘、’7““a9CJ/““‘‘”‘‘一1‘””2‘.pngl  i0;    [R6]
  当鼠标的指针位于QPushButton的上方时，：hover的状态变成了true，指定的规则会覆盖具有较
少规则选择器的其他规则。这里，我们使用这一技术指定一个更明亮的图像作为边界图，使其具
有更好的悬停效果。前面指定的其他的QPushButton的属性仍然适用，只有border面。ge的属性
改变。    n．，二j…：，
    QPushButton:pressed{
    color: lightgray;    、    一，：  一，≥巍  ，
    bo rde r-image:url(:／images／button―pres sed.png)16;
    padding―top：~15pX；  、    。一翼~i    [R7]
    padding曲0ttom：一l7pX；
    ’
    当用户单击按钮时，可以把前景色改为浅灰色，使用一个稍暗的边界闺，并且把按钮中的文字
下移一个像素，对填充区域做小的调整。    +
    ，    ’
    最后的风格规则是自定义QChlbo嘁的外观。为了达到控制和细致的目的．；使用样式表，将区
分只读和可编辑的组合框，如图19．i2所示。只读的组合框是一个右边带下拉箭头的．Qf乜llButton，
可编辑的组合框则由一个类似QuneEdit的组件以及一个小圆按钮组成。这使得我们可以定义
QⅡneE血、QⅡstview和QPusllBu№nI的大多数规则。    一
    (a)只读的组合框    (b)可编辑的组合框
    一    ．
    图19.12具有Candy风格的QComboBox
    ・_．    _    ~．_，
・定义QLineEdit的规则可以用来定义可编辑的组合框：
    QComboBox:editable,    r    √  。
    QLineEdit，    ．  ‘‘
    QListhewcolor:{ r    .    j．，．  j,
    color：rgb(127,0，63);
    backgrou'nd-color: rgb(255, 255, 241);    一    i.
  、  selection-color: white;
    selection-background-color: rgb(191, 31, 127);  ._‘”  ,  .  ,  .:÷    [R3 7]
    border: 2px groove:gray;    j    -.    .
    border-radiUS：lOpX；
    t  padding：2Dx 4px；    ．    ，
    )
    ‘    ，    ：、    ’    一
o定义QPuShButton普通状态的规则可以扩展到定义只读组合框：
338    C++ GUI Qt'4编程（第三版）
QComboBox:,!editable, .
QPushButton {
   color: white;
   font: bold lOpt;
          bo rde r-image:   u rl ( :/images/button .png )   16 ;
   border-width: 16px; '  .  . . .
   padding: -16px Opx;
 . min-height: 32px;
   min-width: 60px;   ,          '  .
}
[R5’]
●鼠标在只读组合框或者下拉按钮上悬停的规则可以修改背景图片，如在QPushButton上应用
  的规则：
QComboBox:leditable:hover,  . '  '  :
QComboBox: :d ro p-down :editable : hover,
QPushButton:hover {      .' .     .   . .
   border-image: url(:/images/button-hover.png) 16
●点击一个只读的按钮如同点击一个QPushButton:
QComboBox: ! editable:on,
QPushButton:pressed {
  ' color: lightgray;
         bo rde r-image:  u rl ( :/images/button~p ressed. png)   16
   padding-top: -15px;  .
  :-padding-bottom: -17px;
)    。j．j遗
[R6’]
[R7 7]
    重用规则R3、R5、R6和R7可以为我们节省不少时间，也有助于保持风格的统一。但我们还
没有定义下拉按钮的规则，所以现在就来创建它：
QComboBox::down-arrow { ,  .
          image:   u rl ( :/i.ma'ges/down-a rrow. png )
}
我们提供了自己的下拉箭头的图像，：以便它可以比标准的箭头稍大一些：
QComboBox::down-arrow:on t
   top: lpx;  .   .'
如果组合框是打开的，向下箭头将下移一个像素：
QComboBox * {
   font: 9pt;
}          .
[R8]
[R9]
[Rl0]
    当用户单击了组合框，它显示一个项的列表。规则Rl0确保了组合框弹出的对象（或者任何
子窗口部件）没有继承规则R5’中指定的大字体：
QComboBox: :drop-down: ! editable {   .
   subcontrol-origin: padding;
 . subcontrol-po.sition: center right
   width: llpx;
   height: 6px;
   background: none;
}
[Rll]
    便用subcontrol-origin和'subcontrol-position属性，下拉箭头竖直居中，位于只读组合框的填充矩
形的右侧。此外，还设置它的大小与按钮内容（11x6像素的down-arrow. png图像）的大小相符，我
们把背景设置为无，因为下拉按钮仅由下拉箭头组成。
QComboBox: ! editable {
   padding-right: 15px
[R12]
、p§目
第19章  自定义外观
    对于只读组合框，我们指定一个右置的15像素的填充区域，确保组合框的显示文字与下拉箭
头不重合。图19.13显示了这些元素彼此的位置关系。    ，
图19 .13      -个只读QComboBox的结构
对于可编辑组合框，需要配置下拉按钮，使它看起来像一个微型按钮：
QComboBox::d rop-d own: edita ble f
p-down
    bo rde r-image:un(:/images/button. png)   16;
    border-width: lOpx;
    subcontrol-origin: margin;
    subcontrol-position: center right;    [R13]
    width: 7px;
    height：6px；
    }
    我们指定button.png作为边界图。然而，这次指定一个宽10像素的边框代替16像素，并按比例
缩小图像，指定一个水平7像素竖直6像素的固定内容尺寸。图19.14是这种做法的示意图。
    ：  ：
卜1F叫≯卜1r叫
哥
卜万眯了’卜百刊
    (a)原始图像    ：  (b)结果图像
    图19.14可编辑型QComboBox下拉按钮的边界图
如果组合框打开，就使用一个不同的、暗色的图像作为下拉按钮：：1
QComboBox::d rop-down: editable: open{    .
    bo rder-image:u rl(:/images/but,ton-pressed: png)   16;    [R14]
}
财于可编辑组合框，指定一个右置的29像素的区域为下拉按钮提供空间，，如图19.15所示：
QComboBox：editable{
[R15]
    现在就完成了CEuidy样式表的创建。样式表的长度大约有100行，并且使用了几个自定义的
j图像。这是个与众不同的对话框。
    使用样式表创建自定义样式需要不断摸索，特别是对那些以前没有用过CSS的人。使用样式
表的一个主要挑战是CSS的冲突方案和层叠的处理比较抽象。更详细的信息请参考在线帮助文
档http：//doc．troll.tech. com/4. 3/stylesheet．html，它描述了Qt的样式表支持，提供css规范的链接。
C++ GUI Qt 4编程（第二版）
    ：    ．：
    图19 .15        -个可编辑的QComboBox的结构
    、  ：，。
    ’，    ．。    ．
19:2子类化QStyle
卜．．I
    QStyle类是在Qt 2.0中引入的，它提供了一种包装应用程序外观的方法。例如QW/ndowsStyle、
QMotifStyle和QCDEStyle，这些类为Qt运行的平台和桌面系统实现了外观。Qt 4.3提供8种样式，还
有QStyle的抽象基类和便利的QCommonStyle基类。图19.16显示了它们之间的关系。
    。    J^    、
    QStyle
    I    r
    QCommonStyle
    --.-―----------――---.--r―――J______________________________________J________一
    ________________________________________________________________________________――
    QWjndowsStyle    QMotifStyle
    QCDEStyle
    广――]
、．  ’    ‘~j  QVMdowsXPStyle    QCleanlooksStyle  QMacStyle  QPlastiqueStyle
    ：    。’    一，：  ？.I    ’    ‘．j    ，j    ’。
    QWindowsVistaStyle
    ．  ：二・    一    ：，‘．  ．    -、    -    ：    ．
    ：：‘t．．    图19.16 Qt内置样式的继承树    ，    ’．
    对于Qt开发者来说，QStyle体系能够通过子类化QStyle或者以现存的样式来开发新的自定义
外观。在现存的样式上(例如QWindowStyle)，我们可以做最少的修改，或者可以从无到有地创建一
种完全自定义的样式。
    QStyle API包含绘制图形元素[drawPruniUve()、drawControl()、drawC omplexC ontrol()等]的函数，
以及样式查询函数[ pixeLMetrics()、styleHint()、hitTest()等]。QStyle成员函数典型地带有
QStyleOp￡ion对象，它包含绘制窗口部件的通用信息（例如其调色板）以及特有信息（例如按钮的文
字）。函数还包含一个可选的QWidget指针，以应对QStleoption不能提供全部所需信息的情况。
    假设我们想创建一个MyPushButton类，它类似于标准的Qt按钮j但不从QPushButton继承。（这
个例子有些牵强i但它将帮助我们弄清窗口部仵和样式之间的关系。）在MyPushButton绘图事件处理
器中，我们将创建一仑QStyleOljtjon(实际上是QStyleopticmButton)，并且会凋用QStyle:'t drawControl()：
    void MyPushButton::paintEvent(QPaintEvent j.／专．event丰／)    .    j    ?    ,,
    {
QP
QS
op
if
op
:CE_PushButton,
      .,..
,:r
  '              LL .
             ..
  .        '   a-
C  rt O rl O O
r-
IJ rl  '
Ln h .
o IJ
o
L
+J
o
u
ro
L
-o
A
IJ
cn
，第19章自，定义外观、
341
    QStyleOpUon:：irutFrom()函数初始化用于显示窗口部件的基本成员变量，例如rect、state（是否
可用、是否获得焦点，等等），以及调色板。具有特性的QStyleOpt/onButton的成员变量必须被手动地
初始化。在MyPushButton例子中，我们初始化features和text，允许lcon和iconSize使用默认值。
    QWidget::style()、函数返回绘制窗口部件的合适的样式。通常使用QApplicaUon：：setStle()设
置整个应用程序的样式，但也可以覆盖它，使用QWidget:：setStyle()为个别窗口部件设置样式。
    drawControl()函数被各种QStle的子类重新实现，用于绘制．QPushButton和其他的一些简单的
    。    ’    f    、』
窗口部件。典型的实现如下所示：
 void  QMotifStyle: :d rawCont rol ( Cont rolElement  element,
                                          . const- QStyleOpt.ion *. option,  -   :
                           QPainter *painter,
                          const QWidget *widget) const
   switch (element*) {   '
   case CE_CheckBox: .  .
   case CE_RadioButton: . .  . ..   " . ' .     .  .  '  .:
        if (const QStyleOptionButton'*buttonOptiort = '
           .   qstyleoption_cast<const QStyleOptionButton *>(option》 {
             // draw push button
            }
 break;
    笫一个参数( element)指出将要绘制的窗口部件的类型。如果类型是．CE_PushButton，opUon参
数将被强制转换为QStyleOpUonButton。如果强制转换成功，将绘制QStyleOpUonButton描绘的按钮。
从const QStleOpuon*向const QStyleOptionButton*的强制转换使用，qstyleopUon_ cast <I．>()来完成。
如果opuon指向的不是QStyleOpt/onButtori实例；该强制转换将返回一个空指针。
‘除了使用QStyleOpt/on，QStle的子类也可以直接查询窗口部件：．，    …．．  ，    。
    case CE'PushButton:    ,    ．  一．    。
    if (const QPushButton车button=  ’
    qobject_cast<const QPushButton *>(widget》{    1    7 7
    ，    t  ／／’draw push butt9n
    I    )    ’-    ’^    ’‘？    、    r-’’：    z√-
  ~break;’    ，一k    .  ”i    、    j.    ,  .n  ._-.j+:  ’7    .’j  -   ..’+
  ．这个版本的缺点是样式的代码依赖于QPushButton，因此不能用于绘制，‘比如，'MyPushButton。
因为这个原因，当内置的QStjle的子类需要获取绘制窗口部件的参数信息时使用QStleOpt/on参
数，只能从QWidget获取的参数就从'QWidget获取o,‘  ’    ~    一  ，．-，_．，
一在本节余下的部分，将介绍如图19 ;17 FJr示的Bronze样式的代码j．Brnze样式实现了带渐变
背景的圆角按钮、非传统的微调框、夸张的选取标志和“棕色画刷”背景。一为亍实现这一点；我们应
用了高级二维图形特性，例如反走样．、半透明、线性渐变以及组合模式". 1-t    +．一
QSpinBox  ’    QDateEdit    …。t j、二．-QTreeView
    图19.17具有Bronze风格的一些窗口部件
342    C++ GUI Qt 4编程（第二版）
以下是BronzeStyle类的定义：
class BronzeStyle : public QWindowsStyle
   Q OBJECT.
public :
   BronzeStyle() {}
void  polish (QPalette &palette) ;
             :,t *widget);      .
:o:;::st:o:l:t,:t-'Q:《WQ:Wy;lg~,;wvlhcfh),constQStyleOption*option. .
            const QWidget *widget = 0,
            QStyleHintReturn *returnData = 0) const; .
int pixelMetric(PixelMetric which, const QStyleOption *option, .
              const QWidget *widget = 0) const;
void drawPrimitive(PrimitiveElement which, .
                      .' const QStyleOption *option, QPainter *painter,
           .     const QWidget *widget = 0) const;
 void . drawComplexCont rol ( ComplexCont rol  which,
                      const QStyleOptionComplex *option,
               ' .    QPainter *painter,
                     const QWidget *widget = 0) const;
QRect subControlRect(ComplexControl'whichControl, .  '
                  const QStyleOptionComplex *option,  .
                   SubControl whichSubControl,
                  const QWidget *widget = 0) const;
public slots:
        QIcon  standa rdlconlmplementation ( Standa rdPixmap  which ,
                              const QStyleOption *option,
                                const QWidget *widget = 0) const
    private:
    void drawBronzeFrame(coost QStyleOption *option,
    QPajnter *painter) const,
    void drawBronzeBevel(const QStyleOption *option,
    QPainter .*painter)  const;
    void drawBronzeCheckBoxlndicator(const QStyleOption *option,
    .    : QPainter *painter) const;
    void d rawBronzeSpinBoxButton( SubCont rol  which,
    const QStyleOptionComplex *option,
    QPaintar *painter). const;
    }；
    当创建一个自定义样式时，我们通常会基于某种存在的样式，这样就不用从零开始做所有的
事情。对于这个例子，我们选择QWindowsStyle，这是一个经典的Windows样式。尽管Bronze样式不
是很像Windows样式，但在QWindowsStyle和它的基类
QCommonStyle中，大部分代码都可以重用，以实
现所想到的任何样式。这就是QMacStyle从QWindowsStyle派生的原因，尽管它们看起来很不同。
    BronzeStyle实现了由QStyle定义的几个公有函数。polish()和unpolish()函数会在安装或者卸
载样式的时候得到调用。它们可以让我们对窗口部件或调色板做适当修改。其他的公有函数有
的是查询函数[ styleHint()．pixelMetric()，subContmlRect()]，有的是用于绘图的函数[drawPrimiUve()，
drawComplexContml()].    u
    BronzeStyle也提供了一个称为standardlconlmplementation()的公有槽。这个槽会被Qt的内省
(intmspectlon)机制发现，尽管它是―个虚函数，但在必要时也可调用。Qt有时利用这一惯例来添
加虚函数以保证与以前舶Qt 4版本的二进制兼容性。在Qt 5中有望用standardlcon()虚函数代替
standardIconImplementaUon()槽。
    BronzeStyle类也定义了几个私有成员函数。在介绍完公有函数之后再介绍它们。
void  B ronzeStyle: : polish (QPalette &palette)
{
   .    QPixmap  backg roundlmage ( " :/images/backg round.png " )
第19章  自定义外观343
QColor bronze(207,  155,  95) ;
QColor veryLightBlue(239, 239, 247);
QColor lightBlue(223, 223, 239);
QColor darkBlue(95, 95, 191);
palette = QPalette(bronze)
palette
palette
palette
palette
palette
palette
setBrush
setBrush
setBrush
setBrush
setBrush
setBrush
QPalette::Window,  backgroundlmage) ;
QPalette: : B rightText ,   Qt : :white) ;
QPalette: :Base,  veryLightBlue) ;
QPalette::AlternateBase, lightBlue); .
QPalette: : Highlight ,  darkBlue) ;
QPalette: : Disabled ,   QPalette: : Highlight ,
Qt::darkGray) ;
    Bronze样式的一个突出的特点是它的颜色配置。无论用户在窗口系统中设置了怎样的颜色，
Bronze祥式都有一个棕色的外观。自定义外观的颜色配置有两种设置方式：忽略窗口部件的
QPalette，使用我们喜欢的颜色（棕色、亮棕色、暗棕色等）进行绘制，或者重新实现QStyle：：polish
(QPalette＆)调整应用程序或者窗口部件的调色板，然后使用该调色板。第二种方法更灵活，因为
可以在子类中(比如，SilverStle)通过重新实现polish()覆盖原有的配色方案。
    抛光(polishing)的概念在窗口部件中是通用的。当样式应用到窗口部件时，polish( QWidget*)
就会得以调用，从而允许我们执行最后的定制：
void BronzeStyle::polish(QWidget *widget)
{
  , if (qobject_cast<QAbstractButton *>(widget)     ,
                           I I  qobj ect_cast<QAbst ractSpinB.ox '*> (widget 》
                 widget->setAtt ribute (Qt : :WA_Hover,  t rue) ;
}
    这里，我们重新实现了polish( QWidget*)，以便在按钮和微调框中设置,Qt:：WA_Hover属性。
当这一属性被设置、鼠标进人或者离开窗口部件所在的区域时，会产生_个绘制事件。这给我们
一个机会，可以根据鼠标是否位于窗口部件上把窗口部件绘制出不同的样子。
    在窗口部件创建完之后并且在第一次显示之前，会使用当前的样式来调用这个函数，然后，只
有在当前样式动态改变时被调用。    7    二    ；
    L
    void BronzeStyle::unpolish(QWidget *widget)
    {
    if (qobject_cast<QAbstraCtButton术>(widget)    ,,
    I I  qobj ect_cast<QAbst ractSpinBox术>(widget))
    widget->setAtt ribute (Qt:':WA_Hover,   fals.e);
+    ’
    正如在窗口部件上应用样式时会调用polish( QWidget*)-样，，当动态改变样式时，同样会调用
unpolish( QWidget*)。unpolish()的目的是取消polish()的作用，这样窗口部件就可以被一个新的样
式抛光。优秀的样式能够取消它们在polish()函数中的操作。
    polish( QWidget*)的一般用法是把样式子类作为窗口部件上的事件过滤器。这对于一些更高
级的定制很有用。例如，QWindowsVistaStyle相QMacStyle使用这种技术使默认按钮具有动画效果。
int BronzeStyle::styleHint(StyleHint which, const QStyleOption ;+ioption,
                      const QWidget *widget, .
                       QStyleHintReturn *returnData) const
                                                                                                          .           l
  switch (which) {
   case SH_DialogButtonLayout:    ,
                 retu rn  int ( QDialogButtonBox: :MacLayout) ;             .
   case SH_EtchDisabledText:   ' .             :   .
      return int(true);                      .    '
   case SH_DialogButtonBox_ButtonsHavelcons:
        return int(true);                    . .    .  .     .  ' .
EBFwl：、
     '344                                              C++ G. UI Qt 4编程(第 -版)
         -~-__v --
case SH_UnderlineShortcut:
          retu rn  int ( false) ;
default: '..  .
   return QV'indowsStyle::styleHint(which, option, widget
                                                         returnData) ;
 int BronzeStyle::'pixelMetric(PixelMetric'whichj . .   . .
                        const os'           :ion, .
 {                                                const' ::It~;::ptvt}:dg;tp) tcor ~t'  .
  I   switch twhjch'): { '_   .
 , ' case PM_ButtonDefaultlndicator:
   .,case PM=Indicato/W/dth: '        .              . .   '. .
 '   ca'se' PM'Ir/dicat'orHeight':        '  y  ,     .   '   .       ', .
   case PM_CheckBoxLabelSpacing:
      return 8;
    case PM_DefaultFrameWidth:                ', . .
       return 2;                  ..- .'..
  default:一  .' .
                  retu rn  QWindowsStyle: :pixelMet ric (whjch,  opt/on , :widget) ;
      }
}
    pixelMeUic()卤数返回一个像素值，用于用户界面元素中。一通过重新实现这．功能，既影响内
置Qt窗口部件的绘制，也影响其尺寸。    ．
QIcon  B ronzeStyle: : standa rdlconlmplementation ( Standa rdPixmap 'wh/ch ,
       const QStyleOption *option, const QWidget *widget) const
{   .
  .'  ' QImage image -
if (image.is.Nul
    return QIco
QWindowsSty.le : : stanqa rd Pixmap (which,   option , . widget)
                                                                                                                                                          ,
     "'QPalette palette;一:  k    :    -.  ..:  .
       'palette - o'    >palette; ;   ' .
 }elseif(w-dg9X-{/:pa .; .;..:...7 .
  ,     palette = widget->palette(); .
   }                           t- .
  : QPainter painter(&image/~~、‘'j‘‘_、a：’“J：？  +
                                                                                                                                                                                       ,.
painter.setOpacity(0.25)
            painte r, setCompositi02Jlld>; ( QPainte r: :CompositionMode  Sou rc:eAtop) ;
           painter.fillRect (image. rect{ ) ,   palette. highlight ( 》 ;-         'l
        painter,end( ) ;
    return QIcon(QPixmap::fromlmage(image》;-
 }
塞
篡
～～，一’
一枷胀
眦脚枷
一一一．t～
蒜
礅～一
叫鼹粥。
删搠眦黼
  标觋躺
  一憾湎蝴
  ㈣瞅慨撇
  间器间
  空．1不之
  的指字
  外制文一'一~
  额控拘一抛
  基
  №对附‘
  蚴孰肺～一
  龇像形一
  ～一～一，一
  对塌}舢舯
  跚制一
SE_CheckBoxlndicat
第19章  自定义外观345
      PM_Indicato Nlidth
 k――=―――――――――――― I
    -------------11
  ……‘F
TeX鼋
SE_CheckBoxFocusRect
. :' '.'.:: :: . ' .    竹SE_CheckBoxContents
       ---JI
PM_CheckBoxLpbe}Spacing_.
图 19;18  '7QCheckBox IYJ结构
    如同前面介绍的那样，Qt调用standardlconlmplementation()槽获取用在用户界面上的标准图标。
我们调用基类的standardPixmap()获取图标，并绘制浅蓝色，使其与余下的风格相协调。着色可以
通过在图标上绘制25%．不透明的蓝色实现。通过使用SourceAtop复合模式；我们确保了原来的透
明区域依然是透明区域，而不是变成了25%的蓝色和75%的透明色。第8章守":矛粤lmage高质量
    ：‘．    一‘、    ．    _、，、
绘图”一节（见8.3节）中介绍过复合模式。
    ：’：．一
    ‘’  j；’。；    ’’。’_‘．-毫：
    void B ronzeStyle::d rawPrimitive(P rimitiveElement  which,
    const QStyleOption *option,    :=抑书？?’
    . QPainter丰painter,    ,    :  _i  j]’
    :const QWidget *'widget). const:t    .  ’F:.’.‘‘i:    .‘  ：
    {
switch (which) {
case PE IndicatorCl:eckBox:
  drawBronzeCheckBoxlndicator(option, painter);
break;
case PE PanelButtonCommand:
.  drawBronzeBevel(option: "pa/nter);  ,    -       .    .   ,t, ;/:"   "
case PE Frame:  .
 .  drawBronzeFrame(optjon, pai.nter): '..‘i:   .      ' "  ..", _,:'.''.  .
 break;
case PE_FrameDefaultButtDn: ..  ,. .                  :. .   ,  .; .':ft'  . '~
                                                                                               .   '.           '
     default:                                                 -   :       :  . ,i   .
                 QWindowsStyle: :d rawP;rimitiv.e (which,.  optjon:   painter,  widget,) ; r  ' .  . : :  ': .  ':.
                                           .
    Qt调用drawPtimiU\re()困数绘制“基本的”用户界面元素，这些元素会被几个窗口。部件使用。
例如，l，E_IndicatorCheckBox会被QCheckBox、QGroupBox和QItemDelegate用来绘制选择指示器。
    Bronze样式重新实现了drawPrimitive()，给选择指示器、按钮和边框定制一种外观。图19.19
所示就是QPushButton的结构，它是Bronze样式必须处理的。．drawBronzeCheckBoxlndicator()、
    j、】～‘
drawBrohzeBevel()和dIawBronzeFrame()函数都是私有函数，稍后将会介绍它们。一  1
SE PushButtonFocusRect
    - - - -1．？●乞'=…_…。
    ．    ，！    ”  ’一
    图19.19 QPushButton的结构
SE_PushButtonContents
346    C+十GUI Qt 4编程（第二版）
    对于PE_FrameDefaultButton，我们什么也不用做，因为我们不想在默认的按钮旁另外再绘制一
个多余的边框。对于其他的基本元素，只是简单地调用基类的函数。
    void B ronzeStyle::d rawComplexCont rol( ComplexCont rol  which,
    const QStyleOptionComplex *option,
    QPainter *painter,
    const QWidget *widget) const
    {
    if (which==CC_SpinBox){
    drawBronzeSpinBoxButton(SC_SpinBoxDown,  option,  painter);
    drawBronzeSpinBoxButton(SC_SpinBoxUp, option, painter);
    QRect rect=subControlRect(CC_SpinBox, option,
    SC_SpinBoxEditField)
    ,adjusted(-l,0.+1,勺)0
    painte r->setPen ('QPen (option~>palette.mid(),1.0));
    painter->d rawLine( rect.topLeft(),  rect. bottomLeft());
    painter->d rawLine( rect.topRight(),rect. bottomRight());
QWindowsStyle::drawComplexControl(which, option, painter
    Qt凋用&-awComplexControl()函数绘制多重辅助控制器窗口部件――特别是QSpinBox。因为
想给QSpinBox -个全新的外观，所以重新实现了drawComplexControl()，处理CC_SpinBox的情况。‘
    要想绘制QSpmBox，必须绘制向上和向下的按钮，以及整个微调框周围的边框。（QSpinBox的
结构如图19.20所示。}因为用来绘制向上按钮的代码几乎与绘制向下按钮的代码相同，我们把它
提出来写到drawBronzeSpinBoxButton()私有函数中。该函数也绘制整个微调框周围的边框。
SC_SpinBoxDownButton
SC_SpinBoxFrame
 H 16 hl           l< 16 N
图19.20 QSpinBox的结构
SC_SpinBoxUpButton
SC_SpinBoxEditField
    QSpinBox便用QLineEdit显示可编辑的部分，因此不需要绘制这一部分。尽管如此，为了清楚
地区分开QLineEdit和微调框按钮，需要在QLineEdit的边缘绘制两条亮棕色的竖线。QLineEdit的
空间大小可以通过调用subControlRect()获得，SC_SpinBoxEditField作为第三个参数。
    QRect   Bron zeStyle:: subCont rolRect (ComplexCont rol  whichCont rol,
    const QStyleOptionComplex *option,
    SubControl whichSubControl,
    const QWidget *widget) const
    {
    if (whichControl==一CC-二SjjnBox){
    int frameWidth=pixelMetric(PM_DefaultFrameWidth, option,
    widget)；
    int buttonWidth =:16;  i  ‘    +
switch (whichSubControl) { '
case SC_SpinBoxFraWe:  .
   return option->rect;' '.
case SC_SpinBoxEditField:
   return option->rect.adjusted(+buttonWidth, +frameWidth,
                       -buttonWidth, -frameWidth)
case SC_SpinBoxDown:
   IJ   .
o a)
cn r-
a
第19章  自定义外观
347
         return visualRect(option->direction, option->rect,
                                                                          QRect ( option-> rect.x( ) ,   option-; rect.y ( )
                  .      buttonWidth,
  option->rect.height(》);
      case SC_SpinBoxUp:
         return visualRect(option->direction, option->rect,
                    QRect(option->rect.right() - buttonWidth
                                                        option->rect.y{) ,
    buttonWidth,
                         option->rect.height(》);  .
                 default :  '
          return QRect();
           }
 . } else {
                 retu rn  QWindowsStyle: : subCont rolRect (whichCont rol,  'option,    .
' }            whichSubControl,widget);
                                                                                                                                                                                                                                                                                      .
                                                                                                                                                                                                                                                                                  .                   .
    Qt调用subControlRect()函数确定辅助控制器窗口部件的位置。例如．，QSpinBox调用它来确定
在哪里放置QLineEdit。处理鼠标事件时也用它查找被单击的辅助控制嚣窗口部件。此外，当实现
drawComplexControl()时，我们自己调用它，在drawBronzeSpinBoxButton()中也会调用它。
    在实现中，我们检查当前的窗口部件是否为微调框i如果确实如此j就返回这些窗口部件有
意义的矩形区域、微调框的边框、编辑区域、向下按钮和向上按钮。图19 .20显示了这些矩形区域
之间的关系。对于其他的窗口部件，包括QPushButton，依赖于它的基类的实现方法。。
    SC_SpinBoxDown和SC_SpinBoxUp通过QStle：：visualRect()返回矩形区域。j，调用visualRect()使
用以下的语法：
    ‘    ！
    visualRect(direction,outerRect, logicalRect)
    如果direction是Qt．：LeftToRight，则logicaIRect将被原样返回；否则，logicaLRect针对outerRect进
行翻转。这保证了图形元素从右到左排列，主要应用于像阿拉伯和希伯来这样的语言。对于对称
的元素，例如SC_SpinBoxFrame和SC_SpinBoxEditField，翻转没有意义，因此不必调用visualRect()，测
试从右到左样式，可以简单地在命令行加入-reverse参数运行使用这一模式的应用程序。图19 .21
显示了从右到左模式下的Bronze样式。
图r9. 21从右到左模式下的Bmrize风格
这就完成了重新实现的QWindowsStyle的公有函数的介绍。
void BronzeStyle::drawBronzeFrame(const QStyleOption *option,
    QPainter *painter) const  .
{．
       painter->save() ;
         painte r->setRenderHint ( QPainte r: :Antialiasing/  t rue) ;
           painte r->setPen( QPen ( option->palette. fo reg r.ound ( ) ,   1.0》
         painter->d rawRect ( option->rect .adj usted (+1,  +1,  - 1,  -1》
      painter->restore( ) ;
}
T面的4个函数是私有绘图函数。
    f    ．
    )、
    drawBronzeFrame()函数会被drawPtimitive()调用，用来绘制一个PE_ Frame私有元素。当边框形
状为.QFrane：：StyledPanel时，它用来绘铷QFrame:(或者其子类，例如QTreeView)的边框。（其他的边
框形状，例如Box、Panel和VLir11e，直接由QFrame绘制，不使用样式。）
    我佃绘制的边框是1像素宽反走样处理的窗口部件的边框，使用调色板的前景画刷实现（可
以使用QStyleOption的palette成员变量）。因为矩形是反走样的，位于整型坐标中，有2像素宽的模
    ’    f    ‘    -    -
糊边框效果，正好是Brorize样式所需要的效果。，；o    。，  ．    ：
    为了保证QPainter保存原来的状态，我们在调用setRenderHint()和setPen()之前调用save()，最
后调用restore()恢复。这是必要的，因为Qt优化了绘图，重媳同一个QPainter绘制几个图形元素。
下一个将要介绍的函数是drawBronzeBevel()，可以用来绘制
    ’    <
void BronzeStyle::drawBronzeBevel(const QStyleOption *option,
QPushButton的背景：
                          QPainter.*paidter) const    . ' , -
{
   QColor buttonCotor = option->palettd.button().color(.);  '
    int coeff = (option->state & State_MouseOver) 1 115 : ies;
QLinearGradient gradient(
gradient.setColorAt(0,0,
gradient.setColorAt(0.2,
gradient.setColorAt(0.8,
0, 0, 0, option->rect.he
option->palette.light ( ) .
buttonColar'.lighter.( coef
buttonColor.darker(coeff
olor(》
》; .
);
g radient. setColo rAt (1,0;  option->palette, dark (.) : color ( 》 ;
    酋先设置QLinearGradient，它用来填充背景。渐变的上方是亮色，下方是暗色，其间是渐变的
棕色。渐变点在0.2和0.8，给按钮*个虚拟的三维效果。：coeff因子控制按钮的三维效果外观。
当鼠标在按钮上移动时，coeff因子使用115 010，使按钮有弹起效果。  ．
    double penWidth=1.0;    ..,‘’.,    1..,    .,  .，一’’
    if (const QStyleOptionButton *buttonOpt=    j    '
    qstyleoption_cast<const QStyleOptionButton *>(option)){
    。if』buttonOpt->featur.es＆oStyleoRtionB'uttqn．．Deijqu鼬tton）．，
    ．“  1口enwidth=2.0：一}j    ’’q 2、    ．
：．一，’！J‘．    j
    7．    、    ’，    、
    Bronze样式对于默认按钮使用2像素宽的边框，否则使用1像素宽的边框。为了判断按钮是
否为默认按钮，我们把optiort强制转换jkjc酶gt QStyleOInionBunon*类型，检查其features成员变量。
>cfo,.adjusLed4;*1:：垫i一1--1)；
int diameter -. 12; r::r .','   ' -v,:.
int. cx = 100 *: diameter0. rou.日d
int c‘’=’’reb *- d;arneterT7;№ur7d
．    ．_    ，^    ，    ，
器粼糖j。i
    ’一
  我们定义了绘制按钮瓣摹珀瓤酶簧爹酌菱量：&和’匆系数猎定按钮的回角程度。它们稂据
    +    ’’    ．  i 1    ~    、一，    ，
    di    ，；‘：，’，，：…i。t  ?j
diameter计算，指定圆角需要酶莹径：一1
painter->save( ) ;                                                        '; .  .
paint.? r-. >setBCusl  (g r― fejo:-y:) j,#/
painter->drawRoundRei    )dRe-t; cX,:'cyi; ., '  ".-: "r . . . .
 Ii-J
c-
a-
o.Ja
 JJ' cn
  H
u IJ
d Of .-
C -o C
=CL
o==
L O lJ
4J' L ~
u-
aj:
Lt f
aH
第19孝，自定义外观349
if (option->state & (St.ate_On l State_Sunken》 {
 . '  QCblor 'slightlyOpaqueBlack(0; 0, '0, 63) ;
          painte r->setB rush ( slightlyOpaqueBlack) ;. . .   .:
       painter->drawRoundRect( roundRect; cx,  'cy.) ;
 painte r->setRende rHint (QPainter:  :;Antialia sing ,  .t rue ); ;   .  .        r _
 painte r->set Pen (QPen ( option-.>palette. foreg.ro und ( l ,  p.enWidth 》.;
painter->setBrush(Qt::NcBrush), .        '  :*     : .
painter->drawRoundRect(roundRect,  cx, cy) ;
painter->restore() ;
void  B ronzeStyle: :d rawB ronzeSpinBoxButton (SubCont rol  wh:
       const QStyleOptionComplex *opt,on. QPaintet'~hX~再 //+st
   PrimitiveElement arrow = PE IndicatorArrowLeft; :  . ',   . ":
: . '  QRect buttodRect = option->rectit.     .'. '           .   .     ,
if《which-一 SC=SpinBoxUp):7.  :-,' '
  .      !- (option->directior/ =- Qt::R/ghtToLeft》 {  '-  ':    :,
    arrow = PE_IndicatorArrowRight;  .  '  . '   t
           buttonRect .t ra n slate (buttonRect.width ( 1, 1   2 ,'. 0) ;
}
buttonRect.setWidth 《buttonRect.widthC)  +:1) '1 2) ;  .
QStyleOption buttonOpt(*option)
．：：、√
。汨f：．'tj、？：
~    ’  ”    _    。
painter->setClipRect(buttonRect, Qt::IntersectClip);f .  i : ":  ..
if {!(option->activeSubControls & which》  . . :,I     '.   ;,;   :    /
     buttonOpt.state &= N(State ;MouseOver .l ,State_On :jl:State_Sunken);.'+;
drawBronzeBevel(&buttonOpt, painter); .
                                                                '   .     :C
QStyieOption arrowOpt(buttonOpt), '.:: ~~  ._'     ~.  . '.;'.' ....".
a'rrowOpt. rect -.'subContralRect(CC_Sp.inBox,  op'tion,  which): . :' jI ; :  ./
          '  .   .adjusted(+3. +3, -.3, -3).;
if (arrowOpt.rect,isValid(》  . '    1 .
          d rawP rimitive( a r row,  &a rrowOpt ,   painter) ;
painter->restore() ;
    -、‘’t‘：    --    。
暗一些。，
‘    ，    ’
画刷，绘制
  ‘dra\，BronzeSpinBoxButton()函数绘制微调框的向上或者向下的按钮，遗依赖+which的值是SC-
SpinBoxDown还是SC_SpinBoxUp。我们首先设置按钮上面的箭头（向左的或向右的箭头），以及绘制
    ‘    。  ，3L    ，，：
按钮的矩形。    。：一  i-；‘：．’”’一  ，。：．-、‘i，，．~’i‘、7．；
~如果which酌值是SC_SpinBoxDown(或者which韵值是SC_:Spin&ixUp#-且布局的方向是跌右到
左)，则使用向左的箭头( PE_IndicatorArrowLeft)，并且在微诃框矩形韵左考穆绘制按钮了否则j使用
    ：    ，
向右的箭头，在右半边绘制按钮。    1．，：，
    ‘  }r
    为了绘制按钮，使用能够正确反映微调框状态的QSt)leOption调用drawBronzeBevel()。例如，
如果鼠标在微调框上方移动，但并非which指定的微遭鹫每；臻i'J就从QStyleOptjon'的状态中清
按钮可以互不干扰。
这是因为我们只想绘制
    最后，在结尾处调用drawPrimitive()绘制箭头。用来绘制箭头的.QStye；opdon提供一个矩形，这个
    ~    ，
矩形与微调框按钮矩形(SC_SpinBoxUp或-SC_SpinBoxDolrm)相对！应，但稍4\二些，以获取小型箭头。
醮荆戤糍戮嚣移氅《只。置覃；、。r：  -“，。    ／
, L   "'
   '      t
    . .       '.
  350    C++ GUI Qt4编程（第二版）
void   B ronzeSt yle : :d rawB ronzeCheckBoxlndicato r(
       const QStyleOption *option, QPainter *painter) const
{
        painter->save ( ) ;
 .   painter->setRenderHint(QPainter::Antidliasing,  true) ;
if (option->state & State_MouseOver) {
          painte r->set Brush (optlon->palette.alte rnateBase ( 》
} else {
if (option->state & (State_On I State_NoChange》 {
 . QPixmap pixmap;   .
      if  ( ! (option->state & State_Enabled》 { ..
                       pixma p .load (”:/images/checkma rk-dis a bled . png " ) ;
    } else if (option->state & State_NoChange) {   '
                       pixmap.load ( " :/images/checkma rk-pa rtial. png ,i ) ;
   } else {
                 pixmal::r.load ( " :/images/checkma rk,png " ) ;
     }
  . QRect pixmapRect = pixmap.rect()     . .
                                                                          .t ranslated ( o ption-> rect .topLeft ( 》
                                           .translated(+2,  -6) ;
    QRect painterRect = visualRect(option->direction, option->rect
                                                        pixmapRect) ;
    if (opt:    irection == Qt::RightToLeft) {
       pair     ct.moveL'eft(-painterRect.right() - 1); '
      }
         painte r->d rawPixmap ( painte rRect,   pixmap) ;
}
painter->resto re.( ) ;
    犀管draw-BronzeCheckBoxlndicator()的代码起初看起来有些复杂，绘制复选框的指示器实际上
相当简单：使用drawRoundRect()绘制一个矩形，并且使用drawPixmap()绘制选取标志。复杂度提高
是因为当鼠标在复选框指示器上移动时我们想使用一种不同的背景色，我们区分启用标志、禁用
标志以及末决标志（三状态复选框），并在从右到左模式下翻转选取标志（通过翻转QPainter的坐标
系统）。
   ri
                        J
   r'
     +
   rl
.N   +
-o
o  IJ
rD  =
-O   'r.
 .  o
o  a,
 IJ     .
 IJ      IJ .
ou
rO
A ^7
I  C
co
o   rl
rl    IJ
IJ   O-
o-  o
o-
v  IJ
-C .          u
'=  R
L  -O
co  C
IJ   =
oo
第19章  自定义外观
351
    现在，我们就完成了Brorize QStyle子类的实现。在图19 .17中，QDateEdit和QTreeWidget、都使
用了Bronze样式。，尽管没有编写针对它们的代码。这是因为QDateEdit、QDoubleSpinBox以及其他一
些窗口部件都是“微调框”，因此可以使用Bronze样式代码绘制它们。同样，QTreeWidget以及其他
的一些继承自QFrame的窗口部件也可以使用Bronze样式自定义外观。
    本节中介绍的Bronze样式可以很容易地应用于应用程序中，只需把它连接进去，然后在应用
程序的main()函数中调用：
就可以了。没有被Bronze样式处理的窗口部件则会保持传统的Windows外观。自定义样式也可以
被编译成插件，在高级版本的Qt设计师中使用，使用该样式预览窗体。第21章将介绍如何将
Bronze样式编译成Qt的插件。，：，  0．j
    。  、  ．    ‘  。    ：~’
    -  Ⅵ    ．
    尽管这里开发的样式仅有大约300行的代码。但值得注意的是，要开发一种功能齐全的自定
义样式则是一项很大的工程j’-般需要3000到5000行的C++代码。因为这个原因，在可能的情
况下，使用Qt样式衰则显得更为容爨襄方便，或者使用两者混合的方法，将样式表和自定义样式
结合起来使用。如果你计划创建一个自定义样式，实现样式以及样式化窗口部件的方法在网站
http：//doc．trolltech．coIn/4. 3/style- reference．html上有深入的介绍。．．i
    -。
第20章  三维图形
    OpenGL是绘制三维图形的标准API。Qt应用程序可以使用QtOpenGL模块绘制三维图形，该模
块依赖于系统的OpenGL库。Qt OpenGL模块提供QGLWjdget类，可以通过对它的子类化，并使用
OpenGL命令开发出自己的窗口部件。对于许多三维应用程序来说j这就足够了。本章第一节介绍了
一个简单的应用程序，该程序使用这一技术绘制一个三角锥，用户可以使用鼠标与其交互。
    从Qt 4开始，可以在QGJjVfidget上使用QPainter，尽管它还只是一个普通的窗口部件。在QGL-
Widget上使用QPa/nter的好处是可以使用垒婴g盔弦麴丝越乳塑逊垡堕坠继叠曾灸以羹箍蓁曩暴萎
制。使用QPainter的另一个好处是司噘砭甬萁二维的高级API，并结合OpenGL调用来绘・
本章第二节将介绍如何在同一窗口部件中使用QPainter和OpenGL命令绘制二维和三维的组合。
    使用QGLWidget，可以在场景中使用OpenGL作为后端绘制三维场景。为了在硬件加速的离屏
表面上绘制，可以使用pbu珏翌塑jcamebuf眨对黎鲎堑芝屋j逊口分别在QGLPixelBuffer和QGLFrame -
bufi~e/0bject粪中。，，奉磊酾臻三节将介绍如何使用帧缓存对象袋堡耋办Ⅱ。
    本章假设读者已熟悉OpenGL。如果刚开始接触OpenGL，那么http：//www. openg. org／是学习它
的好地方。    ，    一：-  ，：
20.1  使用OpenGL绘图
    在Qt应用程序中绘制OpenGI。是很简单的：必须子类化QGLWidget，实现几个虚函数，连接
QtOpenGL和OpenGL库。由于QGLWi（1get派生自QWidget，许多已知的技术仍然适用。最大的区别
是要使用标准的OpenGL函墼董垡QPainter塞塞理绘剜。
    为了介绍QGLWidget的用法；我们将查看图20.1所示的Tetrahedron应用程序的代码。该应用
程序可以显示一个三维的三角锥( tetrahedron)，或者也可以称为四面体，它的每个面都具有不同的
颜色。、用户可以通过单击并拖动鼠标来旋转它。用户也可以通过双击某个面，并从弹出的QColo，一
Dial.og中选择一种颜宦莱谩甚这个面爵颜石：’‘
图20.1  Tetrahedron应用程序
第20章三维图形
class Tetrahedron : public QGLWidget
{.
   Q OBJECT .
public:
   Tetrahedron(QWidget *parent = O);
protected:
        void  init:alizeGL ( ) ;
   void resizeGL(int width, int height);      .
      void paintGL( ) ;
      void mousePressEvent(QMouseEve.nt *event) ,
   void mouseMoveEvent(QMouseEvent *event); .
      void mouseDoubleClickEvent(QMouseEvent *event) ,
private:
      void draw( ) ;
      int faceAtPosition(const QPoint &po.s) ;
      . GLfloat rotationX;
. ' GLfloat rotationY;                                 . . ;
    GLfloat rotationZ;
           QColor  faceColors [4] ;                                                                             :
     QPoint lastPos;
  }.                                                             . :
   J.
    Tetrahedron类从QGLWidget中派生而来。initializeGL()、resizeGL()和paintGL()速三个函数是在
QGLWidget中实现的。鼠标事件处理器在QWidget中实现。    ~    一  ！”、’i
Tet rahed ron : :Tet rahed ron ( QWidget  *pa rent )
   : QGLWidget(parent)
{
   setFormat(QGLFormat(QGL::DoubleBuffer I QGL::DepthBuffer》;  '  :  ', :' .":
    rotationX=-21.0;
    rotationY=-57.0;
    rotationZ=0.0;
    faceColors【0】=Qt:: red;
    faceColors[ll=Qt::green;
    faceColors[2]=Qt::blue;
    faceColors[3】=Qt::yellow;
    }
在构造函数中，调用QGLWidget:：setFonnat()指定OpenGL的显示描述表，并且初始化私有变量。
    void  Tet rahed ron::initializeGL()
    {    ‘j    、    ，  ．
    ’    qglClearColor(Qt::black);
    glShadeModel(GL_FLAT);
    glEnable(GL_DEPTH_TEST).;    ,  .    ,    .
    glEnable(GL_CULL_FACE);t.    .    ,    ,  j    ,,‘
    }
    ．、    ．    ．j    ．    '‘、
    injtializeGL()函数在调用paintGL()之前只被调用一次。可以在这里设置OpenGL的绘图描述
表，定义显示列表，以及执行其他的初始化。一：    j√+1．f。一  ，-‘0j
    ’  ，．‘  ．  j‘    ’
    所有的代码都是标准的OperiGL,除亍对QGLWidget的qgiaeajCcoior()函数的调用。如果想坚
持使用标准的()penGL，则可以在RGBA模式下调用glClea~oior（一商在颜色索引模式下调用gl-

    应在第一次调用paintGL()之前，但在initializeGL()之后调用resizeGL()函数。在窗口部件改变
大小时也将调用resizeGL()函数。在这里可以设置OpenGL视口、投影以及其他与窗口部件尺‘寸相
关的设置。
    void Tetrahedron::paintGL()
    t
    glClear(GL_COLOR_BUFFER_BIT l GL_DEPTH_BUFFER_BIT);
    d raw()；
    }
    在窗口部件需要重绘时调用paintGL()函数。它与QWidget:：paintEvent()类似，使用OpenGL函
数代替QPa/nter函数。实际的绘制由私有函数draw()实现。    ，    ．

    在1draw()中，我们绘制三角锥，应用x、y和z轴的旋转以及保存在faceColors数组中的颜色。每个
调用都是标准的OpenGL，除了qglColor()函数。可以根据颜色模式使用OpenGL函数gIColor 3d()或者
gllndex()。
void  Tet rahed ron : :mouseMoveEvent (QMouseEvent  *event)        .
{,   .'
   'GLfloat dx = GLfloat(event->x() - lastPos.x(》 / width(');
'.  GLfloat dy = GLfloat(event->.y() - l.astPos.y(}) / height()
   if, (event->buttonsj) & Qt::LeftButton) {.  .
        rotationX += 180 * dy;
        rotationY += 180'* dx;              '             ,
            updateGL( ) ;             .
    } else if (event->buttons() & Qt::RightButton) {      .
        rotationX += 180 * dy;
  .     rotationZ += 180 * dx;    .
            updateGL( ) ;
      }
     lastPos = event->pos() ;
L
-o
C
o
L
-o
-C
L
IJ' '
-o
o
> hr
1 1
1  -
o _ r; th
 lIO
N   .
+   -  - ro
co co
o rr, rr,
5 5  .
2 r-J +
m rri
r- r-  -
 . .o
7 rr o
1 2 3 4
a- .o- a- a-
 r-J
 o-
. II附
^叶rL
o
'u
4- rr7
\n a_
o-
 o-
*
4-  rL
ra  _
O r_
f rrl
J- r-J
cn Dr
o~
U r-
 a-
u
r4 rt
4-
IJ
0 0 0
0 0 1
    J  0
 .  o  OXYN
  o   CCC
    H.-- ~ O O O
           l- o r4 rl  r4
      J．【  . 4- IJ 4-
      --.4- v 4- 4-  IJ
    eiH; f O O O
 .   -0 4- Q> L L L
     o C 4-(((
     E_Q> m f f f
          x -O r  Q>  Q) . Q>
      rl H Ul I  I  IJ
     L O c a, a, a,
      iJ ra ra 4_ rJ rJ
    ra o L O O O
     E _l T R R R
.N  r r r r r r
r_g D O. O. g 0.
 rt o r-J
~+--
  d
  LU
  L
1，仃丁
4- .
>
*
4-
>
LU
12   .
o
a
4-
>
IU
Y;  .-
Q> .  -
Lv
o-   cn
\n nr
=A
o  I
E  4-
..   C
..    Q>
C>
L
-O    lI
-c   <n
a,  o
L  O_
4-    4-
Q>    <n
T   ra
-o
H
o
> "J
    第20章三维图形355
    mousePressEvent()和mouseMoveEvent()函数在QWidget中实现，用户可以通过单击并拖动鼠标
旋转视图。鼠标左键可以沿着x和y轴旋转，右键可以沿着x和。轴旋转。
当rotationX.rotationY和rotationZ其中一个变量的值改变时，我们调用updateGL()重绘场景。
void Tetrahedron::mouseDoubleClickEvent(QMouseEvent *event)
{    ，
    int  face=faceAtPosition(event->pos());
    if (face!=-1){
    QColor  color=QColo rDialog::getColor( faceColo rs[ face],  this);
    if (color,isValid(》{
    updateGL(删叫吼0r；
    }    }
}
    mouseDoubleClickEvent()在QWidget中实现，用户可以双击三角锥的面设置其颜色。调用私有函
数faceAtPosition()确定光标下的面。如果用户双击了某个面，就调用QColorDialog：：getColor()，为该面
获取一种新酌颜色。然后，使用新颜色更新faceColors数组，并且调用updateGL()重绘场景。
makeCurrent();
glGetlntege rv ( GL_VIEWPORT,   viewpo rt ) ;
glSelectBuffe r ( MaxSize,   buffe r) ;
glRend,erMode(GL_SELECT) ;
glInitNames ( ) ;
glPushName(0) ;
  glMat rixMode ( G L_PROJ ECTION ) ;                .  '
 glPushMatrix() ;  .
 g'lLoadldentity ( ) ;
 gluPickMat rix (GLdouble ( pos.x( 》 ,  GLdouble (viewpo rt [31  -  pos,y( 》
GLfloat x = GLfloat(width(》 / height();  .
glFrustum(-x,'x, -1.0, 1.0, 4,0, 15.0);  : l       .  '   _
glFlatrixMode(GL_PROJECTION);  ' '  ' .:':: " .
'glPopMat rix ( ) ;      .
    faceAtPosition()函数返回窗口部件某位置所处的面的编号，如果没有面就返回-1。确定被选
面的代码在OpenGL中有点复杂。辜实上，我们以GL_ SELECT模式绘制场景，使用OpenGL的选择
功能，从OpenGL的命中记录中读取面编号（它的“名字”）。代码是标准的OpenGL代码，除了起初
的QGLWidget::makeCurrent()调用，它可以确保我们正确地使用OpenGL描述表。[QCLWidget在调
用initializeGL()、resizeGL()或paintGL()之前会自动调用它，在Tetrahedron实现的其他地方则不需要
调用它。]
    以下是该应用程序的main()函数：
if (!QGLFormat::hasOpenGL(》 {
o
1J
C
rl
o
o
1J
C   ,
o
U
C
o
rl
1J    N-    '
rl   t.J ._
o   Ln oJ
L  N
1J    II ;rl  '
<    S .-
o  QJ x-
U    N t0 4
ro    d EC
f  S ~rJ
..   x   L
N.    ro a) o
C   E u- O
-a   C o rl
-C      1J
ro    rJ c rJ
L   tn rl C
a)     o _i _i
T    u O O
1J
C
rl rt
a:
LU
o
Z
o:
                 I
J
 a)         . -
-o   ,-.
o   rri
H .-【
L _l L
o I a)
-o          . -
 C  c: .-
OL=
at = -o
r 1J
a) o C
-. L L
    1J
.-  o
rl  L
    r-
,-.   >
>L
a)   ra
L
ra  '  N
*  ,u
   07}
LL
ro    ra
ua
 N   ra
u
a)  r=
LO
   +J
+J   ro
cu
, -1        rl
ca
rl   a
ro  <
EO
 1J ,
C
rl rt
   356                           ..  .    C++ GUI Qt 4'编程(第二撰)     .- ,.
._______,_--._-______---_.,_一 -
           std::cerr<< "This system has no OpenGL support"<< std::endlj    . '.':..  . ' .
   '  Tetrahedron tetrahedron;                         .".   .   .  ', .  ' .
       .            tet rahed ron.setWindowTitle (QObj ect : :tr( "Tet rahed ron" 》 ;       ,    '
      tetrahedron.resize(300, 300);                                . . ' ;
             tetrahedron.show() ;
如果用户的系统不支持OpenGL，则会在控制台打印错误信息并立即返回：
    为了使应用程序正确连接QtOpenGL模块和系统的OpenGL库，需要在．pro文件中添加这一项：
这就完成了Tetrahedron应用程序。
20.2 0penGL和QPainter的结合
  ：前i节中已经看班了如何在QGLWidget上使用OperrGL命令绘制一个三维场景。我们也可以使
用QPainter.莓QGLWidget上绘制二维图形。本节的Vowel. Cube例子组合使用了．OpenGL和QPainter．
    ：    一    ’
以便尽可能地越到两全其美。本节还给出了QGLWidget：：renderText()函数的用法，该函数可以在三
维场景中绘制不变形懿文本标注。该应用程序的运行效果如图20.2历示。
图20.2  Vowel Cube应用程序
    Vowel Cube显示一个由土耳其语言的8个元音字母组成的立方体，这一图形经常出现在介绍土
耳其语法和语言的书中。在前景部分，一个图例列举了元音的类别，以及各个元音所属的类别。这个
立方体使这一信息更为直观。比如说，前元音位于立方体的前面，后元音位于立方体的后面。背景部
分则使用了辐射渐变。
’  class VowelCube:public QGLWidget    ‘
    {Q    ．
    O_OBJECT
    public：    ’。    ‘4
    一第20章三维图形357
    VowelCube(QWidget *parent i 0);
    ―VowelCube()；
protected:
   void paintEvent(QPaintEvent *event);
       void mousePressEvent (QMouseEvent  *event) ;
   void mouseMoveEvent(QMouseEvent *event);
     void wheelEvent(QWheelEvent *event) ;
p rivate:
     void createGradient() ;
     void createGLObject() ;
   void drawBackgrou.nd(QPainter *painter), .""
   void drawCube(); '     '
      void drawLegend(QPatnter *painter.) ;:  . , .  ; ':
GLuint glObject;
QRadialGradient gradient;
GLfloat rotationX;
GLfloat rotationY;
GLfloat rotationZ;
GLfloat 'scaling;
QPoint lastPos;
VowelCube类派生自QGLWidget．它使用QPainter绘制背景的渐变，然后使用
方体，接着使用renderText()绘制立方体角上的8个元音字母，最后使用QPainter
制图例。用户可以单击并拖动鼠标来旋转立方体，并且可以使用鼠
OpenGI：调用绘制立
和QTextDocumei/t‘绘
不像前面一节中三角锥的例子j在那个例子中j我们实现了QGLWidget‘的禽致函数iniUaiizedi(>、
resizeGL()和  paintGL( ) ,这次我.fi们实现传统的 Q'ffidget处理 ,这更有利于更新
              VowelCube :  : VowelC u be ( QWidget  '*pa'r
  .  :QGLWidget(parent)';  p lnt~
          setFormat(QGLFormat(QGL::SampleBuf.fers},)’;’j. .    :. . .. :.
  .  rotationX=-38.0':    ，‘  ‰  _．”．’．，
  createGradient(); 'l~
    在构造函数中
始化类的各个私有
调用createGLObject
地重绘场景。
OpenGL的帧缓存。
    void  VowelCube::c reateGradient()    ．  一，    。
    {
    g radient. setCoo rdinateMode( QG radient::Obj ectBoundingMode);
    g radient- setCenter(0.45,0.50)；    ．    ；j  ：‘一、一？。，：，，+  -    二：    ．
    g radient. setFocalPoint( 0.40,  0.45);
    g radient. setColorAt (0.0,  QColo r(105,   146,   182));    ‘”誊_-,”    .,.-  .7‘    ；
    g radient .setColo rAt(0 .4, .QCol.or( 81,   113,   150.));  .
    g radient.setColo rAt (0;8,'QCotor (116:   56 "121)j;.    _  0.    ‘  ～
    、    。
    )    ：
    ．    』。I
    在createGradient()中，我们简单地使用不同的蓝色渐变色设置QRadialGradiento setCoordinate-
Mocle()调用确保指定的中心和焦点坐标根据窗口部件大小进行调整。其位置用O和1之间的浮点
数表示，O对应焦点坐标，1对应圆的边缘。
C++ GUI Qt 4编程（第二版）
glShadeModel(GL_FLAT)
glObject
gl.NewLis
qglColor
glLineWi
t(g
coc
dth
 lGenLists ( 1) ;
Object, GL_COMPILE)
lir(255, 239, 191》
glBegin (GL_LINES) ;
glVertex3f(+l.0, +1.0, -1.0);
glVertex3f(-l.0, +1.0, +1.0);
glEnd( ) ;
glEndList ( ) ;
    createGLObject()创建OpenGL列表，该列表保存绘崩的立方体的边。除了在开头部分的QGL-
Widget:：makeCurrent()调用外，这些代码都是标准的OpenGL代码，但它可以确保我们正确地使用
OpenGL描述表。
    在析构函数中，调用glDeleteLists()删除构造函数创建的OpenGL立方体对象，然后需要再一次
调用makeCurrent()。
void VowelCube::paintEvent(QPaintEvent * /* event */)
{        .
   QPainter painter(this);.
      drawBackground(&painter) ;            .
      drawCube() ;   .
  drawLegend(&painter); .
            -
茌paintEvent()中，像普通的QWidget -样来设置QPainter，然后绘制背景、立方体以及图例。
void  VowelCube: :d rawBackg round ( QPainter  *painter)
{
painter->setPencot::NoPen);
 ' painter->setBrush(gradient);   .
        painter->drawRect ( rect ( -》 ;
}
绘制背景，简单来说就是使用合适的画刷调用'drawR.ect()。
    drawCube()函数是该定制窗口部件的核心。我们分两部分来介绍它：
    void VowelCube::drawCube()
    {
    glPushAttrib (GL_ALL_ATTRIB_BITS);
    glMatrixMode(GL_PROJECTION);
    glPushMat rix()；
    glLoadldentity()；
    GLfloat x=3.0章GLfloat(width(》／height();
    glOrtho(-x, +x, -3.e, +3,e, 4.0, 15,0);
glMatrixMode(GL_MODELVIEW) ;
glPushMatrix( ) ;
glLoadldentity ( ) ;
glTranslatef(o.e, 0.0, -10.0);
4J
u
'r
o
J
J
ra
L   .~
u-
oc
DO
=L
LL
3 .   Q)
>  ra
    E
-o
rl
o
>{
    .    4J
      u
      o
-     'r-t
--    -o
=  o
J   _ cn
o  C 4J
3    ~- cn
o  ' C-H
>    o -l
 I   .L O
..    L 4J
..   = o
oU
D  OO
u    a, J
r EO
o
o
第20章  三维图’形359
glScalef(scaling, scal'ing, scalingJ
glRotatef ( rotationX,'- l.0,  0..0,  0.0) ;
glRotatef(rotationY, 0.0, l.Or 0.0);
glRotatef(rotationZ, 0.0, 0.01 1.0);
glEnable(GL_MULTISAMPLE) ;
    因为在两段代码中有一些OpenGL的代码，所以必须小心二一特别地，我们必须保存修改的
OpenGL状态，然后再在适当的时候恢复它。因此，需要保存OpenGL的属性、投影矩阵以及修改前
的模式视图矩阵。最后，设置GL_MULTISAMPLE参数启动反走样。
glCallList (glObj ect) ;
setFont(QFont("Times", 24》;
qglColor(QColor(255, 223, 127》
renderText (+1.
renderText (-1.
renderText (+1.
renderText(-l,
renderText (+1.
renderText (-1.
renderText (+1.
renderText (-1.
glMatrixMode(GL_MODELVIEWJ
glPopMat rix (,) ;
glMatrixMode(GL_PROJECTION) ;
glPopMatrix ( ) ;
glPopAttrib()
QChar
QChar
QChar
QChar
QChar
QChar
QChar
QChar
OxeOF6
Ox0131
OxOOFC
    按着，调用glCallList()绘制立方体对象。然后设置字体和颜色，调用QGLWidget：：renderText()
绘制立方体角上的元音。对于不能用ASCII表示的土耳其元音，就使用它们的Unicode值。    ．
    renderText()函数带一组(x，y，z)坐标，指定文字在模式视图上的位置。文字本身不能变形。
void  VowelCube: :d rawLegend (QPainter  *painterJ
{
   const int Margin = 1'1;
   const int Padding = 6;
QTextDocument textDocument;
textDocument.setDefaultStyieSheet ( "* {  color:  #FFEFEF  } " ) ;
textDocument.setHtml("<h4 align=WcenterW>Vowel Categories</h4>
                 "<p align=\"center\"><table width=\"lOOga\">
                                                             " <t r><td>Open :<td>a<td>e<td>o<td>&ouml ; "
textDocument. setTextWidth ( textDocument , size ( ) .width ()) ;
QRect  rect (QPoint (O r  0) ,  textDocument. size( ) .toSize( )
                        + QSize(2 * Padding, 2 * Padding》;
painter->translate(width() - rect.width() - Margin,
        '       height() - rect.height() - Margin);  ;r'
painter->setPen(QColor(255, 239, 239》; .   . :'     .
painter->setBrush(QColor(255, ot e, 31});   '
painter->drawRect ( rect):
painter->t ranslate ( Padding,   Padding)
textDocument . d rawContents ( painter) ;
    茌drawLegend()困数中，我们使用一些HTML文字设置QTextDocument对象，列举了土耳其语
言的元音种类和元音，在半透明的蓝色矩形上绘制它们。
r-{ 1 1 1 1 r-{ r-{ r-
11▲1▲1▲1▲ r-{ r-{ r-
  N  N  '~  N  N  N  N  N
1 1▲1 1 1▲1▲1▲ r-
1 1 1▲1 1 1▲1▲ r-
NNNN-NNN
1▲1▲ r-{ r-{ r-  + + +
C++ GUI Qt4编程（第二版）
    VowelCube窗口部件实现了mousePressEvent()、mouseMoveEvent()以及wheelEvent()，但没有什么
特别之处。如同在一个标准的Qt定制组件中，在需要重绘的时候调用update()。例如，以下是
wheelEvent()的代码：    一
void VowelCube::wheelEvent(QWheelEvent *event)
                                         .
   double r     -ees = -event->delta() / 8,0;  .  '
    doubi: :::;lfi;~:e. numDegrees / 15.0;
   scaling *- std::pow(1,125, numSteps);. .
                                                                                                                             ...
    这样就完成了对本例的介绍。在VowelCube的paintEvent()实现中，使用以下通用模式：
    1．创建一个QPainter。
    2．使用QPainter绘制背景。    ．
    3．保存OpenGL状态。
    4．使用OpenGL操作绘制场景。    。
    5．恢复OpenGL状态。
    6．使用QPainter绘制前景。
    7．销毁QPainter。
还有其他的可能oi．例j/p？，妻Ⅱ果不绘制背景，可以这样做：
    1．使用OpenGL操怍绘制场景j  '
    2．创建QPainter。，：
    3．使用QPainter绘制前景。
  4．销毁QPa/nter。
    ．    ．    ‘    。
这对应于下面的代码：    ．，一’‘    f  ．    ：    ．
    void VowelCube::paintEvent(QPaintEvent章／车event丰，)
    {    。
    drawCube()：
    d rawLegend()；
    )  ．    i
    void VowelCube::drawCube()    .
    {
    )    。    ．
    void VowelCube::drawLegend()
    {
    值得注意的是，这一次我们在drawLegend()函数中创建QPairiter对象：该方法主要的好处是
不需要保存和恢复OpenGL的状态。但不能就这样使用它，因为QPainter在开始绘制之前会自动清
除背景，从而覆盖OpenGL场景。为了避免这种情况，必须在窗口部件的构造函数中调用setAuto-
FillBackground( false)。    ．
    如果只绘制背景和立方体，而不绘制前景，那么就会发生另外一种有趣的模式：
  、1．创建.QPainter。  ，  、    ？    -
    2．使用QPainter绘制背景。  ‘’    ‘∥’
rl
L.
4J   .
.1上
ra _
o-
4J
.1上
m.
o-  .
o.
 .    、t
第20章一’三维图形
361
    3．销毁QPainter。  ！    ．
    4．使用．OpenGL操作绘制场景。‘  ．，~，    ．  ’，i
    这次不需要保存和恢复OpenGL状态。但这样也不能工作，因为QPainter为了使结果可见在其
析构函数中自动调用QGLWidget:：swapBuffers()，任何QPainter析构函数之后的OpenGL调用将会作
用于离屏缓存，而不会在屏幕上显示。为了避免这一点，必须在窗口部件的构造函数中调用setAu-
toBufferSwap( false)，在paintEvent()的结尾处调用swapBuffer()。，例如：
      drawBackground( ) ;
   .  drawCube() ;
      swapBuffers() ;
}
void  VowelCube: :d rawBackg round ()
{
      QPainter painter(this) ;  .
}
    J’    ．
    ．)
    总之，最通用的方法是在paintEvent()中创建一个QPainte。，在进行纯O:penGL操柞时葆荐和恢
复其状态。倘若记住以下几点，就可以避免一些状态的保存操作：    --j
    。QPainter的构造函数[或者QPainter:：begin()]自动调用glClear()．除非预先调用窗口部件的
    ．  ：一i   -’一
    setAutoFillBackground( false).
    ●QPa/nter的析构函数[或者QPainter:：end()]自动调用QGLWidget:：swapBuffers()切换可见缓，
    存和离屏缓存，除非预先调用窗口部件的setAutoBufferSwap(false)。  ，  、
    。当QPainter被激活，我们可以交叉使用纯OpenGL命令，只要在执行纯OpenGL命令之前保存
    OpenGL状态，之后恢复OpenGL状态。
    注意到这几点，将OpenGL和QPainter结合起来就变得容易多了，QPainter和OpenGL为我们提
供了更强的图形处理能力。    ‘
20.3使用帧缓存对象生成叠加
    通常，我们需要在一个复杂的三维场景中绘制简单的注解。如果场景非常复杂，可能需要几
秒钟来绘制它。为了避免重复绘制场景，每当注解改变时，我们可以使用Xll叠加或者OpenGL内
置支持的叠加。
    最近，pbuffers和framebuffer对象提供了更方便和更灵活的制作叠，力口的方法。基本的思路是在
离屏表面绘制三维场景j并将其绑定纹理。纹理通过绘制矩形映射蓟屏幕，洼解绘制在上面。当
注解改变时，只需重绘矩形和注解。概念上，这类似于第5章的二维Plotter窗口部件。
    为了阐述这一技术，我们将介绍如图20.3所示的Teapots应用程序。该应用程序由单个OpenGL
窗口组成，该窗口显示了一组茶壶，用户可以在上面单击并拖动鼠标来绘制橡皮筋选择框。茶壶
不以任何方式移动或改变，除非窗口大小发生变化。实现上依靠fmmebuffer对象来保存茶壶的场
景。也可以使用pbuffer来实现相同的效果，用QGLPixelBuffer代替QGIFmrnebufferObjectj
362    C++ GUI Qt 4编程（第二版）
class Teapots : public QGLWidget
{
Q_OBJECT
public:
   Teapots(Q/lidget丰parent = O)
        ~Teapots ( ) ;     .
图20.3 Teapots应用程序
p rotected:          .
        void  initializeGL( ) ;
   void resizeGL(int width, int heighti;
   void paintGL();
   void mousePressEvent(QMouseEvent丰event);
      void mouseMoveEvent(QMouseEvent丰event) ;
   void mouseReleaseEvent(QMouseEvent丰event);
private:
         void  c reateGLTeapotObj ect ( ) ;
   void drawTeapot(GLfloat x, GLfloat y, GLfloat ambientR
                GLfloat ambientG, GLfloat ambientB,
         . ' . . GLfloat diffuseR; GLfloat'diffuseG,. .
                GLfloat diffuseB, GLfloat specularR,
               GLfloat specularG, GLfloat specularB,
               GLfloat shininess);
       void  d rawTeapots ( ) ;
         QGLF ramebuffe rObj ect幸fbObj ect ;
   GLuint glTeapotObject;
  QPoint rubberBandCornerl;
  QPoint rubberBandCorner2;
  , bool rubberBandIsShown;
    Teapots类派生自QGLWidget，实现了OpenGL的高级处理函数irutializeGL()、resizeGL()和paint-
GL()。同时，它还实现了mousePressEvent()、.mouseMoveEvent()和mouseReleaseEvent(‘)，以便可以让
用户绘制一个橡皮筋选择框。
    私有函数负责创建茶壶对象以及茶壶的绘制。代码基于“OpenGL ProEtamming Cuide”这本书中
的teapoLs例子，而且很复杂，该书的作者是Jackie Neider、Tom Davis和Mason Wqo(Addison-Wesley，
1993)。由于它跟我们的目的没有直接的关系，所以在这里就不苒介绍了。
    这些私有变量可以保存framebuffer对象、茶壶对象、橡皮筋选择框的各个角，以及橡皮筋选择
框的可见属性。    、
    ，，第20章三维图形363
Teapots : :Teapots ( QWidget  *pa rent )
         :  QGLWidget ( pa rent )
 L               .
 . rubberBandIsShown = fatse;
    makeCurrent()；
    fbObject=new QGLFramebufferObject(1024, 1024:
    QGLFramebufferObject::Depth);
    createGLTeapotObject();
    }
    Teapots构造函数初始化rubberBandIsShown私有变量，创建.fiamebuffer对象，并创建茶壶对象。
我们将跳过createGLTeapotObject()函数，因为它很长而且并不包含与Qt相关的代码。
    Teapots::~Teapots()
    {
    makeCurrent()；
    delete 'fbObject；    一
    glDeleteLists( glTeapotObj ect,1)i
    }    ～
    ~    ．，+‘i
在析构函数中，释放与fran/ebuffer对象和茶壶相关的资源。
    void Teapots::initializeGL()
    {
    static const GLfloat ambientll={0.0, 0.0, 0.0, 1.0};
    static const GLfloat diffuse[J={1.O,1.0,1.0,1.0};    .
    static const GLfloat position【】={e.0,3.O,3.O,0.O};
    static const GLfloat lmodelAmbient【】={0.2,0.2,0.2,1.O};
    static const GLf10at locaWiew[】={0.0};
    gU.ightfv(GL_LIGHT0,GL__AHBIENT.ambient);    --
    g‘【Lightfv(GL―LIGHT0,GL DIFFUSE,diffuse);
    gU.ightfV(GL―LIGHT0,GL POSITION,position);
    gUightHodelfV(GL_LIGHT-HODEL-AHBIENT,lmodeUmbient);
    gUightHodelfV(GL_LIGHT-HODEL―LOCAL_vIEwER,locaWiew);
    glFrontFace(GL__CW)；
    glEnable(GLLIGHTING);    .
    glEnable(GL―LIGHT0)；
    glEnable(GL-AUTO―NORMAL);
.    glEnable(GL_NORHALIZE);
    glEnable(GL一DEPTH_1_EST);
    glDepthFunc(GL LESS)；
    }
    initializeGL()函数用来设置光照模式，打开各种OpenGL特性。代码直接来自于前面提到的
“OpenGL 'Pt_ogramming GLude”这本书的teapots例子。
    void Teapots::resizeGL(int width, int height)
    {
    fbObject->bind()；
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_LIGHTING);
    glEnable(GL_DEPTH_TEST);
glViewport(0, 0, width, height);
glMatrixMode(GL_PROJECTION) ;
glLoadldentity() ;
if (width<= height) {    .'
     glOrtho(0.0, 20.0, 0.0,' 2d,0 * GLfloat(height) / GLfloat(width)
         -io.o, io.e);
} else {
   glOrtho(0.0, 20.0 * GLfloat(width) / GLfloat(height), 0.0, 20.0
         -io.e, io.e);
                                                                                                               .
;lMatrixMode(GL_MODELVIEW) ;
d rawTeapots ( ) ;
fbObject->release();' '
364    C++ GUI q4编程（第；版）
    resizeGL()函数在Teapot窗口部件改变大小时重绘茶壶场景。为了在：framebuffer对象上绘制
茶壶，在函数的开头调用QGLFramebuffeIobject：：bind()。然后，设置_些OpenGL特性，以及投影和
模式视图矩阵。结尾的drawTeapots()调用在framebuffer对象上绘制茶壶。最后，'Irelease()调用释放
framebuffer对象，确保随后的OpenGL绘制操作不会发生在framebuffer对象上。
    void Teapots::paintGL()    .  ～.7  .
    {
    glDisable{GL_LIGHTING);
    glViewpo rt(0,0,width(),height());    .
    glMat rixMode( GL_PROJECTION);    j,  .
    glLoadldentity()；    j    ，  ．
    glMatrixMode(GL_MODELVIEW):
    glLoadldentity()；
    glDisable(GL_DEPTH_TEST);    ’一，”’    ‘。一。  +  ..:
gl(lear(GL_COLOR BUFFER_BIT);   '  .
glEnable(GL_TEXTURE_2D) ;
glBindTextu re ( GL  TEXTURE_2D,   fbObject->texture ( 》 ;
glColor3f(l.0,  1.0,  1.0) ;
GLfloat  s  = width( )  /  GLfloat ( fbObject->size( ) .width( 》 ;
GLfloat  t  =  height ( )  /  GLfloat ( fbObject->size( ) .height ( 》
glBegin(G:c~2}U(:D~),:0.0
glTex(OD rd21
glVert.ex2f{i: 1.0,. -1;0
glTexCDord2'f(s,  0.0) ;
glVertex2f(l.0, -1.0)
glTexCoord2f(s, t);
glVertex2f(l.O, 1.0);
glTexCoord2f(0.0, t) ;
glVertex2f(-l.0, 1.0)
glEnd( ) ;
    茌paintGL()函数中，首先重新设置投影和模式视图矩阵。然后，把framebufler对象绑定到纹
理上，绘制一个带有该纹理的矩形覆盖整个窗口部件。
if  ( rubberBandIsShown) {
      glMatrixMode(GL_PROJECTION) ;     .
   glOrtho(0, width(), height(), e, o, ioo);  .  '
  , glMatrixMode(GL_MODEMEW);" '  .
      glDisable(GL_TEXTURE_2D) ;
 . glEnable(GL_BLEND);
        glBlendFunc( GL_SRC_ALPHA,  GL_ONE_MINUS_SRC_ALPHA) ;
     glLineWidth(4.0) ;
   glColor4f(l,0, 1.0, 1.0, 0.2);
         glRecti( rubberBandCornerl.x( ) ,   rubberBandCornerl. y( j ,
                              rubberBandCo rne r2.x( ) ,   rubbe rBandCorner2 , y ( 》
   glColor4f(l.0, 1.0, 0.0, 0.5);
  glLineStipple(3, OxAAAA);
      glEnable(GL_LINE_STIPPLE) ;
egin(GL_LINE_LOOP) ;  .       .
ertex2i(rubberBandCor'nerl.x
ertex2i( rubberBandCorner2.x
ertex2i(rubb<rBandCorner2,x
ertex2i(rubberBandCornerl.x
glLjneWidth(l,S) ;    :
 glDis abte ( GL_LINE_S) TJ:PPLE).;  .  II j
glDisable(GL_BLEND) ;
加果橡皮筋选择框是可见的，我们可以把它绘制在矩形上。代码是标准的OpenGL。
ri .+ 2 2
o o Q) Q)
C C C'C
LLLL
DOOO
uuuu
-o -o -o -o
C C c'c
co co aa co
L L I_ L
Q) o o"o
_o b b _o
b b _o _o
====
L L I_ L
第20，章  三维图+形
void Teapots::mousePres.sEvent(QMouseEvent *ever)t)
{         .
.   rubberBandCornerl = event->pos();       .
   rubberBandCorner2 = event=>pos();    .  ,.
   rubberBandIsShown = true;
                                                                                                                                                                                                                                                          .
void Teapots::mouseMoveEvent(QMouseEvent *event)
{
)
void
{
if  ( rubberBandIsShown)  {
   rubberBandCorner2 = event->pos()
      updateGL( ) ;
}
Teapots: :mouseReleaseEvent (QMouseEvent  * /*  event  */)
if  ( rubberBandIsShown)  {
   rubberBandIsShown = false;
  L updateGL();                             .   .       ...
    _’
    )    一    ，    …
    {：～J
    鼠标事件处理器负责更新用来绘制橡皮筋选择框的rubberBandComerl、IuibberBandComer2和
    一’
IuibberBandIsShown变量，并且调用updateGL()重绘场景。重绘场景的速度很快；因为paintGL()仅绘
制一个纹理矩形以及其上的橡皮筋选择框。只有当用户改变窗口大小时，场募才毒:resizeGL()中
重新绘制。
    以下是该应用程序的ma/n()函数：
int main(int argc, char *argv[l)
{
   QApplication app(argc, argv)
if  ( ! QGLFormat: : hasOpenGL( 》. {                                           .
   std::cerr<.( "This system has no OpenGL support"<< std::endlj
   return l;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            '
if   ( ! QGLF ramebufferObj ect: :hasOpenGLFramebufferObj ects ()J  {
   std::cerr   "This system has no framebuffer object support
    << std::endl;
   return l;
Teapots teapots;
 teapots . setWindowTitle (QObj ect: :t r ( "Teapot s ,l 》 ;
teapots.resize(400, 400); :    '  '  '. . .
teapots.$how() ;
return app,exec( ) ;
  如果系统不支持OpenGL，或者不吏持framebuffer
回该错误代码，结束运行。    一，．．．
对象，该函数将会发送一条错误信息，并且返
    ’‘    -    ，J
  Teapots例子告诉我们如何在离屏表面绑定纹理，以及如何使用，(JpenGL命令在该表面上绘制
图形。但是我们还可以在其他方面进行有益的尝试。例如，可以使用QPainter代替OpenGL命令在
QGLFramebufferobject或QGIPixelBuffer上绘制。这为在OpenGL场景中绘制变形字提供了一种方法。
另一种常用的做法是使用framebuffer对象绘制场景，然后对其结果调用．tolmage()生成QImage。Qt自
带的很多例子都展示了在实际应用中的多种做法，它们都是针对framebuffer对象和pbuffers的。
第21章  创建插件
    动态库（也称为共享库或者动态链接库）是存储在磁盘上一个单独文件中的独立模块，可以被
多个应用程序访问。程序通常会在连接的时候指明它们所需动态库，在这种情况下，当该应用程
序启动的时候，就会自动加载这些库。使用这种方式通常需要把这个库以及包含它的路径添加到
应用程序的．pro文件中，并且需要在源程序文件中包含相应的头文件。例如：
    LIBS    +=-ldb―cxx    ．
    INCLUDEPATH+=/us r/local/BerkeleyDB.4,2/include
    另外一种方式是在需要的时候动态加载这个库，然后再解析这个库中希望使用的那些符号。
Qt提供的QLibrary类可以使用一种与平台无关的方式来实现这．点。只要给定一个库名字的词
干( stem)，QLibrary就会在该平台的标准位置搜索这个库，并查找适当的文件。例如，给定名字nu -
met)rpe，在Windows上，QLibrary就会查找mimetype．dll；在Linux上，QLibrary就会查找numet)rpe．so；而
在Mac OS X上，QLibrary就会查找mimetype．dylib。
    利用插件，通常就可以对现存的GUI应周程序进行扩展。插件就是一个动态库，它为可选的
额外功能提供了一个特殊接口。例如，第5章就创建过一个插件，它可以把自定义的窗口部件集
成到Qt设计师中。
    Qt可以识别自己用于各域中的一套插件接口，这些域包括图像格式、数据库驱动程序、窗口部
件风格、文本编解码技术以及可访问性(accessibility)等。本章的第一节将解释如何使用Qt插件来
扩展Qt。
    为一些特殊的Qt应用程序创建与应用程序相关的插件也是可能的。通过Qt的插件框架可以
很轻松地编写出这样的插件，这个框架在QLibrary之外添加了失效安全(crash safety)和易用性。在
本章的最后两节中，将演示如何让应用程序支持插件以及如何为应用程序创建自定义插件。
21.1  利用插件扩展Qt
    可以使用很多插件类型来扩展Qt，其中最常用的就是数据库驱动程序、图像格式、风格和文本
编码解码器。对于每一种类型的插件，我们通常至少需要两个类：一个是插件封装器类，它实现了
插件的通用API函数；另外一个是一个或多个处理器类，每个处理器类都实现了一种用于特殊类
型插件的API。通过封装器类才能访问这些处理器类。这些类如图21.1所示。
    为了说明如何使用插件扩展Qt，找们将在本节实现两个插件。第一个插件是非常简单的
QStjrle，用于第19章开发的Bronze风格中。第二个是一个可以读取Wi    色光标文件的插件。
    假定我们已经开发了所用的风格，那么QStyle插件的创建将会非霉蓄≤孚我们所需要做的全
部事情就是生成三个文件：一个是.pro文件，但这个文件与我们之前见到的都有所不同；还有一个
．h文件和一个．cpp /c,f+，由它们提供一个QStylePlugin子类，用作该风格的封装器。我们将从．h
文件开始研究：
    class BronzeStylePlugin:public QStylePlugin
    {
    public：
    QStringLi.st keys() const,
    QStyle *create(const QString &key);
    )；
，y
第21章创建插件
    所有的插件至少要提供一个keys()函数和一个create()函数。keys()函数会返回一个该插件
可以创建的对象列表。对于风格插件来说，对于字母键的大小写是不区分的，因而“mystyle”和
“MyStyle”将会被看作是一样的。create()函数返回一个给定键的对象，该键必须与由keys()函数返
回的列表中的一个相同。
┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃蒸纛舔糕瓣鬻灞黼          ┃瀚瀚朗糍糕麟麟鍪          ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QAccesslbleBridgePlugin   ┃QAccessibleBridge         ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QAccessiblePlugin         ┃'QAccesslblelnterface ' . ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃ODecorationPlugirt        ┃ODecoratiort              ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OFontEnginePlugin'        ┃OAbstractFontEngine       ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OlconEnginePluginV2       ┃OlconEngir/eV2            ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OlmageIOPlugin            ┃OlmageIOHandler           ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OlnputContextPlugin       ┃OlnputContext             ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OKbdDriverPlugin*         ┃OWSKeyboardHandler*       ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃Q~ouseDriverPlugn*        ┃OWSMouseHandler*          ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OPictureFormatPlugin      ┃ N/A                      ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OScreeriDriverPlugn*      ┃OScreen*                  ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OScriptExtensionPlugin    ┃ N/A                      ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OSqIDriverPlugin     . '  ┃ OSqIDriver               ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃ OStyle Plugin            ┃ OStyle                   ┃
┣━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃OTextCodecPlugin          ┃OTextCodec                ┃
┗━━━━━━━━━━━━━┻━━━━━━━━━━━━━┛
_仅在Linux下的QUEmbedded中可用。
    图21.1 Qt的插件类和处理器类
    .cpp文件几乎与．h文件一样简明扼要：
    QSt rjngList  BronzeStylePlugin::keys()  const    :‘
    {
    return QStringList()<<"Bronze‘‘；
    )
keys()函数会返回一个由该插件提供的风格列表。这里，仅提供一种称为“Bronze”的风格：
    QStyle  *BronzeStylePlugin::c reate( const  ost ring &key)
    {’
  +if (key.toLower()一"bronze")
    return new BronzeStyle;  ,
    return 0：
    )
如果该键是“Bronze”（忽略大小写），就创建一个BronzeStyle对象并且将其返回。
    在.cpp文件的最后，必须添加～个下面这样的宏，它可以适当地输出其风格：
    用于Q_EXPORT_PLUGIN2()的第一个参数项是目标库名字去除任意扩展符、前缀或者版本号之
后的基本名。默认情况下，qmake会使用当前路径名称作为基本名，这可以通过修改.pro文件中的
TARGET项来替换该名字。用于Q_EXPORT_PLUGIN2()的第二个参数则是插件的类名。
    插件的．pro文件和应用程序的．pro文件不同，所以我们就以查看Bronze风格的．pro文件作
为结束：    ，
    TEMPLATE    =lib
    CONFIG    +=plugin
    HEADERS    =../bronze/bronzestyle,h＼
    bronzestyleplugin．I1
C++ GUI Qt 4编程（第二版）
= ../bronze/bronzestyle.cpp \
bronzestyleplugin,cpp
= ,./bronze/bronze.qrc
= $$[QT_INSTALL_PLUGINS]/styles
    默认情况下，．pro文件使用app模板，但是这里必须把它指定为lib模板，这是因为插件只是一
个库，而不是一个可单独运行的应用程序。CONFIG行的代码是告诉Qt，这个库并不是一个通用
库，而是一个插件库。DESTDIR指定了这个插件应当存放的目录。所有Qt的插件都必须放在Qt
安装路径下plugin,s的适当子目录中。这条路径放进了qmake的路径，并且可以通过$$[QT―
INSTALL_PLUGINS]变量获取它的取值。由于我们的插件提供了一种新的风格，所以把它放到Qt
的plugins/styles子目录中。可用的目录名和插件类型可以从http：//doc．trolltech. com/4. 3/plugins-
    -，    ．    一
howto．html中获取。
‘  使用release模式和debug模式为Qt、构建的插件是不同的，因此，如果Qt的这两种模式都安装
了，比较明智的做法足在．pro文件中指明要使用的是哪个文件。例如，可以添加如下一行：
    一旦构建了风格，就可以准备使用了。通过在代码中指定这个风格后，应用程序就可以使用
    ”    ：  。，．  ，一  一
它。例如：√    ．，一
    ・    -
    QApplicat/on::;s色tStyle（’”Bronze'”）j
  、    ．一t  、。，  ：  ，
    只需通过在运行应用程序莳莳候带上_ st，le选项，完全不必改变应用程序的源代码，也同样可
    -    -
以使用这一风格。例如：
    在Qt设计师运行时，它会自动查找各个插件。如果找到一个风格插件，它将会在它的Form―
Preview子菜单中提供一个预览该风格的选项。
    使用Qt插件的应用程序必须用它们打算使用的插件进行配置。Qt插件必须放在特殊的子目
录中（例如，pluguis/styles是用于自定义风格的子目录）。Qt应用程序在可执行文件所在目录的plu-
孚ns目录中查找插件。如果希望把Qt插件配置到不同与此的目录中，那么就需要在一开始就调用
QCoreApplication:：addLibraIyPath()来扩展插件的搜索路径，或者也可以在启动程序之前设置QT_
PLUGIN_PATH环境变量。
    我们现在已经看过简单插件了，下面将要处理的达个插件则有一定的挑战性：一个可以读取
Windows单色光标文件（．cur文件）的图像插件。（．cur文件的格式如图21.2所示。）Windows的光标
文件可以保存分别用于表示同一光标不同大小的几幅图像。只要构建并且安装了这个光标插件，
Qt就可以读取．cur文件并读取出不同的光标形状(例如，通过QIrnage、QlmageReader或者QMovie)，
并且可以使用Qt的其他任意图像文件格式输出这些光标，例如BMP、JPEG和PNG格式等。
    新的图像格式插件封装器必须继承QImageIOPlugin，并且还需要重新实现一些虚函数：
    : class Curso.rPlugin:.public QImageIOPlugin    .
    '{
    public:
    QStringList keys() const;
    Capabilities capabilities(QIODevice *device,
    1    ’,.  cDnst QByteArray'&forma:t) const;
    QImageIOHandler *create{QIODevice *device,
    const QByteArray &format) const;
    )；
    keys()函数返回一介该插件所能支持的图像格式的列表。capabilities()和create()函数中的
format参数可以认为是这个列表中的一个值。
   LU
Ln   U R
LU  R H
U    =, o
ce   a T
-.   cn cn
a   LU LU
cn   ce o
第21章创建插件
图21:.2 .cur)t件的格式
ost ringList  Cu rso rPlugin : : keys { )  const
{
    return QStringList()<< "cur";
}.
    我们的插件仅支持一种图像格式，所以它返回一个只包含一个名字的列表。理想情况下，这
个名字应当是这种格式所使用的文件扩展名。当处理带有几种不同扩展名的图像格式时（例如，
JPEG格式可以使用．jpg和．jpeg．两个扩展名），我们可以为同一格式返回一个曳搀令元素组成的
    't-    ～    ’
列表，而其中的每个元素都代表一种扩展名。    ．一？。  。
QImageIOPlugin::Capabilities
Cu rso rPlugin : : capabilities ( QIODevice  *device,
                                . const QByteArray &format) const
{
if (format
 return
CanRead;
if (format.isEmpty(》 {
   CursorHandler handler; '
     'handler.setDevice(device) ;
  if (handle'r.canRead(》
      return CanRead;
}
return 0;
    函数capabilities()遁回该图像处理器利用给定的图像格式所具有的处理能力j-二共有三种处
理能力(CanRead、CanWrite和CanReadlncremental)，并且返回值是所能应用、的那些能力的按位“或”
    -    ．    。
    ．    ：
后的结果。
    j    1    ’
    如果格式是“cur”，我们的实现就会返回CanRead。如果没有给定格式，就创建一个光标处理器
并且检查它是否具有从给定设备读取数据的能力。canRcad()函数只是粗略查看一下数据，判断它
是否可以识别这个文件，但并不会改变文件指针。如果能力值是0，则意味着这个处理器不能读取
或者写入该个文件。    ，
QImagoIOHandler *CursorPlug:in::create(QIODevice *device,  .      :" :
                                            const QByteArray &format) const
    CursorHandler *handler = new CursorHandler;   ' .    .    .  '
      handler->setDevice(device) ;
      handler->setFormat(format) ;        ,
醚群隧酴黪戳篓务争窭劳，j一、一    ．    ／
C++ GUI Qt 4编程（第二版）
    在打开光标文件时(例如，通过QImageReader)，就会利用设备指针和作为格式的“cur”为参数，
调用这个插件封装器的create()函数。我们创建一个CursorHandler实例并且用指定的设备和格式
对其进行设置。调用者会获得这个处理器的所有权并且会在不需要时将其删除。‘如果需要读取
多个文件，那么就需要为每个文件各自创建一个新的处理器。
    Q_EXPORT:  PLUGIN2( cu rso rplugin,   Cu rso rPlugin)
    在.cpp文件的最后，我们使用Q_EXPORT_PLUGIN2()宏确保Qt能够识别这个插件。‘第一个
参数是我们希望给这个插件起的任意名字，第二个参数是插件类的名字。
    对QImageIOPlugin的继承是很简单的。‘插件的实际工作是在处理器中完成的。图像格式处理
器必须继承QImageIOHandler，并且需要重新实现它的一些或者全部公有函数。让我们先从头文件
．开始看起：    ，
class CursorHandler
{
public:
    bool canRead() const；
    bool read(QImage *image);
    bool  jumpToNextlmage();
    int currentImageNumber() const;
    int imageCount() const;
    D rivate：
    enum State{BeforeHeader,Beforelmage,AfterLastlmage,Error）；
    void readHeaderIfNeceSSary() const;    ’
    QBitArray readBitmap(int width, int height, QDataStream &in) const;
    void enterErrorState() const;
    mutabl'e State state;
    mutable iilt 'currentIrnageNo;
    mutable int numlmages;
    )；
    所有公有函数的签名都是固定的。作为一个只读处理器，像write()这样的一些特殊函数我们
并没有必要去重新实现它们，所以就将它们省略了。成员变量都使用了mutable关键字，因为它们
会在const函数中得到修改。
    CursorHandler：：CursorHandler()
    {
    state=BeforeHeader;
    ．    cu rrentImageNo=0；    ‘
    numlmages - 0；    、_
    }
    在构造处理器的时候，先从设置它的状态开始。我们把当前的光标图像设置成第一个光标，
其编号为1。但由于把numlrnages设置成了O，显然是说我们还没有任何光标图像。
    bool Curso rHandler::canRead()   const
    {
    if (state==Be'foreHeader){
    return device()->peek(4)==QByteArray(“＼0＼0＼2＼0“,4):
    } else{
    return state I-Error;
    }
    }
    每当处理器在判断是否能从这个设备中读取更多数据的时候，就会调用canRead()函数。如
果在读取任j苣数据之前已经调用了这个函数，但还处于BeforeHeader状态，那么就需要检查用以识
别Windows光标文件的那个特殊签名了。这里的QIODevice::peek()调用可以用来读取设备文件的
第21章创建插件    371
前4个字节，但并不会改变该设备的文件指针。如果此后再调用canRead()，只要没有发生错误，就
一直返回true。
    int  Cu rso rHandler:: cu rrentImageNumber()  const
    {
    return currentImageNo;
    )    ’
这个简单函数返回设备文件指针指向的光标的编号。
    处理器一旦构造完毕，就可以按任意顺序来调用它的任一公有函数了。这就存在一个潜在问题，
由于我们必须假定只能连续读取，所以在做其他任何事情之前，都需要读取一次文件头。通过在那些
依赖头文件并已经读取了头文件的函数中调用readHeader矾ecessuy()函数，就可以解决这一问题。
int. Cu rso rHandler: :imageCount ( )   const
{
     . readHeaderIfNecessary() ;
   return numlmages;  .
    这个函数返回在这个文件中图像的个数。对于一个不曾发生过读取错误的有效文件，它会返
回一个至少是l的计数值。
  下一个函数有些麻烦，所以将一段一段地查看它’：    ．
 bool  Curso rHandle r: : read ( QImage  *image J
   readHeaderIfNecessary();                               . : : (.．上
if (state != BeforeImageJ
   return false;
    read()函数会读取从当前设备文件指针位置处开始的任何一个图像的数据。如果文件头读取
顺利，或者是在一个已经读取完毕的图像之后，并且该设备指针又恰好在一个图像的开始处j那么
就可以读取下一个图像了。
quint32
quint32
quint32
quint16
quint16
quint32
size;
width;
height;
numPlanes;
 bit sPe rPixel ;
compression;
QDataStream in(device(》;
in . setByteo rde r(QDataSt ream: : LittleEndian j
in 》 size;
if. (size l.= 40) {
      enterErrorState() ; '
   return false; '
}
in 》 width 》 height 》 numPlanes 》 bitsPerPixel 》 compression;
height l= 2;
in.skipRawData《size - 20J + 8J
    我们创建一个QDataStream读取这个设备。必须把字节顺序设置成与．cur文件格式规菹相匹
配的顺序。由于整数和浮点数的格式在数据流的不同版本之间不存在变化：所以就没有必要设置
QDataStream的版本号。接下来，读人光标文件头部数据中的各项，并且跳过与文件头不相关的项
和使用QDataStream:：skipRawData()函数的8字节颜色表。
 II
C
o
.+
E
o
u
rl
  II
-
o
x
. -1
o
o-
IJ
, -1         '
-o
- --
  o
rl 4J
    ro .-
 11 4J a)
-. cn cn
 L_
Ln o ro
 O L H-
CL
 tl, LU C
_LL
o- o =
 E 4-  -,
= C a)
COL
372                                     C++ GUI.Qt 4编程(第；版)
    我们必须考虑这个格式的所有特性――例如，把高度减半是因为．cur格式所给的高度是实际
    、．'    …
图像高度的两倍。在单色的．cur文件中，bitsPerPixel和compression的值总是分别为I．和0。如果遇
到任何问题，就可以调用enterErrorState()并且返回false。
QBitArray xc    ap_:= readBitmap(width, height, in)
QBitArray ;rTd:i::a菲一：'readBitntap(width: heightr in)
if  (in.status () . ! =' QDataSt ream: :Ok)  {           :,         '
enterErrorState();
   return false;
}
    文件中接下来的两项是两个位图，一个是XOR掩码，另外一个是AND掩码。我们把这两项读
入到QBitArray中，而不是QBitmap’中．。QBitjnap是寸个类，设计用于在屏幕上画线和绘图，但是在
这里，我们需要的只是一个普通位数组。≥  。j：、  ．，  ‘
    当读取这个文件之后，就检查QDataStream的状态。之所以这样做，是因为如果QDataStream申
的状态是一个错误状态，那么它就会保持这种错误状态并且。直返回0值。例如，如果对位数组
的第一位读取失败，那么对第二位的尝试读取将产生一个空的QBitArray。
    *-image=QImage(width, height―QImage::Format_ARGB32);
    for (int i=0;i<int(height); ++i){
    for (int j=0;j<int(width.); ++j){
    QRgb color;
    int bit ='(i丰width)+j；    叱
    if (andBitmap.testBit(bit》{    ‘?…    ‘
    if (xorBitmap.testBit(bit》{
    .color=Ox7F7F7F7F;    ！  .、    ，
    ) else{
    color=OxOOFFFFFF：
      imag:e->s:etPixel(j,it color);
  一_我们以正确韵大小构造o个新的QIniage并且将其赋值给*image。然后，遍历XOR和AND两
个位数组中的每一个像素并且把它们转换为32位。AGRB的颜色格式。如下表所示，XOR和AND
位数组可以用于获取每个光标像素的颜色值：    一
┏━━━━┳━━━━━━━━━━━━━━━━┓
┃蕤粼黧  ┃甏鬻麟囊l豢鬻熬熬糕翳滋嚣鬟蒸豢 ┃
┣━━━━╋━━━┳━━━━━━━━━━━━┫
┃    l   ┃    l ┃    背景像素颜色反色    ┃
┣━━━━╋━━━╋━━━━━━━━━━━━┫
┃    1   ┃    O ┃  ．    透明像素        ┃
┣━━━━╋━━━╋━━━━━━━━━━━━┫
┃    O   ┃    1 ┃    ‘白色              ┃
┣━━━━╋━━━╋━━━━━━━━━━━━┫
┃    O   ┃    O ┃    黑色    ’          ┃
┗━━━━┻━━━┻━━━━━━━━━━━━┛
    ．  ’、
    要获取黑色、白色和透明像素不存在什么问题，但是在不知道背景像素原始颜色的情况下，我
们却没有办法使用ARGB颜色格式获得背景像素颜色反色的像素。作为背景像素原始颜色的替
代品，我们使用一种半透明的灰颜色(Ox7F7F7F7F)。
IJ
IJ U-   o
rl U_    CO
co u-    <:,
4J U-   co
o u-   u-
IJ U-   u-
    .X  x
            a- co  瞅        ,)
    ro
      E lI    "
   4J
    rJ L  L
     on c) -r Q
  Lr r
 oooo
    x u cn u
  -r(   r
        o
1， Jn rl   rH   rH
  o
 rH        rH
k
第21章，，创建插；件
    ++currentImageNo;    ．    ，    ’    ’
    if (currentImageNo=i numlmages)
    state兰\AfterLastlmage;,    ,.1 1,    ,…  ‘.  ;:    .
    return true;    ．？    7‘
    }    一
    一旦完成了这个图像的读取，就可以更新当前图像编号。如墨读取的是最履_个图謦，则同
时还需要更新state的值。此时，设备将指向下一个图像或者文件的最后位置处。
    bool CursorHandler：：jumpToNextlmage()    -    ‘
    {    ÷
    QImage image;
    return  read (&image)；
    这个jumpToNextlmage()函数用于跳过-个图像．o-为简便起见j我们兵简单调用；tead（1并忽略
作为结果的QImage。一种更为有效的实现应当是使用保存在5．cui’文件头中韵信息并且直接跳到
    ．    ～．‘，    一    ’
这个文件中的适当偏移量处o．  1    7‘：。    ；  ：    _‘
retu rn ;
quint16
quint16
quint16
reserved;
ty.pe;
count ;
QDataSt ream  in (device ( 》 ;
in , setByteo rde r ( QDataSt ream:  : Lit tleEndian)
in 》 reserved 》 type 》 count
in,skipRawData(-16木 count) ;
if (in,status() != QDataStream::Ok II reserved l= 0
       II type l= 2 11 count == 0) {
      enterErrorState() ;
   return,   '  '
state = B
cu rrentlm
numlmages
二j：：王善
    ：    ’
-．    一■
{◇：，
    )
    私有函数readHeaderIfNece。sary()会被i。n。geCount()和read()调用：；如果该文律的文件头已经
被读取过，那么。tate就不会再是BeforeHeader了，所以可以立即返回。否则，就在这个设备上开启
一个数据流j读入__些普通数据（包括这个文件-中的光标个数）j并且把;state?设置为j Beforelmage。
最后，把这个设备的文件指针指向篇．个图像的前面。．：，‘  ：≯‘。r j!‘．  ．7．：' .譬？j、
void  Curso rHandler: :ente rE rro rState( )   const                      '.  :  '. /   .;  :"'
state = Error;  . .
currentImageNo = o,'  . -.  . '  ; :.:'
    )
    知果有错误发生，就认为不存在有效图像并且把state设置为Erroro -旦进入Error状态，这个
处理器的状态就不能再改变了。
QBitArray
{    :
QBitAr
quint3
quint8
CursorHandler: : readBitmap(/nt width,-int 'height- .  -    - .
                              QDataStream &in) const
ray bitmap(width *_heightl;  :   :: '
..    .
,
   '   '.
::.   .
 ' J,   .
                                  .
                        .
  '.   . :
IJ  T
b.
to  -
o
.u     .
z
o.o
 to .        o
o  to
rD   . Q)
OL
'L  O
L  rD
J    II
o  -.
I  IJ
L  .  t0
o  IJ
 cn  . cn
L_
=
o.
-rl
o
 > h-
    IJ
.N  C
 rn C)  c-,
to  u
E il -
H  lJ
a) o c:
LZ rl
o Q)
f a, lI
a) to
  374    C++ GUI Qt 4编程（第二版）
    ___-....._______.___-__.._________.____-一
    一个应用程序插件就是实现了一个或多个接口(mter~ace)的动态库。接口就是由专有的纯虚
函数组成的类。应用程序和插件之间的通信是通过接口的虚表(virtual  tabie)来完成的。在这一节
中，我们将主要集中看看如何在一个Qt应用程序中通过它的接口使用插件。在下一节，将说明如
何实现插件。
    为了给出一个具体的例子，我们将会创建一个如图21.3所示的简单的，rxt Art应用程序。这
些效果是通过一些插件提供给文本的，应用程序可以获得由每个插件提供的文本效果构成的列表
并且遍历它们，然后在QListWidget中逐项显示这些效果。
    ’rext An应用程序定义了j个接口：    。
    class TextArtlnterface
    {
    public:
    virtual―TextArtlnterface(){)
    叫  文    虽插
    ‰黼删渊  e    。”均
    0    0
    霖
    再二
    栉第
    辆汛    一一～
    具方一一．  一    一～黼
    5；眦
    幽能
    兰功
    码的    层
    掩下    ～    肌黼燃
    些珊抵酬    的图提
    r) _Lj这后
    一从到谍
    ．〔    码的
    +    掩i用
    h
    E
    d
    ・l
    {  e    }：
    t    ，  4    1
    t  时    ”8
  ・  +    j一一一一  一    ～～一  _
    E
    +  1    1 8
{j-    i 8
  +roo
--+    一∞
・l    V    V
+；    VIJ呶
+h    k
  t -r    d
  ；。  ；，  鼍    ～一
  眦“叫  0托№    №阿
g    =y C    C 0
缸v jl  k 6I    ‘w
h．]  ；  >    t
 V；孙0 i- A -O    i
    口U    -，
  0 3 ili n O    t  l
・l  ~  C．1 W    e
  I%d    S  =
一，    r r    ．    V
O。]1】O O    p  V    ；
lJ IJ“W   -    )    E    p
    m  d    a
  。    ．  ，  E    一
  ；；    ，。    一一一一  ～CI    ～
    e夺。E1
    。    寻
    。一一一
    ・1上
    ／
    、  缸
    ＼  p  U
    nr pL
    h  C pP
    n巾卜正L―
    e n e n L
    。虬仉啦n
    n U n U S
    ra - ra rt Z
    h ph pI
    ：，    一～一一
    ・-1 0刚叶叶T一
    。屿n n n n m
    i 1~U U U U$
    1~p C C C C$
  Ci    )b  w    n
t    b
 n r
。rl O    n
Cf    ，  r
。    毗    一～  一。～：t一：：一一一  一
    rH L    ・    鑫紫触
t    ，，  ～一～    u建：盯e陷幡嗽
    ，    蜥黼黝枞一一一呲哪麟觚贿  2
    1‘    ～  很
    第贿勖砩  件    触伽  纠
  +J
  u
    IJ
 .N C C
 LL
 II IJ IJ
  S cn
 IJ OO
 C +J IJ
o cn Ln
urr
 oo
-uu
 Ln iJ '
IJ u
f . f
f LU
    rJ ' .
IJ O-
cn o .
.+ rD
al o-
c ro
.+ E
LX
IJ .+
S P  .
oo
1L rJ
= =,  '
IJ +J  .
LL
.+ .+
》
第21章・创建插件
                                              const ;QFont &font,  const .QSize &$ize
                                                  const QPer/ &pen,
                                     const QBrush &brush) = O;          '
};.
 Q_DECLARE_IhITERFACE ( TextA rtlnte rfa ce ,               .
                                                  " com . softwa re-inc.TextArt .TextArtlnte rface/l. 0 " )
图21.3  Text AIt应用程序
    接口类通常都需要声明一个虚析构函数，一个返回QSt珊gList的虚函数和一个或者多个其他
虚函数。这个析构函数主要是为了抑制( silence,)编译器，因为如果不这样做，编译器就会抱怨一个
具有虚函数的类却没有一个虚析构函数。在这个例子中，effects()函数可以返回该插件能够提供
的文本效果的列表j可以把这个列表看成一个键列表。每次调用其他几个函数中的一个函数时，
就需要把这些键中的一个作为第一个参数进行传递，这样才有可能在一个插件中实现多个效果。
    最后，我们使用Q_DECIARE_INTERFACE()宏使这个接口与一个标识符关联起来。这个标识
符通常包含4个部分：一个倒置了的域名，用来说明这个接口的创建者是谁；一个应用程序的稆
字；一个接口的名字；还有一个版本号。只要我们改变了这个接口（例如，增加了一个虚函数或者
改变了一个已有函数的签名），就必须记得要增加版本号；否则，这个应用程序可能会因为试图访
问一个过期的插件而崩溃。    。  ．
    在一个称为TextAtDialog的类中，实现了这个应用程序。我们将只说明能够让这个应用程序
感知插件相关的代码。先从构造函数开始：
TextArtDialog: :TextArtDialog ( const  QSt ring &text ,  QWidget  *pa reht)
   : QDialog(parent)
{
    listWidget = new QListWidget;
          listWidget->setViewMode ( QListWidget : :IconMode) ;
            lis tWidget->setMovement ( QListWidget : :Static ) ;          .
         listWidget->setIconSize(QSize ( 260,  80》 ;
        loadPlugins ( ) ;
       populateListW,dget (text) ;
)
这个构造函数创建了一个QListWidget列出所有可用的效果。它调用loadPlugins()私有函数查
  376    C++ GUI Qt 4编程（第二版）
找并且加载实现了TextAnInterface的每一个插件，并旦通过调用另外_个私有函数populateLi。t―
Widget()弹出这个列表窗口部件。
 void  TextArtDialog: :loadPlugins ( )
{
    QDi'r pluginsDir = directoryOf("plugins");  -  .
     foreach (QString fileName, pluginsDir.entryList(QDjr::Files》 .{ .
                  QPluginLoader  loader( p.uginsDir.absoluteFilePath ( fileName》 ;
.       if.. (TextArtlnterface *interface =
                                                  qobject_cast<TextA rtlnterface  *> (loade r,instance ( 》 )
                 interfaces.app'end.(interface') ; .  ;. '     . .
     }
}
    在loadPlugin,s()中，我们先从搜索该应用程序的plugins目录开始。然后，试图加载在这个应用
程序的plugins目录中的所有文件o directoryof()函数与在笫17章中使用的directo．yOf()函数是同
一个函数。
    …  ，-  ：：．j；    ，    ～。
    如果我们试图加载‘的文件是一个和这个应用程序的Qt版本号相同的.Qt插件，那么QPl1呼n-
Loader：：instance()将会返回一个指向这个Qt插件的QObject*。我们使用qobject_cast <T>()检查这
个插件是否实现了TextArtlnter~aceo每次强制转换成功．的时候，就把这个接口添加到TextArtDialog
的接白列表（类型为QList <I'extAnInter~ace*>）中。
    一些应甩程序也许想加载两种或者更多种不同的接日。在这种情况下，获碍接口的代码看起
将更像是如下所示的样子：
QOb
if
if
if
ect *plugin = loader.instance();
TextArtlnterface *i = qobject_cast<TextArtlnterface *>(plugin》
textArtlnterfaces.append(i) ;
 eo rde rA rtlnterfa ce  *i  =  qobject_cast<Bo rde rArtlnterface'*> ( plugin J )
borderArtlnterfaces.append'(i); .  .
Textu relnte rface  *i  =  qobject_cast<Texturelnterface  *> ( plugin 》
texturelnterfaces.append(i) ;               .    '  '
加果使用多重继承方式，那么同一个插件就可能成功强制转换出超过。个的接口指针。
 void  TextArtDialog : : populateLis tWjdget ( const_ QSt ring'&text )
1
         QFont  font ( "Helvetica ",   iconSize.height ( ) ,  QFont: :'Bold) ;
 . QSize iconSize = listWidget->iconSize();  .   .    .  .
         QPen  pen (QColo r ( "darkseag reen:'》 ;'         .      .
QLinearGradient gradient(0, 0, iconSize.width()
:?  , .'  /:+ '.  . ;-   :rconSize.height() / 2)
 g radient : setColo rAt ( 0.0,   QCoio r( "da rkoliveg reen
 g radient , setColo rAt (0.8,   QColo r( "da rkg reen" 》 ;
g radient. setColo rAt (1.0,  QCoLo r( "l-ightg reen " 》 ;
foreach (TextArtlnterface *interface, interfaces) { .
   foreach (QString effect, _interface->effects(》 {.  :
       QListWidgetltern *item = new QListWidgetitem(effect,     '
                                                                                                ,             listWidget ) ;
       QPixmap pixmap = interface->applyEffect(effect, text, font
                                  iconSize, pen,
                                                                                 ient) ;      '
                    item->setData ( Qt : :Deco rationRole,   pixrrlap9) radien'
     }
}
listWidget->setCurrentRow(0) ;
    茌populafeListWidget()，函数的一开始，就创建了_些要传递给applyEffect()函数的变量，特别是
创建了一种字体、一支画笔和一个线性渐变器(gradient)。然后，它遍历由loadPlugins()发现的每一
r-J  ，，  ，
    、，，    ，
／  ，
第21章创建插件
个TextArtlnterface。对于每一个接口所提供的每一种效果，会使用它的效果名称的文本和使用
applyEffect()生成的QiPixmap来创建一个新的QListWidgedtem。
    在这一节中，我们已经看到在构造函数中是如何调用loadPlugins()加载插件的，并且看到了在
populateListWidget()中是如何使用它们的。不论是否有插件提供Text_Artlnterface、或者只提供一个、
或者提供多个，这段代码都可以很好地处理这些情况。另外，还可以在之后的时间里添加一些额
外的插件：每当应用程序启动的时候，它都会加载所发现的能够提供它想要的接-口的那些插件。
这样就可以很容易地扩展应用程序的功能，而不需要改变应用程序本身。
    ．=
21.3，编写应用程序的插件
    一个应用程序的插件就是QObject和它想要提供的接口的一个子类。与本书一起使用的例子
中包含了两个插件，它们可用于上一节中讲到的Text Art应用程序，这样我们就可以说明该应用程
    __    ，    。  -    {
序可以正确地处理多个插件。
  。这里，我们仅查看其中一个的代码：Basic Effects插件。假定这个插件的代码廷放在二个称为
basiceffectsplugin的目录中，并且Text Art应用程序是放在和它并列的一个称为‘extart的目录中。这
    ’    5；i    ，：    ：
里是该插件类的声明：
    ．    ~    h、。    i    .！，‘，圣；曹；’；1j―
    class BasicEffectsPlugin:public QObject,.publi.c 'TextArtlnterface::
    {    r。二
    Q_OBJECT    …jjb芎一i t    ：‘    ：
    Q_INTERFACES( TextA rtlnte rface)    :    j:    ,.’--.    :
     QStringList effects(J const;      .                                        '  ' . _. :_ :;  : '
    QPixmap applyEffect(const QString &effect: cor/st QSt;ring &text}   :   ..:.?:'~'?  ～
                        const QFont &font, const QSize &size,   '.   ;   -    ;:.  ._-
                            const QPen &pen, const QBrush &brush);.    :_.  .  . .-  : '  : ::i.:
};
    这个插件只实现了2个接口：TextArtlnterface。除了Q_OBJECT之外，’还必须为继承的每一个接
    ．    ．
口使用Q_WIERFACES()塞，以确保moc和qobject_cast<D()可以一起正常工作。
    QStringList BasicEffectsPlugin::effects() .const    一    、  :.r一．
    {return QStringList()PlainOutline'Shadow"    0‘  ：
    return QStringList()<<“Plain”<<“0utUne“<<’‘Shadow‘‘:  :    ,    ’
    ’    )
    ：  r    ．    ，：“．    ．-
‘  effects()函数返回插件所支持的文本效果的列表。这个插件支持三种效果，所以返回了一个
    -。    --…    +‘  ~-    -
包含每个效果名称的列表。    +  ．，、，：？
applyEffect()函数提供了插件的功能并且它稍微有些复杂，所以我们将分段来查看它：
QPixmap BasicEffectsPlugi“：：applyEffect(const QString &effect,iz；    。  、
    co;nst QString &text, const QFont &font, const Q<.    !j’  .‘1
    const QPen &pen, const QBrush &brush)    、
{
QFont myFont = font;   .
QFontMetrics metrics(myFon
while 《metrics.width(text
                   I'I  met rics , height (
       && myFont.pointSize
myFont.setPointSize(my
   metrics = QFontMetrics
    )
  找们想确保给定的文本能够尽可能地占满所给定的大小。基于这个原因，我们使用字体规格
    ．    ．
( metncs)看看文本是不是太大了，r并且如果是这样的话，就进入到一个减小字号的循环当中，直到
       -
          _
    c-   I
  --
-- -
 7:t o
         IJ . o        N
   .o QJ     rl c_
 'N N_O H
C++ GUI Qt 4编程（第二版）
找到一个合适的字号，或者直到达到9磅( point)的字号大小时为止，这也是我们设定的最小值。
QPixmap pixmap(size) ;
QPainter painter(&pixmap) ;
painter.setFont(myFont) ; .
pa/nter.setPen(pen); '
painter.setBrush(brush) ;       .
painte r. setRende rHint (QPainter
painte r . setRende rHint ( QPainte r
painter. setRende rHint (QPainter
painter.eraseRect ( pixmap. re ct (
Antialiasing,
TextAntialias
SmoothPixmapT
    我们根据所需大小创建了一个像素映射（pixmap），和一个要在它上面进行绘制的绘图器
( pa/nter)。还设置了’一些着色提示，用来保证最可能实现的平滑结果。eraseRect()的调用则会使用
背景色清空这个像素映射。
if. (effect == "Plain") {
      painter,setPen(Qt'l:NoPen) ;      .
 else if (effect == "Outline") {
.  QPen pen(Qt:/black);
 . pen.setWidthF(2.5);
    . painter.setPen(pen) ;
 else if (effect == "Shadow") {
   QPainterPath path;
  ,:    painte r: setB rush (Qt: :da rkG ray) ;
       path.addText 《 (size.width ( )  - metrics.width(text 》 /  2)  +  3,
               (size.height() - metrics.descent(》 + 3, myFont
      painter;drawPath(liath) ; ' ,
      painter.setBrush(brush) .~ '           '
    财于“Plain'’效果，就不需要任何轮廓( outline)了。对于“Outline”效果，会忽略初始的画笔，并且
会创建一个黑色的、2.5像素宽的画笔。对于“Shadow”效果，需要先绘制阴影，以便能够使文本绘
制在“Shadow”之上。‘
QPainterPath path; ,
path.addText 《size.width ( )'  -  met rics.width(text》  /  2,'
                             size. height ( )  -  met rics .descent ( ) ,  myFont ,' text) ;
painter.drawPath(path) ;
return pixmap
    觋在已经为每一个文本效果设置好了画笔和画刷，并且在“Shadow”效果中已经画好了阴影。
这样就为渲染文本做好了准备。文本是水平居中的，并且在这个像素映射的底部留有足够的空间
来绘制后面的部分。
    ：    ．    ，
    Q_EXPORT_PLUGIN2(basiceffectsplugin, BasicEffectsPlugin)
在.cpp文件的最后，我们使用Q_EXI:，ORT_PLUGIN2()宏来让插件变得可以被Qt使用。
    ・pro文件和本章前面的BIDIlZe风格插件中的．pro文件类似：
    TEMPLATE    =lib
    ―  CONFIG    +=plugin
    HEADERS    =一./textart/textartinterface.h＼
    basiceffectsplugin．h
    SOURCES    =basiceffectsplugin.cpp
    DESTDIR    =.一./textart/plugins
    如果本章已经能够让你对应用程序的插件感到兴奋的话，那么你也许会希望进一步研究一下
Qt提供的更高级的Plug&Paint倒子。这个应用程序支持三种不同的接口，并且包含了一个有用
的Plugn Infonnation(插件信息)对话框，其中列出了所有可用于这个应用程序的插件和接口。
    =
    L
   .N IJ
   Q)  -
 =E
.N L L
 Jo
Q)  f
= . - cn
L O.C
i- c: ro
  rl L
第22章，应用程序脚本
    脚本是采用解释型语言写成的程序，增强了系统的灵活性。有些脚本就是独立的应用程序，
其他的则嵌入到应用程序中运行。从Qt 4.3开始包含了QtScript，这是一个可以使用ECMAScript
fif<J模-~: ECMAScript是标准版本的JavaScript。这个模块是早前Trolltech产品Qt应用程序脚本
(QSA，,Qt Script for Applications)的全面改写，可以提供对．ECMAScript版本3的全面支持。
    ECMAScript是一个由Ecma国际组织标准化的官方语言名称。它构成了JavaScript(Mozlla)、
JSc,ript(Microsoft)和ActionScript( Adobe)的基础。尽管该语言的语法表面上与C++和java．语言相类
似，但潜在的概念是根本不同的，从而使它独立于许多其他的面向对象的编程语言。7在本章的第
一节，我们将快速了解ECMAScript语言，介绍怎样在Qt中运行ECMAScript代码。如果你已经了解
了JavaScript，或者其他基于ECMAScript的语言，那么就可以跳过这一节。
    第二节将介绍如何在Qt虚用程序中添加脚本支持。这使得用户可以在应用程序已提供功能
的基础上添加他们自己的功能。这一方法也常常被用来支持用户，技术支持人员可以以脚本的形
    -    ‘：’t、‘+    。
式提供缺陷修正和解决方案。    、
    第三节将介绍如何结合ECMAScript代码和Qt设计师创建的窗体开发jGUI前端。这一方法对
那些不喜欢C++开发中的“编译、链接、运行”周期循环，而更喜欢脚本方法的开发者很有吸引力。
它可以使那些有JavaScript经验的用户不用学习C++就能够设计功能齐全的用户界面。
    在最后一节，将介绍如何开发依赖于C++组件的脚本。这可以通过任意的C++和H／Qt组件
完成，不用构思就可以设计出来。这个方法很有用，特别是当几个程序需要使用相同的基本组件
编写程序，或者是当我们想让非C++程序员使用C++功能的时候更是如此。
22.1  ECMAScript语言概述
  ．这一节对ECMAScript语言作一简单的介绍，以便更好地理解本章的代码片段，并且可以开始
编写你自己的脚本o Mozill丑基金会的网站上保存有更完整的用户指南htq,：//developer.mozilla.org/
en/docs/Core_JavaScript_l.5~Guide'此外，Davidnanagan的“JavaScript．The Defuutive Guide"(O' Reilly，
2006)也是值得推荐的，它既可以作为指南又可以当作参考文档。官方的ECMAScript、规范可以查
看在线文档http：//www．ecmaintemational．org/publications/standarcis/Ecma-262．htm。
    基本的ECMAScript控制体-if语句、for循环以及whde循环等，这些都与C++和Java是相
同的o ECMAScript也提供或多或少的相同的赋值、关系和算术运算符。ECMAScript字符串支持使
用+的串联形式和+=的叠加形式。    ，
    为了掌握ECMAScript的语法，我们首先来学习下面●个程序，它可以打印1000以下所有素数
的列表：
const MAX = 1000;
var isPrime = new Array(MAX);
for (var i = 2; i < MAX; ++i)
 .  isPrime[iJ = true;     .
for.(var i = 2; i <.MAX; ++i) {
     380                                               C++ GUI Qt 4编程(第-版)
  -
for (var'i - 2; r < MAX; ++i) {
      if  (isPrime[/' J )
              pri'nt (i) ;    '
}   " '.
    从一个C++程序员的角度来看i可能ECMAScript最显著的特点是变量而不是显式类型，利用
var关键字就可以定义一个变量。只读变量可以使用const来声明，而不是使用var来声明。前面
程序中，另外一个值得注意的特点是没有main()函数。函数外面的代码会被立即执行，即从文件
的开头一直执行到文件的末尾。
．，  与C++不同，语句末尾的分号在ECMAScript中通常是可选的。利用改进的规则，解释器能够
自动添加大部分遗漏的允号。尽管如此，还是要尽量自己输入分号，这样可以避免意外的发生。：
  ：运行上面的程序，我们可以使用qscript解释器，它位于Qt的examples/script/qscript目录下。虫口
果解释器被调用时带有_AI作为参数的文件名，那么这个文件就会作为ECMAScript而得以执行；
    +    ：，
否则，就开始一个交互式会话。
    如果声明、Ⅲ变量时没有提供初始值，那么默认值就是undefined，这是一个Undefined型的特殊
值。稍后可以便用赋值操作符(=)把它指定为任何类型的任意值。请看下面的例子：
X = 5;
typeof x;
X = "Hello
typeof x;
。．-．tyeof操作符返回一个小写的字符串，它返回与保存在变量中的值相关的数据类型。ECMAS-
cript定义了5种基本的数据类型：Undefined、Null、Boolean、Number和String。Undefined和Null类型
是undefined和null．常量的特殊类型j Boolean类型包含两个值：true和false。Number类型用来保存
浮点数j Slring类型则可以保存UIucode字符串。    j^  一‘”4    ‘
：．变量也可以保存对象和函数，分别对应于Object和Function数据类型。例如：
    如同Java -样，ECMAScript也会区分基本类型和对象类型。基本类型类似℃++的值类型，例
如。int和QStringo．这些不用new操作符创建，可以按值复制。相反、，创建对象类翱则瑟须使用new
操作符，这些类型的变量只保存对象的引用（指针）。当使用’new创建对象时，我们不用担心释放
内存，因为垃圾信息收集器会自动处理这件事。    +
    一    -
    如果使用、哪关键字为～个变量赋值而没有提前声明它，那么该变量将被当作全局变量。如
果试图读取一个不存在的变量的值，则会得到一个ReferenceError异常。可以使用try. catch语句
捕获这个异常，如下所示：
         '
  +
  +
.+   rl
_- '     v
rl    rl
a) m o_
E > cn
 rl( rl
L
O- L
    、，
r  =
= f   L f
C 0  4J o
   (u      (u
 Il O-   il O-
    i-      i-
       C
 L  L
   = '   .=
  L .  .L
   ;/.  \
             .       . :v
o  .   L.
rl              ' .
II”. II卯
k 4J   X 4J
    第22章应用程序脚本    381
    ―――――.――――.'―――一______________________-________一
try {
 . print(y);
} catch (e) {
   print(e.name + ": 'i十 e.message)
如果变量y确实不存在，那么信息“ReferenceError：y is not defined”就会被输出到控制台上。
    女口果未定义的变量会在程序中造成危害的话，那么这些已定义f却保存undefined常量的变量
也会虫口此――在使用var声明一个变量时，如果没有提供初始值就会以此作为默认值。要测试un-
defined，我们可以使用严格的比较操作符==：或者！F：m例如ji
    类似的==和！=比较操作符在ECMAScnpt中也可以使用，但不像：：：和！：：，当被比较的值
有不同的类型时，它(ll通常返回true。例如，24==“24”，以及riuⅡ：：undefined都可以返回true，而
24===“24”和null===undefined返回false。    ‘    。…
    ECMAS    叫    j  j：～．
    现在看一个更复杂些的程序，介绍在EcMAScript中如何定义自己的函数：，，ji_
    function square(X)    一    ，’    ●_j，一    j
    ．。‘，’-，i．  ．、，二，、    ，
    {    ．．
function sumOfSquares(array)
  . var result = 0;
    for (var i = 0; i < array.length; ++i)   .
                                                                                                                                                                                                                                                                                                                                                                                           .    '' ,
             result += squa.re(array[i] ) ;
   return result;
var array = new Array(100);
for (var i = 0; i < array.length; Hi)                  ..
   array[i] = (i * 257) 96 101;
print(sumOfSquares(array》 ;     .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .
    函数用function关键字定义。为了保持ECMAScript的动态性，参数声明没有类型i函数没有显
式的返回类型。一    ？  。    ，’．’．j．．j。    ，．  ．
    通过查看代码，我们可以猜测square()调用的参数是Number，surnOfSquare。()调厢的参数是A一
ray对象，但也不一定就是这样。例如，square(“7”)将返回49，因为'ECMAScnpt，的乘法操作会在数
字上下文中把字符串转换为数字‘。同样，sumOfSquare()函数不仅可以使用Array对象，也可以使用
具有楣同接口的其他对象。
    t    ．
    一般地，ECMAScript会使用鸭类鉴别原理(duck typing principle)：“如果它走路像鸭子，叫声像
鸭子，那它一定就是鸭子”。这与C++和Java的强类型鉴别相对立，强类型鉴别的参数类型必须被
定义，变量必须与声明的类型相匹配。    ．  ：i．    ~，！  ，，  √
    在前面的例子中，sumOfSqum:es()以硬编码的方式为数组的每个元素计算。quare()。我们可以
使它更灵活，让它接收一个一元函数作为第二个参数，并把它改名为。um()。
function sum(array, unaryFunc)               _ <
{                                               :
   var result = 0;  .     '      .       . :':
 .   for (var i .= Q; i. < array.length;+十i)
      .      result +='unaryFunc(array[i] ) ;    , .  ,
   return result;
wi“g●；，？
   rl
  -o
   C
   =
 o i] x
           II
  II -. II
.L
. fD .-
. > rl
  382    C++ GUI Qt 4编程（第二版）
_--__-_______-‘‘’’’‘‘一
    )
var
for
.print(sum(array,  square》;
  调用。um(array, square)跟调用sumOfSquares(anay) -样。除了定义square()函数外，还可以传
递一个匿名函数给surn()：
    print(sum(array, function(x){return×丰×;)y);
    除了定义一个array变量，也可．以传递一个数组字面值：
    print(sum([4,8,11, 15l, function(x){return×丰×;)));
    ECMAScript允许向函数提供比定义的参数更多的参数。额外的参数可以通过arguments数组
访问。请看下面的例子：
functio'n sum(unaryFunc)
{
   var result = 0; , '   .
    for (var i = 1; i < arguments.length; ++i)
  . . '     resutt += unaryFunc(arguments[il) ;
        'return  result ;
}
print(sum(square, 1, 2, 3, 4, 5, 6》;
    这里，。un，()函数被定义为带可交参数。第一个参数是我们想使用的函数，其他的参数是需要
求和的数字。’当遍历aruments数组时，必须跳过位置0这一项，因为它对应的是unaryFunc_元函
数。也可以从参数列表中忽略unaryFunc参数，把它从arguments数组中提取出来：
    var result=0：
    for (var i=1;i(arguments.length; ++i)
    result+=unaryFunc(arguments【il);
    return result：
j  )    一    。
    arg\ments数组可以根据参数类型或者它们的数量重载函数的功能。例如，假设我们想让
驯n()带有一个可选的一元参数，以及一个数字的列表，并且允许我们这样调用它：
print(sum(l, 2, 3, 4, 5, 6》;    .                             _d
print(sum(square, 1, 2, 3, 4, 5, 6》;     . .
为了达到这个目的，可以这样实现sum()函数：
function sum( )
{
   var unaryFunc = function(x) { return x; };
   var i = 0;  .
var result = 0;
while (i < arquments.length) '   '
        result  +=  unaryFunc{arguments [iHI ) ;
return result;
 .+
  +
  +
 _L:
   J ._
  g r+
 .- N
-  . rP
0 m-
+ u r-
( u 5
ro
L y d(
L
3 .-
ti.毗 il
C II -
 II1
ro u ro
u ro L
L>L
ro - ro
    E
    =
   '    n了
              II
    C
    =
- u-
EL
=    {1,
U,  C
    =
OL
rl    ll,
C
=
L_ -r
:
C
C
=
F '-
:o
1: 7J.
-C
U, =
CL
a> ra  :
= il
  =
f U_ .-
  rl             r -.
    第22章应用程序脚本383
    如果第一个参数是一个函数，在求和之前，这个函数会处理每个数字；否则，可以使用恒等函
数function(){retum x;}.
    对于C++程序员，认为ECMAScript最难的就是它的对象模型。ECMAScript是一种基于对象
( object-based)的面向对象的语言，以使它区别于C++、C#、Java、Simula和sⅡ，alltalk，它们都是基于
类的。代替类的概念，ECMAScript提供了一种更低层次的机制。
    允许我们在ECMAScript中实现类的第一个机制是构造函数。构造函数是一个能被new操作
符调用的函数。例如，以下就是Shape对象的构造函数：
    function Shape(x，y){
    this．x=x：    ，
    this.y=y；    。‘
    )
    Shape构造函数有两个参数，它基于传递给它的值去初始化新对象的x属性和y属性（成员变
量）。tlus关键字指被创建的对象。在ECMAScript中，对象本质上是一个属性集，属性随时可以被
添加、删除或者修改。属性会在第一次进行设置的时候得到创建，因此当我们在构造函数中为
    tl    ‘    ？
us．x和this.y赋值时，x和y的属性就被创建丁。
    对于C++和Java开发者来说，一个普遍的错误就是在访问对象属性时忘记使用tlii。关键字。
在前面的例子中，这似乎不太可能，因为语句x=x看起来很可疑，但在其他的例子中，这将导致创
建一个虚假的全局变量。
    为了创建Shape对象的实例，可以这样使用new操作符：    ：．j，，，
    , var shape=new Shape(10, 20);
’    虫口果在shape变量上使用typeof操作符，则数据类型是Object，而不是Shape。如果想确定Shape
构造函数是否创建了对象、，可以使用in。tanceof操作符：
    ：：’    ’
    var array=new Array(-100);
    array instanceof Shape.;    ／／returns false
    var shape=new Shape(10, 20);    :
    shape instanceof Shape;    ／／returns true
    ECMAScript允许任何函数作为构造函数。尽管如此，如果函数没有对tlu。对象做任何修改，作
为构造函数调用它也没有意义。相反，构造函数也可以作为普通函数而得到调用，但这也并没有
什么意义。
    ．    ．    ．。
    除了基本数据类型，ECMAScript提供内置的构造卤数，允许我们实例化基本对象类型，比如
Array、Date和RegF,xp。与基本数据类型相对应的其他构造函数，允许我们创建能够保存原始值的
对象。valueOf()成员函数可以用来查询保存在对象里的原始值。例如：    。
    va.r' boolObj=new Boolean(true);
    typeof boolObj;    ／／returns”object“
    var boolVal=boolObj,valueOf();
    typeof boolVal;    ／／returns“boolean“
    图22.1列举了ECMAScript提供的内置的全局常量、函数和对象。下一节将在内置的功能中
添加额外的、应用程序相关的C++组件。
    前面已经了解了如何在ECMASa/pt中定义构造函数，以及如何向构造的对象中添加成员变
量。通常，我们也需要定义成员函数。因为在ECMAScript中，函数被看作是一等公民，这就变得异
常容易。这里有一个Shal兕构造函数的新版本，它带有两个成员函数，．nanhattanPos()和translate()：
    function Shape(x―y){    .    _    .
    this．X=X：
    this．y=y；
  384    C++ GUI Qt4编程（第二版）
this.manhattanPos = function() { . .
    return Math.abs(this.x) + Math.abs(this.y)
};
this.translate = function(dx, dyJ {
    this.x += dx;
.   this,y += dy; .
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃淄磷鬻鬻鬻鬓熬戮添鬻鬻戮瓣嚣鬻鬻鬻麟蕤滋黼慧缀戮戮麟缀鬻鬻鬻            ┃
┣━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┫
┃print(x)①                    ┃在控制台打印一个值                      ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃eval( str)                    ┃执行一个ECMAScript程序                  ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃parselnt(str, base)           ┃把字符串转换为整型                      ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃ parseFloat ( str)            ┃把字符串转换为浮点型                    ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃isNaN(n)                      ┃如果n是NaN，返回truc                    ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃isFirute(n)                   ┃如果n是非NaN、+ aa或一m的数字，返回true ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃tlecbdeURI(;str)  。    ．    ┃把．8位编码URI转换为Unicode             ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃ 'decodeURnponent{ str)       ┃把8位编码UIU组件转换为Unicode           ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃encodeURI(.str) {'; :-   J'.  ┃把Urucode URI转换为8位编码的URI         ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃encodeURIComponent( str)      ┃把Unicode URI组件转换为8位编码          ┃
┗━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃簇慧赫鳞蒙壤熬鬻壤鬻豢蒸鬻鬻鬻瀚糕麓豢戮骥鬻骥鬻嚣鬻麟鬻鬻鬟豢  ┃
┣━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┫
┃Object'’       ┃提供所有对象通用的功能                        ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃tFuncdori       ┃封装一个ECMAScript函数                        ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃Array    ．‘   ┃描述一个可变长的项向量    ．                  ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃SUing           ┃保存一个Urucode字符串                         ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃Boolean         ┃保存一个布尔值(true或false)                   ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃，Number        ┃保存一个浮点数                                ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃Date    ．  t． ┃保存日期和时间                                ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃RegExp          ┃：提供正则表达式的模式匹配                    ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃Error           ┃基本错误类型                                  ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃EvalEnor        ┃错误地使用cval()时抛出                        ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃RangeError      ┃数值溢出时抛出                                ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃ReferenceF,rror ┃试图访问未定义变量时抛出二                    ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃SyntaxError     ┃ eval()检测出语法错误时抛出                   ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃TypcEnor        ┃参数类型错误时抛出                            ┃
┣━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━┫
┃URIError        ┃ URI解析失败时抛出                            ┃
┗━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━┛
①ECMAScript标准并未说明。
图'22.‘l全局对象的内置属性‘’
第22章应用程序脚本
可以使用．（点）操作符调用成员函数：
var shape=new Shape(10, 20);
shape.translate(100, 100);
print(shape.x+“,”+shape.y+“(”+shape.manhattanPos()+“)“)
    使用这种方法，每个Shape实例都包含自己的marihattanPos和translate属性。’由于这些属性对于
所有的Shape实例应该是一样的，所以它们只需要保存一次，而不是保存在每个实例中。ECMAScript
允许我们使用原型法达到这个目的。原型(prototype)是一个备用的对象，提供属性的初始化集。这种
方法的好处是可以随时修改原型对象，并且修改可以立即反映到使用该原型创建的所有对象中。
    请看下面的例子：
function Shape(x,
   this.x = x?
   this.y = y;
}
    Shape.prototype.manhattanPos=function(){  、
    return Math.abs(this.x)+Math.abs(this. y);‘
    n    ．0．
    Shape.prototype,translate=function(dx, dy){
    this.x+=dx;    、_    一
    this.y+=-dy;    ’  』    ！。…，：
    )：    ．
    在Shape的这个版本中，我们在构造函数之外创建manhattanPos和translate镉矬，．把它们作为
Shape．prototype对象的属性。当实例化Shape时，新创建的对象保存一食指扁rhape. prototype，的内
部指针。当查询一个Shape对象中不存在的属性值时，将会到原型中查询。因此，t'Shape原型是保
存可以被所有Shape实例共享的成员函数的理想场所。．    ：：；一一一_二
    把需要在Shape实例中共享的各种属性保存在原型中的方法不错，这与‘鬟子秀簸静态成员变量
或者Java的类变量类似。这一特性对只读属性（包括成员函数）有用，因为原型是期来查询属性值
的一种备用策略。然而，试图给共享变量赋新值是行不通的。取而代之的是，可以创建二个新的
变量，以覆盖原型中具有相同名称的属性。这种对变量读和写的不对称访问经常使ECMAScript程
序员新手感到困惑。    ，    ，．，
    在基于类的语言中，比如C++和Java，可以使用类继承创建一系列的对象。例如，可以定义一
个Shape类，然后从Shape继承出Triangle，Square和Circle。在ECMAScript中，使用原型可以实现类
似的效果。下面的例子介绍了如何定义Circle对象，它也是Shape实例：  ，．  一  ：。
function Shape(x, y) .{ .
   this.y = y;
Shape.,prototype:area = function()'{ return 0'; }';
function Circle(x, y, radius) {
      Shape.call(this, x, y) ;
   this.radius = radius;
                    .
    Circle.prototype=new Shape;    ‘_÷
    Circle.prototype.area=function(){
    retU rn Hath．P工术thiS．radiUS术thiS．radiUS：
    )；    ．
  ：首先定义一个Shape构造函数，关联一个总是返回O的area()函数。然后定义一个C№le构造
函数，它使用cau()函数调用“基类”的构造函数，caⅡ()函数是为所有函数对象（包括构造函数）定
义的，此外还添加了一个础us属性。在构造函数外，我们设置Circk的原型为一个Shape对象，并
且用Circle定义的实现覆盖Shape的area()卤数。下面就是对应的C++代码：  ，  ，
  386    C++ GUI Qt 4编程（第二版）
double y)
class Circle  :public Shape
{    ’？
public:    +
    Circle(double x.double y,double radiusJ
    ：Shape(x,y)
    {    一    ．
    this->radius=radius;
    )
    double area() const{return M_PI 4 radius+radius;)
    double radius;
)；．
instanceof操作遍历原型链，．以判断哪个构造函数被调用了。因而，子类实例也被认为是基类
的实例：
var .circle =
circle instan
circle instan
circle u. istan
circle' idstan
    这就是我们对ECMAScnpt的简短介绍。在接下来的章节中，将介绍如何在C++ tQt应用程序
中使用这一语言，为终端用户提供更多的灵活性和可定制能力，或者仅仅为了提高开发进度。
22:2使用脚本扩展Qt应用程序
、使用QrScnpt模块，我们可以编写能够运行ECMAScnpt的C++应用程序。脚本可以扩展应用
程序的功能，而不需要重新编译和重新部署应用程序毛我们可以把ECMAScnpt文件的硬编玛集作
为应用程序的一部分，也可以被新版本的应用程序所替代，或者也可以让应用程序使用任意的EC-
MASclfipt文件。
    在C++应用程序中执行脚本通常包含以下步骤：
1．把脚本读入QSming。
2．创建一个QScnptFngine对象，并设置应用程序相关的
  功能。
3．执行脚本。
    为了说明这一点，我们将学习如图22.2所示的Calculator
应用程序。Calculator应用程序允许用户在脚本中实现某些功
能来提供一些自定义按钮。当应用程序启动时，它会访问
scripts的子．目录，寻找脚本文件，创建与这些脚本相关的计算器
按钮。默认情况下，Calculator包含以下脚本：
图22.2 Calcdacor应用程序
      x
            II  II
      _O A A
         =l  I
         o Ln Ln
 o)            -a   rl   rl .
a    C -t= -t=
r0      0 4J 4J
-C     o-
cn    .- m
       u -t=
cn   .+ cn
ro   _o
r=
-o -o
==
 o . o,
-a -a
    ,0
0 0 0 cn
= = =r
L L L rr,
~J ~J 4J f
L L L .L
====
4J ~J ~J ~J
OOQO
LLLL
    o .N   .-
     - 0 .- 4-  '~
  Qr Q U y
-.“ t即.~i阳
   ':  L  rl i: _O .L
J, u       .
1   3 0 0 0.:O
    (u Q) Q) 0 0
 ..  C u u u u
．1／
第22章应用程序脚本387
●cube.js计算当前值的立方（X3）。
●factorial.js计算当前值的阶乘（菇！）。
●pi.js用丌的近似值覆盖当前值。
    大部分Calculator应用程序的代码都与本书中使用的C++ tQt代码属于同一类型。这里，我们
仅介绍与脚本相关的代码，先从createCustomButtons()私有函数开始，它在Calculator构造函数中得
到调用：
void  Calculato r: : C reateCustomButtons ( )     .
{
      QDir scriptsDir = directoryOf( "scripts") ;
   QStringList fileNames = scr.iptsDir.entryList(QStringList("*.js"), .
 . foreach (QStringrfileName, fileNames) {    QDir::Files)j
      QString text = fileName;
  '  text.chop(3);   .
       QToolButton *button ." crea'teButton(text,
                                                                                  SLOT( customButtonClicked ( 》 ) ;
                 button->setStyleSheet ( " color:  rgb ( 31,  63,   127) ". ) ;
      .              button->setP rope rty ( ii s c riptFileName " ,
            scriptsDir.absoluteFilePath(fileName》; '
   .            customButtons .append ( button ) ;                  .
    createCustomButtons()困数使用QDir对象访问应用程序脚本子目录，寻找带．js扩展名的文件。
它使用相同的directoIyOf()函数，第17章已使用过它。
    对于每个．js文件，通过调用私有函数createButton()函数创建QToolButton。该函数还连接新按
钮的clicked()信号和customButtonClicked()槽。然后，设置按钮的样式表使前景色文字为蓝色，以
区别于自定义按钮和内置按钮。
    调用QObject:：setProperty()为QToolButton动态创建一个新的scriptFileName属性。在customBu-
ttonClicked()槽中使用这一属性来确定应该执行哪个脚本。    t
    最后，把新按钮添加到customButtons列表中。Calculator枸造函数将列表中的定制按钮添加到
窗口的网格布局中。
    对于此应用程序，在它启动时访问脚本子目录一次。另一个方法是使用QFileSysteinWatcher监
听脚本的子目录，当目录内容发生改变时更新计算器，允许用户不必重新启动应用程序就可以添
加新脚本和删除已存在的脚本。    ’  _    ’
void  Calculato r: : customButtonClicked ( )
{
       QToolButton  *clickedButton = qobject_cast<QToolButton  *>(sender( 》 ';
            QFile   file ( clickedButton->p ro pe rty ( ii s c riptFileName" ) .toSt ring ( 》 ;
        if  ( ! file.open (QIODevice: :ReadOnly》  {
              abortOperation ( ) ;
                  retu rn;      .
QTextSt ream  in ( &file) ;
in . setCodec ( "UTF_8 " ) ;
QString script = in,readAll();
file,close( ) ;
QScriptEngine interpreter;
QSc riptValue  ope rand (&inte rp reter,   display->text ( ) .toDouble ('》
interp reter.globalObject ( ) .setP rope rty ( ".x" ,   ope rand) ,           ,
QScriptValue result = interpreter,evaluate(script) ;
if  ( ! result.isNumber( 》  {     .
    ．-    j
C++ GUI．Qt'4编筘<第二版）
    setDisplayValue( tesult .toNumber());    :    .
    waitingForOperand=true;
    '
    在customButtonClicked()槽中，首先调用QObject:：sender()确定被单击的按钮。然后，，提取
  scriptFileName属性查询与该按钮相关的．js文件名。’接下来，把文件的内容读入script字符串中。、
    ：    ．
    ECMAScript规范要求解释器支持Unicode，但它没有要求使用哪个编码保存脚本。我们假定
  ．js文件使用UTF-8，这是一个纯ASCII的扩展集。
    ‘当脚本被读入QString时，我们创建j个、QScripfflngine去执行它。一个QScripfflngine实例代表
  j个ECMAScript解释器，并保存当前的状态。我们可以同时拥有任意数量的QScriptEngine，各自保
  存自己的状态j’  _    ‘：  ’    ’
    在运行脚本之前，必须保证脚本可以查询到计算器当前显示的值。选择的方法是创建一个称
  作x的ECMAScript全局变量――或者，更准确地说j就是向解释器的全局对象中添加一个称为x
。  的动态届性。在代码中，x可以被直接使用。    ’
    设置的x的蓿的类型必须是QScriptValue。概念上，QScriptValue类似于QVaIlt，因为它可以存
  储很多的数据类    ‘只能保存ECMAScript数据类型。
    最后，使用藿clc.tptEngine：：evaluate()运行脚本。结果是脚本返回的值，或者如果发生错误，返
  回一个异常对象≥（在下一节中，我们将了解如何用消息框报告错误。）脚本的返回值是retum调用
  的返回值；如果return被忽略了，那么返回值就是最后一个表达式求得的值。一旦得到了返回值，
  就可以检查它是否是一个数字，如果是就显示它。
    对于这个例子，每次用户单击相应的按钮，脚本就会执行一次。因为这一步包含加载和解析
  整个脚本，通常更可取的是使用一种不同的方法，脚本不是立即执行，而是返回一个函数或者对
  象，它可以被再次使用：下一二节将使用这一替代方法。    …
    为了链接QtScnpt库，必须在应用程序的．pro文件中添加这一行：
    p    ．    ．
例子脚本很简单，就是这样一行的？pi.js:-．，二    。一  。
    return 3.14159265358979323846;‘'  .  -
值得注意的是，我们忽略了计算器的x值。cube.js廊本也是一行，但它使用了x的值：
    ．  ，。，j．  ．    ：    ．    1
．  ．  return x章．‘x车x；。、  ，
．    ‘    ：  ，．    ．
factofial.js脚本定义了一个函数并且调用了它：  ，一．    。：．
  :function factoriat(n) .
      .      return l; .
          return n # factorial(n - 1);
    .    }
标准的阶乘函数仅操作整数，因此使用了Math.floor()函数把x转换为整数。
    我们了解了QtScnpt模块的基础：QScriptEngine翱QScriptValue，前者代表一个解释器和它当前
    ECMAS    ？    ，    ’
的状态，后者保存一个EC地cript的值。    。。。’    一  -
／7
第22章．应用程序脚本389
    在计算器例子中，很少涉及脚本和应用程序之间的交互：脚本从应用程序．中读取_个参数，返回
一个单独的值。在下面的几节中，将了解更高级的集成办法，并且介绍如何向用户报告异常。
22.3使用脚本实现GUI扩展
    如同前面介绍的，提供脚本计算数值很有用但有局限性。通常，我们想要在脚本中直接访问
应用程序的窗口部件以及其他的组件。也可能需要组合ECMAScript文件和Qt设计师的，；ui文件
提供额外的对话框。使用这些技术，就能够主要使用ECMAScript赛牙发应用程序，很多程序员也
正希望如此。    ？+．-．，7：，．一，  ，  ．    ，    ，
  本节将介绍如图22.3所示的rIML编辑器应用程序。该应用程序是。个纯文本编辑器，使用
QSyntaxHighlighter高亮显彖HTML标签。该应用程序特殊的地方是它提供了一个Scripts莠甍，它将
应用程序scripts子目录下的以。．js作为扩展名的脚本文件和相应的．UI对话框组装起来。对话框
允许用户参数化他们想要执行的操作o．j
    图22.3  HTML编辑器应用程序    =  一…‘：I、：…  ’_’1_
    _．    ．．。    r_，-    ‘_  、    1
  我们提供了两个扩展：Stat/stics财话框和Refonnat Text对话框，如图瑟j4’所示：‘Statistlcst'~j-话
框是个纯粹的信息提供者，它统计文档中的字符、单词和行的数量，在一个模式对话框中显示总
数。Refonnat Text对话框更复杂一些，它是非模态对话框；这意味着在对话框显示的情况下用户仍
然可以与应用程序的主窗口进行交互。该对话框可以用来重新对齐文字、换行，以及标准化标签
的语法。所有这些操作都实现在ECMAScript中。    。
    该应用程序的核心是HUnlWindow类，它是一个QMainWindow的子类，使用QTextEdit.作为中心
窗口部件。这里，我们只介绍与脚本相关的代码。    ’  ‘+
    当应用程序启动时，我们必须组装脚本菜单，菜单动作与scripts子目录下的．js和．UI文件相
对应。这与前面的Calculator应用程序中的createCustomButtons()函数很相似：    ．√  一
void HtmlWindow::createScriptsMenu().       ,.  l 'r
{
         .$c ript sMenu  =  meriuBa r ( ) ->addMenu (t r,( "&Sc ript s ",》
   QDir scrjptsDir = directoryOf("scripts");
390    C++ GUI Qt 4编程（第二版）
ost ring List  j s FileNames  =  sc riptsDir.entryLjst (QSt ringList ( "*, j s " )
sc riptsMenu->setEnabled ( ! sc riptsMenu->isEmpty( 》 ;
    对于每个脚本，我们调用createScriptAction()函数创建动千；，并把它添加到Scripts菜单中。如
果没有发现任何脚本，就将菜单设为无效。
图22.4Statistic-s和Refonnat Text对话框
createScriptAction()函数执行以下步骤：
1．调用并求脚本的值，保存结果对象到变量中。
2．使用QUiLoader和．ui文件创建对话框。
3．使脚本能够访问对话框。
4．向脚本揭示应用程序的相关功能。
5．创建QAction使用户可以访问脚本。
函数需要做很多工作，而且很长，因此将分段介绍它。
bool  HtmlWindow::c reateSc riptAction( const  QSt ring＆j sFileName)
{    ．  ’
    QFile jsFile(js FileName);
    if(!jsFile.open( QIODevice::ReadOnly))t
    QMes sageBox::wa rning (this,t r("HTML  Editor"),    ．，
    tr("Cannot read file 961:\n%2.‘’)
    .a rg( st rippedName(j sF/leblame))
    .arg(jsFile.errorString(》);
    return false;
    }
QTextSt ream  in ( &j sFile) ;
in . setCodec ( "UTF-8“) ;
QString script - in.readAll()
jsFile,close();
QScriptValue qsScript = interpreter.evaluate(script) ;
if (interpreter.hasUncaughfException(》 {
      QMessageBox messageBox(this) ;
            messageBox, setlcon ( QMes sageBox: : Wa rning) ;         .
          messageBox, setWindowTitle ( t r( " HTML  Editor" 》 ;
    messageBox,setText(tr("An error occurred while executing the "
                     "script 9sl.")
                                                          .a rg ( st rippedName ( j sFileName》 ) ;
    o
.-  E
-  rv
oo
.+    rJ
U-  LL
   . .              cn
Lv
o  IJ
o .  rr,
   a-
  LL
 .  o
   -- IJ
 Or
.EO
   z -o
  o ra
 ~-1上 L
  LL rJ
   .,- cn
    IJ
 ~a
  O rJ
 EL
  rv u
ov
 rC
  rJ O
  LL rJ
   cn rJ
   'r. U
   <
ovIJ
 ca
    rJ .+
 LL
  IJ u
oo
       -
    rr,
 ;C o
 UL
  ' ra u
  L
  o
第22章应用程序脚本    391
mes sageBox. setlnfo rmativeText (
                   t r (”%1. " ) .a rg (interp reter. uncaughtException ( )
                                                                                                                                                                                                                                                                                                                                                                                                                         .
join(“＼n“))；
    }
．  首先读取．js文件。由于只需要一个解释器，可以使用QScriptEngine类型的称作mterreter的
成员变量。我们求取脚本的值，并把它保存在名为qsScript的QScriptValue对象中。
如果脚本不能被求值（例如语法错误）；QScriptEngine：：hasUnca
在这种情况下，可以使用QMessageBox报告错误。
ughtException()函数将返回true。
    对于本应用程序所使用的脚本，我们采用一种约定，当被求值时，每个脚本都必须返回一个EC-
MAScript对象。这个对象必须提供两个属性：一个称作text的字符串保存用以识别脚本的Scripts菜
单的内容，以及一个称作mn()的函数，当用户选择Scripts菜单的脚本时可以被调用。我们把对象保
存在qsScript变量中。这种方法最大的好处是只需在启动程序时读取和解析脚本一次。
QString uiFileName = jsFileName;
uiFileName.chop(3) ;
uiFileName += ".ui";         '
QFile uiFile(uiFileName) ;      .
if  ( ! uiFile.open (QIODevice: :ReadOnly》' {       ' .
       QMessageBox: :warning (this,  t r( "HTML  Editor" ) ,
                     tr("Cannot read file gal:\riga2.")
                                                              . a rg ( st rippedName ( u/FileName》
 .arg(uiFile.errorString(》);
   return false;
QUiLoader loader;
QWidget' *dialog =
uiFile: close ( )';1
if (!dialog) {
        QMessageBox: :
loader,load(&uiFile,  this) ;
warning (this,  tr( "HTML  Editor" ) ,
     . tr("Error loading %1.")
    ．a ra( strippedName( uiFileName)));
    return false：    ．    ’、    。
    }
  一另外的约定是每个脚本必须有一个相对应的．ui文件，为脚本提供一个GUI对话框。．ui支件
和脚本文件的文件名前部分必须相同。
    ‘    ：    ：．
    我们试图读取. Ul文件，动态地创建一个包含所有窗口部件、布局和．Ul文件中指定的连接的
QWidget。窗口部件的父对象作为load()调用的第二个参数给定。如果发生错误，向用户发出警告
并返回。
QScriptValue qsDialog -: interpreter.newQObject(dialogJ
qsSc ript. setP rope rty ( "dialog " r   qsDialog ) ;
QScriptValue qsTextEdit = interpreter.newQObject(textEdit)
qsSc ript. setPrope rty ( "textEdit " ,   qsTextEdit ) ;
QAction *action = new QAction(this);
action->setText (qsSc ript . p roperty ( "text " ) .toSt ring ( 》 ;        .
action->setData(QVariant::fromValue(qsScript》; '  ..' ,;
connect (action,   SIGNAL(t rigge red (》 ,
                    this ,   SLOT ( s c rjptActionTr;glgered ( 》 ) ;                  .
 s c ript sMenu->addAction ( action )
return true;
E巴群件畦辩辩套4#．。∥Fk 7}．．
  L
  IJ
  u
 ca
  c
  o
  IJ
  o
  x
 LU
  IJ
IJ o
x=
F- u
-o c
Q) =
rl L  '
r0 0 .-
IJ IJ -
0 Q) C
OLU
rJ o o)
0 L X .~
cn Q) Q) a)
  . IJ  . cn
x C Xr
O rJ o ro
B   m L_
Q)  0
 cn  g c
a,   a, L
cn   cn =
 cn    cn lJ
E  EL
C++ -CUI Qt 4编程（第；版）
    一旦成功读取脚本文件和用户接口文件，就可以把脚本添加到Scripts菜单中。但首先有几个
需要注意的细节：脚本的run()函数需要能够访问创建的对话框。此外，脚本应该能够访问QTex-
tEdit，它包含被编辑的HTML文档。
    我们首先把对话框作为QObject*添加到解释器中，解释器使用该对象来显示对话框，把它保
存在qsDialog中。我们把qsDialog对象添加到qsScript对象中，把它作为一个新的称作dialog的属
性。这样，脚本就可以通过新创建的dialog属性访问对话框，包括它的窗口部件。使用同样的技术
使脚本可以访问应用程序的QTextEdit。
    最后，创建一个新的QAction在GUI中显示脚本。设置动作的文字为qsScript的text属性，动作
的“data”项设置为qsScript。最后，连接动作的tr/ggered()信号和定制的scriptActionTriggered()槽，把
动作添加到Scripts菜单中。
void  HtmlWindow: : sc riptActionTrigge red ( )
{
  ' QAction *action = qobject_cast<QAction *>(sender(》.;  :.    :
          QSc riptValue  qsSc ript .=  action->data ( ) , value<QSc rjptValue> ( ) ;
          qsSc ript . p rope rty( " run " ) . call (qsSc ript ) ;
}          .
    岩调用该槽时，需要首先查出是哪个动作得到了触发。然后，使用QVaraIlt：：’value<’r>()提取出
该动作的用户数据，并且把它转换为QScriptValue，保存在qsScript中。接着，触发qsScript的run()函
数，以qsScript为参数，这将使qsScript作为run()函数的this对象①。
・  一．’：，    ，，r‘、矗延i：：，．    ：
．  QActjon.的！‘data”项机制基于QVarant。QScnptValue类型不是QVariant可以识别的数据类型。
幸运的是，Qt提供了一种机制可以扩展QVaIiant处理的类型。在htn，lwindow．cpp开始的地方，#in-
clude的后面，有这样一行：  ’
・这一行应该出现在定制的数据类型被声明之后，且只对那些有默认构造函数和复制构造函数的数
据类型有效。
    既然已经丁解了如何加载脚本和用户接口文件，以及如何提供一个动作，用户可以触发它并
运行脚本，我们可以看看脚本本身了。从Statistics脚本开始，因为它最容易也最短，将分段介绍它。
’    var obj=new Object；    ‘
    obj.text=“&Statistics.”；
    t    1    。    ，
    我们创建一个新的对象，为它添加属性，把它返回给解释器。第一个属性是text属性，它保存
Scripts菜单显示的文字。
    obj.run=function(){
    var text=this.textEdit.plainText;
    this ,dialog.f rame. cha rCount LineEdit .text=text .length,
    this .dialog.frame.wordCountLineEdit.text=this.wordCount(te×t):  ,
    this.dialoq.frame.1ineCountLineEdit.text=this.1ineCount(text);    ’
    this.dialoq.e×ec();,  ’、-    ;、  ‘    .    :
    )：
    创建的第二个属性是nm()函数。该函数从对话框的QrIktE（虹t中读取文字，把对话框的窗口
部件和汁算结果结合起来，最后模态地显示对话框。    ．
①Qt 4.4有望提供一个qScriptConnect(j函数，允许我们创建C++和脚本的连接。利用这个函数，可以直接连接QActi。。
    的mggered()信号和qsScript的M()函数：
    q5c riptConnect (action,  SIGNAL(t riggered()).qsScript,  qs5c ript.p rope rty(‘’run“J】：
    第22章泣用程序脚本    393
    只有当对象变量obj具有合适的textEdit和dialog.属性时，该函数才可以工作，这就是需要在
createScriptAction()函数末尾添加它们的原因。对话框本身必须有一个窗体对象（这里是QFarⅡe，
但类型不重要），以及三个子窗口部件-charCounLineEdit、wordCounLineEdit:和lineCountLineEdit，
它们都带有可写的text属性。除了this．dialog.

我们使用相同的样式创建一个普通的对象，为它添加属性，把它返回到鳃释器中。除了text
和run()属性，还添加了uutialized属性。第一次调用run()时，initialized是~alse，我们设置信号一槽，
连接对话框上按钮的单击事件和脚本中的函数。
    这里使用了Statistics脚本相同的假设。我们假定有一个合适的dialog属性，它上面有称作ap-
plyButton和closeButton的按钮。apply()函数与对话框的窗口部件交互，特别是Apply按钮（使其可
用和禁用），以及群组莓、复选框和微调框。它还与主窗口的QTextEdit交互，从QTextEdit中获取文
字信息，把格式化的结果返回到QTextEdit中。
    我们忽略了reindented()、、vIapped()相fixedTagCase()函数的代码，它们在脚本内部使用，因为实
际的计算过程跟理解如何对Qt应用程序脚本化并没有关系。
    现在，我们完成了如何在C++ tQt应用程序中使用脚本技术的介绍，包括具有自定义对话框的
应用程序。在IiTML编辑器这样的应用程序中，脚本与应用程序对象进行交互，我们还必须考虑
许可协议的问题。对于开源的应用程序，它符合开源许可协议本身的要求。对于商业应用，事情
就有些复杂了。对于为商业应用编写脚本的开发者，包括应用程序的最终用户，如果他们的脚本
只使用ECMAScript内置的类和应用程序相关的API，或者如果他们使用Qt API进行较少的扩展或
者修改存在的组件，这样做是免费的。但任何脚本编写者编写实现内核GUI功能的脚本必须拥有
商业Qt许可协议。如果有许可协议问题，商业版Qt使用者应该联系Trolltech的销售代表。
22.4使用脚本自动化处理任务
    有时，我们使用GUI应用程序每次以相同的方式处理数据集。如果操作需要触发许多的菜单
项，或者需要与对话框交互，不仅会变得很单调，而且还会有风险，有时会漏掉某些步骤，或者颠倒
两个步骤的顺序――或许有时不会意识到已经犯了错误。一个便这一工作变得容易的方法是编
写能够按动作的顺序自动执行的脚本。
    在本节中，我们将展现一个GUI应用程序，提供一个命令行参数- script，允许用户指定一个脚
本去运行。启动应用程序，执行脚本，然后结束，根本没有GUI的显示。
    这里用来阐述这种技术的应用程序称为Gas Pump。它可以读取加油泵的交易记录列表，并且
以表格的形式来显示数据，如图22.5所示。
    对于每项交易，加油泵都记录了日期和时间、数量、公司ID和卡车司机的用户ID，以及交易状
态。Gas Pump应用程序能够以老练的方式处理数据，排序、过滤、求和，并且可以在升和加仑间进
行转换。
一，
    第22章应用程序脚本395
―――刁――――一
图22.5  Gas Pump应用程序
    Gas Pump应用程序能够以两种格式处理数据：“Pump 2000”和“XML Cas Pump”‘：前者是以.p20为
扩展名的普通文本格式，后者是以.gpx为扩展名的XML文本格式。应角程序苛以加载和保存两种
格式的数据，因此可以彼此互相转换，只需加载时使用一种格式，保存时使用另一种格式。
    应用程序提供了4个标准的脚本：
    * onlyok.js删除所有状态不是“OK'’的交易。
    ●p20togpx.js把Pump 2000格式的文件转换为XML Gas Pump格式。
    ●tohtml.js以.HTML格式生成报告。    ’’  ，  ．
    ●toliters．js从加仑到升的单位变换。
使用- script命令行参数调用这些脚本，后面跟着脚本的名字，然后是操作的文件名。例如1：  。
    gaspump -script scripts/toliters.js data/2008q2.p20    ’    、+
    这里，我们运行scripts子目录下的toliters.js脚本，它位于data子目录下Pump 2000格式的
2008q2.p20数据文件。该脚本把所有的数量值从加仑转换为升，惨改文件的相应位置。
    Gas Pump应用程序就像其他的C++ tQt应用程序一样编写。实际上，它的代码很像第3章和
第4章中的Spreadsheet例子。该应用程序有一个称作PumpWindow的QMainWindow的子类，它提供
应用程序的框架，包括动作和菜单（菜单如图22.6所示）。还有一个定制的QTableWidget，称为
PumpSpreadsheet，它用来显示数据。一个QDialog的子类FilterDialog如图22.7所示，用户可以使用
它指定过滤条件。因为有很多的过滤条件，它们在PumpFilter的类中进行排序。我们简单地查看
这些类，然后介绍如何向应用程序中添加脚本支持。
豳篱  ．
  蘑霉翮
  №誊
  。j隧
图22.6  Gas Pump应用程序的菜单
396    C+斗7．GI=ⅡOt 4编程'（第二版）
class PumpSpreadsheet
  Q_OBJECT .
Q_ENUMS(FileFormat
图22.7 Filter对话框
public QTableWidget
Column)
public:
   enum FileFormat { Pump2000, GasPumpXml };
   enum Column { Date, Time, Pump, Company, User, Quantity, Status,
               ColumnCount };
’PUmpSp rea'd sheet(~Vtrdaet'parent=o);
pfb/ic siots
    void:;clea rData ( ) ;
.. bdol addData(c;)hs;t QString &fileName, FileFormat format);
      bodt :.s aveDa:t丑.( co.n s t  .QSt ring  &fileNarrie ,  . FileFortnat  ,fo rmat) ; .
 void sortByColumn(Column column,
                . Qt::SortOrder order = Qt::AscendingOrderJ
  vo/:2'1app~LyF.ilter{corls,t:.Pump.Filter&filter);  .  .       '. .
 void convertUn/ts(double factor);     -'      . .  -;
.. :void computeIotals{Column-jcolu周nJ;   , ':' ; .
 .void setT.ext(jnt row, int column, const. Qstr~pg &t~til' .  .
  QStr:ing' text(int rovr, .int:columdr const; ' . .
，：一j p'ri/atet:
)
保存数据，提供操作数据的函数（把函数做成了槽‘）’。通过用户接口可以访问
这些槽，编写脚本也可以使用它们。Q_ENUMS(+)宏用来生成关于：FileFormat1和Coltunn枚举类型的
META标签信息，稍后再介绍它。
 QMa/nWindow子类  PumpWindow有一个  loadData(.)函数 ,它使用了二些
void PumpWindow::'loadData()       .         .:   . ':    '
{
 .  QString fileName = QFileDialog::getOpenFileName(this,      .  . '.
                        tr("Open Data File"), ".",
                                             fileFilters) ;
       if  ( !fileName.isEmpty( 》 .{:. , ' ,        .  .    .
                ;-.'
                  sp readsheet->clea rData ( ) ;                                                       .        ..".
              '   sp readsheet->addData ( fileName,   fileForfr/at ( fileName)) ;
PumpSpreadsheet植：
dsheet保存在PumpWiridow中i作为它的成员变量；称为spreadsheet。PumpWindow的
lter()槽的典型性稍逊：    o
，第22章，应厨程序脚本397
                                                                            .',
void PumpWindow::filter()-: .:  '.  ! . ' ' -: .. . :
{         .
   FilterDialog dialog(this); '   .         . '/
          dialog .initF romSp readsheet ( sp readsheet) ;   . .
   if (dialog.exec(》    ' . ' .  .    一
                    sp readsheet->applyFilte r ( dialog . fjlte r ( 》,;          .  :'
    initFromSpreadsheet()函数把FilterDialog的组合框和泵、公司ID、用户ID以及状态编码组合起
来。当调用exec()时，会弹出如图22.7所示的对话框。如果用户单击OK，FilterDialog的filter()函
数返回一个PumpFilter对象，把它传给PumpSpreadsheet：：applyFilter()。
class PumpFilter
{
public:
         PumpFilte r ( ) ;      "
QDate fromDate;  '
QDate toDate;
QTime fromTime;
QTime toTime;
QString pump;
QString company;
QString user;
double fromQuantity
'double toQuantity;
QString status;
=一    一r    ：
j：嚣-■：  ’
PumpFilter可以使传递过滤参数变得更容易，采用分组的方式，而不是传递,10个单独的参数。
    目前为止，我们没有看到值得惊奇的地方。不易引人注意的不同点是我们把所有想耍脚本化
的PumpSpreadsheet函数变成了公有的槽，我们也使用了Q_ENUMS()宏。为了使：Gas P11嘞脚本t匕，
    一？一．-
还需要做两件事。第一，必须修改main .cpp添加对命令行的处理，+以及执行被指定・的脚本。第二，
    ’  二，．j．，一！…  ‘，  ．？
必须使应用程序的功能可以被脚本使用。    j    。
C++原型以及一个构造函数，在脚本中使用new操作符就可以实例化这些类。Gas Pump倒王阐述
了这两种方法。
    在学习运行脚本的架构之前，来看Gas Pump提供的一个脚本。这就是完整的onlyok.js脚本：
if (arg's.length == O)  ' .
.  throw Error("No files:specified on the'command ljne");
for (var i = O; i < args.length; ++i) t
      spreadsheet.clearData() ;   .         .
      if  ( !spreadsheet:addData(args [i] ,;/Pumpspreadsheet.Pump2000》 .扣‘   ." '‘‘
         throw Error("Error loading Pump 2000 data");              '.  .:.!, :
var filter ~ new PumpFilter;
filter.status = "OK";
s p readsheet .applyFilte r ( filte r) ;                              '    ' "            "
if   ( ! spreadsheet . saveData (a rgs [il ,  PumpSpreadsheet.Pump2000》.
   throw Error("Error saving Pum'p 2000 data");.   ,....:' -' .'
print("Removed erroneous t'ransactions from'" + args[il);
    这个脚本依赖于两个全局变量：args_和sprieadsheet。i;args变量返回命令行参数，提供一script后面
的参数。。pread。heet变量是PumpSpreadsheet对象的一个引用，可以使用它做各种操作（文件格式辖
C++ GUI Qt 4编程（第二版）
换、单位变换、过滤等）。脚本调用PumpSpreadsheet：对象的一些槽，实例化和初始化PumpFilter对
象，使用PumpSpreadsheet：：FileFormat枚举。
    我们首先执行一个完整性检查，然后对于命令行中列出的文件，清除全局的spreadsheet对象，
读取文件数据。假设这些文件的格式都是Pump 2000( .p20)。对于每次成功载入文件，创建一个
新的PumpFilter对象。我们设置过滤器的status属性，然后调用PumpSpreadsheet的applyFilter()函数
（因为它是一个槽，我们可以访问）。最后，把更新了的电子表格数据保存到原始文件中，输出一个
用户信息。
  其他三个脚本有相同的结构，它们包含在本书配套网站的源码中。    ，
  为了支持脚本，例如onlyok.js，在Gas Pump应用程序中需要执行下面的步骤：
  1．检查- script命令行参数。
  。2．加载指定的脚本文件。
  3．在解释器中引入一个PumpSpreadsheet的实例。
  4．在解释器中引入命令行参数。
  5．在解释器中引入FileFonnat和Column枚举。
  6．包装PumpFilter粪，使得脚本可以访问成员变量。
  7．使PumpFilter对象可以在脚本中被实例化。
  8．执行脚本善j
相关的代码在 main.cpp.scripUng.cpp和 scripting.h中a首先请看 main.cpp:
    int main(int argc, char *argv[J)     '
 . {.  '
 . '    QApplication app(argc; argv);     .
      . QStringList args = QApplication::arguments();
        if (args.courit(》= 3 && args[lJ == "-script") {
                     .   . runSc ript (argsI2J ,  args .mid (3》 ;
       -  return 0;'
   .    } else if (arg's.count() -cl) {    '
             PumpWindow window;      .                                   f
 .                    window.show( ) ;
                     window. resize(600,  400) ;
                      return  app.exec( ) ;
      } else {.
           std::cerr   "Usage: gaspump [-s,r;lllpt my:script.js .arguments>J-
          return l;   ,                                   .     ..p
      }
    命令行参数通过QApplicaUon：：arguments()函数访问，返回一个QStringList。列表中的第一项是
应用程序的名称。如果至少有三个参数，并且第二个参数是- script，就假定第三个参数是脚本名。
在这种情况下，调用runScript()，脚本名作为第一个参数，字符串列表的其他部分作为第二个参数。
如果脚本已经运行，应用程序立刻终止。
    如果只有一个参数一应用程序的名称，就创建并且显示PumpWindow，以常规的方式开始应
用程序的事件循环。
    scripting．h和scripting. cpp提供应用程序的脚本支持。这些文件定义runScript()函数、pumpFil-
teIConstructor()支持函数以及'PumpFilterPrototype支持类。支持函数和支持类是Gas Pump应用程序
专用的，但我们仍将介绍它们，因为它们揭示了使应用程序脚本化的一些要点。
    下面将分段介绍mnScript()函数，因为它包含几个小细节。
l
第22章应用程序脚本、399
bool runScript(const QString &fileName, const QStringList &args)
                          .
        QFile  file ( fileName) ;       .
       if  ( ! file.open (QIODevice: :ReadOnly》  {       '
     . std::cerr   "Error: Cannot read file "<< qPrintable(fileName)
《 ": 'I<< qPrintable(file.errorStrin.g(-》 .
《 std::endl;     .
      retu'rn false;
QTextStream in(&file) ;
in.setCodec("UTF-8") ;
QString script = in.readAll();
file,close( ) ;     .
首先把脚本读人QString中。
QScriptEngine interpreter;
'PumpSpreadsheet spreadsheet;
QScriptValue qsSpreadsheet = interpreter.newQObject(&spreadsheet);
 inte rp reter, globalObj ect ( ) , setP rope rty ( "spreadsheet " ,
                                                         qsSpreadsheet') ;          '
肖把脚本读人QString以后，就创建QScriptEngine和’PumpSpreadsheet实例。然后创建一个
QScriptVaule类型的Pum
实例的引用，把它设置为解释器的全局属性，使它作为spread-
sheet全局变量可以在脚本中被访问。所有
在其他脚本中进行访问。
t槽和属性都可以通过spreadsheet变量
QScriptValue qsArgs = qScriptValueFromSequence(&interpreter, args)
 interp reter .globalObject ( ) .setPrope rty ( "a rgs " ,   qsArgs) ;                     .
    传人runScript()函数的QStringⅡst类型的args(可能为空)列表包含用户想要传人脚本的命令
行参数。为了使脚本可以访问这些参数，必须总是创建-一个QScriptValue来表示它们。为了把顺
序容器（例如QI.ist <T>或者QVector <T>）转换为QScriptValue，可以使用QtScIipt模块提供的
qScriptValueFromSequence()垒局函数。我们把参数变量脚本化成全局的args变量。
QScriptValue qsMetaObject =. .
                    interp rete r. newQMetaObj ect ( s p readsheet .metaObj ect ( 》 ;
inte rp reter.globalObject ( ) . setP rope rty ( "PumpSp readsheet " ,
                                                        qsMetaObject) ;      .
    征pumpspreadsheet.h中，定义了FileFonnat和Column枚举。此外，还包含Q_ENUMS()声明指定
这些枚举。在一般的Qt程序中很少使用Q_ENUMS()，主要的用处是创建定制窗E『部件时可以访
问Qt设计师。但它在脚本上下文中很有用，因为可以通过注册包含它们的类的元对象在脚本中
使用枚举：
    通过添加PuinpSpreadsheet的元对象作为Pump$preadsheet的全局变量，FileFonnat和Column枚
举可以在脚本中访问它们。脚本编辑器能够通过输入，比如PumpSpreadsheet．Pump2000查询到枚
举值。
PumpFilterPrototype filterProto;
QSc riptValue  qs Filte rProto  =  interp rete r. newQObj ect ( &filterProto)
inte rp rete r, setDefault P rototype ( qMetaTypeId<PumpFilt e r> ( ) ,
                                            . qsFilterProto) ;
    困为ECMAScnpt使用原型，不使用C++的类，如果想脚本化一个定制的C++类，必须采用一
种迂回的方法。在Gas Pump例子中，我们想脚本化PumpFilter类。
    一个方法应该是修改类本身，让它使用Qt的元对象系统-，把它的数据成员输出成Ql_属性。对
  400    C++ GUI Qt 4编程（第二版）
I_________.-______._._____-,-一
于Gas Pump例子，我们选择保持原有应用程序的完整性，创建一个包装类PumpFilterPrototype，它可
以保持和提供对PumpFilter的访问，我们将介绍它是怎样实现的。
    I'
    setDefaultPrototype()调用告诉解释器使用PumpFilterPrototype实例作为PumpFllter对象的隐原
型。该原型继承自QObject，提供访问PumpFilter数据成员的Qt属性。
QScriptValue qsFilterCtor =
                    interp reter. newFunction ( pumpFilte rConst ructo r,
                                                  qsFilterProto) ;
inte rp rete r.globalObject ( ) , set P rope rty( "Pump Filter" ,   qs Filte rCto rJ
    我们为PumpFilter注册一个构造函数，这样脚本编写者能够实例化PumpFilter。在幕后，通过
PumpFilterPfototype访问PumpFilter实侈lJ。。
    初级准备完成了，我们挹脚本读人QString，设置脚本环境，提供两个全局变量：spreadsheet和
args。我们可以使用PumpSpreadsheet元对象，提供对PumpFilter实例的包装访问。现在可以执行脚
本了。
interpreter,evaluate(script) ;
if (interpreter.hasUncaughtException(》 {
   std::cerr《 "Uncaught exception at line "
《 interpreter,uncaughtExceptionLineNumber()《 ": il
          .《 qPrintable(interpreter.uncaughtException()   .
    << std::endl《 "Backtrace: ,,
《  qP rintable ( inte rp reter. uncaught ExceptionBackt ra ce ( )
《  std: :endl;
   return false;
    return true,
    }  ．。    ．
    ，    ？一
我们照常调用e:valuate()运行脚本。如有语法错误或者其他的问题，将输出适当的错误信息。
    现在查看微型支持函数pumpFilteIConstnlctor()，以及有点长【但很简单）的支持类PumpFilter-
    -_
Prototype。
QScriptValue pumpFilterConstructor(QScriptContext * /* context */,
                              QScriptEngine *interpreter) .
{
          retu rn   interp rete r->toSc riptValue ( PumpFilter ( 》 ;
}
    当脚本使用ECMAScript语法new PumpFilter创建新对象时，构造函数被调用。使用context参
数可以访问传人构造函数的参数。这里简单地忽略它们，创建一个默认的PumpFilter对象，包装在
QScriptValue中。toScriptValue<D()函数是一个模板函数，把类型T的参数转换为QScriptValue。类
型T(在这里指PumpFilter)必须使用Q_DECLARE_METATYPE()注册。
口DECLARE_METATYPE ( PumpFilter)
以下是原型类的定义：
    一
class PumpFilterPrototype:publid QObject, public QScriptable
{    。
    0_OBJECT
    Q PROPERTY(QDate fromDate READ fromDate WRITE setFromDate)
    Q_PROPERTY(QDate toDate READ toDate WRITE setToDate)
Q_PROPERTY(QString status READ status WRITE setStatus)
public:
   PumpFilterPrototype(QObject *parent'- 0)
第22章应用程序脚本    401
void setF:romDate(const QDate &date)
QDate fromDate'(') const;     '
void setToDate(const QDate &date);
QDate toDate() const;
void setStatus(const QString &status);
QString status() const;
    原型类派生自QObject类和QScriptable类。．对于每对getter/setter的访问，可以使用Q-
PROPERTY()。通常，使用Q_PROPERY()仅仅为了访问集成到Qt设计师的定制窗口部件的属
性，但它们在脚本环境中也很有用。如果函数被脚本使用，就可以把它们变成公有的槽或者属性。
    所有的访问器都类似，因此只介绍一对典型的例子：    ．
void  PumpFilterPrototype: : setF romDate ( const  QDate &date)
{
   wrappedFilter()->fromDate = date;     .
}
QDate  PumpFilte rPrototype: :f romDate ( )  const
{
          retu rn  wrappedFilter ( ) ->f romDate;
}
纵下是rwappedFilter()私有函数：  。
PumpFilter *PumpFilterPrototype::wrappedFilter() const
    QScriptable:：thisObject()函数返回与解释器当前执行的函数相连的tllis对象。它返回一个
QScriptVaue，我们把它强制转换为它代表的C++ tQt类型PumpFilter*。只有当使用Q二DECLAPLE_
    METATYPEP    ・_’，，、
加ⅡA1啊PE()注册PumpFilter*时，这种强制转换才有效：    i  、一
Q_DECLARE: METATYPE (PumpFilter *)
最后是PumpFilterPrototype构造函数：
PumpFilterPrototype: :PumpFilterP rototype ( QO bj ect   *pa rent )
   : QObject(parentJ
    {
    )
    ，．    ’
  在本例中，我们不让脚本编写者实例化它们自己的PumpSpreadsheett对象，，而是提供一个全局
的单例对象spreadsheet供它们使用。为了允许脚本编写者能够，自己实例化PumpSpreadsheet，需要
注船一个pumpSpreadsheetConstructor.()函数，正如.PumpFilter所实现的。
在Gas Pump例子中，足可以提供脚本，访问应用程序窗口部件（例如对
PumpSpreadsheet的访
问）以及用户定制数据类(例如PumpFilter)。尽管在Gas Pump例子中不需要，有时使脚本访问
C++的函数也很有用。例如，下面是一个C++定义的简单函数，脚本也可以访问它：
QScriptValue square(QScriptContext *context, QScriptEngine *interpreter)
{
   double x = context->argument(O).toNumber();         . . ,  . .
 .  return QScriptValue(interpreter, x.* X).;   .    .      . .  .
}
打算给脚本使用的函数需要这样定义：
 QSc riptValue  myFunc ( QSc riptContext  *context , . QSc riptEngine  *.inte rp ret.e r)
  o
  u
  L
 u-
 -o
  o
  o
  *
  L
 u-
.. o
Q) E
ra o_
>
L   ._
o  A.
                 .i
                                 .
  .
  u
:Or
 o
  A
  *
  L
  rl
 u-
  o
  E
  =
  v
  :l
     . ra
  >
  L
  u
  cn
  L
  =
  L
r{L   A.
402    C++ GUI Qt 4编程（第二版）
    函数的参数可以使用QScriptContext：：argument()函数访问。返回值是QScriptValue，我们使用
QScriptEngine作为第一个参数创建它。
  接下来的例子更详细一些：
    ．    ，    ．
QScriptValu2 sum(QScriptContext *context, QScriptEngine *interpreter)
{
   QScriptValue unaryFunc;
  . int i = 0;
if  (con'te::ncarg：鼎t (0) .1sFunction (.》
     '   una ryFur           /:nte.xt->a rgument (.0 ) ;
while (i < context->argumentCount(》 {  .    '
  .  QScriptVatue qsArg" = context->argument(t) ;     ;
 . if (unaryFunc.isValid()} {  . i ,      ' "'   .
    . QScriptValueList qsArgList;      .
      qsArg = unaryFunc.caiicoScr/ptValiuec), qsArgList)
     }
       result += qsArg.toNumber( ) ;
}
 return  QSc riptValue (inte rp reter,   res ult ) ;
    sum()西数可以用露歌亨燕担用一一种简单的方法是用数字作为参数调用它。在这种情况
下，urwyFuⅡc是一个无~-的、QScnptValue，执行的操作是简单地把给定的数字相加并返回结果。复
杂一点的方式是用ECMAScript函数作为第一个参数调用它，然后是任意的数字参数。在这种情况
下，给定的函数针对每个数字调用一次，这些调用的结果相加并返回。我们在本章的第一节见过
使用ECMAScript编写的相同的函数。使用C++而不是ECMAScript骞现底层的功能有时可以带来
    -二+‘，    一  ，  ：，^  ．’    ’，    ，
很大的性能提并。‘
    在脚本调用.C．}千函数之前，必须使用newFunction()和setPropeIt()，使函数可以被解释器使用：
    f-    1
    , QSc riptValue  qsScluare=inte rp reter:newFunction( squa re):
    inte rp reter. gtob^10bject().setPr01perty(”square”，司sSquare);    ’    ，
QScriptValue qsSum = interpreter.rtewFunction(sum) ;
interp rete r. globblObj ect ( ) .setP ro pe rty( " s'um" ,   qsSum)
    找们已经把- square()和sum()设置为解释器的全局函数。现在，就可以在脚本中使用它们，如
    T    。
下所示：    ．‘    ．。’．  o
    ‘～一
    7interpreter.evdluate(”print(sum(r,.2,3,4.5,6I);?);
    interpreter,evaluate(“print(sum(square,1,2-3,4,5-6》;“);
    +  r    ．    ’  ’    ’
    这就是使用Qt,Scnpt模块脚本化Qt应用程序的介绍。该模块提供了，大量的文档，包括总体介
绍，以及相关类的详细描述，包括QScriptContext、
一读。
QScriptEngine.-QScriptValue和QScriptable，都值得读，，
第.23章  平台相关特性
    在这一章，将会看到一些Qt程序员可用的平台相关选项。我们先从如何访问一些本地应用
程序编程接口(API)开始，例如Windows上的Win32应用程序编程接口、Mac OS X上的Carbon，以及
Xll上的Ⅺib。然后，会转到对Act/veQt扩展的奥妙探寻之上，以说明如何在Qt/Windows应用程序
中使用AcUveX控件，以及如何创建一些被当成是ActiveX服务器的应用程序。在最后一节，将会
阐述如何让Qt应用程序与Xll下的会话管理器一起协同工作的原理。  一  一
    除了在这里介绍的这些特性之外，Trolltech还提供了多个与平台相关的q．Solut/ons，其中包括
用于简化Motif/Xt和MFC应用程序向Qt移植的Qt/Motif和QuMFc移植框架。(migraUon' framework)。
对于TcVTk应用程序，提供了一个类似的froglo'gic扩展，并且可以从fflaralvdalens，Datakonsult获取一
个Microsoft Windows资源转换器。更多详细的信息可以参考以下网页：
    ．    ’    ’  '7    ：
    ・http:/／www.tmutech.co■p捌ucts，叫addoll,sol砸ons／catalo∥4／    ’
    t    ，
    ・http：／／玳州，鱼蝴c．c确以q／    ．  √-：，‘。．_一。，，
    ．‘http j／,www.kdad.net／knut／
    ，一    ≈f  i：√，？
对于嵌入式开发，Tr出面h提供了Qt叩ia应用程序平台，会在第24章羹萎妻攀
    一些预计与平台相关的q功能已经可以采用与平台无关的方封    j例如，在Wi南ows、
U№【和Mac os x平台，都有一个Qt Sol砸on可以用来创建不同的服务（薪迸穆）≥j’？珐_
    ‘一    1‘一  ’  ‘．
23.1  连接本地的应用程序编程接口  …    ：  “
    Qt完善的API可以满足所有平台上的绝大多数需求，但是在某
些情况下，我们也许想使用底层的、与平台相关的API。在这：一节
中，将说明如何在Qt所支持的不同平台上使用平台夺地的API来
完成那些独特的任务。    ：    ’。
    对于每一个平台，QWidget都提供了一个可以返．回窗口‘ID或者
其句柄的winld()函数。QWidget还提供了一个称为find()的静态函
数，它可以根据一个特定的窗口ID返回该窗口的QWidget。我们可
以把这个ID传递给本地的AH来获得与平台相关的效果。例如，
下列代码使用winld()郓MacOS X(Carbon)上的函数把一个工具窗
    ”：    毒
口的标题栏移动到了该窗口的左侧（如图23.1所示）：、’
图23.1标题栏在侧边的
试：_j―Mac OS X真窗口
#ifdef Q_W5j'lAC
             ChangeWindowAtt ributes ( HIViewGetWindow( HIViewRef ( toolWin . winld ( 》 )
 kWindow5ideTitlebarAttribute,
                                                           kWindowhIoAtt ributes) ;
#endif
在Xll上，以下给出了应当如何修改一个窗口属性的代码片段：
    #ifdef O W5 Xl1
    Atom atom=XInternAtom(QXlllnfo::display(), "MY_PROPERTY", FaLse)
    long data=1；
C++ GUI Qt 4编程（第二版）
    XChangeProperty (QXlllnfo::display(),window->winld(),atom,  atom,
    32, PropModeReplace,
    reinterpret_cast<uchar *>(&data),1);
    #endif    ，
    这里把与平台相关的代码包围起来的# ifdef和#endif标记，将可以确保这个应用程序仍旧能
够在其他平台上编译通过。
    对于一个只用于Windows的应用程序来说，我们在这里给出了一个例子，说明了如何使用GDI
调用在一个Qt窗口部件上进行绘制：
    vo/d GdiControl::paintEvent(QPaintEvent+／+event+／)
    {    i'i―
    RECT rect;    、
    GetClientRect (winldj), &rect);
    HDC  hdc=GetDC(winld());’    一    7  7,
    ‘    ．
    FillRect( hdc,  &rect,  HBRUSH( COLOR_WINDOW+.1));
  ,    SetTe“‘Alig“(hd‘，TA_CENTER! TA_BASELINE);  ~    :
    TextOutW( hdc,width(    -ight()／2j text.utf16(),text. size(》;
    ReleaseDC (winld    hdc)    、    j
    ReleaseDC(winId(),hdc);
    )
    要使这段代码能够工作，还必须重新实现QPaintDevjce．．paintEngine()，以便可以返回一个null
指针，并且还需要在这个窗口部件的构造函数中设置Qt：：WA_PaintOpScreen属性。，，
    下面的例子，说明了在一个使用QPaintEngine的getDC()和releaseDC()函数的绘制事件处理器
中，如何组合使用QPainter和GDI调用：
    void 'MyWidget：．．paintEvent (QPaintEvent车／车event车／)    +    j
    ，{  ．    ．    ：    ．
#ifd
#end
)
ter
ect
nte
  4
Eng
his
 e'c t
pai
40
e()
    像这样混合使用QPainter和GDI调用，有时可能会导致一些不可预料的后果，在QPainter调用
出现在GDI调用之后的时候尤其如此，因为QPainter会对底层的绘制层(drawing layer)的状态做出
一些假设。、
    Qt会定义下列4个窗口系统符号中的一个：Q_ws_wnv、Q-WS-X11、Q_WS_MAC相Q-WS-QWS
( Qtopia)。在各个应用程序中使用它们之前，必须至少包含了一个Qt头文件。Qt还提供了许多预
处理器符号‘，以用来识别操作系统：    ’
Q_QS_AIX
Q_QS_BSD4
Q_QS_BSDI
Q_QS_CYGWIN
Q_QS_DGUX
Q_QS_DYNIX
Q_QS_FREEBSD
' Q-QS-I-WUX ..
. Q_QS_HURD
' Q_QS_IRIX
:  Q_QS_LINU. X
' Q_QS_LYNX
' Q_QS_MAC
' Q_QS_NETBSD
Q_QS_OPENBSD
 Q-QS-. QS2EMS
Q_QS_QSF'
Q_QS_QhJX6 .
Q_Qs_QNx . '
Q_QS_REUANT
Q-QS-SCO . .
' Q_QS_SOIARIS .
  Q_Q$_ULTIUX '
Q_QS_UNIXWARE
      Q-QS-W. IN32
Q_QS_WIN64
    我们可以假定，这些符号最多只定义了它们中的一个。为了方便，当检测到定义了Win32或
者Win64的时候，Qt还会定义Q_OS_WIN;并且在检测到任何一种基于UNIX的操作系统（包括
 -o
  4J      :
-o
 o   -f
  . t-J
 N  -
   t-J        IJ
 . l       -c:
         .N 07
  . N   - rl
' o  -- v
  t-J   u -C
    o
    .    IJ  N
  0   00 .-
  t-J    Ol-f，
-A-
  o   iiu
. 4J   -- cv
   cn    v - u,
  =    = -c: ro
  'r.   rl lJ V
 : -o '    Ol-0 r
  .' ru '     C  rl  O
.--   IJ   A
rl r .   m -o c
ro r z a -c:.+
O rlH  -m
  f Wl '1 2 p
o     n' u q L
r- m W -0 r {r)
第23章平台相关特性405
Linux和Mac ,OS X)时，Qt就会定义Q_os_uMx。在程序运行时，我们可以通过QSyslnfo：：Windows-
Version或者QSyslnfo：：MacintoshVersion来区分Windows（2000、ME等）或者Mac OS X(10.2、10.3等)
的不同版本。  ．+    -    一
    ．  ’    ”
    除了这些操作系统和窗口系统宏之外，Qt还有二系列用于编译器的宏。例如，如果编译器是
Microsoft Visual C++，那么就会定义宏Q-CC-MSVC。在避开编译器中的bug时，这些宏会显得非常
有用。
    几个与Qt的图形用户界面相关的类提供了一些与平台相关的函数；这些函数可以返回这个
底层对象的一些底层句柄。图23.2列出了这些函数。    一    、
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                            ┃
┣━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┫
┃ATSFontFormatRef  ┃QFont::handle()  . .   .                ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  CGImageRef      ┃QPixmap: :macCGHaridte( )             . ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  GWorldPtr       ┃QPixmap: :macQDAlphaHandle ( )          ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  GWo rldPt r     ┃QPixmap::macQDHandle()                  ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  RgnHandle       ┃QRegion::handle()  .                    ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HIViewRef       ┃QWidget: :winld ( )       .             ┃
┣━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━┫
┃                                                            ┃
┣━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┫
┃  HCURSOR         ┃  QCursor;:handle()    ，二iflr-        ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HDC             ┃QPaintEngine::g'etDC()     :            ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HDC             ┃QPrintEngine::getPrinterDC()   ;        ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HFONT           ┃QFont.::handle()  ,                     ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HPALETTE        ┃QColormap::hPal()                       ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HRGr<           ┃QRegi'on::handle()  .                   ┃
┣━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━┫
┃  HWND            ┃QWidget: :winld ( )                     ┃
┗━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━┛
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                                                                                      ┃
┣━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Cursor            ┃  QCu rso广：：handle()                                                                                         ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Font              ┃  OFrnt：．一ndle()  ?    、                                                                                    ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Picture    、  ． ┃. QPgxmap::xllPictureHandle().                                                                                  ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Picture           ┃. QWidget : :xllPictu reHand.le () ,, j              .                                                          ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                    ┃                                                 .:.      .                                                     ┃
┃  Pixmap            ┃                                                                                                                ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃QXlllnfo    ”      ┃QPixma'p::xlllnfo().;  . '..'                                                                                   ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃QXlllnfo  ’  ．    ┃QWidget; :xlllnf.o( );                                                                                          ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃Region    ‘        ┃一．q姆gij”：handle‘()                                                                                        ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Sc reen           ┃QCursor::xllScreen()  . .  :                                                                                    ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  SmcConn           ┃QSessionManager::handle()  .                                                                                    ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Window            ┃. QWidget::handle()           . .                                                                               ┃
┃                    ┃                                                                                                   .         :  ┃
┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃  Window            ┃ QWidget: :winld ( )                                                                                            ┃
┗━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
圈23.2 -些用于访问底层句柄的与平台相关的函数
    在Xll上，QPixmap:：xlllnfo()和QWidget:：xlllnfo()返回一个QXlllnfo对象，这个对象提供了
各式各样的指针或者句柄，比如display()、screen()、colormap()和visual()等。例如，我们可以使用
这些函数在一个QPixmap或者QWidget上创建一个Xll的图像上下文。
钺）6C++. GUI Qt 4.编程（第三版）。．  …
    经常需要与其他工具包或者库进行交互的许多Qt应用程序必须在将一些底层事件(在Xll
上是XEvent，在Windows上是MSG，在Mac OS X上是EventRef，在Qtopia上是QWSEvent)转换成
QEvent之前能够先访问这些底层事件。我们可以通过子类化QApplicat/on并且重新实现相应的与
平台相关的事件过滤器来完成这一工作，即xllEventFilter()、winEventFilter()、macEventFilter()和
qwsEventFilter()四者之一。作为替代方法，还可以通过重新实现xllEvent():winEvent()、macLvent()
和qwsEvent()中的一个函数来访问这些与平台相关的事件，而这些事件会被发送到某个给定的
QWidget中。对于处理Qt通常忽略的特定事件类型，例如像游戏手柄事件，这种做法会很有用。
    有关与平台相关的更多信息，包括在不同平台上如何配置Q应用程序等问题；可以参考网页
http://doc.  trolltech. com/4. 3/winsystem. html。
23.2在Windows土使用ActiveX
    Microsoft的Act/veX技术允许应用程序与其他应用程序或者库提供的用户接口组件一起工作。
它构建于Microsoft的COM基础上，为使用组件的应用程序定义了一套接口，并且为提供组件的应
    。‘
用程序和j    另外一套接口。  ：    ．。    ．
  叫研薹巽肇藜/~:c'oUWindows Desktop础石碗，提供了ActiveQt．框架，用以为．ActiveX和Qt提供
完美结合。。Acti姻蠢墙裔脊模块组成≯8 7  t‘一    。。_．    ，．  _：
    。・_．‘_    -    T
    Jf    ：
    ・QAxConta/ner模块允许我们使用COM对象并且可以在Qt应用程序中嵌入Act/veX控件。
    ・QAxServer模块允许我们导出使用Qt编写的自定义的COM对象和ActiveX控件。
    第一个例子将会在一个使用了(jAxCon/a/ner模块的Qt应用程序中‘嵌入一个Windows Media
 Player(如图23.3所示)。、‘这个’Qt应用程序在Windows Media 'Player的ActiveX控件上添加了一个
Open按钮、生个Play/Pause按钮。、一个Stop按钮以及一个滑动条。
  ．    、，i．图23,3.  Media Player虚用程序．
    ’，    ，_    ，    ．
’  这个应用程序主窗矗的类型磬PLdyerWindoW:一-。。  、j
    class PlayeNindow:public QWidget'?j j
、  {j  .:j    .j:  .  ,:  +、+,  ,,.  i    j..  ,.
    Q_OBJECT
-:    Q―ENUMS(ReadyStateConsta'ntsT:  j’‘j h.    .r    ’.  -  .
    public:
    ．  第23章平台相关特性407
    ．    ．
    ..................::....................................．一
enum PlayStateConstant.s { Stopped = 0, :Paused -. l, Playing -. 2 };
enum ReadyStateCohstants ;{ Uninitialized =' 0', Loading = 1, .; . '  '
 .  .. :{"' .        . ::   .:  Interactive -. 3, Complete = 4 }; ..  .
PlayerWindow()
protected:                   i .   . .  : .
   void timerEvent(QTimerEvent *event)
private  slots :
   void onPlayStateChange(int oldState, int newState); . .
     void onReadyStateChange(ReadyStateConstantt       y.State.) ;
   void onPositionChangei:double otdP6s, do:b{:i';:';;yS't)';
   void sliderValueChanged(int newValue); .    . .  :
       void  openFile( ) ;
private:       .:
   QAxWidget *wmp,'
QToolButton *openButton;
QToolButton *playPauseButton;
QToolButton *stopButton;
QSlider *-seekSlider; .  .  . " '.  .. _
QString fileFilters;             . -' '
int updateTimer;    .               ' . ':1  :
    }；
    PlayerWindow
的，用来告诉moc
private:-墼，我们声
  ．Playe rWindow:
    {
    wmp=new QAxWidget;
    wmp->setCont rol(“{22D6F312-BOF6-11D0-9;4AB-0080C74C7 E95}?)；：生！    二7．．/ /÷：i÷．j．  ：：
    在构造函数中，我们从创建一介QAxWidget对象封装jWindoWs．Rledia Player的。AetiveX控件开
始。QAxContainer模块由三个类组成：QAxObjeet封装一个COM对象，QAxWjdget封装一企ActiveX
控件，而QAxBase则为QAxObject和一QAxWidget.謇粤了COM}~<J孩心功能。这三个类之间的关系如
图23.4所示。    i’：．”“？    ，。．0，I’‘
箩{攀；麓磐≤羹誊
    ・B鑫一≮尊：裁。e．
。．，，尘竖
  QAxO\bji:ect,  号蒸量e．
Q毒菇薹i，一√。。÷g
    1：图23__4
    ，…-。  ；。
我们使用WindoWs Media Player。苍4
，对QAxWidget调用setControl()。
这样将会创建一个所需组件的实例。从那时起，这个ActiVeX控件的所有属性、事件和方法都可以
通过QAxWidget对象而作为Qt的属性、信号和槽来加以使用。：
    如图23：5中总结的那样，COM数据类型可以自动转摸蜀相应的Qt类型。例如，一个类型为
VARIAl-]T_BOOL的输人参数可以转换成一个bool‘变量j并且一个类型为VARIANT_ BOOL的输出参
数也可以转换成一个bool&变量。如果结果类型是了介Qt．类≮，L如像-QString、QDateTime等），那么
输入参数的类型将会是一个常量引用（例如，const QString&h．~．    ，
    要得到带Qt数据类型的QAxObject或者QAxWidget中可用的属性、信号和槽列表，可以调用QAx-
Base:：generateDocumentation()．或者在命令行中使用Qt的dumpdoc工具，该工具位手Qt的tools＼
activeqt \dumpdcc目录中。
。蠕乎
}嚏哆…
宏蜒  ．
一她胁  _
豢一一
器
408    C++ GUI Qt 4编程（第二版）
┏━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃蒸獭熬骥瓣滋溺溯黼鬻          ┃濑鬻辫鬻漱糕瓣鬟          ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃VARIA"T BOOL                  ┃  bool                    ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃char,short,intilong           ┃  int                     ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃unsigned char,unsigned short, ┃  uint                    ┃
┃unsigned int, unsigned long   ┃                          ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃float, double                 ┃  double                  ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  CY                          ┃qlonglong, qulonglong     ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  BSTR                        ┃  ostring                 ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  DATE                        ┃QOateTime, QDate,QTime .  ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  OLE COLOR                   ┃  QColo r                 ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃SAFEARRAY {VARIANT)           ┃QList<QVariant>           ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃SAFEARRAY (BSTR)              ┃QStringList               ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃SAFEARRAY(BYTE)               ┃  QByteArray              ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  VARIANT                     ┃  QVa riant               ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  IFontOisp+                  ┃  QFont                   ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃IPictureDisp.牛 .             ┃  QPixmap                 ┃
┣━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃  用户定义类型                ┃QRect, QSize,QPoint       ┃
┗━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━┛
图23.5  COM类型和Qt类型之间的关系
我们继续查看’pjayerWindow的构造函 ~r :'
wmp->set Prope rtjt -9F/owcont rois,l ;   ;false ) ;
wmp->s etSizePolicy (QSizePolicy: : Expanding ,   QSizePolicy: : Expanding )
connect (wmp,  SIGNAL "PlayStateChange (int ,   int》 ,
                this,  SLOT(onPlayStateChange (int,  int》 ) ;
connect (wmp,  SIGNAL ( ReadyStateChange ( ReadyStateConstants 》 ,
                    this ,   SLOT( onReadyStateChange ( ReadyStateConstants 》 ) ;
connect (wmp,  SIGNAL ( PositionChange (double,  double》 ,
  .         this,  SLOT(onPositionChange(double,  double》 ) ;       '  .
    茌调用QAxWidget：：setControl()之后，通过调用QObject：：setProperty’()，可以把这个Windows
Media Player的．ShowControls属性设置为false，因为我们自己提供了用来操作这个组件的按钮。函
数QObject:：setPropetty()既可以用于COM属性又可以用于普通的Qt属性。它的第二个参数酌类
型是QVan咖。    ．
    接下来调用setSizePolicy(.)，让这个ActiveX控件占有布局中所有可用的空间，并且把COM组
件中的三个ActiveX事件连接到三个槽中。
stopButton = new QToolButton;
stopButton->setText ( t r( "&St.op" 》 ;
stopButton=>setEnabled ( false) ;     .
connect (stopButton,  SIGNAL{ clicked ( 》 :  wmp,  SLOT( Stop ( 》 ).;
    除了把一些Qt信号和这个COM对象提供的槽[Play()、Pause()和Stop()]连接起来以外，Player-    ，，，
Window构造函数中的其余部分都与我们在平常模式下的情况一样。由于这些按钮的功能实现都
有相似性，所以这里只给出了Stop按钮的实现代码j
    让我们离开这个构造函数，来看一看t/merEvent()函数：
void PlayerWindow::timerEvent(QTimerEvent *event)
{.
   if (event->timerld() == updateTimer) {
                    double  cu rPos  =  wmp->prope rty ( "CurrentPosition " ) , toDo'uble ( )
      onPositionChange(-l, curPos);       .
   } else {
，+’
第23章平台相关特性
    当正在播放一个多媒体片断的时候，每隔一定时间就会调用timerEvent()函数一次。我们使用
它推进滑动条的滑块。通过调用ActiveX控件上的property()获得CurrentPosition属性的QVaraJlt类
型的值，然后调用toDouble()把它转换成double值，就可fX实现滑块的推进。然后，我们调用onPo-
sitionChange()来执行更新。
    我们将不会再去查看其余的代码了，因为它们中的绝大多数都不直接和ActiveX相关，并且里
面也没有任何以前没有涉及过的东西。在本书的例子中包含了所有这些代码。
    在．pro文件中，需要使用下面这一项来连接这个QAxConta/n'er模块：
    _    ‘、    ：．
    CONFIG+=qaxcontainef
    在处理多个COM对象时，经常需要能够直接调用一个COM方法（而不是把它连接到一个Qt
信号上）。要做到这一点，最容易的方法就是使用这个方法的名字和签名作为调用QAxBase:：dy-
namicCaⅡ()的第一个形式参数，并且把这个方法的实际参数作为额外参数。例如：
    wmp->dynamicCall(“TitlePlay(uint)“，6);
    这个dynamicCaⅡ()函数最多可以带8个Qvarianf类型的参数；并且它可以返回一个QV撕ant。
如果需要使用这种方法传递IDispatch*或者IUnkown*，就可以把这个组件封装到-个QAxObject
中，并且对它调用asVariant()，以将其转换成一个QVaIiant。如果需要调用能够返回IDispatch*或
者IUnkown*的COM方法，或者如果需要访问一个具有上述类型之-的teiM属性，那么就可以使
    ：    。
用queySubObject()来替代：
    如果我们希望调用一些函数，而这些函数的参数列表中还有一些不支持的数据类型，那么就
可以使用QAxBase：：querylnterface()来取得COM的接口并且直接调用这个函数：就像往常使用
COM -样，在我们已经完成了对COM接口的使用时，必须调用Release()。如果需要经常调用这样
的函数，那么可以子类化QAxObject或者QAxWidget，并且再提供一些封装这些COM接口调用的成
员函数即可。需要注意的是，这些QAxObject和QAxWidget的子类不能定义它们自己的属性、信号
    ．．  ．  ；．。i  ：
或者槽。    +
    现在查看一下QAxServer模块。这个模块使我们能够把标准的Qt程序变成ActiveX服务器。
这个服务器既可以是一个共享库，也可以是一个独立运行的应用程序。通常把构建为共享库的服
务器称为进程内服务器(in-process server)，而把可以独立运行的应用程序称为进程外服务器(out-
of-process server)。
    第一个QAxServer例子就是一个进程内服务器，它提供一个可以显示左右弹跳的球的窗口部
件。我们还将看到如何把这样的窗口部件嵌入到Intemet Explorer浏览器中。  ；    、    …-
    这里给出的是AxBouncer窗口部件的类定义的开头部分：
    class AxBouncer:public QWidget, public QAxBindable
    {
    Q_OBJECT
    Q_ENUMS (SpeedValue)
    Q―PROPERTY(QColor'color READ color WRITE setColor)
    Q―PROPERTY(SpeedValue speed READ speed WRITE .setSpeed)、.t    一    ：    ’
    Q―PROPERTY(int radius READ radius WRITE setRadius)
    Q一PROPERTY(bool running READ isRunning)
4J
>
o
4J
>
LU
L
o
 r+    .
4J
 ..    .
4J
o
 rH
  rH
    L
 '  0
   'o
   u-
   4J
  'r
 . -  f
--  0
   o
C  r .-
o   o --
cn   v 4J
o au
cn   .r rv
     0 4J
-  u- C
4J  . 4J o
u rU
o  =L
-o  f . o
o Or
-o  o o
=   4J U-
y  G O
L  ::
0 ,-
=   . 4J
o  -o
o cn o
r 4J _O
4J u =
= m cn
 0 4J y .
 CL
II o v
u=
 C 4J . q
r+ = I
cn f o
v o r+
cn o cn
 }   - cn
uu
00
-o -o
oo
aa
410    C++、GUIQt4编程（第二版）
    如图23.6所示的AxBouncer同时继承了QWidget和QAxBindable。类QAxBindable在这个窗口
    -    ．    ，    ，．
部件和AcUveX客户端之间提供了一个接口。任何QWidget都可以当作一个"ActjveX撞件导出，但
是通过子类化QAxBindable，当一个属性的值发生变化，就可以通知该客户端，并且可以实现COM
接口来补充那些已经由QAxServer实现过的接口。    一
图23.6  Intemet Explorer中的AxBouncer窗口部件
    当包括一个源于QObject类的多重继承的时候，就必须总是把这个起源于QObject的类放在第
一位，以便moc可以快速识别它。
  我们声塌亨豆个读写属牲和毛个只读属性。？Q―ENI脚S（，宏是必需的j密用来告诉．noc、这个
SpeedValue类型是#拿枚举类型。在这个类的public段中，声明了这个枚举类型：
                                                                                                  ,:    .
:：？, I"' e{w, Jr,, Sp,~edValue.争Slow, N.ormal.,. Fast
    AxBounce r.(QWidget f{pa rerittf.0)；。    一
    ’．
’一  ’  "void s.etSpeed(Speed.Valu:e  newSpeed);
4  :SpeedValue speed() const{return ballSpeed;}    ’‘  ‘
‘.  void setRadius(int newRadius);    r“
    int radius()const{return baURadius;)
  .    Void setColor(const QColor＆newColor);
    qColor color()const{return ballColor:}    .    .
    bool isRunning()const{return myTimerId+!=0;}+    ‘
    QSize sizeHint()const;
    QAxAgg regated车c reateAgg regate();
  1  .publi七．slot§.:.‘.！一    ’’t:-.,’},  ‘:.’    1-  ’  :’    1.  .    .
    ~    v_o王d'start()；    、    ：
    ’7'  void stop()；    ．+    ：  ？    ¨    ．
  .}‘.    ,  j  ,、,,.^.0.    ..    、    j    .  ..:  、    ;    .
    SignalS：
    .  IvOld bouncing();  :  _?+  、.’、    .    ,’  ．
    ，    ．．-、“    ．
  AxBouncer构造函数是一个可用于窗口部件的标准构造函数，它有二个p病nt叁数。将用于导
出组件的Q∞姒CTloRY DE枷()宏希望带～个存这样签名的构造函数。1
    c呦teAg辨狰te()函数是从QAxBind烈e中重新实现的。我们将在稍后解释它。  ，
‘、．_{蠢《纂鬻赫遣群篓豢蓥甏嘲磐藿溪嚣蒜臻鬻8镬甾a塌灞瓣蹬
    QColor  ballColor；    。
    SpeedValue ballSpeed;    ,,
    int ballRadius;
    int myTimerld;
    int X；    ．
    int delta;
    }；
在这个类的protected和private段中，应当会和标准：g疸甲部件中的内容一致。
    AxBouncer::AxBouncer (QWidget   *pa rent)
    ：QWidget(parent)
    {
    ballColor=Qt::blue;
    delta=2；    ．  J p  0
    }    ~
    气  _  ，‘
这个AxBouncer构造函数初始化了这个类的一些私有变量。一    i，
    void  AxBouncer::setColor( const  QColor &newColor)    .i
    ’㈠
    {    。    一    ，’。
    if(newColor I=ballColor＆＆requestP ropertyChange(“color")){
    ballColor=newColor;’    ：。~：：．    ：’    ，：．
    update();
    propertyChanged("color"J;    .、./    …
    }    ：f  'V一，    _    ‘_’f 1  2’  ’i
    …．
    }    。  ‘’z二．．j?‘；，《
这个setColo，()函数设置了color属性的值。它调用update()宋重新绘斜这介窗口部件秀：  ．。
    与众不同，的部分是requestPropertyChange()调用和propertyChanged()调用。，这两个函数是从
QAxBindable中继承而来的，并且无论何时只要我们一改变某个属性，它们就应当立刻碍到调用。
reque。d)ropertyChange()函数会要求客户端允许改变一个属性值，并且如果客户端允许改变的话，它
就会返回true。而propertyChanged()函数会通知客户端：这个属性已经改变子。‘’  。：_
    setSpeed()和setRadius()这两个设置器也帮遵循这__旗式，j并且在start(')和stop(:)槽中也是这
样的，因为它们会改变这个running属性的值。    ’．’一r．¨7。．：¨一。“：：
    ・    一：  ：t
    还剩下一个有趣的AxBoLulcer成员函数：    ．  ㈠一    ，、：，．：。
    QAxAgg regated  *AxBouncer::c reateAgg regate()  j    二    j{’1 j    ,    +7‘
    。    j    、；  -    ，
    {
    return new ObjectSafetylmpl;    ?
    }    一．．．-≯  ~一一“、  √。，    ．
    createAggregate()函数足从QAxBindable中重新实现的。它允许我们实现QAxSeⅣer模块牛还没
有实现的COM接口或者绕开QAxServer默认的那些COM接口。这里，我们使用它提供IObjectSafety
接口，Intemet  Explorer会使用它访问一个组件的安全选项。这就是去除Intemet Explorer_,rfi声明狼
藉的“Object not safe for scripting”（这个对象对于脚本是不安全的）错误消息的一个标准窍门。
    以下是这个类的定义，其中实现了IObjectSafety.接口：。…i、÷j    。？
    class ObjectSafetylmpli pL/bliC QA4Aggr!ega7ed,..pubU clObjectSafety,-，．~．    ．
    {
    public:    ‘,3    _1:.:.:、  √、誓：7.j,.！、  +1._’一；‘  I,.i..r J
                         ..         .
           .~:.
                                                                                                                                                              .
                                           '!
                 '         :,
         .         r' .
            .     .'       .
J叶   .
vl.-
章       .- .
           '     --
          i- i-    (
           c C   .  tn
      》   c
                . LU LU        o
         i- L _  U
                           c , Q)            v
            -l E      tn
               o- l-    l
            . i- i-      E
      "cC   c
                   LU iU         ra
                i- iL        >
       C'V   L
         . . rl E      V
           : ra rl      i_
          .. a i-      C
          i- rl rl      i_
           'u o 'o    i-  C
       v 》  ra H
    t   .      >
          o        ' rl
   L   L
  a..a
/~
m    .
E .~
L Ln
0 1 .-
Z  O
       lJ
o = d
V rlH
  O L ._
a m vo
U1 d E rN
l   - II
aaEX
  412    C++.GUI Qt 4编程（第二版）
long querylnterface(const QUuid &iid, \toid **iface);
QAXAGG_IUNKNOWN
 .  HRESULT WINAPI Gi     rfaceSafetyOptions(REFIID riid,
                       DWORDI-DIl;lt;e~o: ;a:edOptions,  DWt~Dt R:~tyEnabl
    HRESULT WINAPI'g"    rface59fetyOptions(REFIID 7:}.c7dOptions);
         DWORD pdwSupportedOptions, DWORD pdwEnabledOptions);
};
    ObjectSafetylmpl类既继承了QAxAggregated又继承了IObjectSafety。QAxAggregated类是实现其
他附加COM接口的一个抽象基类。由QAxAggregated扩展的COM对象是可以通过controllingUnk-
nown()访问的。COM对象是在后台中由这个QAxServer模块创建的。
    QAXAGG_IUNKNOWN宏提供了Querlnterface()、AddRef()和Release()昀标准实现。这些实现
只是对正在控制的COM对象简单地调用一些相同的函数。
long ObjectSafetylmpl::querylnterface(const QUuid &iid, \toid **iface)
{
   *iface = 0;
   if (iid == IID_IObjectSafety) {
      */iface = static_cast<lObjectSafety幸>(this);
   } else {     '
      return E_NOINTERFACE:;
      }
   AddRefl-f; '   '  .
     return S_OK}k．、 . . .
}
    querylnterface()函数在QAxAggregated中只是一个纯虚函数。正在控制的COM对象可以调用
它允许对QAxAggregated子类提供的接口进行访问。我们必须为没有实现的接口和IUnkrown返回
E_NOINIERFACE。
HRESULT WINAPI ObjectSafetyImpl::GetInterfaceSafetyOptions(  .
        REFIID /* riid */, DWORD *pdwSupportedOptions, '      .
       DWORD *pdwEnabledOptions)                  :  .   "
{
   *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA                .     i  '
                        'l INTERFACESAFE FOR UNTRUSTED_CALLER; ' .                  '    ，
    *pdwEnabledOptions = *pdwSupportedOptions;    .  .                                    :' 1
   return S_OK;                                   .   ,
                                                                                                                                                                             .          .,
HRESULT WINAPI  ObjectSafetylmpl:':'5etInter.faceSafetyOptions (
       ' REFIID /* riid */, DWORD /* pdwSupportedOptions' */,
  .     DWORD /* pdwEnabledOptions */)
{
   return S_OK;
}
    GetInterfaceSafetyOptions()和SedntedaceSafetyOptions()函数都是在IObjectSafety中声明的。我们
实现它们是要告诉世人，我们的对象对于脚本是安全的。
现在看一下main．cpp文件：
#include <QAxFactory>
#include "axbouncer.h"  4
QAXFACTORY_DEFAULT(AxBouncer,     .
                                                                  " t5e2461a a -a3e8-4f7a-8 b04-307459a4c08 c}
                                               " {533afllf-4899-43de-8b7f-2ddf588d1015 }
                                                                  " t772 c14a5-a840-4023-b79d -19 549eceOcd9 }
                                               " tdbcele56-70dd-4f74-85e0-95c65d86254dJ
                                               " t3f3db5e0-78ff-4e35-8a5d-3d3ba6c83e09}
    第23章平台相关特性    413
    QAXFACTORY_DEFAULT()宏可以导出ActiveX控件。我们可以把它用作仅仅导出一个控件
的ActiveX服务器。在本节的下一个例子中，将会给出如何使用它来导出许多ActiveX控件的
示例。  ．
    QAXFACTORY_DEFAULT()宏的第一个参数是要导出的Qt类的名字。它也是下面将要导出的
控件的名字。其他5个参数分别是类的ID、接口ID、事件接口ID、类型库ID以及应用程序ID。我
们可以使用一些像gtudgen或者uu/dgen这样的标准工具来生成这些标识符。因为服务器是一个
库，所以不需要ma/n()函数。
    以下是这个进程内的ActiveX、服务器的。pro文件：
    TEMPLATE    =lib
    CONFIG    +=dll qaxserver    ;
    ・  HEADER5    =axbou_ocer.h＼    一    ，    、
SOURCES
RC_FILE
DEF FILE
objectsafetyimpl.h
= axbouncer,cpp \
  main.cpp \
objectsafetyimpl.cpp
= qaxserver.rc
= qaxserver.def     .
    在．pro文件中提到的qaxseⅣer. rc和qaxsewer. def这两个文件都是标准文件，可以从Qt的。rc\
activeqt\control目录中把它们复制出来。    ．．
    由qmake生成的makeffle或者Visual C++项目文件包含了把服务器注册到Windows注册表中
的规则。要在最终用户的机器上注册服务器，可以使用regs、Tr32工具，可以在所肴版本的Window。
系统下使用该工具。
然后，我们可以在一个HTML页面中使用<object>标签来包含这个Bounce．组件：
<object id="AxBouncer"                                                         .   . '
                        classid=" clsid :5e2461aa-a3e8-4f7a-8 b04-307459a4c08c ">  . '
<b>The Act'iveX control is not available. Make SUfe you have built and ' .
registered the component server.<／b>       : '.
</object>                                   '  .       .   .
我们可以创建调用这些槽的各个按钮：
<input type="button" value="Start" onClick-"AxBouncer,staftl)J->
<input. type=" button " .value="Stop "   onClic k= " AxBounce r. stop ( ) ">.  .
    酉以像使用其他任意的ActiveX控件二样来使用JavaScript或者VBScript，卣它们操作这个窗口
部件。’请参考本书例子中的demo.l．tml文件，它是作为使用该ActiveX服务器的一个基本页面。
    最后的例子是一个可以脚本化的Address Book应用程序。这个应用程序可以作为一个标准的
QUWindows应用程序，或者也可以作为一个进程外的ActiveX服务器。后者可能允许我们脚本化
这个应用程序，比方说使用Visual Basic。
class AddressBook : public QMainWindow .
Q_OBJECT
    Q_PROPERTY(jnt count READ count)        ' .
 .  Q_CLASSINFO("ClassID", "{588141ef-llOd-4beb-95ab~ee6a478b576dj").-' ' .
       Q_CLASSINFO ( "InterfaceID" ,  "t718780ec-b30c-4d88-83b3-79b3d9e78502} " )
          Q_CLASSINFO ( "ToSupe rClass " ;  "Add ressBook" )
   int count() const
public slots:
         II
   J
  C
  L
 a-
  *
   J
  o
  o
  -t o
 ac
 om
   cn cn
  Q) L
   L -O
 . o -o
u -o <
o
=
a-
414    C++ GUI Qt 4编程（第二版）
ABItem *createEntry(const QStrjng &contact) ;
ABItem *findEntry(const QString &contactl const;
ABItem *entryAt(int indexJ const;
private slots:.. ,
   void addEnt'r,y(); '
   void edit'Entry(); .
      void deleteEntry() ;
private:
 . void createActions();
       void  createMenus ( ) ;
   QTreeWidget *treeWidget;
   QMenu *fileMenu;
   QMenu *editMenu;    .
   QAction *exitAction;
   QAction *addEntryAction;
   QAction *editEntryAction;
 ': QAction ,*deleteEntryAction;
};   .
AddressBook窗口部件是这个应用程序的主窗口。
它所提供的属性和槽可用于编写脚本语言。
Q_CLASSINFO()宏用于确定这个类和与这个类相关的接口的ID。通过使用像guid或者uLud达样
的工具，这些都可以产生出来。一    -：  、+    ．    ．，
    在前面的例子中，当使用QAXFACTORY_DEFAULT()宏导出QAxBouncer类的时候，我们给定了类
和接口的ID。在这个例子中，我们希望可以导出多个类，因而不能再使用QAXFAdORY_DEFAULT()
宏。对我们来讲，还有两个选择可以使用；，．    …，    ’    一
    ．q×．？  i  二．  -    ．：    ’，  ：    ．1    ．    、
    o可以子类化QAxFactory，重新实现它的虚函数以提供我们想要导出的类型的相关信息，并且
    可以使用QAXFAdtORY_EXPORT()宏来注册其工厂方法。
    f    、-    ，t    _
  o可以使用宏QAXFACTORY_ BEGIN()、QAXFACTORY=END()、QAXCIASS()和QAXI'YPE()来
    声明和注册工厂。这一方法需要我们使用Q_CLASSINFO()来指明类和接口的ID。
    回到AddressBook类的定义：Q_CLASSINF0()的第三次出现可能有些不同寻常。默认情况下，
Ac:tiveX-控件不仅会暴露它们自己的属性、信号和连接到客户端的槽，而且还会暴露它们向上直到
QWidget的父对象类。ToSupeI=Class属性可以指定我们想耍在继承树中暴露的最高的父对象类j这
里，，指定该组件(-AddressBo//k)的类名字来作为要导出的最高的父对象类；也就是说，在AddressBook
的父对象类t中继承的那些属性j信号以及槽将不会被导出。
class ABItem : public QObject, public QTreeWidgetltem  : ' . :
f
  Q_OBJECT    .
   Q_PROPERTY(QString contact READ contact WRITE setContact)         .
   Q_PROPERTY(QString address READ address WRITE setAddress)        .
   Q_PROPERTY(QString phoneNumber READ phoneNumber
           WRITE setPhoneNumber)
   Q_CLASSINFO("ClassID", "{bc82730e-5f39-4e5c-96be-461c2cdOd282}")  '
           o_c LASSIN FO ( "InterfaceID" ,   " {c8bc1656-870e-48a9-9937-fbelceffBb2e} " )
 . Q_CLASSINFO("ToSuperClass", "ABItem")
public:
   ABItem(QTreeWidget *treeWidget)
void setContact(const QString &contact);
QString contact() const { return text(0), }.:
Void setAddress(const Qstring &address);   .
QString address() const { return text(l); }
void setPhoneh!umber(const QString &number);
QString:phoneNumber() const {,,retur.n.-text:(2); }  { -
    、第23章平台相关特性415
public slots:
   void remove();
};      .
    ABItem类表示了地址簿中的一项。它从QTreeWidgedtem中派生而来，所以它可以显示在一个
QTreeWidget中。同时，它也还从QObject中派生出来，因而可以导出为一个COM对象。-
    int main（int a广gc，cha广木a广gv【】）    ’
    {QApplication app(argc,  argv);    ’。
    if'lIQAxFactory::isserver()){    一
    AddressBook addressBook;    ,  .,,.
    addressBook.show();    ’    ‘    i
    、    return  app.exec():    ’    ‘    ,  j
    ’    ，．    ．
    广eturn app.exec();.,    ..  .    +  …
    '    ．，    ’    -
    在nla/n()中，我们检查应用程序是将独立运行还是将用作服务器。-activex命令行选项可婴由
QApplication识别，并且它可以让这个应用程序运行为服务器。如果该应用程序不是作为运行服务
器，那么靓可以像在任何-个单独运行的Qt应用程序币所做的那样来创建它的主窗口部件并且
一-r.d-．    ‘    ．  ‘一    ‘‘：7．‘．：j’  ，t  ，一，一：，’，，，：  ‘
曰不。已。    ”    ，，．
    除了-activex选项以外，ActiveX服务器还可以理解下面这些命令行连璎：’：“  ‘0’
    ．-regsenrer会把莓食服霸器t册到季缚荽册毒中。一！、。_j：：y．¨，j/-。i．摹j j．．！  ；．，
    ．-unregsenrer会从系统注册表中取消这仑服务器的蠲猡巴：：．I≮．{一帮，．．．、：―：，。，．
    ．-dumpidl jile．涩会把这个服务器的IDL输出到_个给定的文件中。
    当应甬程序作为服务器而运行时，必须把AddressBook和ABItem两仑类作j COM挚件导出：
    QAX,FACTORY_BEGIN（”{2b2b6f3e-86cf-4c49-9df5:180483b47f"17b}",.  -：：  7  .i；、i.0  ；一。
    ‘    一    ”{8e827b25一l48b一4307一ba7d_23f275244818'”）    4’  一  ’  ．‘’  ’-  ‘+‘  ’、‘
    QAXCLASS(AddressBook)  ’、..    ’、,    ‘.,    ,’  .  ;_  .’  一一．  ÷,.    .’:.，毒？:.4 V、i~j
    0时下rPE(ABItem)    ’
    QAxFAcTo吖一5“C!()    。    、．一．  ～  ，’  j  、-’；i．‘i．乙，。！，‘  ’_’：‘】．：
．上面的这些宏导出一个创建‘coM对象的工厂。由于我们想导出两种类型鲍coM对象i所以
不能像前一个例子中．所做的那样只是简单地使用Q∞@A(∞印LDEFA聩Z()。：！√。≯．弧．_’，、
    O∞【FA．CIDRY。BEG矾()的第一个参数是类型库田；；第，三=参：数是应用程序；的峨；在
OAj(FAcrIDRl__BEG矾()和叫阅队crIDRLpp()之间，我们可以指定有可r以初始化的誉掣及所
有我们想作为COM对象而访问的数据类型。。：  ，一    ，！  ．  。一一．i  ：i一～…
    以下是用于进程外的Activex服务器的．p∞文件：    ．。o j
TEMPLATE
CONFIG
HEADERS
SOURCES
FORMS
RC FILE
= app
   addressbook.h \
 addressbook.cpp\          'I' .' .'    .-  f一'? ..-
   editdialog.cpp \
   main.cpp         .                                : . . .
 = editdialog.ui
    在，pro文件中提到的qaxserver. rc文件是一个标准文件，可以从Qt的src\activeqt\control目录中
    ‘‘    一
把它复制出来。    j。．一．．，．    。    。
    还可以在示例翟序的vb目录里面查找一个使用Address Book服务器的Visual Basic项目。
416
C++ GUI Qt 4编程（第二版）
    到此为止，我们就完成了ActiveQt框架的回顾。Qt的发行版中还包含了一些其他的例子，并
且文档中也包含了有关如何构建QAxContainer和QAxSeⅣer的信息，以及如何解决常见的协同工作
问题的一些信息。
23.3处理X11会话管理
    当从Xll注销的时候，一些窗口管理器会询问我们是否希望保存会话。如果回答“是”，那么
在下一次登录进来时，这些应用程序就会自动恢复到重新运行的状态，而且它们会具有与我们注
销时一样的屏幕位置。在理想情况下，它们的状态也可以保持与我们在注销时的状态一样。这方
面的一个例子如图23.7所示。
图23.7  KDE上的注销
    用于注意保存和恢复会话的与Xll相关的组件称为会话管理器(session manager)。为了让一
个Qt／X11应用程序可以感知到这个会话管理器，必须重新实现QApplication：：saveState()，并且把
应用程序的状态保存在那里。    ．
    Microsoft Windows和一些UNIX操作系统都提供了一种不同的机制，称为休眠(hibemation)。当
用户让计算机进入休眠的时候，操作系统只是简单地把计算机的内存有放到磁盘中，并且在唤醒
计算机的时候再重新加载它。但应用程序在系统休眠的时候不需要做任何事情，或者说它甚至根
本就没有感觉到发生了系统休眠。
    当用户启动一个关闭( shutdown)操作的时候，通过重新实现QApplicat/on：：commitData()，就可以恰
好在关闭发生之前得到控制权。这样就可以允许用户保存任何未保存的数据，并且在需要的情况下
还可以和用户进行交互。会话管理中的这一部分内容在Xll和Windows上都是支持的。
    我们将通过仔细查看一个如图23.8所示的可以感知会话的Tic-Tac-Toe应用程序的代码来研
究会话管理。首先，查看一下main()函数的代码：
int'main(int argc, char *argv[J)
{    +．
  Application app(argc, argv);
  TicTacToe toe;
  toe.setObjectName("toe");
  app.setTicTacToe(&toe);
  toe,show()；
  return app.exec()；    ‘
’
我们创建一个Application对象。这个Application类从QApplication类派生而来。同时，我们重
新实现了commitData()相saveState(、)来支持会话管理。
第23章平台相关特性
417
    接下来，我们创建一个TicTacToe窗口部件，让这个Application对象可以感知它，并且显示它。
我们曾经把这个TicTacToe窗口部件称为“toe”。如果希望会话管理器可以恢复这个窗口的大小和
位置，就必须给顶级窗口部件指定一个唯一的名字。
以下是Appbcat/on类的定义：
图23.8 Tic-Tac-Toe应用程序
class Application : public QApplication
{
Q_OBJECT
public:
   Application(int &argc, char *argv[l)
void setTicTacToe(TicTacToe *toe) ;
void saveState(QSessionManager &sessionManager) ;
void  commitData (QSessionManager &sessionManager)
p rivate:
   TicTacToe *-ticTacToe
Applicat/on类保存一个指向TicTacToe窗口部件的私有指针变量。
void  Application: :saveState (QSessionManage r &sessionManage r)
{
   QString fileName = ticTacToe->saveState();
QStringList discardCommand;
discardCommand<< " rm'       fileName;
 sessionManager. set Dis ca rdCommand ( disca rdCommand) ;
    茌Xll上，当会话管理器希望这个应用程序保存它自己的状态时，就会调用saveS tate()函数。
这个函数也可用于其他平台，但是它从来没有被调用过。QSessionManager参数允许我们和会话管
理器进行通信。
    我们从要求TicTacToe窗口部件把它的状态保存到一个文件开始。然后，设置会话管理器的
放弃命令( discard command)。放弃命令是这个会话管理器必须执行的，它用于删除关于当前状态
的任何存储信息。对于这个例子，我们把它设置为：
rm sessionfi Le
这里的sessionfz.le就是含有会话中要保存状态的文件名，而皿是用于删除文件的标准UNLX命令。
  会话管理器还有一个重新启动命令(restart，command)。它是会话管理器必须执行的，用来重新
启动应用程序。默认情况T，Qt提供下面这样的重新启动命令：
418    C+十GUI Qt 4编程<第二版）
    appname -session id_key
    _'，，：：
    第一部分的appname来自于agv[0]。葩部分就是由会话管理器提供的会Ta ID，需要确保它
是唯一的，以用于区分不同的应用程序以及相同的应用程序的不同运行实例。key部分会在唯一
标识后添加一个用于表明状态保存时候的时间。由于各种各样的原因，会话管理器可能会在同一
会话期间多次调用saveState()，并且必须能够区分这些不同的状态。
    因为现存会话管理器的一些局限性，如果想让应用程序能够正确地重新启动，就必须确保应
用程序的路径存在于PATH环境变量中。特别是在想亲自试验一下Tic-Tac-Toe实例时，你就必须
把它安装到(比方说)/usr/local/bin目录下，并且以tictactOe的方式调用它。
    对于那些简单的应用程序，包括Tic-Tac-Toe，我们可以把保存状态作为重新启动命令的一个
单独附加的命令行。例如：
    ．  '
    tictactoe -state OX-XO-X-O
    l ij  。
    这样应当就可以不必再把数据保存到一个文件中，并且不需要再提供一条删除这个文件的放
    ，    4    ，’    ‘』    J  ’    ’    1
弃命令。
void  AppLication : : commitData (QSessionManage r &sessionManager)
{
 if(ticTacToe->g, rogress() ' :ion(》{--': "
     int r-'"['QM'?ssage~(jTh~gX9(t   'finished.\n"  '
                       "Do you reaLLy want to quit?"),--.
               . QMessageBox::Yes"I QMessageBox::No);
       if (r = QMessageBox::Yes) {
sessionManager,reLease();
      } eLse {
sessionManager.canceL();
            }
  =‘当用户注销的时候，‘就会调用comm/tData()函数。我们可以重新实现它，让它可以弹出一个消
息框，警告用户可能存在数据丢失的危险j默认实现会关闭所有的顶层窗口部件，这和用户一个
接一个地单击窗口标题栏上的close按钮来关闭这些窗口的行为一样。在第3章中，我们已经看到
了如何重新实现closeEvent()来满足这一要求并且弹出一个消息框的示例。    i~
    为了达到这个例子的所要完成的目的，我们重新实现了commitData()，并且如果还有任伺一个
游戏程序在运行的时候，我们就允许会话管理器能够和用户进行交互，弹出一个消息框来要求用
户确认注销操作（如图23.9所示）。如果用户单击的是：Yes，就调用releasee）来告诉会话管理器继
续注销操作；如果用户单击的是No，就调用cancel(.)来取消注销操作。
    图23.9“Do you raally want to quit?”
现在，让我们一起来看看TicTacToe类：
class TicTacToe : public QWidget
   Q_Of3JECT .  ' ..:
第23：章平台相关特性
419
public:
         TicTacToe (QWidget. *pa rent  = .0 J
bool gameInProgress(" const;
ost ring  saveState ( )  const ;
QSize  sizeHint ( )  const ;  . '
protected:
   void paintEvent(QPaintEvent *event);  '
.  void mousePressEvent(QMouseEvent *event);
p rivate:
      enum { Empty -  '-', Cross -  'X' r' Nought =,'0',}';
void clearBoard(); .
void restoreState();   '
ost ring   ses sio n FileName ( )  . const ;
QRect cellRect(int row, int column) const;
int cellWidth() const { return width() / 3; }        '
int cellHeight() const { return height() / 3; }    . ',  . : .':
                                                                                                                                                      '                        ,
bool threeInARow(int rowl, int coll, int row3, int c013) const;
char  board [3:1 [3] ;
int turnNumber;                         .. .,               '.   . '
    )；
    ‘    t
    TicTacToe类派生自QWidget，并且重新实嘲了sizeHint.()、paintEvent()和mousePressEvent()。它
还提供了我们在Application类中使用过的gamelnProgess()和saveState(')两个函数。’
TicTacToe'::TicTacToe(QWidget *parent) , ' .  .
i clearBoard(};                       : ... -..; :
  if (qApp->isSessionRestored(》
 setWindowTitle ( t r ( "Tic-Ta c_Toe " 》
    在构造函数中，会清空如图23.8所示的棋盘，并且如果应用程序是使用带有j薯sion选项调用
    ．    ．：    ，    ‘    。    ，．’    ’    ，．  ‘    -    ’
时，就会调用私有函数restoreState()来重新载人以前的状态。    ，    ，，．。  ．
    ，_  ‘，    t^
void TicTacToe::clearBoard()
     for (int row = 0; row < 3;++row) {       _ .': .
        for (int column = 0;' c'olumn < 3; ++column)
         .:   board[rowl[columnl=. Empty; .  .    '  '
茌clearBoard()中，我们清空了所有单元格。并且把
    一    牛
QString TicTacToe::saveState() const '  :
{
         QFile  file ( ses sionFileName( 》 ;          ,
        if  ( file.open (QIODevice: :WriteOnly.》  {
trunNumber.设置为0。
    ．■j、  ，∥，
     QTextStream out(&file) ;
   for (int row = O; row < 3; ++row) {‘      :
      for (int column = 0; column < 3; ++column)
                 out<< board[rowl[columnJ ;          ,
     }
}
return  file,fileName( ) ;
    在saveState()中，我们把棋盘的状态写到磁盘中。文件格式很简单，就是用“X”表示叉，用“O’
表示圈，用“一”表示空白单元格。
     420.                                              C++ GUI Qt 4编程(第 -版)
                    -
    QString TicTacToe::sessionFileName()  const
    {
    return QDir::homePath()+"/.tictactoe_"+ qApp->sessionld()+”.-
    + qApp->sessionKey()；
    )
    sessionFileName()私有函数会根据当前会话的ID和会话键(session key)返回其文件名。这个函
数会由saveState()和restoreState()使用到。这个文件名可由会话ID和会话键得出。
    void TicTacToe:: restoreState()
    {
    QFile file(sessionFileName(》;
    if (file.open(QIODevice::ReadOnly》{
    QTextst ream  in (&file):
    for (int row=0;row<3;++row){
    for (int column=0;column<3;++c吼umn){
    in>>board[row】[column】；
    if(board[row】[column】！=Empty)
    ~    ++tUrnNUmber：
    )    ．    ．
    )
    )
    update()；
    )
    在restoreState()中，我们载入与需要恢复的会话相关的文件，并且使用其中包含的信息填充棋
t盘。我们通过棋盘上的X和0的数量就可以得出tumNumbe，的值。
    在TicTacToe构造函数中，如果QApplicaUon：：isSessionRestored()返回tIue，我们就调用restore-
State()o在这种情况卞，sessionld()和sessionKey()可以返回与保存应用程序状态时一致的值，这样
sessionFileName()就可以返回那个状态的文件名。
    会话管理的测试和调试是一件令人倍感沮丧的事情，因为我们总是需要不停地登录和注销。
要避免这种情况，一种可用的方法就是使用Xll提供的标准xsm工具。在第一次调用x。m时，它
会弹出一个会话管理器和一个终端。我们从这个终端中启动应用程序，这样就可以使用xsm作为
它们的会话管理器，以此来替代那个通常的、系统范围内的会话管理器。然后，可以使用xsm的窗
口来终止、重新启动或者放弃某一个会话，并且可以从中查看应用程序的行为是否和它预期的一
致。有关如何做到这一点的详细信息，请参考http：//doc．trolltech。com/4. 3/session. html。
第24、，章  嵌入式编程
    开发那些运行在移动设备，比如PDA和手机上的软件是很有挑战性的，因为与桌面系统相比，
嵌入式系统的处理器更慢，永久性存储容量（闪存或硬盘）更小，内存更少，并且显示器也更小。
    Qt/Embedded Linux(也称Qtopia Core)是为嵌入式’Linux优化过的Qt版本。Qt/Embedded Linux
提供了Qt的桌面版(Qt/Windows、QUX11和Qt/Mac)相同的？API和工具，并且加入了嵌入式编程所
需的类和工具。通过双协议方式，可以在开源或者商业开发中使用它。
    Qt/Embedded Linux可以在运行Linux的任何硬件上运行――包括Intel x86、NnPS、ARM、Strong -
ARM、MotoroWFreescale 68000，以及PowerPC体系①。不像Qt／Xn，它不需要X窗口系统，它实现的
是自己的窗口系统，即QWS，从而大大节省了存储和内存。为了尽可能多地减少内存占用量，Qt/
Embedded Linux可以被重新编译以去掉那些不用的特性。如果可以提前知道设备需要用到哪些应
用程序或者组件，就可以将Qt/Embedded Linux的那些库静恋地编译到一起。
    Qt/Embedded Linux也得益于Qt桌面版的各种特性，包括把广泛应用的隐含数据共享（“写时复
制”）作为节约内存的技术，利用QStyle支持客户化窗口部件风格，和一个可？隧高效利用屏幕空间
的布局系统。    ．
    Qt/Embedded Linux构成了Trolltech嵌入式产品的基础，同时还包括Qtopia Platform、Qtopia PDA
和Qtopia Phone。这些产品提供了专为移动设备设计的类和应用程序，可以与一些第三方Java虚拟
机集成。    ．
  ’24.1  从Qt/Embedded Linux开始
  Qt/Embedded Linux应用程序可以在任何安装了适当工具包的平台上开发。最通用的选择是
在UNIX系统上创建GNUC++交叉编译环境。这一过程被Dan Kegel用一个脚本和一些补丁简化
了，它们放在http://kegel.com/crosstool/上。在本章中，我们将使用Qtopia开源版4.2，可以从http:／／
www．trolltech．com/products/qtopia/opensource/下载。这一版本只在Linux上可用，并且包含Qt/Embed-
ded Linux 4.2昀一个副本，还有一些支持Qtopia在桌面PC上编程的额外的工具。‘一
    Qt/Embedded Linux的配置系统支持交叉编译，这可以通过conflgure脚本的- embedded和-xplat-
fonn选项来实现。例如，为ARM体系做交叉编译需要键人：
可以通过向Qt的mkspecs/qws目录中添加新文件来创建用户自定义的配置脚本。
    Qt/Embedded Linux直接在Linux的帧缓存中绘图（与视频显示相关联的内存区域）。‘如图24.1
所示的虚拟帧缓存是一个Xll应用程序，像素一一对应地模拟真正的帧缓存。要想访问帧缓存，
可能需要拥有/dev/fb0设备的写操作权限。
  二要运行QUEmbedded Linux应用程序，必须首先创建一个进程作为GUI服务器。服务器负责为
客户端分配屏幕区域，生成鼠标和键盘事件。任何Qt/Embedded Linux应用程序都可以成为一个服
①从4.4版开始，Q￡有望运行在Wlndows 'CE上。
422
C++ GUI.Qt 4编程（第二版）
务器，需要在命令行指定- qws参数或者将QApplicaUon：：GruServer作为QApplicaUon构造函数的第
三个参数。
    ‘    ？
’  客户端应用程序通过共享内存和UNIX管道与QUEmbedded Linux服务器通信。在后台，客户
端将它们自己绘制到帧缓存中，并且负责绘制自己的窗口部件。。
量堍誊一．
  。。：“  ÷妻，，l    ，．，
图24.1在虚拟帧缓存中运行Qt/Embedded Linux
    客户端可以通过QCOP彼此进行通信，这是一个Qt通信协议。一个客户端可以通过创建一个
QCopChannel对象，连接它的received()信号监听一个名字通道。例如：
    QCopChannel *channel.= new口CopChannel(‘‘System",  this);1
    connect (channel,  SIGNAL( received(const QString＆,const QByteArray＆)),
    this,  SLOT( received(const QString＆,const QByteArray＆))).
    ．    ^
    QCoP消息包含一个名字和一个可选的QByteAmy。静本困数QCopchannel：：send()在通道上
广播消息。例如：    ”
    QByteArray data；
    口Datastream out(＆data,QIoDeVice::writeoily);
    out<<QDateTime::CurrentDateTime();    ’,    ‘,:
    口CopChannn::send(‘‘jystem“,“clockSk色w(QDateTime)n,data);    ’
    前面的例子阐述了一个理念：我们需要使用：QD雏＆联un编码，因为我们把这个数据格式放到
了消息名称中，就如同它是一个C++函数，确保接收者能够正确地解析QByte心ray。
    各种各样的环境变量会影响到Q￡，E出edded口n畔应用程序，最重要的是QWS―MoUSE―P唧
和QW_S-Ⅺ灌B蚴，它们用于指定鼠标设备和键盘类型。请参考h却：／／d6c．tI_Utech．∞d4.2／和pi-
acore-envvars．h嘲上介绍韵环境变量的完整列表o'  ．一    ，、
，如果将心Ⅸ作为开发环境，可以使用Qt的虚拟帧缓存(q、，fb)来测试应用程序，这是一个模拟
实际帧缓存韵．X11应用程序。这在相当程度上加速了开发周期。为了在，Qt，E础．edded+Ⅱnux上支
持虚拟帧缓存，可以在配置脚本中加入．q、，fb参数。注意这个参数的目的不是做产品级的应用程
序。虚拟帧缓存应用在蜘Wq血目录下，可以这样调用：    一
    qVfb-Width 320一height 480一depth 32    ,    .
}
鲞
；    ．第24章嵌入式编程    423
}――
}    使用Xll特性的虚拟帧缓存的另一个办法是使用虚拟网络计算(VNC，Virtual Network Comput-
}ing)远程运行应用程序。为了使QUEmbedded Linux支持VNc，可以在配置中加入- qt- 4x-vnc参数。
！    然后，在命令行中加入-display VNC：0来启动你的Qt/嵌入式应用程序，并且运行一个VNC的客户
j    端来指向你的应用程序运行的主机。显示的尺寸和位深可t以在运行QUEmbedded Linux应用的主
j，机上通过设置QWS- SIZE和QWS二DEPTH环境变量来指一定（例如，QWS- SIZE= 320 x480，QWS -
一’
；  DEPTH= 32)。
    。。j    ，  ．
24.2  自定义Qt/Embedded Linux'
    ，+
    在安装Qt/Embedded ,Hnux时，可以通过指楚二些；瓤篁来解决减少内存的占用问题。QU Embed-
：    ded Linux包含了100多个配置特性，每个特性都跟一个预定义的符号相关联。例如，QT_ NO_
；FII_EDIALOG从QtGui库中去掉了QFileDialog，Qt_N0_Il8N去掉了对国际化的全部支持。在src/c ore -
}lib/global/qfeatures，txt中列出了这些特性。．1-：  i’．一  一：
    Qt/Embedded Linux提供了5种配置范例(mimmum，盏aillmedium，large’和dist)，它们保存在src/
    corelib/global/qconfig-xxx.h文件中。这些配整可以通过corkgure脚本的-qconfig嬲石参数指定。例如：
    ./configure -qconfig small    i
    1}
    要创建用户的自定义配置，可以手动地提供一个qconfig- xl:x：且jC件，就像使用一个标准的配
    置文件一样来使用它。此外，还可以使用qconfig的图形化工具，它位于Qt酌啪ls子目录中。
    QUEⅡ．bedded Linux提供了下面这些类来负责与输入输出设备的交互，并且可以负责客户化窗
口系统的外观。    ：
┏━━━━━━━━━━━┳━━━━━━━━━━━━━┓
┃熏鬟震蘩鬻蘸鬻        ┃                          ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QScreen               ┃屏幕驱动‘    ：t r．     ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QScreenDriverPlugn    ┃屏幕驱动插件  ‘j         ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QWSMouseHandler       ┃鼠标驱动                  ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QMouseDriverPlugin .  ┃鼠标驱动插件              ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QWSKeyboLudHandler    ┃键盘驱动                  ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QKdbDnverPlu~jn       ┃键盘驱劫插件              ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QWSInputMethod        ┃输入法驱动                ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QDecoration           ┃窗口外观装饰风格          ┃
┣━━━━━━━━━━━╋━━━━━━━━━━━━━┫
┃QDecorationPlu~jn     ┃窗口外观装饰风格插件  。  ┃
┗━━━━━━━━━━━┻━━━━━━━━━━━━━┛
    为了获得预定义驱动程序、输入法和窗口装饰风格的歹0表；可以在运行，configure脚本的时候
使用-help选项。    ．‘：’  ‘‘    ’    ．jr。、二、    -：：+’
    在启动QUEmbedded Linux服务器的时候．，就像前一节中看到的那样，可以通过使用-display命
令行选项或者设置QWS：DISPLAY环境变量来指定屏幕驱动程序．。：可以通过设置'QWSP MOUSE一
PROTO环境变量来指定鼠标驱动程序和关联设备的驱动程序，这令环境变量的值必须使用卯吧：
deuice这样的语法；其中的typ吧’是所支持的驱动程序之』，而d”z,ce．是指向设备C#J'路径(例如，QWS
二MOUSE; PROTO：InteⅡiMouse：/dev/mouse)。使用类似的方式，通过指定QWS_KEYBOARD环境变量
就可以处理键盘。’可以在程序中使用QWSServer：：setCurrentIripudVlethOd()和QApplication:：qwsSet-
Decoration()谩定服务器的输入法和窗口装饰孑一，，≯  1j j    ，．∥‘’¨
    还可以通过对从QStle继承的窗口部件风格的设置，自由地设置窗口的装饰风格。例如，设
  424    C++ GUI Qt 4编程（第二版）
―――――――――.―――――――――■――●●●―――――.――一―.―一
置窗口装饰风格为Windows并且窗口部件风格为Plast/que是完全可能的。只要你愿意，装饰可以
基于每个窗口进行设置。
    QWSServer类提供了大量的自定义窗口系统的函数。运行在Qt/Embedded Linu）【服务器中的应
用程序可以通过QWSServer：：instance()静态函数访问唯一的QWSServe，实例。
    Qt/Embedded Linux支持如下字体格式：TrueType( ITF)、PostScript Type 1、位图发布格式(BDF)，
以及Qt预渲染字体(QPF)。
    因为QPF是一种光栅格式的字体，所以它更加快速，并且如果只需要一种或两种字体大小的
时候，它通常比rrF和Type 1这样的矢量字体还要小。makeqpf工具可以让我们预渲染一个rrrF
或者Type 1文件并且把结果保存到QPF格式的文件中。另外一种方式就是使用一。avefonts命令行
选项运行应用程序。    ，
    ，    ．    ^
24.3 Qt应用程序与Qtopia的集成
    因为Qt/Embedded Linux提供了与Qt昀桌面系统相同的API，任何标准的Qt应用程序都可以
被重新编译运行到QUEmbedded Linux上。尽管如此，在实际应用中，为了解决屏幕较小、键盘有限
（或者不存在键盘）以及资源受限地运行于QUEmbedded Linux的微型设备上所出现的问题，创建专
用应用程序是明霄之举。此外，Qtopia还提供了一些额外的库，用于支持Qt/Embedded Linux应用程
序中使用到的移动设备的特性。    -j
    _    _
    在使用Qtopia的APJi编写应用程序之前，必须编译和安装Qtopia的开发包，包括它自己的Qt／
Embedded LinuJ【的副本。这里假设使用的是Qtopia的开源版本4.2，它几乎包含了Qtopia电话版的
所有东西。
    编译Qtopia不同于标准的UNIX应用程序，因为Qtopia不应当在源码目录下编译。例如，如果
把qtopia-opensource-sr℃-4.2.4.tax.gz源码包下载到$HOME/downloads目录下，应该这样编译Qtopia：
    cd $HOME/downloads    ：
    gunzip qtopia-opensource-src-二4.2.4.tar.gz
    tar xvf qtopia-opensource-src-4,2.4.tar
    觋在，必须创建一个Qtopia的编译目录，例如：
    cd $HOME
    mkdir qtopia
    为了方便，文档里建议设置QPEDIR环境变量。例如：
    export QPEDIR=$HOFIE/qtopia    .’
这里，假设使用的是Bash解释器。现在就可以编译Qtopia了：
    cd $QPEDIR
    $HOME/downloads/qtopia-opensou rce-s rc-4.2. 4/con figu re
    make
    make install
    我们没有指定任何的配置参数，但你可能希望这样做。运行configtu℃-help可以看到所有可能
用到的那些参数。
    安装完成之后，所有的Qtopia文件将位于$QPEDIR/image目录中，由用户创建的与Qtopia交互
的文件将位于$ QPEDIR/home目录中。在Qtopia看来，一个“镜像”就是Qtopia的一个文件系统，它
位于桌面计算机中，由Qtopia在虚拟帧缓存上运行时使用。    。
    ．    ．
    Qtopia提供了复杂的文档集，并且熟悉它们是很重要的，因为Qtopia提供了许多Qt的桌面版
无法使用（或者无关）的类。这些文档的起始页面是$ QPEDIR/doc/html/index．. html。
第24章嵌入式编程
    一旦编译和安装完成，就可以通过运行$ QPEDIR/scripLs/runqtopia来做一个测试。这个脚本调
用带了皮肤的虚拟帧缓存以及qpe，包含Qtopia应用程序栈的Qtopia环境。单独运行虚拟帧缓存以及
Qtopia环境也是可以的，但需要以正确的顺序来启动它们。如果不小心首先启动了qpe，Qtopia就会写
到Xll的帧缓存，最好的结果也会破坏屏幕的显示。runqtopia'脚本可以通过使用-help查看它所支
持的命令行参数。这包括- skin，以及可选的皮肤列表。
    虚拟帧缓存有一个上下文菜单，在Qtopia以外的区域单击右键就可以弹出。菜单有助于我们
调整显示以及关闭Qtopiao
    既然Qtopia已经运行在虚拟帧缓存中，我们就可以编译一个自带韵例子，看看进程是如何工
作的。然后，我们创建一个非常简单的应用程序。    ．，
    把目录切换到$ QPEDIR/examples/application下。Qtopia有它自己版本的qmake，称为qtopia-
make，它位于$QPEDIR/bin目录下。运行它来创建一个makefile，然后运行make。这将创建一个ex-
ample可执衍文件。然后，运行make install安装它，安装程序将会把example（以及其他一些文件）复
制到Qtopia的镜像文件夹中。现在，如果先关闭Qtopia，然后再重新运行它，可以使用runqtopia，我
们就可以看到一个新的“Example”应用程序。要想运行这个应用程序，可以单击Qtopia底部中央的
“Q”按钮，然后单击软件包的图标（“box”图标，手形标志的上方），最后单击“Example”粤口可（如
图24.3所示）。
    我们将通过创建一个很小但很有用的Qtopia应用程序来结束这一节，因为其中还有一些需要
注意的细节。应用程序的名字称为单位换算(Un/t Con。erter)，如图24.2所杀；…它只是使用了Qt的
API，因此没什么新奇的地方。下一节将使用一些Qtopia专有API:来创建二个更复杂的例子。
图24.2 Unit Converter应用程序
    单位换算应用程序包含三个文件：main. cpp、umtconverter.h和unitconverter. cpp。创建一个新的
umtconverter目录，然后进入该目录，创建一个空的.cpp和．h文件。然后运行：
  ：qtopiamake -project
    ^    L    k
来创建一个：pro文件。这个文件类似于；
 = unitconverter
+= qtopia_main no_quicklaunch
+= unitconverter,h
+= main,cpp \
  unitconverter.cpp   .
 = none
    CJ CJ
- .D CC LU
LU H LU U
o u- o a:
< o LU O
T u =: S
426    C++ GUI Qt 4编程（第三版）
’r即使我们写了代码，编译出了可执行文件，并且安装了它，，它也不会出现在Qtopia的应用程序
列表中。为了做到这一点，我们必须指定该应用程序图片的位置，即它的．desktop文件的位置，以
及应该把它放在什么地方。提供一些如何打包方面的知识也是_个不错的练习。因此，我们来手
动修改. pro文件，把它改成这样：j
qtopia_proj ect ( qtopia  app)
TARGET
CONFIG
HEADERS
SOURCES
INSTALLS
desktop,files
desktop.path.
desktop.hint
pic s . files
pics .path
pjcs., hint
 = unitconverter
+= qtopia_main no_quicklaunch
+= unitconverter.h
+= main.cpp \
unitconverter.cpp
+= desktop pics
- unitconverter.desktop
= /apps/Applications
= desktop
= pics/*
= /pics/unitconverter
plcs
pkg.name     = unitconve.rter '    , .     . . . .    F   ::.
pkg.desc     = A program to'convert between various u'nitS of measurement
pkg.version  = i..o.e
pkg,domain   = window
  觋在的．pro文件包含一个INSTALLS选项，它的意思是说当运行make install时，应用程序的
．desktop文件和图片必须跟可执行文件安装在一起。
  图24.3定位Example应用程序
j  根据惯例，图片会被安装在？pic子文件夹中，．pro文件中的pics. xxx项指定了原始图片的位置
以及它们需要被安装到的位置。desktop．xxx项指定应用程序的、．desktop文件的名称以及它应当安
装的位置。把它安装在／apps/Applications目录下保证了当用户单击软件包图标时它可以出现在应
用程序列表上。当应用程序在桌面环境中运行时，绝对路径，例如/apps/Applications和/pics/expenses    ．
实际上是Qtopia，镜像目录中的一个相对路径（apps会被bin所取代）。
    urutconverter. desktop文件提供了．些应用程序的基本信息。使用官的目的是可以在应用程序
列表中显示它。这是完整的文件.：j。  ／t’    ，
[Desktop EntryJ
Comment[J=A program to convert between various units of measurement
Exec=unitconverter
Icon=unitconverter/Example
Type=Application
                                                                    ....
第24章嵌入式编程
．．  我们提供的这些信息只是能够指定的信息的子集。例如，可以提供翻译的信息。n注意图标没
有.png之类的扩展名。由Qtopia的资源系统去查找和显示合适的的图片。、  ：
    现在，已经得到了一个特定的手动修改了的．pro文件以及一个、，、desktop文件。我们还需要做
一件Qtopia特有的工作，然后就可以使用标准Qt语言并且按照其标准方式来编写、unitconverter.h
和unitconverter. cpp文件了。对于Qtopia来说，必须遵循一个特殊的习惯，与qpe关联起来。整个
main. cpp则被裁减到只剩下这么几行：    ，  ，
    #include <QtopiaApplication>
    ．。  J    ，
    #includellunitconverter.h¨
    QTOPIA_ADD_APPLICATION(”UnitConve rt.e^UnitConve rter)
    QTOPIA_MAIN
    ，r P    、    1 J’    。    ，^，
    主窗口类的名称是UnitConverter，包含在unitconverter.h文件中。用恭与qtopiamake和unitcon-
verter.h、unitconverter. cpp文件关朕，我们可以创建一个在Qtopia环境中‘遣荇曲Qtopia应用程序。
    ，，    。。    )    。
main()函数由QTOPIA_MAIN宏定义。    ？
    ‘t    ：、
    因为这个应用程序除了main．cpp，使用的只是标准的Qt类，它也可以被编译成普通的Qt应用
程序来运行。想要做到这一点，需要使用标准的qmake，并且修改rnajn．cpp≯：    ”’。^-
    ”二    rj
#include "unitconverter.h"
int main(int ar'gc, char *argv[J)
{
      QApplication app(argc,  argv) ;
   UnitC0仉verter converterr  .
       converter.show( ) ;      .
      return app.exec() ;
    ÷一一瓮尊{、，■¨
    j?}‘奠‘；+’^Y．‘．：
    、    ^    一
此外，还需要注释掉．pro文件中的qtopia_project() -行。
    、，‘    7 j。
    对于只需要在Qt/Embedded Linux下运行的应用程序来说，把它们如同标准的Qt应用程序一
样开发通常是很方便的，或许可以显式地设定主窗口的resize()为手机或者PDA的大小，当它们做
完初版测试后再把它们修改为Qtopia应用程序。作为～种替代方法，可以有两个不同的main．cpp
文件，或许是main_desktop.cpp和main_qtopia. cpp，以及两个：pro文件。
    单位转换应用程序中的大多数代码都与本书中介绍的其他Qt例子中的代码相类似，因此就
不再逐一介绍了。    ，．0．．I．一：    ，
    要想测试一个应用程序，必须运行make，然后make install，接着是runqtopia。一旦Qtopia在虚
拟帧缓存中运行起来，就可以单击“Q”按钮，然后单击软件包图标j接着单击”Ur/:it．Converter”。在这
之后，就可以试验这个应用程序了，可以修改数量和选择组合框中的不同单往≯■20一、  。’
    创建Qtopia应用程序与创建传统的‘Qt应用程序并没有太大的不同；只是除子对于初始化的设
置以及用qtopiamake代替'qmake等不同（特殊的．pro文件和？fdesktop_文件）之外0测试嵌入式应用
程序应该是很容易的，因为它们可一以被编译.安装，还可以在虚拟帧缓存中运行。’．’对于应用程序来
说，尽管它们可以是传统的Qt应用程序：但实际上，把嵌入式环境的局限性考虑进去也是可取的，
而且使用Qtopia特色的API可以确倮它们跟Qtopia的应用程序栈很好地集成起来。’，  。’
24.4使用Qtopia的API、  i  '
    Qtopia PDA版和Qtopia电话版提供了一系列针对嵌入式用户的应用程序’。大多数的这些应用
  428    C++ GUI Qt 4编程（第二版）
    ________________________-.__-.j___________________..__一
程序会被释放到库中，或者使用版本相关的库。这些库可以在Qtopia应用程序中使用，允许我们
访问设备的服务，例如闹钟、邮件、打电话、SMS、语音录音，以及其他的一些应用程序等j。
  ．如果想在应用程序中访问设备相关的特性，可以有多种选择：
    ・使用Qt/Embedded Linux，编写自己的代码并与设备进行交互。
    ・修改一个存在的Qtopia应用程序，使它具有所需的功能。
    -使用附加的API编写代码，例如，Qtopia电话API或者Qtopia PIM应用程序的库。
    本节将尝试最后一种方法。我们将编写一个小程序，记录简单的消费信息。它使用Qtopia
PIM应用程序的数据来弹出一个联系人列表，然后向选定的联系人以SMS消息的形式发送消费报
告。它还说明了如何使Qtopia支持大多数手机所具有的“软键盘”。
    如图24.4所示，应用程序将位于应用程序软件包的列表中，就像前面一节中介绍的例子一
样。跟以前一样，我们首先来看一下．pro文件，然后是．desktop文件，最盾是应用程序源代码。这
里是expense的．pm文件：
    qtopia_project(qtopia app)
    depends(libraries/qtopiapim)
CONFIG
HEADER5
SOURCES
INSTALLS
desktop.files = expenses.desktop
desktop,path  = /apps/Applications
desktop.hint = desktop
pics.files   = pics/*
pics . path         =  /pics/expenses .
pics.hint   =.pics     ,
pkg.name, .    = expenses  .
pkg.desc     = A program to record and SMS expenses
pkg.version   =. i.e,e
pkg.domain   = window
图24.4定位和运行E】(penses应用程序
    qtopia_project()这一行跟前面一样。因为这个应用程序依赖子Qtopia的PIM库，我们使用de-
pends()指定这个库。如果需要使用多个库，可以用逗号把它们隔开。余下的．pro文件跟我们在单
位转换例子中看到的类似，只是这次有更多的源文件，因为这个应用程序更夏杂一些。
u    //
'g- -    印叩
. I   -c -C    u u
o    ' -'
    o o  o o  tn
C   - -o a_r -O   U
rl    m c a_ n, =    rl
 n, _C  rl 'rj  U:-rl .j       a_
E,  . -o '   . -0 3 a_
   I a> w a>  a) a> a> a_ a_
rl C C C = = =  . lJ
o a- a a- p a a--+ tn
4JXXXxxXm0
U Q> Q> Q> Q) Q) Q) E d
第24章嵌入式编程429
expense. desktop文件与前面看到的类似：
[Desktop EntryJ
Comment[J=A program to record and SMS expenses
Exec=expenses
Icon=expenses/expenses
Type=Application '
Name[l:Expenses
main．cpp也一样：
#include-'<QtopiaApplicatjon>
#include "expensewindow.h"
QTOPIA_ADD_APPLICATION( "Expenses" ,  ExpenseWindow)
QTOPIA MAIN '
    现在介绍Expenses应用程序的头文件以及那些Qtopia特有或者与其显著相关的源码部分，首
先从Expense类开始：
class Expense
{
public :
     Expense() ;
    Expense(const QDate &date, const QString &desc, qreal amount);
bool isNull() const;
void setDate(const QDate &date);
QDate date() const;
void setDescription(const QString &desc);
QString description() const,
void setAmount(qreal amount);
qreal amount() const;
private:
 .  QDate myDate;
   QString myDesc;
   qreal myAmount;
};
；≯好。
  这个简单的类保存了一个日期、一个描述信息以及一个账户。我们不介绍expense．cpp文件，
因为其中没有一段代码是Qtopia所特有的，并且它也很简单。
class ExpenseWindow : public QMainWindow
{
Q~OBJECT
public:
   ExpenseWindow(QWidget *parent = 0, Qt::WFlags flags = 0)
protected:
   void closeEvent(QCloseEvent *event)
private slots:
      void add( ) ;
       void  edit ( ) ;
   void del();
   void send();
      void clear( ) ;
private: '
        void  c reateActions ( ) ;
    void rcreateMenuOrToolBar()
       void  loadData ( ) ;
  . void showData();    '   .
QList<Expense> expenses;
  430    C+卡GUI Qt 4编程（第二版）
  ___  _―_――‘.=――--._=‘=_2÷==――.―.=====
    ExpenseWindow是应用程序的主窗体，它提供了一些方法；用户可以添加：编辑或删除个人消．
费信息，发送具有所有消费清单的SMS消息，并且可以清除这些信息。消费信息保存在Q“st<E）【一
pense>值中。
    构造函数创建了一个QLjstWidget和两个QLabel。一个标签显示文字“Total”，另外二个显示消
费的总和。这个动作由createActions()函数产生，菜单或者工具栏由createMenuOrToolBar()函数生
成。两个函数都在构造函数中得到调用。所有已存在的记录都在构造函数的结尾处通过调用
loadData()函数加载进来。我们将跳过构造函数，而仅仅介绍一下它所调用的那些函数：
void  ExpenseWindow: : createActions ( )
{
   addAction = new QAction(tr("Add"), this);
            addActio n-> s etlcon ( QIcon ( il : icon/add " 》 ;
         connect ( addAction,  SIGNAL (t riggered ( 》 ,  thiS,
clearAction = new QAction(tr("Clear"), this);
clea rAct ion->setlcon ( QIcon ( " :icon/clear" 》 ; .
connect ( clea rAction,   SIGNAL (t riggered ( 》 ,   this,   SLOT ( clea r( 》 ) ;
    createActions()圈数创建了Add、Edit、Delete、Send以及Clear操作。尽管可以使用Qt的资源文
件（．qrc），当编写Qtopia应用程序时，对于图标标准的做法是把它们保存在pic子目录中，然后复制
到设备中（这要归功于．pro文件中的INSTALLS这一行）。为了在几个应用程序中都可以共享它
们，Qtopia使用一个特殊的数据库来优化对它们的访问。‘    、，’．    +t
    h'    ．    ．
    在Qt或者Qtopia需要一个文件名的任何地方，都可以提供一个Qtopia资源的名称。通过文件
名中打头的冒号来标识，紧跟着一个指定资源类型的单词。在这种情况下，我们指定需要的图标，
给定一个文件名(例如，：icon/add)，忽略文件的扩展名。Qtopia会在一些标准的位置寻找一个合适
的图标，首党会从应用程序的pics目录开始。详情可以查看http：//doc．trolltech．com/qtopia4. 2/qto -
pia-resource-system.htmlo    ’    ’
    void  ExpenseWindow::c reateMenuOrToolBa广()
  +    {
    #ifdef QTOPIA_PHONE
．．：：j  ,QMenu  .*menuorToolBar:=:QSoftMenuBar::menUFoi(listWidget)0。．i-‘  ‘：1  ’    。
    #else
    ,;  、  QToolBar？毒menuOrToolBar=rrew QToolBar;    .7  ‘    ,  ’    .    ,    ’
    addToolBar(menuOrToolBar);
    书endif
      .          menuO'rToolBa r->addAction ( addAction) ;
          .    menuOrToolBa r->addAction ( editAction) ;
                     menuo rToolBa r->addActio n ( deleteAction) ;
  .  menuOrToolBar->addAction(serTdAetion); .
              menuorToolBar->addAction (claearActionl;
-  有些电话有“软键盘”j也就是说，具有一些多功能键，它们的操作是针对应用程序或者上下文
环境的。QSoftMenuBar类在合适的地方使用软键盘，否则弹出一个菜单。对于PDA来说，我们通
常更希望把弹出菜单改为i真栏：#ifdef-识确保在电话上使用菜单，而在PDA上使用工具栏。
    用户可能希望能够在关闭应用程序时，不必显式地去保存数据。他们可能也希望稍后重新启
动应用程序时数据能够得以恢复出来。这可以简单地通过调用构造函数中的IoadDa.ta'()来实现，
可以在应用程序的closeEvcnt()中保存这些数据。Qtopia提供了许多保存数据的方式，包括保存到
SQLite数据库的表中或者保存到文件中。因为消费数据很小，所以将用QSettings来保存它。我们
将看到是如何保存它的，以及是如何加载它的。
    第24章嵌入式编程431
    ‘‘‘‘‘‘‘’‘‘‘‘‘‘‘‘‘‘‘‘‘‘‘?‘I_-_________’_’一
void ExpenseWindow::closeEvent(qCloseEvent *event)
   QByteArray data, ' :    .       . ' .     '
QDataStream out(&data, QIODevice::WriteOnlyJ
 out.setVe rsion (QDataSt ream: :Qt_4_2) ;
foreach .(Expense expense, expenses) {.        .
   out<< expense.date()<< expense.description() ':
    ,    << expense.amount();   .
QSettings settings("BookSoft Ltd", "Expenses");
settings . setValue( "data" ,  data) ;
event->accept ( ) ;
    我们创建一个QByteArray，并且把所有的数据写进去。然后，在接收到关闭事件允许应用程序
结束之前把它保存在data键值下。
void ExpenseWindow::loadData()  .':' '
{
        QSettings  settings ( uBookSoft  Ltd" ,  ." Expenses " ) ;
   QByteArray data = settings.value("data").toByteArray();  .
     if  (data: isEmpty(》        .
expenses , clea r ( ) ;   .
QDataStream in(&data, QIODevice::ReadOnly)
in . setVe rsion (QDataSt ream: :Qt_4_2) ;
while  ( ! in.atEnd
. ' ' QDate 'datet':
   QStr~ing desc
   qreal amount
    in 》 date '》 desc 》 amount;     /   .   .
   expenses.append(Expense(date, desc, amount》
}
showData ( ) ;
7，…    ．E一
；{唧置每÷善≥  ．.
io≥j封露j。，    ’5、
    数据来源于前面的会话，我们清空了存在的数据，然后读人每个新的消费项。，showData()函数
清空了列表窗口部件，然后循环加入消费信息i为每个消费信息添加一个新的列表项，然后更新标
    ．  ，‘  ，．    i．~．    ~
签的显示。
    +    ^
    运行应用程序，用户可以添加、编辑或者删除消费项，用SMS、消息发送宅们，或者把它们全部
清空。    ‘  ~“  ，  、’
    对于删除操作，我们检查列表窗口部件中当前是否存在有效的行，然后使用一个标准的QMe。．
sageBox：：waming()静态便利函数谊l问用户确认删除操作。如果用户选择痢除所有的消费信息，我
们可以再使用一个消息框。所有这些操作都是标准的Qt程序。Qtopia负责消息框的显示，以及与
    ‘    ’    ‘    ．
Qtopia环境的完全集成。
    ：    、    一‘    ’‘  ’    ．．    ．c．，…
    如果用户选择Add操作，则会添加一个新的消费项，从而会调用葫a()槽：
    ：’    1    7'
    void  ExpenseWindow::add()    .
    {，    。I．    +  ．    ？  ，．j一    ．    ’
, Expe){g::};Xp;ldj'alog'Exp霪．、 '  ,r
.  if (Qtol   lication::7Pt;'JD()Jbcjh;&d)a;lligj):{ ";-.;'.   - ..
      . expenses.append(dialog.expense(》;  .      ' ::  I ,'  . /
              showData ( ) ; ,   '         .
                                                                                                                                                                                                                     '  .
 432           .   . C++'GUIQt4编程(第=版)
     -
--
这个槽创建了一个ExpenseDialog，稍后将介绍这个类，但我们不是调用对话框的QDialog:：exec()
函数，而是调用QtopiaApplication：：execDialog()函数，
把对话框作为一个参数传进去。调用exec()是
可行的而且是有效的，但使用execDialog()确保了对话框的大小和位置更适用于微型设备，如果有
    ．    ’
必要，它将被最大化。
    Edit()槽与之类似。如果edit()函数被调用，它会检查当前列表窗口部件中是否存在有效的
行，如果有，它将该行对应的消费信息作为第一个参数传到ExpenseDjal.og的构造函数中。如果用
户确认修改，修改后的信息将覆盖原有的信息。
    最后一个需要介绍的ExpenseWindow函数是send()，但在介绍它之前，我们将讨论一下Ex -
penseDialog类：
    . class ExpenseDialog  :public QDialog  .    .
    {
，    Q_OBJECT
public:
;    ExpenseDialog(const Expense &expense, QWidget *parent = O)
 . . Expense expense() const { return currentExpense; }
public slots:
    .  void  accept ( ) ;
 ,. voicf Cteate~ons(); ar();    .
: void createMenu04rToolBar'   .
   Expense currentExpense;    .
    }；
    很明显，我们有创建操作、菜单或者工具栏的函数，就如同ExpenseWindow类的定义。我们不
会创建QPushButton或者QDialogBuggonBox，而会创建工具栏或者QSoftMenuBar，因为这些比创建按
钮更容易与Qtopia环境进行集成。代码与我们创建应用程序的主窗口类似：
void ExpenseDialog::createActions() . .
   okAction = new QAction(tr("OK"), this);
            o kAction->setlcon ( QIcon ( " :icon/o k " 》 ;
         connect (okAction,  SIGNAL (t riggered ( 》 ,  this,  SLOT(accept ( 》 )
      cancetAction = new QAction(tr( "Cancel") ,  this) ;
            cancelActio n->setlcon ( QIcon ( " :icon/cancel" 》 ;
         connect ( cancelAction,  SIGNAL(t riggered( 》 ,  this,  SLOT( rej ect ( 》 ) ;
}
toid  ExpenseDialog: : c reateMenuo rToolBa r( )
{
#ifdef QTOPIA_PHONE .                                  .    ,
      QMenu *menuOrToolBar =' QSoftMenuBar::menuFor(this) ; ,  .
#else .
    QToolBar *menuOrToolBar = new QToolBar;
 ' menu.OrToolBar->setMovable(false);   '
   addToolBar(menuorToolBar);         .'  .
#endif
    :.  .menuO rToolBa r=>addAction'( okACtion);
    menuo rToolBa r->addActi.onl cancelAction);
  ．    }    、
    如果用户确认了操作，我们设置当前消费记录的日期j描述以及金额属性，并允许调用者使用
对话框的expense()函数检索数据。，
    如果用户选择了Send．操作，send()函数就会得到调用。这个卤数提示用户选择一个联系人来
发送信息，准备要发送的文字，然后使用SMS协议发送该消息（如图24.5所示）。
图24,5选择一个联系人并且发送SMS消息
void  ExpenseWindow: :send ( )
4
   QContactSeiector dialog(false, this);
          dialog ,setModel ( new  QContactModei) ;
          QtopiaApplication : :execDialog ( &dialog) ;
        if   ( ! dialog .contactSelected ( 》       .
 return;
    QContactSelector对话框和QContacflVIodel模式／视图类都是由PIM库提供的。QContactModel访
问用户集中联系人信息的数据库。如果有很多的记录，QtopiaApplication：：exee.将会最大化
地弹出QContactSelector对话框。如果用户没有选择联系人，.ontactSele/ted()葛霎鬈篙萎联系人(意
    false)    ／！    ．
味着挝se），在这种情况下什么都不做。否则，准备发送消费信息：
    QTemporaryFne file;
    file;setAutoRemove(false):
    if(!file．open()){
    QMessageBox::warning(this, tr(1‘Expenses“),
return
tr(."Failed to send expenses: %1.")
.arg(file,errorString(》);  .
QString  fileName = file.fileName( ) ;
qreal total = 0.00;
QTextstream out(&file)
out.setCodec( "UTF-8") ;
out《 tr("Expenses\n");
foreach (Expense expense, expenses\ {
   out《 tr(”%l $%2 %3\n")
                         ,a rg'( expense.date ( ) .toSt ring (Qt: :ISODate》
        .arg(expense.amount(), 0, 'f', 2)  '
.arg(expense.description(》;
       total += expense.amount ( ) ;
}    .
out《 tr("Total $%l\n").arg(total, 0, 'f', 2);
file.close( ) ;
    为了发送SMS消息，我们需要传递保存SMS消息的文件名。这里，我们把消费数据用QText-
s Lream保存到一个临时文件中。通常，QTemporaryFile茌调用close()时删除文件，但我们关掉了这
个操作，因为在SMS被发送之前文件必须存在，同时Qtopia将自，动删除它。
    total变量是个qreal类型。这一类型是对float或者double的定义，依赖于体系结构。例如，在
ARM上，因为性能问题，它代表一个float类型。在Qt的API中（特别是在QPainter中），qreal的使
用胜过double。    ，    i．
  434    C++ GUI Qt4编程（第二版）
___.,_--____-____’__一
      QContact contact = dialog.selectedContact( ) ; '    .
'  QtopiaServiceRequest request("SMS",
                                                                                  "writeSms ( ost ring,QSt ring,QSt ring) " ) ;
           request<<  ost ring ( "%1  %2" ) .arg ( contact , firstName( 》           a  '
                                                      .arg( contact.lastName( 》
《 contact.defaultPhoneNumber()<< fileName;   .
       request.send( ) ;
    Qtopia把SMS协议实现为一个服务而不是一个库。想发送SMS，我们创建一个QtopiaService-
Request对象，给它服务的名字，“SMS”，把需要使用的函数连同参数列在圆括号中：“writeSms( QString，
QString，QString)”。深入下去，QtopiaServicesRequest使用QCOP与提供“SMS”服务的进程通信。    一
    我们用接收者的名字和电话号码，以及文件韵名字来创建一个请求，调用send()杷消息发出
去。当send()被执行，一个Create Message对话框会被Qtopia系统弹出来，文件中的消息的主体部
分会显示在上面。用户可以修改这些文字，然后发送或者取消SMS。Expense应用程序只能在提供
SMS服务的实际的或模拟的设备上进行测试。  ’
    如同本例中谈到的，嵌入式编程意味着我们必须考虑怎样使用和操作服务以及Qtopia特有的
API。它还要求我们以不同的思路考虑用户交互的设计，以解决嵌入式设备具有的微型屏幕和有
限的输入设备的问题。从一个程序员的立场来看，除了必须熟悉Qtopia特有的那些额外的工具、
库以及服务外，编写Qtopia应用程序跟编写桌面平台的应用程序并没有什么分别。
    冀粤骚．．
第四部分  附录
附录AQt的获取和安装  ‘
附录B  编译Qt应用程序
附录CQt Jambi简介
    ，    -
    ．    ’
附录D  面向Java和C'#程序员的C++简介
附录AQt的获取和安装
    本附录说明了如何获取并在你的系统中安装GPL版的Qt。，这些版本可用于Windows、Mac OS
 X、和Xll(可适用于Linux和绝大多数的UND()。可用于Windows和Mac OS X的预编译库中包含了
    一    ～    -
SQLite和SQLite的驱动程序，SQLite1目前已用于公痰数据库年’j从源码包中编译而来的版本则可
以自由选取是否包含SQLite。开始之前，请先从http：//www.trolltech.com/download/下载Qt的最新版
本。如果打算开发商业软件，那么将需要购买Qt的商业版，然后按照他们提供的安装说明进行安
装即可。
  ．  ，    ．    、    √    ．  。：    ．
…Trolltech还为像在PDA和移动电话这些基于Linux的嵌入式设备上构建应用程序提供了
    ．    ，    ‘
QUEmbedded Linux版。如果对创建嵌入式应用程序感兴趣，那么可以从Trolltech的下载网页中下
载QUEmbedded Linux。    ：
‘，  用于本书韵所有应用程序的例子都可以从本书的网站中下载到，网址是http://www.informit.
com/title/0132354160。另外，Q￡琴零供了许多小汞例应用程序，它们放在examples子目录中。  ，
  一、謦■；．；善’t
协议说明
    一・般说来，可以通过两种方式获取Qt：一种是开源形式，另外一种是商业形式。开源版的各个
版本都可以免费获取，而商业版的各个版本则需要通过一定的费用购买得到。  ，
    如果你希望发布自己基于Qt开源版创建的那些应用程序，那么就必须遵从在创建这个应用
程序时所使用的Qt软件协议中列举出的那些特定条款和条件。对于开源版，这些条款和条件包
括了使用GNU通用公共协议(GPL，General Public License)的要求。像GPL这样的开放协议会给予
这个应用程序的用户一些特定的权利，包括查看和修改源代码以及重新发布这个应用程序（在同
等条款下）的权利。如果希望在发布应用程序的同时不公布源代码（要保持源代码的私有性），或
者如果希望在发布应用程序时使用自己的商业协议条件，那么就必须购买创建该应用程序时所使
用到的那些商业版Qt软件。这些商业版允许基于自己的条款来销售和发布应用程序。
    许可协议中的这些完整法律条款都包含在用于Windows、Mac OS X和Xll的GPL版Qt中，其
中也包含了如何获得商业版的信息。
A.2  Qt/Windows的安裟
    J／
    在本书还在编写时，Qt在Wi．，dows下的安装程序称为qt- win-opensource-4.3.2．mingw.e）【e。这个
版本号可能会与你阅读本书时所看到的版本号有所不同，但其安装过程则应当是相同的。要开始
安装过程，请先把这个文件下载下来并运行它。
    当安装程序运行到MinGW这一页时，如果你已经安装过MinGW C++编译器，那么就必须指定
它所在的目录；否则，请选中复选框，以便让安装程序自动为你安装MinGW。GPL版的Qt不能用
于Vi。ual C++，所以，如果还没有安装MinGW，那么就需要先安装它。安装程序会自动安装Qt的那
些标准示例程序和参考文档。‘
    ，    ’
／，
    附录A Qt的获取和安装    437
    女口果安装时选择了安装Mit．GW编译器选项，那么在MinGW安装结束之前，可能还需要一段时
间才能开始安装Qt。
    安装完成后，你将会在W{ndows的“开始”菜单中着到一个名为“Qt by TroL[tech v4.3.2( Open-
Source)”的新程序组。在这个程序组中，有指向Qt助手(Qt Assistant)和Qt设计师(Qt De。igne，)的快
捷方式，还有一个名为Qt 4.3.2命令行提示符(Qt.4.3.,2 Commai，(l Pro毋pt,)的快捷方式，它可以打开
一个控制台窗口。打开这个窗口后，它能够自动设置使用MinGW编译器编译Qt程序时所需的环
境变量。，在这个窗口中，可以季行qmake和make命令来编译Qt应用程序。
A.3  Qt/Mac
的安装
    在把Qt安装到Mac OS x之前，必须已经安装了Apple的Xcode Tool。工具包。这些工具包通
常会包含在和Mac OS x一起提供的那些CD(或者DVD)中，也可以从Apple Developer Connect/on中
    http//developer. apple com    ‘  f  ?    一
下载这些工具包，网址是http：／／deve嫦舀，印ple．com。
    如果使用的是Mac OS x 10.4和Xcode Tools 2.x(with GCC 4.O.x)或者是之后版本：那么就可以
使用如下描述的安装步骤、；如果使用的是Ma℃OS' x的早期版本，或者GCC是一个较早的版本，那
么将需要手动安装这个源码包。该源码包的名称是qt-mac-opensource-4．争2．tar：画，而宜可r从
Trolltech的网站中下载它。如果要安装这个软件包，那么请按照下一节中所给出的在Xll上安装
Qt的操作说明来进行相关安装。    善》ij。‘j_’
    要使用安装程序安装Qt，请下载qt-mac-opensource-4.3.2.dmg。（在写作本书时采用的就是这
个版本，但当你阅读此书时，版本号可能已经与此有所不同了。）双击这个：．．dmg文件i然后再双击
这个Qt.mpkg软件包。这样将会启动安装程序，它会把Qt的文档及其标准示例程博与．q毒起安？
装在/Developer目录中。    ？-：-  ~  !  一÷、一。。二
    要运行像cpnake和Ⅱ姐ke这样的命令，就需要使用一个终端窗曰，例如,/ApplicatjorisjUtiMes目
录中的Tenninal'. appa还有的情况就是要用qmake生成一个Xcode工程。例如，要为hello这个例子
生成一个Xcode工程，就需要先打开2个控制台，比如Telminal,. app；然后把当前路径切换到exam-
ples/chapOl/hello，并且输入以下命令：  +    ．    ，一j  ．一一…．一j    ．．，  j_?
    qmake―spec macx-xcode hello.pro    ,    .,    ,:  :’  一．    .     .:-.    ,    .
    _‘    ，  ．    ：  ，  一    ．    ，’    ，    ，    t
A.4 Qt/X11的安装
    ？    ‘
    +}．
    从TroL[tech的网站中下载文件qt-xll- opensource- src-4.3.2．tar.gz。（在写作本书时采用的就是
这个版本的文件，但当你阅读此书时，使用的文件可能已经发生、了改变。）在Xll中．，要把Qt安装
    ：？
到它的默认位置，需要拥有mot权限。如果没有root的访问权限，那么请使用configure工具的- pre -
rix选项来指定一个你具有写操作权限的目录。
1．把当前路径切换到你存放下载文件的目录处。例如：  i
    cd /tmp
2．解压该压缩文件．：    ，
    gunzipf  'qt-xll-opensou rce-s rc-4.3. 2,to r.gz    .:    +
    tar xvf qt-xll-opensource-src-4.3.2.tar
毗时会生成_个／tmp/qt_xll_opensoLu℃e-src-4.3.2目录。Qt需要的是GNU的tar工具，而在
某些系统中它称为gtar。
C++ GUI Qt 4编程（第二版）
3．用你喜欢的选项来执行configure工具，它可用于编译Qt库以及与Qt -起提供的工具软件：
    cd／tmp/qt-xll-opensou rce-s rc-4.3.2
    ./configure
    要查看configure的配置选项列表，可以运行./configure - help命令。
4．要编译Qt，可以输入命令：
  这样将会生成Qt库，同时也会编译所有的演示程序、示例程序和工具软件。在某些系统
  中，make命令称为gmake。
5．要安装Qt，可以输入命令：
    su―C"make install¨
  然后输入root密码。（在某些系统中，上述命令是：sudo make insdU。）这样就可以把Qt安装
  到/usr/local/Trolltech/Qt-4.3.2目录中。如果要改变安装路径．，那么可以在configure命令的
  后面使用- prefix选项来做到这一点。如果你已经对安装目录具有写操作权限的话，那么只
  需输入以下命令即可：    一
  make．install
6．为Q设置二些特定的环境变量。
  如果使用的shell是bash、ksh、zsh或者sh，那么请把以下两行代码添加到．profile文件申：
  PATH=tusr<F}o'caL/T:roll,lt.e‘h/Qt-4,3.2/bi“：$PATH
  export P#
  如果使用的shell是csh或者tcsh，那么请把下面一行代码添加到.lo~jn文件中：
  setenv PATH /usr/local/Trolltech/Qt-4.3.2/bin:$PATH
  如果使用了configure的-prefix选项，那么请使用你自己指定的路径来代替这里给出的默认
  路径。
  如果你正在使用的编译器不支持rpath命令，那么还必须扩展LD_LIBRARY_PATH环境变
  量，使其包含/usr/local/Trolltech/Qt-4'.3. 2/Lib。对于带有GCC的Linux用户来讲，则没有必要
  执行这一步。
    Qt有一个演示程序qtdemo，它可以充分地展示Qt库中的许多特色。也可以把它看成是开始
查看Qt功能的完美工具。要查看Qt的文档，既可以访问http://doc,trolltech.com网站，也可以运行
Qt助手，它是Qt的一个帮助程序，只需在控制台窗口中输入assistant命令即可把它调出来。
附录B  编译Qt应用程序
    编译工具的使用很大程度地简化了Qt应用程序的编译工作。我们可以使用三种方法来编译
Qt应用程序：第一种方法是使用Qt提供的qmake工具，第二种方法是使用第三方的编译工具，而
    h  ’
第三种方法是使用集成开发环境(IDE)。
    qrnake工具可以使用与平台无关的．pro文件生成与平台相关的makefile。该工具包含了调用
Qt内置代码生成工具(moc、UIC和rcc)的必要的逻辑规则。在本书的所有例子中都使用了qmake，
在多数情况下会使用相对简单的．pro文件。实际上，qmake提供了很多的特性，包括创建可以递
归调用其他makefile的make6le，以及根据目前平台切换相关特性的开关状态等。本附录的第一节
将会介绍qrnake，并且会介绍它的一些高级特性。    。  ．I―  j    ~i’
    理论上，任何第三方的编译工具都可用于Qt的程序开发中，但使用可感知Qt（Qt- awue）的工
具会更容易些。第二节将介绍一些可感知Qt的编译工具。    。  ‘：  1―7；：
    ―些开发者喜欢使用IDE编译应用程序。Trolltech提供了可与Visual Studio+和。’Eclipse（如
图B.l所示）相集成的软件．并且提供了一些开源的IDE软件，如KDevalop和QDevelop，它们都是
使用Qt编写的，并且为Qt开发提供了极好的支持．。  ’    ．j!!：藏。。；：一j
B.1  使用qmake
图B.l使用中的集成了Qt的Visual Studio和Ecl/pse;、
    qrnake工具是与Qt -起提供的。它用来编译Qt本身，并且生成Qt自带的工具和例子。贯穿
整书，我们一直使用qmake工程文件（．pro文件）编译例子应用程序和插件。本节将系统（但非全
面）地学习．pro文件的语法，并且会介绍几个qrnake的基本概念。要想全面了解它们，请参阅
qmake指南的在线帮助文档http：//doc．trolltech．com/4. 3/qmake- manual.  html。
    ・pro文件的目的是列举工程中包含的源文件。由于qmake用于编译Qt及其相关工具，所以它
很熟悉Qt，并且能够生成一些触发moc、UIC和rcc的规则。因此，qmake的语法很简明，而且很容易
学习。
    工程文件主要分为三种：app(单独的应用程序)、lib(静态和动态库)和subdirs(递归编译)。工
440
C++ GUI Qt4编程（第二版）
程文件的类型可以使用TEMPLATE变量指定如下：
    subdirs模板可以用来编译子目录里的目标文件。在这种情况下i除TEMPLAIE= subdirs外，还需要
指定SUBDIRS变量。在每个子目录中，qmake会搜寻以目录名命名的.pro文件，并且会编译该工程。用
于本书例子中的examples．pro文件就使用了subdirs模板，可以分别在每个单独的例子上运行qmake。
    如果没有TEMPLATE这一项，那么默认工程是app。对于app或者lib工程，最常使用的变量是
下面这些：…    +  。  7    ．    ？
    ：    ，  ．．。，，’    ．    ，
    ・HEADERS指定工程的C++头文件(.h)。
    +-  一    ：    ，
    ・SOURCES指定工程的C++实现文件(．cpp)。
    -    1    ．    ’
    ・FORMS指定需要UIC处理的由Qt设计师生成的．ui文件。
    ・RESOURCES指定需要rcc处理的，．qrc文件。，    ，
  一．‘DEFINES指定预定义的C++预处理器符号。
    ・INCLUDEPATH指定C++编译器搜索全局头文件的路径。
    ・LIBS指定工程要链接的库。库既可以通过绝对路径指定，也可以使用源自Unix的一L和一l
 t    秣识符来指定（例如,'-Uusr/loc/Ulib和-ldb．．6赋）：  、
    l CONFIG指定各种用于工程配置和编译的参数。
一二j．QT指瓮孟穗蓊要使用的Qt模块（默认的是core gui，对应于QtCore和QtCiL模块）。
    ．VERSION指定目标库的版本号。
    ・TARGET指定可执行文件或库的基本文件名，其中不包含任何的扩展、前缀或版本号。（默
    认的是当前的目录名。）．i i    。‘j：√    ．    ，，  ．
’  ．DESTDIR指定可执行文件放置的目录。（默认值是平台相关的。例如：，在Linux上，指当前
  。一目。彝！：鸯Windows上，则是指：debug或release王目录。）
  ：    ‘  ，
    ・DLLDESTDIR指定目标库文件放置的目录。（默认路径与DESTDIR相同。）
    J    ．    一、    _    +
  CONFIG变量用来控制编译过程中的各个方面。它支持下面这些参数：
・debug是指编译具有调试信息的可执行文件或者库，链接Qt库的调试版。
一release。是指编译不具有调试信息的可执行文件或者库，链接发行版的Qt库。如果同时指
  定debug和release，则debug有效睁  ，    ．  一    ；、。    ’  ．，．i
。wam_ off会关闭大量的警告。默以情况下，警告的状态是打开的。一
．qt是指应用程序或者库使用Qt。这一选项是默认包括的。
一一du是指动态编译库。
・staticlib是指静态编译库。
．plugin是指编译一个插件。插件总是动态库，因此这一参数暗指dll参数。
，．console．是指应用程序需景写控制台(使用cout，cerr，qWaming()，等等）。
●app_Jxmde只适用于Mac OS x编译，是指可执行文件被放到束中，这是Mac OSx的默淡隋况。
・lib_bundle只适用于Mac OS X编译，指库被放到框架中j
    要生成工程文件hello. pro的make6le，可以输入：
    qmake hello．pro    ，  t
在这之后，可以调用make或nmake编译工程。：通过键入以下命令，也可以使用qmake生成一个Mi-
crosoft Visual Studio工程（.dsp或．vproj）文件：
附录B编译Qt应用程序
441
在Mac OS X系统上，可以创建一个Xcode工程文件：
要创建makefile，可以输入：
    +    。    t
    qmake -spec macx:_ g++ hello.pro
    。    t
    这里的- spec命令行参数可以用来指定平台／编译器的组合。通常，qmake可以正确地检测到所
在的平台，但在某些情况下则有必要显式地指定平台情况。例如，在linux上以64位模式调用Intel
C++编译器(ICC)生成makefile，应当输入：    一    ”    -二    +
    ：    ，，’一    ，    ，    一
    qmake -spec linux-icc-64 hello.pro
那些可用的规则在Qt的mkspecs目录中。  ？  √    ~    ’    ？i    “。“’
    -    ，，    ’    +    ．
    尽管qmake的主要目的是生成．pro文件的makefile，但也可以使用- project参数在当前目录下
    ．    -．  、    ‘∥    ：’
使用qmake生成．pro文件，例如：
    ．    ’  ：一    。    ．    1  +  √，  1  ~-    ?、‘i  ’
    ：qmake -project    。    一_    -．    二。≥+。  ：，二：，．f ti．j  -
    在这种模式下，qmake将搜索当前目录下县知扩展名、（．h、：．epp、，L，，笋等澜镑蓉纤，生成一个列
举这些文件的. pro文件。    ．二  一    _．  -_j：．：？置，：；、j{≯一、．
  本节的余下部分将更详细地介缉．pro文件的语法。’一个' pro文件胄妁；纂羁的零法通常具有
如下形式：    一．f．i．，、寰霹孑l”|。■：_：一：
    variab Ze=va Lues    ．    “：  ‘_  :1：‘，’i三二-：：  ，./j    .
value,s是字符串的列表。注释以井号(#)开头，在行尾处结束。例如：。一■、“’j：’7．，…．
    CONFIG=qt release warn二off    社I know.what工‘而+doing'-，‘‘  ．‘、，‘．  ’一、，一，？、，j_．1。．。'F  ?
将列表[“qt”，“releas。”，“wam_off”]赋给CONFIG变量，‘它会覆盖以前韵各个值，额外操榫符作为
：操作符的补充。+：操作符可以用来扩展变量的值j因此；一-‘∥：÷一j：_?_j‘：j：；j’‘7
    CONFIG:qt    +    .:7  ,，‘’‘i:.:.:.』.  _；一
    CONFIG+=release
    CONFIG+=warn_off    V-    .  ’    .’    :.  ,:‘.j.』  ..≤t一十17.≥’    i.、
这几行会和前面的例子一样，可以有效地把列表‘[“qt”，“release”，：：？wam_6巧”]赋值绪:CONFIG交量。
一：操作符从当前的变量中移除所有出现的指定的值。因此：．  √~i；  ’  …“．一一．。？
    CONFIG  =qt release warn_off    :    +    +    、    1‘:    、  -  1一    ‘  .:’、？
    CONFIG一=qt    ．：    ：    ’、，：  ‘    ‘，一    ’
会使CONFIG的值变成[“release”，“warri._ off'’]。*=操作在一个变量上添力口、一个值，，但要求被添加
的值不在变量的列表上；否则，就什么都不做。例如：    ‘  。  一  一
    SOURCES+:main.cpp    :    .    .    ,、    ’  ;.  :
这一行将把mam．。pp实现文件添加到工程中，只有当还没有被添加的情况卞才添加它。‘最后，=
操作符使用指定的值替换符合正则表达式的值，这是二种类似手sed（UNIX流编辑器）的语法。
    ．    ‘，  ’    ．    ，    ．、．    7；
例如：
  i  SOURCES~：s八．cpp\b/. cxx/    一．．    一：j。    ，  ‘；二
使用. cxx替换SOURCES变量中所有.cpp文件的扩展名。
    在值的列表中：，qn/ake提供了访问其他qnake变量，、环境变量和配置参数的方法。图B.2列举
了这些语法。，
C++ GUI Qt4编程（第二版）
┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━┓
┃                            ┃                                    ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━┫
┃$$tXIr Name或者$${varName}  ┃・pro文件中qmake变量在那一时刻的值  ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━┫
┃$$(varName) .   '           ┃当qmake运行时环境变量的值           ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━┫
┃$( varName)                 ┃当处理makeflle时环境变量的值        ┃
┣━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━┫
┃$$『var Name]               ┃Qt的配置参数值                      ┃
┗━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━┛
图B.2 qmake的存取函数
    前面的例子中使用的总是一些标准变量，例如SOURCES和CONFIG，然而，我们也可以设置任
意变量的值，并且可以使用$$varⅣame或者$${varName}语法引用它。例如：
    MY_ VERSION  =1.2
    SOURCES_BASIC=alphadialog.cpp＼
    main．cpp＼
    windowpanel.cpp
    SOURCES_EXTRA=bezierextension.cpp＼
    xplot,cpp
    SOURCES    =$$SOURCES_BASIC＼
    $$SOURCES_EXTRA
    TARGET    =imgpro_$$jMY_VERSIONJ
    接下来的例子组合了前面介绍的几种语法，使用内置函数$$lower()把字符串转换为小写：
    # Lis't of classes in the pro'ject
.- FIY-tLAS诣S。。、'-.-rAffn.atation＼    ：
    CiyBlock＼
    一-。：c式海苕眯＼，
    CityView
# Append
SOURCES
SOURCES
SOURCES
# Append
HEADERS.
HEADERS
cpp extension to lowercased class names, and add maLn.cpp
   = $$lower($$MY_CLASSES)
    一= s/([a-z0-9_]+)/\l.cpp/
 . += main.cpp
h~ extension to lowercased class names
  .  ; $$lower($$MY_CLASSES}    .' '                .
  N= s/([a-z0-9_]+)/\l.h/
    有时可能需要在．pro文件中指定包含空格的文件名。在这种情况下，只需简单地把文件名用
引号括起来即可。；
。当在不同的平台上编译工程时，可能有必要基于平台指定不同的文件或者不同的参数。
qmake的条件判断语法是：‘．==
    condition{
    ，-
    then-case
    ) else{
    else-case
    )
    conduion,部分可以是平台名字(例如，win32、UIUX或者macx)，或者更复杂的断言。then,- case和
eke;case都分使用标准语法为变量赋值。例如：
    win32{
    SOURCES+=serial_wir..cpp
    )else{
    SOURCES+=serial_unix.cpp
    )
    else分支是可选的：为了方便，当therv- case部分仅有一条变量赋值，而且在没有else-case分支
时，qmake也支持单行形式的语法：
    condition: then-case
    附录B编译Qt应用程序443
    _____..____-__-_---_-________-。一
_-___.____r.____________。一
例如：
  如果有几个工程文件需要共享相同的项，则可以把相同的项提取到单独的文件中，在各自的
・pro文件中使用include()语句包含它们：  ．
    include( ,./common.pri)
    HEADERS    +=window.h
    SOURCES    +=main.cpp＼
    window．cpp  一    1
通常，打算被别的工程文件所包含的工程文件会带有7．面（工程包含）的扩展名。
    在前面的例子中，我们了解了$$lower()内置函数，它可以返回参数的小写版本。另外一个有
用的函数是$$。y。tem()，它允许我们从外部应用程序中产生字符串。例如，如果想要确认当前使用
的UNIX版本，可以这样写：    ：  ，
    OS_VERSION=$$system(uname -r).
然后，可以在条件中使用结果变量，并与contains()合用：
    contains.(OS_VERSION, SunOS):SOURCES+=mythread_sun.c
    e    ．    1  ≈这童所刮
    本节只讲了一些表面的东西。甲扭ke工具提供了许多多数和特性，远多于    牛到的这些，
包括对预编译头文件的支持、对Mac OS x通用二进制库的支持以及对用户定义的编译器或者其
他工具的支持等。对于这方面更多信息的了解，可以参考qmake指南韵囊鲮杀助文档。
B.2使用第三方编译工具
    许多编译工具都可以用于编译Qt应用程序，包括开源的和商用的。这些工具可以分成两大
类：一类是生成一些makefile（或者一些IDE工程文件）并且依赖于标准编译系统的工具；另一类是
不需要外部编译工具的单独的编译系统工具。
    本节将介绍三种工具，它们都可以对Qt提供内置支持，或者是比较容易使用的：第一个工具
是CMake，它可以生成一些Ⅱ础．efile；另外两个分别是Boost．Build和Sco璐，它们则是单独的编译系
统。对于这里给出的每个工具系统，我们将介绍如何编译第‘3章和第4章中开发的Spreadsheet应
用程序。如果要评估任何新的编译工具或者编译系统，都需要详细地研读并且对实际的应用程序
进行实验，但我们希望在此给出的简短介绍能够说明这一问题。    ’
Cmake：跨平台的Make
    CMake工具是一个开源的跨平台makefile生成器，它内置了对Qt 4程序开发的支持，可以从网
站http://wvnv.cmake.org/申获取它j为了使用CMake，必须为工程创建一个CMakeLists．txt文件来描
述它，该文件很像是一个qmake．pro文件。下面是为Spreadsheet应用程序写的CMakeLists．txt文件：
    project(spreadsheetJ    ,
    cmake_.minimum_requ'red (VERSION 2.4.0)
    find~package(Qt4 REQUIRED)
    include(${qT―USE―FILE¨
    set(spreadsheet―sRCS
    CeU．Cpp
    finddialOg．Cpp
    gOtOCelldialOg t Cpp
    main．Cpp
    mainWindOW．Cpp
4 44
C++ GUI．Qt4编程（第三版）
  sortdialog:cpp'; ':
  spreadsheet:;cpp ; i:
)              .
set(spreadsheet_MOC- SRCS
' finddialog.h .
        gotocelldialog. h
   .    mainwindow. h
${spreadsheet_MOC_SRCS})
 $Jspreadsheet UIS})
UI${spreadsheet_UIS_H})
)RCC_SRCS ${spreadsheet_RCCS})
    torget_link_lib+aries(spreadsheet $jQT_LIBRARIES) pthread)    :  ‘
-  文件的犬部分都是麓鹣韵模板文件苫我们必须填写的那些与应用程序相关的项目就是应用
程序的名字（磕碧喜争行）≯。印p源文件的列表，illi文件的列表，以及．qrc文件的列表。对于头文件，
CMake会足够聪明．沱籀鼬多自己判断出它们之间的依赖关系，因此不需要指定o.然而，由于用于定
义Q_OBJECT类的．h文件需要被moc处理，所以必须列举这些文件。，  一
    开始的几行会设荤应用程序的名字西为Q 4添加CMake的支持，然后设置一些变量保存文件
名。qt4_wrap_ cpp()俞令会以给定的文件来运行moc，同样，qt4_wrap_Lu()会运行LUC，：而qt4_ add_
resources()则可以运行_rcc。为了创建可执行文件，需要指定所有的- cpp文件，包括由moc和．rcc所
生成的这些文件。最后。，，必须指定可执行文件要链接的库，这里会指定那些标准的.:Qt4的库和线
    ，‘j’  ．
程库。
    ．。，．'-    ．    ．    ‘。‘。．    ’一    ，    -．
    CMakeLists．txt完成以后，就可以使用下面的命令生成makefile：
该命令会告诉CMake读取当前目录下的CMakeLists．txt文件并生成Makefile:文件。然后，可以使用
make(或者nr．1ake)来编译应用程序，并且如果想从头开始编译，那么只需执行make：clean即可。
Boost .Build(bjam)  .;  i.    1…、.7“    ,  .“.、    :.
    一’乍，  ‘．1t●’  ”i-j、  、‘。    ’  ’    ：、+  ’    ：    ．
    Boost C++类库包含它们，自己嗨编译工具，称为Boost.Build或者bjam，其免费文档位于http：／／
www. boost．org/tools/build/v2/。该工具的第2版提供对Qt 4虚用程序的内鬣支持，但前提是要有一
个QTDIR的环境变量，以用来指定Qt 4的安装路径。有些Boost.Build的安装版在默认情况下是不
支持Qt的。对于这些版本，必须编辑user-config.jam，添加如下一行代码：
除了依赖QTDIR之外，还可以这样修改前面的那行代码来指定Qt的安装路径：
    using qt  :  /home/kathy/opt/qt432  ;    ,
  使用Boost. Build编译的任何应用程序都需要两个文件：boost-bLuld,jam和Jamroot。事实上，对
                                                       L/, IL.   I IJ G
               .    u  lu o=
                       '     o cn o o co           r.
    H H H._C LIJ t         cn
                                         l=,   l}n D, o        r.U
                              iJ   It -o   lO      H Of
                                a  - a) rD o -C),
                   a) a) o oz n Sg:l:l
            rl         '     c a) _e L   l-o u.
             =      cn       Ln -c }n o_l- ra Of Q Q U
         cn  .      u u   -o cn -o u7 0 0 ffl,E E Of
         H Ol  R L    m -o rD C D L   I  l, l
    -C    = o rl    CI:, CT    o m O u7  l  O_ IJ IJ 4   IJ
C  .      l- =      I .    L a) t- o -- Ln a) o o o
 . IJ    iJ ra  .    rJ rJ    o_ L a u cn C ~} o o o
c:n a)    O rl g   a) o    cn a cn L C O _C _C _C _C
o a)    a) -o o    a) a)  ( cn( = o _ }n Ln \n {n
- -C     C - -    -C -C     o- C o- o rl O -C, -O -C, -O
m cn    cn - rD    cn cn    o_.+ o_ Ln r- m m m rD ra
rl -O    -O O rl    -O -O     U =, U,O rl IJ O O O O
-o rD    ra u -c,    m m     I  I  IL.C = L L L L
iJ a)    a) o rJ    o a)    o_ a a   l-rl U a O a a
L L    L IJ L    L L    m m m -o .+- o u7 cn cn Ln
o o-    o- o o    o- O-          L -C, O X '-d'-d'-d'-r
cncn cn gcn ' -    w111 4
    -    -     131m:nlol*n'
          IJ          IJ
      -- cn      __ Ln   .
附录B编译Qt应用程序445
于任意多的应用程序我们只需要再复制boost-build.jam -次，并且只要把它放在包含所有应用程
序目录的那个目录下（无论嵌套有多深）即可。boost-build.jam文件只需要包含一行指定编译系统
安装路径的代码即可。例如：    ，  ．  。  ，一．  ．
    boost-build /home/kathy/opt/boost-build;    j…
    ，  1    1  ‘
    用来编译Spreadsheet应用程序的Jamroot文件如下所示：
    using qt:/home/kathy/opt/qt432;    ’    ‘
    exe spreadsheet:    J    ,.,.’    -
    cell, cpp    一，    。一，  ．
    finddialog,cpp    ，  ～，‘
    finddialog,h
    gotocell.dialog,cpp    ’    ,    t.
    gotocelldialog.h -    1‘    、  .t。  一．
    gotocelldialog.ui
    main.cpp    ,  ’  .’    ..  “?  --,,..    ...
    mainwindow.cpp    一一j?  、    一
    mainwindow-cpp    '1.    .’    ‘    _.¨|..  Y.
    mainWindoW.h    ’    =:‘    .  ．    一    -    -    .:..
    so rtdialog. cpp    ―j    一二，．、一．  ：jr.，．．、一：，、：：、_i．
    sortdialog.h    ‘一    t’  √  ‘    ：
    sortdialog.ul    ’    ?’:！j-‘_’+!j?  ‘.‘
    spreadsheet.cpp    ,:.jj.:  ::：二‘=‘‘一‘
    spreadsheet.h    ‘.-一’:●’’i'
    spreadsheet.qrc    j‘  :~,’÷.;,:”、口。j‘,i二；
    /qt//QtGui    i:_7.:、．一÷:7.i:、::’.:
    /qt//QtCo re；    ：‘    一．．‘，二‘j；．~二蟛悖！：“‘  ～-
’  其中的第一行加入了对Qt 4：的支持。i我们必须在此提供Qt 4""1YJ娶鞭髂径“接着i指定可执行
文件的名字为spreadsheet，并且列出那些依赖=文件。对手头文件.;:B'dostt.Build:足以推断出它们之间
的依赖关系，因此通常不需要再列举它们。然而，．由于必须使用；矗&处理那些定义了'[Q- OBJECT类
的．h文件，所以必须列举它们。最后两行指定了想要使用的。Qt;库j．二．？：：-一'  _、：。1“：j。。
    假设bjam可执行文件位于当前路径下，可以使用下面的命令编译应用程序+：：i‘一一i
    bjam reLease  .,’    ,,√-.,.  .    ..i+  ,j  ::,i j 7.._.、:¨  ,  i  .、
    r    ：    ‘    ．I’、’    1    ．    ，
它会告知Boost.Build以发行版的方式编译当前目录下Jamroot：文件所指定的应用程序。（如集只安
装了Qt的调试版，则会产生错误j这种情况下可以’运行bjatn debug。）在必要的情况下，可以运行
moc、UIC和rcc工具。想要清除结果，可以运行bjam clean release。
    一  ，-。。一    …  。。    、  ：、’．i    二    ．  ．：‘
SCons:软件构建工具
    SCons工具是一个基于毋thon的可以替换tnake的编译工真漠向班趸：http：//www.scons::org//电
可以对Qt 3提供内置支持，遂有一个支持q‘'4，酌插件：它由’Davd Carc;a G壶6r;提供j，网妊是’http：
／／Ⅵw.iua. upf. edu/~  dgucia/Codders/sconstools．html。从该网站可以下载一个文侍qt4';py，应该担它
放到与应用程序相同的目录中。在未来适当的时候，该扩展将会包含到官方的SCons发行版中。
    一旦把qt4:py放到了适当。的位置，就可-苡创建二个SCorist/uct-.文痒柒指定编译条件：
    -  ：    ：  。  7j，i．．：,f：．..．  一．一’t蔓，    ．。！-．( ,'i
    群！/u'sr7bin/env pythdn..
    、‘  i―r c。。，、一，．。’．  ，一i’、一-j 0．‘”f_  ．i‘．一！+；    ：
    import os    ‘
    ．．    ，．    ‘：    ：  ，    ：，：1-‘_    。    ．    。
    QT4_PY_PATH=”，”
    QTDIR=“/home/kathy/opt/qt432“    ．
    pkgpath=os.environ,get("PKG二CONF'IG二PATi,-。”？)  “，，-‘X―j。’
    pkgpath+=”:96s/lib/pkgconfig“%QTDIR
    os.environ[“PKG―CONFIG- PATH”】=pkgpath    ’：一‘'    ,  .
    os.environ[“QTDIR”】2 QTDIR
{    ;.    ,.,．    一，,:  ,  i j l.::‘:  ,j一’i::.:j,j  r.,。一-,    ’、
446    C++ GUI Qt 4编程（第二版）
env  =  Environment (tools= [ "default" ,  "qt4 " ] ,   toolpath= [QT4_PY_PATH] )
env["CXXFILESUFFIX"] = ".cpp"
 env.EnableQt4Modules ( [ "QtGui" ,   "QtCo re" ] )
rccs -. [env.Qrc("spreadsheet.qrc", QT4_QRCFLAGS="-name spreadsheet")J
uis = [env.Uic4(ui) for ui in ["gotocelldialog.ui”, "sortdialog.ui"JJ
sources = [
       ,icell.ctpp", .
"finddialog.cp'p",
        "gotocelldialog,cpp" ,
"main.cpp",
: "mainwindow,cpp",   ' '
   "sortdialog.cpp", . . .
 ' "spreadsheet.cpp"】
env.Prog ram ( torget="spreadsheet " ,  'source= [ rccs,   sou rces ] )          .
这个文件是通过Python写出来的，因此我们可以使用Python语吉的所有特性和库。
    文件的大部分都是样本文件，只有几个与应用程序相关的项。首先设置qt4.py和Qt 4的安装
路径。通过把qf4.py放在一个标准的位置：并设置相应的路径，就可以避免把它复制到每个应用
程序目录中。我们必须显式地启用Qt模块，这里是QtCore和QtCui，必须指定需要rcc或IUC处理
的文件。最后，我们列举源文件，设置程序名字，以及它依赖的源文件和资源文件。我们不需要指
定．h文件，Qt4足以通过检查.cpp文件正确地运行moc。
    现在，可以使用’南ons命令来编译该应用程序：
scons
它将编译当前目录下SConstruct文件所指定的那个应用程序。也可以使用scons―c来清除结果。
附录CQt Jambi简介
    Qt Jambi是Java版的Qt应用程序开发框架。Qt Jambi的核心部分是Qt的，C++库；Java程序员
可以通过Java的本地接口(Java NaUve Interface，JNI)使用它。尽管在把Qt Jambi集成到Java中作了
许多努力，以使它的API可以被Java程序员正常使用，但C++ tQt程序员仍然可以感觉得到这些
API是熟悉而且是可以预见的。所有类的文档都使用Javadoc生成，请参阅http://doc.trolltech.com/
qtjambi/。    ．：一
    ．    ．    +j’  。
    目前，Java GUI程序员不得不使用AWT、Swing、SWT和类似的GUI类库，但它们都不如Qt方便
和强大。例如，在传统的Java GUI库中，需要把用户的操作，例如点击按钮，连接到相应的具有事
件监听类的方法中；而在Qt Jambi中，只需要一行代码就可以完成同样的事情。而且Qt的布局管
理比Swing的BoxLayout和GridBagLayout要更好用些，并且可以生成更好的外观。
    ．  ：    ‘
    Qt Jambi应用程序使用具有菜单条、工具栏、停靠窗口、状态栏的主窗口，就像使用C++编写
的Qt应周程序。它们还具有与平台相关的外观，并且兼顾了用户对主题、廖泡N字体等的偏好。
在Qt的鼎力支持下，Qt Jambi应用程序可以使用Qc强大的二维图形体系（特别是图形化的视图框
架）及其扩展，例如OpenGL。
    1    ∥；，，：芷t■  、’    ．
    Qt Jambi的好处不只局限于Java程序员。特别是C++程序员可以使用程序生成器工具把他
们自定义的Qt组件转换成Java程序员同样可以使用的组件，该程序生成器工具与由Trolltech提供
的用于把Qt的API转换成适用于Qt Jambi中API的那个工具相同。
    本附录将介绍Java程序员是如何使用Qt Jambi来创建图形用户界面应用程序的。然后，将介
绍如何在集成了Qt设计师的EcLpse中使用Qt Jambi，最后介绍如何让Qt Jambi程序员使用那些自
定义的C++组件。本附录将假定你很熟悉如何使用C++ tQt和Java进行编程。而Qt Jambi则需要
使用1.5版或者更高版本的Java。    +
C,l  Qt Jambi入门
    在这一节中，我们将开发一个小的Java应用程序，用于显示如图C.1所示的窗口。除了窗口
的名字外，Jambi Find对话框与第2章创建的Find对话框有相同的钋观和行为。通过使用相同的
例子，可以更容易地了解C++ tQt和Qt Jambi程序开发的不同点和相同点。在阅读代码的同时，我
们将讨论C++和Java在概念上的不同。
    图C.l   Jambi Find对话框
Jambi Find应用程序的实现放在一个称为FindDialog,java的文件中。我们将分段介绍该文件
  448    C++ GUI Qt4编程（第二版）
  r;_  ___________‘________________‘______一
_____._______’.-____.__._-_‘_一
的内容，首先从unport的声明开始。
impo rt  com.t rolltech.qt. co re ,*;
import com.trolltech,qt.gui.*;
    在这两行的作用下，两个import声明使Java可以使用Qt的’core和GUI类。同样可以使用类似
的import声明方式导入其他的那些类（例如，lmport com.U-olltech.qt.opengl.*）。
public. class FindDialog extends QDialog {            ...
    FindDialog类是QDialog的一个子类，就像在C++版中所做的那样。．G++在头文件中声明信
号，依靠moc工具生成支持的代码。在Qt Jambi中，Java的内省技术用来实现信号和槽机制。但仍
然需要一些声明信号的工具，这可以通过一些SignalN类来实现j  '
public Signa12<String, Qt.CaseSensitivity> findNext =
           new Signa12<String, Qt.CaseSensitivity>() ;
public Signa12<String, Qt.CaseSensitivity> findPrevious =
    .      new Signa12<String,  Qt,CaseSensitivity>() ;       :
    寸共有。10个SighlN类-Signal0，'$ignall'41>，…,'Signa19‘<，I'l，．．：，T9>。名字中的数字代表
它们带的参数数量，类型Tl，…，T9用于指定参数类型。这里声明了两个信号，每个信号都带两个
参数。在这两种情况下，第一个参数是Java String，第二个参数是Qt. CaseSensitivity，这是一个Java
型的枚举。在Qt API中使用QString的地方；在Qt Jambi中则使用String来代替。
    不像其他的那些- SignalN类，Signal0不是_个泛型类。为了创建_个没有参数的信号，可以这
    Si    、一    ．    ，    ^
样使用Signal0:
    r    ¨‘：。i
    public Signalo somethingHappened:new Signal0();    ‘
    创建完信号，就可以开始介绍构造函数的实现了。函数很长，因此分咸三部分来介绍。
public FindDialog(QWidget parent) {
      super(parent) ;             .
    '.   .   label: -. ,new. QL曲el ( t r (,.";Find. &what: " 1 ) ;
 ;...。：‘  lineEdit- =. ne,,tiQLineEdit'( ) ;:.   .
         labeL.:SeltBuddyflineEdit'): :.:  '-,
caseCheckBox = new QCheckBox(tr("t4atch &case"》;  .
backwardCheckBox = new QCheckBox(tr( "Search &backward"》
findButton
findButton.
findButton.
closeButton = new QPushButton{tr( "Close"》
／
在Java和C++中创建窗口部件的唯一不同点就是语法的细节稍有不同。注意tr()会返回一
个String，而不是一个QString。
lineE dit. textChanged. connect (this,   "enableFindButton( St ring)”);
fin dButton. c.licked. conne ct{t hl:s,。"'findCljckedH”);    ,:’
closeButton: clidked. conr/ect (this:、“rej.ectl)“);
一    ’    1    ．^，  l    。：
在Qt JJ哪M中，信号一槽的连碡语法跟一c++／q稍有不同，但仍然很简洁。
法是：
r    _    一
    ＼    ，‘．-_一    ：
sende;r.sign.aZName.connec;t(.receiver, ".sZo.tName{T1', 1_ .:. TN)");
一般情况下，其语
  不像c++ /Qt那样，我们不需要给信号指定签名。。如果信号的参数多于它连接的槽的参数，多
余的参数都会被忽略掉。此外，在Qt Jambi电；信号。槽机制不仅局限于．QObject子类，任何继承于
QSignalEmitter的类都可以发送信号，而任意类的任意方法都可以作为槽函数。
-o
C
rl
:
= .--
o- a)
= L ra
Ca iJ .-
-C((
cn p -O
O- =r
0 ra _o
  f ra
Q> o LU
 II  rn rn
附录C  Qt Jambi简介
QTransform transform;
transform.t ranslate (+50.0,  +50.0) ;
transform,rotate(+45.0) ;       .
t ransform.t ranslate (-50,0,  -50.0) ;
paj nte r. setWo rldTransfo rm ( t ransfo rm)';
painter, d rawText( pos,   tr( "Sales t' 》 ;
'QHBoxLayout  mainLayout  ='new QHBoxLayout () ;
mainLayout.addLayout(leftLaynut);, .  ,
 mainLayout . addLayout ( right Layout J ';
setLayout (mainLayout) ;                              ...'
setWindowTitle (t r( "Jambi  Find " 》 ;              . '
set FixedHeight (sizeHint ( ) . height( 》 ;    .     ,.'
．．。这些用于布局的代码几乎就是原来C++中韵原有代码；因而具有相同的布局和相同的效果。
在：Qt Jambi中，也可以使用Qt设计师创建窗体，地会使用到jtnc(用于Java用户接西的编译器)j找
们将在下一节予以介绍。．    i ,:  ．    ．．    ≥j一，‘_
    t    、  “-
private void  findClrcked.( ).
    . String text = lineEdit.:ext( )';'.';,
      Qt.CaseSensitivity cs = caseCheckBox.isCtiecked( ) ' '
          7 Qt,CaseSensitivity.CaseSensitive
       .  : Qt.CaseSensitivity.Caselnsensitive;
if  (backwardCheckBox.isChecked( 》 {
      findPrevious.emit(text,  cs) ;
      firidNext.emit(text,  cs) ;      '
    ：一：一一照孵弩圣’■．o．j
'j，●  ！j    ；：：
：一一  +．i．。∥一j 0、菇誊一’‘j’
。  ●  ：：，‘’’    j-  ．‘
    Java型枚举的语法比C++更详细些，但是很容易理解。要想发送÷个信号：：葡以使用SignalN
对象调用emit()函数，并传递一些正确类型的参数。在程序编译结束后‘，类型检查就完成了。
er/ableFindButton()函数本质上与C++的源代码相同。
private QLabel label;  .
private QLineEdit lineEdit;
private QCheckBox caseCheckBox; . "
private QCheckBox baclnvardCheckBox;
private QPushButton findButton;
private QPushButton closeButton;
    力了与本书其他的代码保持一致，我们声明所有的窗口部件都作为类的私有域。这纯粹是个
    |  '    ‘
    ～    -  、
风格上的问题，没有什么能够阻止我们在构造函数中声明那些只在构造函数中使用的窗口部件。
    ．，～    ，    ‘‘  。
例如，可以在构造函数中声明label和clo§eButton：因为它们不被别的地方引用，而且它们也不需耍
构造后就进行垃圾信息回收。因为Qt Jambi使用和C++ tQt相同的父一子类机制，因此一旦label和  。
closeButton创建成功，FindDialog窗体就是其所有者：在程序后台j它将保持对它们的引用，使其不
被销毁。Qt Jambi递归删除子窗口部件，，因此如果上层窗7口被删除了，该窗口将逐个删除其子窗口
和布局，以及它们的子窗口部件，直到整个清理过程完成为业。t．！？‘
IJ         .
o    .

C++ GUI Qt 4编程（第二版）
    Qt J砌血充分利用了Java的垃圾信息回收功能，因此不像AWT、Swing和SWT，如果最后一个上
层窗口的引用越删陵了，那么该窗口将被回收，而不需要显式调用dispose()。这种方法非常方便，
并且工作方式也与C++ tQt相同。但是对于SDI(单文档界面)应用程序要特别小心，我们必须保
持对创建的每个上层窗口的引用，以防止对它们的回收。（在C++ tQt中，SDI应用程序通常使用
Qt:：WA_DeleteOnClose属性来防止内存泄漏的产生。）
   public static void main(String[J args) {  .
                  ' QApplication .initialize ( a rg s ) ;
 .    .FindDialog dialog = new FindDialog(null)
           dialog.show() ;
 .   QApplication.exec(); .
      }
}         .
    为了方便，我们为FindDialog提供了main()函数，用以实例化一个对话框，并把它弹出来。un-
port com.trolltech.qt.gui.*的声明可以确保使用QAppLicat/on对象。当Qt Jambi应用程序启动时．我
们必须调用QAppLication.initialize()，并把命令行参数传给它。这就允许QAppLication对象可以处理
它所能识别的那些参数，例如- font和- style。
    当创建FindDialog时，我们把null作为父对象，以指明该对话框是顶层窗口。一旦mnain()函数
结束，对话框将失去作用，并且会被作为垃圾信息而加以回收。调用QAppLicatjon. exec()可以开始
事件循环，仅当用户关闭对话框时，控制权才会转到mnain()函数中。
    Qt Jambi API与C++ tQt的API很相似，但也有一些不同。例如，在C++中，QWidget:：mapTo()
函数有以下特点：
QPoint mapTo(QWidget *widget, const QPoint &point) const
    QWidget会作为非常量指针传人，而QPoint则会作为常量引用传人。在Qt Jambi中，等效的方
法有以下签名：
public final QPoint mapTo(QWidget widget, QPoint point) { ...
    因为Java没有指针，所以在方法签名中就没有可见差异来区分传给某个方法的一个对象是否
可似由该方法所修改。理论上，mapTo()函数应当可以修改任何参数，因为它们都是一些引用，但
    附录C QtJarr】bi简介    451
    _    __    _．二，．，――．-―-―一
  Q JaⅡrbi会保证不修改QPoiIlt参数，因为在C++中，它是作为常量引用而传人的。从上下文中，通
  常清楚哪个参数可以修改，哪个不可以修改。如有疑问，可以参考文档，以澄清该。隋况。  ：'
    除了不要修改值传递或作为引用传递的参数之外，Qt J锄bi也可以确保返回任何非void方法
    的返回值，因为在C++中将返回一个值或者一个常量引用，它们是一个独立的副本，因此改变它不
，  会产生副作用。    ‘  ．    +    l‘  ‘i，
    前面提到过，在Qt Jarnbi中，C++ tQt使用QString的地方，都可以使用Java的Stririg’来代替。’对
  于QCha。来说，也存在这种对应关系。在Java中，有两个可以与它对应：char和java.lang.Character。
  还有一些关于Qt容器类的类似对应关系：QHash可以被java.util.'HashMap代替，QList和QVector可
  以被java．util：List代替，而QMap可以被java.uul.SortedMap代替。‘此外，QThread也可以由java.
．lang．皿．read代替。    I一    √    ．    ，tj'
    Qt的模型／视图体系和数据库AP广泛使用了QVariant。该类型在Java牛是不需要的，因为所
  有的Java对象都可以把java:lang. Object作为祖先，所以在Qt J锄bi的全部API.tfa，QVariarit都可以
  用java.lang. Object来代替。Qv面ant提供的那些额外方法也可以使用？com.trolltech.qt.QVariant：的
  静态方法来代替。    ：‘    ，    ’J。．‘‘
  ‘    这就是对Qt J锄bi小应用程序的介绍，并且我们讨论了许多Qt Jambi和C++ tQt程序概念上的
    不同点。除了CLASSPATH环境变量必须指定为Qt Jambi的安装路径之外，，编译和运行’哒Jambi应
    用程序与其他Java应用程序并没有什么不同。我们必须用。Java编译器编译该类；然后使用Java解
    ‘    ‘}-
    释器运行它。例如：  ．
    expo rt  CLASSPATH=$cLASSPATH: $HOME/qtj ambi/qtj ambi.ja r:$PWD    …≯’’.‘  一。
    javac FindDialog.java    ’
    ’    】ava FindDialog    ”、
    这里，我们曾经使用Bash。heU来设置了CLASSPATH坏境变量，而基他的命令行解释器可能需
    Z
    要不同的语法。在CLASSPATH中包含当前路径就可以找到FindDialog类。在Mac OS x上，必须为
    Java指定命令行参数-XstartOnFirstThread，以使Apple的Java虚拟机可以处理线程问题。在Windows
    上，可以这样运行应用程序：’    、。．
    set CLASSPATH-%CLASSPATH%;%JAMBIPATH%＼qtjambi.jar;%CD%
    javac FindDialog.java    ‘    ．
    】ava FindDialog'
    ．Qt Jambi也可以用在IDE'中。下一节将介绍如何使用流行的Eclipse IDE来编辑、编译和测试
    Qt Jambi应用程序。    ．
C.2在Eclipse IDE中使用Qt Jambi
    Eclip。e集成开发环境（简称“Eclipse”）是多达60个开源工程的Eclipse家族中的一个关键软件。
Ecli口se对于Java程序员来说很熟悉，并且由于它是用Java写的，因而它可以运行在所有主流平台
上。Ecl/pse显示的那些面板的集合称为视图(view)。Eclipse可以使用很多视图，包括导航、大纲和’
编辑器视图，菜一特定视图的集合则称为透视图( perspecUve)。。    ．‘
    为了在Eclipse中可以使用Qt Jambi和Qt设计师，我们有必要安装Qt Jambi Eclipse集成开发
包。一旦该包被释放到适当的位置，就必须运行带- clean参数的Eclipse来强制它搜索新的插件．，而
不是依赖于它的缓存。在参数选择对话框中会出现一个“Qt Jambi Pteference Page”参数。很有必要
切换到该页，并且设置q Jambi的位置，这一过程可以参照http:  //doc．troⅡtech.  com/qtj ambi-4:3.2―
01/com/trolltech/qd qtjambi-eclipse．html。一旦设置和验证了路径，Eclipse．将会关闭并且重新启动，以
使新的设置生效。    ‘
452    C++．CU Qt，4编程（第二版）
    下次启动Eclipse时，可以单击File- New Project，弹出的NeW．Project对话框将提供两种类型的
Qt Jambi工程：Qt Jambi, Project和Qt' Jambi  Project( Using'Designer Form)。’本节将通过说明Qt Jambi版
本的Go to Cell例子（在第2章中开发的）来讨论这两种类型的工程。    。
    要想创建一个纯代码的Qt Jambi应用程序，可以单击File-*New Project，选择Qt- Jambi Project，
然后按向导进行操作。最后，Eclipse将创建一个工程，生成一个.java框架文件，它带一个main()
函数和一个构造函数。在Eclipse中，可以使用Run寸Run菜单运行该应用程序。Eclipse在编辑器
的左边可以显示语法错误，在一个控制台窗口中可以显示运行时的那些任意错误。
    创建一个使用Qt设计师的。Qt．Jambi应用程序与创建纯代码的应用程序类似。点击File―New
Pl:oject，然后选择Qt Jambi Project( Using Designer Form)。将会出现一个向导。把工翟命名为JambiG-
oToCell，在最后一页，指定类名为GoToCellDialog,并且选择Dialog作为窗体类型。  ‘
    一旦向导运行结束，将生成一个GoToCellDialog.java，以及一个Java’用户接口文件GoToCellDia-
log.jui。双击.jLU文件会调用Qt设计师编辑器。将会出现一个带有OK和Cancel.按钮的窗体。．要
访问Qt设计师的功能，可以单击Window寸Open Perspective-*Other，然后双击Qt Designer UI。这一
透视图会显示Qt设计师的信号一槽编辑器、动作编辑器、属性编辑器、窗口部件箱以及其他工具箱
等等，如图．C.2所示。
图C.2 EcLipse中的G0 to Cell对话框
．，为了完成设计，可以执行第2章中同样的步骤。可以在Qt设计师中预览该对话框，同时由于
Eclipse生成了框架代码，点击Run―Run也可以运行它。
    最后的步骤是编辑GoToCellDialog.java文件，实现需要的功能。Eclipse生成了两个构造函数，
但只需要一个；因此删掉没有参数的构造函数。在生成的main()方法中，必须传人nuU.作为GoTo -
CellDialog枸造函数的父对象。同样，必须实现GoToCellDialog(QWidget  parent)构造函数，并且提供
一个on_lineEdit_ textChanged( String)方法，它可以在发送行编辑器的textChanged()信号时得到调用。
这就是GoToC ellDialog.java文件：
    impo rt  com.t rolltech.qt. co re.*;
    import com.trolltech.qt.gui.*;    ,,
    附录C  .Qt Jambi简介’453
    ，    “．    r
pubt/c class. GoToCellDialog extends QDialog { " .  . .r,.:.. : -  .  :J .:..J::.:  .' .
 ... : private Lli_GoToCellDialogClass ui = .new U.i_,GoToCelll
                             '- . . ;llDialogClass..()-l:
   public GoToCellDialog(QWidget parent) { . .      \  '        .
    super(parent);            .   . . .   . .
ui.okBLjtton. setEnabled ( false) ;'
QRegExp  regExp = new QRegExp( " [A-Za-zll [-1-9] [0-9] {0',2}") ;  ' . .
ui.lineEdit . setValidator ( new  QRegExpValj dato r( regExp,   this 》 j
ui.okButton.clicked. co.nnect ( this ,  "accept ( ) " ) ;
ui.cancelButton. clicke'd . connect ( this,  "'reject ( ) " ) ;
public static void main(String[J args) {
         QAppljcation . initialize (.a rgs ) ; .
   G,oToCellDialog testGoToCellDialog = new GoToCellDialog(null);
  testGoToCellDialog.show();                  ' .
QApplication,exec();
  Eclipse员责调用juic，用来把GoToCellDialog
个Ui_ GoToCeUDialogClass类，由此生成Qt设计师
它的引用保存在私有成员Ul中。
t一等堪≮，
．‘：蘩’！i，
    在构造函数中，我们调用Ui_GoToCellDialogClass的setupUi()方法创建和布局窗口部件，设置其
属性，以及信号―槽连接，包括依照名字规则on_objectName_sigrialName()自动连接槽。’~
    Eclipse集成的一个方便的特性是很容易把窗口部件箱中QWidget的子类拖到窗体上。我们将
简单地介绍LabeledLineEdit泊．定义窗口部件，然后介绍如何在Qt设计师的窗_|j部件箱中使用它。
    当使用Qt设计师创建自定义窗口部件时，通常要为程序员提供一些习供萁穆改韵自定义窗
口部伴属性，这并不是什么难事：图C．3显示了一个窗体中的自定义窗口部件LabeledLineEdit。该
窗口部件有两个自定义属性，labelText和editText，可以在属性编辑器中设置它们。在C.++ tQt中，
属性使用宏Q_PROPERrl'Y()定义。在Qt Jambi中，内省机制用来检测存取函数对，它们遵循Qt的
1:XX( )/setXa:x()命名习惯，或者遵循Java的getXxx( )/setX,:x()命名习惯。也可-以指定其他的属性，
以及使用注释自动隐藏检测到的属性。
import com.trolltech,qt.*;
import com,trolltech.qt.gui.*;
public class LabeledLineEdit extends QWidget {
    -    -
    第一个import声明是为了访问Qt Jambi的@QtPropertyReader()和@QtPropertyWriter()注释，它
允许我们向Qt设计师中导人属性。
    ：    、

454    C++ GUI Qt 4编程（第二版）
    对于只读属性，可以简单地使用@ QtPropertyReader()注释，并提供一个getter方法。这里我们
想提供读一写属性，因此既有getter又有setter。对于本例，我们忽略注释，因为访问方法依照Qt的
命名规则。
图C.3窗体中的IabeledLineEdit自定义窗口部件
public LabeledLineEdit(QWidget parent){
       super(parent) ;
label = new QLabel();
lineEdit = new-.QLineEdit();
label.SCrtBuddy(lineEdit) ;
QHBoxLayout layout - new QHBoxLayout(.);
layout:addWidget (label) ;
layout.addWidget (lineEdit) ;                 .
setLayout(layout) ;               .
    private QLabel label;    ,  i  “.’    f
    private QLineEdit lineEdit;‘
    ／”  一
  构造函数比较常规。为了能够在窗口部件箱中使用，必须提供一个带有QWidget参数的构造
函数。
public static void main(String[] args) {
          QApplication .initialize ( a rg s ) ,;   .
   LabeledLineEdit testLabeledLi'neEdit = new LabeledLineEdit(null)
            test Labeled LineEdit. set LabelText ( "&Test " ) ;
     testLabeledLineEdit.show() ;      .
      QApplication.exec() ;      .
                                                                                                                                       .
    Ecl/pse舍自动生成main()函数。我们把nuU传人LabeledLineEdit的构造函数，添加一行设置
标签的文字属性。
    一旦拥有了自定义的窗口部件，就可以将其.java文件复制到包浏览器中工程的src下。然
后，调用工程的属性对话框，单击Qt Designer PhWns
页。该页列举了工程中所有合适的QWidget子
附录C  Qt Jambi简介
类。只需选中Enable plugin选项就可以在窗口部件箱中看到这些子类，然后点击OK。下次用Qt
设计师编辑窗体的时候，就可以在窗口部件箱底部看到作为插件添加进来的窗口部件了。
    这就是对于在Qt Jambi编程中使用Eclipse的简单介绍。Eclipse提供了功能强大的便于软件
开发的IDE。正确地集成Qt Jambi，也可以完全在Eclipse环境下创建Qt Jambi应用程序，包括Qt设
计师的使用。Trolltech也提供了C++/Qt Eclipse集成，与Qt 'Jambi  Eclipse - -样具有很多优点。
C.3在Qt Jambi中集成C++组件
    Qt Jambi允许C++程序员很容易地在Qt代码中集成Java。为了使自定义的C++组件可以在
Qt Jambi中使用，可以馋用Q Jambi的生成器，它包含一个C++头文件集以及一个XML文件，该文
件提供了我们想要包装的类，这些类为C++组件提供了Java绑定。Qt Jambi API本身使用生成器
生成。
    图C.4阐述了这一过程。运行生成器之后，我们获得一些Java文件，必须使用Java编译器编
译它们，还有一些．h和.cpp文件，把这竺文件一起编译到C++动态库中。
图C.4在Qt JaHlbi中使用c++的类
    为了阐述这一过程，我们将绑定第5章开发的Plotter窗口部件的PlotSettings类。然后，我们将
在Java中使用绑定。图C,5展示了应用程序的运行情况。
    头文件必须定义（或包含其定义的头文件）编译库所需的全部类：
    #include <QtGui>
    #include”.一./plotter/plotter,h“
  ，    i    ．？    ’    ’+    ．    ：-    ，。  _．    ’    t：
C++‘GⅥQt：4编程（第二版）
图C.5   Jambi Plotter应用程序
    假设Plotter例子的代码位于Qt Jambi打包器的同级目录T≥我们也需要_个XML文件，告诉
生成器要打包什么，以及如何打包。文件’的名称是jambiplotterixml:一    ，：  ，    ’
 <typesystem  package="com.softwa reinc. plotter"             '.
          .  defa'ult-superclass="com.trolltech.qt.QtjambiObject"> . .   '. .
;.   ' -:   /;lo ad-t jjpesy 9tZfrF~ffle_,r85 t;rollt et h/geite ra to r/t ypesys tem_co re , t xt "
                     generate="no" />                       .
    <load-typesystem name=ii:/trolltech/generator/typesystem_gui'.txt"; .  : ."
    <object-type name="Plotter" />
, : ;- <vaLlr.ettype:;'najne="Plo'tSet;tings".  >"' ::  '. . -.,  /一：：7
</typesystem>
    在钋层的标签中，我们为Plotter组件指定称作com.softwareinc.plotter的Java包。<load-typesys-
tem>标签导入关于QtCore和QtGtu模块的信息。    -_．：    r：。，。
    <object-type>和<value- type>标签指定我们要使用的两个C++类。我们已经指定Plotter类是
一个C++“对象类型”。这适合那些不能被复制的对象，例如窗口部件。相反，PlotSettings类被看作
是C斗十的“值类型鼍o．  '。    一_    ’
    对于Qt Jambi：用户．o这两者没有明显的不同。当生成器从C++ API映射到Java API时，区别就
明显了。例如，如果方法返回“值类型”，那么生成器将确认返回一个新的独壶的对象（为了避免副
    ．    ，，一’  ，
作用），但如果返回的类型是对象类型，那么将返回原始对象的引用。
    我们将需要两个环境变量，一个指定Qt Jambi路径，另一个指定Java路径。在UNIX系统下，
可以这样设置(使用Bash shell)：    ’
    export JAMBIPATH=$HOME/qtjambi-linux32-gpl-4.3.2_01
    expo rt  JAVA=/us r/j ava/jd kl.6 0_02    。
    Windows    ^+    ．    ，
在Windows下，应当写成：
    set JAMBIPATH=C:\Qtjambi
    set JAVA=“C:\Prog ram  Files\Java\j dkl.6. 0_02“    ,    .,
    当然，在你的系统中，版本号和目录可能不同。从现在开始，假设JAMBIPATH和JAVA都已设
置好。一旦拥有头文件和XML文件，就可以在控制台中运行生成器，：，，
如果Qt．Jambi被安装在本地目录而不是系统目录下，那么在某些系统上，命令将执行失败。
                                                       "'FH黍C :. Qt Jambi:简介 . .                              '        457
解决办法是为QtJaⅡi：洲 J库提供‘个合适的路径∥．。．缸一j≮。。“0。，苇’；
    、    ．
    export LD_LIBRARY::PATH-$LD.LIBRARY PATHi'$JAMBIPATH/lib'..L.,    ’:;,
    ‘    k
    ・-  ．'
    我们又一次使用了Bash shell的语法。在Mac．．OS X下，相应的环境变量称为DYLD_ lUBRARY
PATH。在Windows下，可以将其添加到PATH即可. ?
    …～    --。；  ：.
    set PATH-%PATH%;%jAMBIPATH%＼lib    一、
现在，在Windows F，可以像这样运行生成器：一  。
%JAMBIPATH9a\bin\gene rato r 'j ambiplotter. h  .jqmbiplotte r,xmi .       .   :'.     .     .  '   .   .
  代码生成器运行一段时间后，会在控制台中输出一些总结信息。在本例中，生成器会在同一
    ，_    ，
目录中产生下列这些文件：    ”，”    ，
 , ./com/softwa rein c/plo老t e r/PlotSettjngs tj ava ,
. ./com/softwa reinc/plotte r/Plotter,j ava:     '
.  ./com/softwa rein c/plotte r/.Qtjambi_Lib ra rylni
^i  ~：：？
    ‘,：．
tializer.java
./cpp/com_softwa reinc_plotte r/com_softwa reinc_plotte r. p ri
./cpp/com_softwareinc_plotter/metainfo;.cpp .        ' . .
 ./cpp/com_softwa reinc_plotte r/metainfo . h
./cpp/com softwareinc plotter/qtj:ambi_libraryjnjtializer.cpp .
./cpp/com softwareinc_plotter/qtj'ambishell_PlotSettings.cpp '
,/cpp/com_softwa reinc_plotte r/qtjambishell  PlotSettings.h
./cpp/com_softwareinc_plotter/qtjambishell_Plotter.cpp   . '
 ./cp p/com_softwa reinc_plotte r/qtj ambishell_Plotte r . h                    .   !
    观在，必须同时编译Java和C++文件，但在这之前，必须确认
设置了。例如，如果使用Bash shell，可以这样做：
j o i一立
．  ：’r‘’jr―jj，：？：ji    ’
：t。：~  ．f，}l―
CLA $PA2'H,臻辘变量被正确地
t；．、亭粥0
j    。‘5j。。    一  -    :1  : .  ‘‘    ‘
    expo rt C LASSPATH=$CLASSPATH: $JAMBIPATH/qtj ambi.ja r:$PWD:$ PWD/.'.i  二．，一
    ：。‘．‘  0．A-．-  ．
    这里，使用Qt Jarnbi的.jar文件，并把当前目录以及当前目录的上层目录作为rC LASSPATH的
    。：-h．{．
扩展。需要上层目录是为了可以访问同级的com目录。Windows上的语法是：    ‘
    set   CLASSPATH=%CLASS PATH%; %JAMBIPATH%\qtj ambi;ja r;%CD%; %CDga\,,.，一．,    ‘.’’:_.,..1..j    ,’
现在就可以把．{ ava文件编译成
cd .'./com/softwareinc/plotter  '
javac *.java
．class文件：
：／-．  ？-：’：    ’，j j    7  ．．
    编译完.java文件，必须回到jambiplotter曰录。下一步是创建C++动态库，为-‘Plotter和PlotSet-
tings．提供C++代码，还有为生成器生成的C++打包代码。首先创建_AI．'pro文件：
-r.EMPLA-rE  .  = lib .:  .    .                                      .    . "
TARGET      = com softwareinc_plotter ..   r    . ,.    '  .r'    ::":  t ,   _;:.'  .  '
DLLDESTDIR   = .
HEADERS   . = ../plotter/plotter.h
SOURCES ' .   .  = ;./plotter/plotter.cpp
RESOURCES         =  . ./plotte r/plotte r,q rc
INCLUDEPATH += ../plotter \
              $$(JAMBIPATH)/include \
          .  $$(JAVA)/include
unix {
   INCLUDEPATH += $$(JAVA)/include/linux
win32 {. ,
   INCLUDEPATH += $$(JAVA)/include/win32
}
LIBS .   .  .    += -,-L$$(3AMBIPATH.)/lib -lqtjaaibi
    r    h．    r
include ( . ./cpp/com_softwa reitic_plotte r/com  so.ftwa reinc_plotter.; p r.i)    .:
    毖须把rIEMPJArIE变量设置为lib，因为我们想创建的是动态库‘，’而不是应用程序。TARGFr
变量可以指定Java包的名字，但使用下画线代替句点，DLLDESTDiR指定动态库（或’Dn）放置的位
C++ GUI Qt4编程（第二版）
置。INCLUDF,PATH变量必须包含源码目录（因其不在当前目录下）、Qt Jambi的包含路径、Java SDK
的包含路径和与Java SDK平台相关的包含路径。（附录B介绍了LUUX和wir/32的语法。）还需要把
Qt Jambi的库本身包含在LIBS项中。最后的include()目录用来访问生成的C++文件。一旦拥有
・pro文件，就可以运行qmake和make编译该库i
    既然拥有了动态库和配套的Java打包代码，我们就可以在应用程序中使用它们。Jambi Plotter
应用程序创建了PlotSettings和Plotter对象，利用它们显示一些随机数据。重要的是，我们可以把它
们像其他的Java或Qt Jambi类一样来使用。整个应用程序相当小，因而将会给出它的全部代码：
tt
tt
tt
tt
tt
tt
    QApplication.exec()；
    )
    )
    我们导入一对Java的标准库和Qt Jambi的库，以及PlotSettings和Plotter类。我们本来也可以
    i    f，’
简单地写成mport con\.softwareinc.plotter.*的形式。
    初始化QApplication财象后，创建了一个PlotSettings对象，并且为它设置了一些值。C++版本
的类，把lninX、maxX、minY和maxY作为公有变量。除非特别说明，Qt Jambi生成器会使用Qt的命
名规则[例如，minX()和setMinX()]为这类变量创建访问器。一旦完成绘图设置，就可以生成两组
曲线数据，每组包含100个随机点。在C++ tQr.中，每条曲线的点保存在QVector <QPointF>中；在
Qt Jambi中，将其保存在AnayList <QPointF>中，可以依赖Qt Jambi对其进行转换。
    设置完毕并且准备好数据后，我们就可以创建一个新的没有父对象的Plotter对象（使它成为
上层窗口）。然后设置plotter，导入曲线数据，调用show()显示绘图。最后，调用QApplication. exec()
启动事件循环。
    在编译应用程序时，不仅需要包含通常的CLASSPATH，还需包含com．softwareinc. plotter包的路
径。‘为了运行应用程序，必须设鼍几个额外的环境变量，以确保加载器可以找到Qt Jambi和那些
绑定。在Windows下，需要这样设置PATH环境变量：

    ：‘附录C  Qt Jambi简介    459
    _.-.____-_-――._.____一
    set PATH=~PATH%;%jAMBIPATH%＼bin;%CD%    “
    在UNIX上，必须这样设置LD_LIBRARY_PATH:
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$JAMBIPATH/lib:$PWD
    在Mac .OS X下，环境变量称为DYLD_ LIBRARY_ PATH。而且，在三个平台中，必须设置QT_
    PLUGIN_PATH，由其包含QJambi的插件目录。例如：
    set QT_PLUGIN_PATH=%QT_PLUGIN_PATH%;%jAMBIPATH%＼plugins.
    要想在所有平台上编译和运行Jambi Plotter，有了CIASSPATH的设置后，只需简单输入：
    javac JambiPlotter.java
    】ava JambiPlotter
    现在，我们就完成了这个例子，并且介绍了如何在Qt Jambi应用程序中使用C++组件。事实
  上，Qt Jambi生成器是Jav'a使用C++组件的基础，提供了许多的特性，前面的只是简单介绍。尽管
  生成器只支持C++的一个子集，该子集包括历有最常用的C++结构，包括多重继承和操作符重
  载。生成器的完整文档可以参阅http：//doc．trolltech．com/qtj ambi-43.2―01/com/trolltech/qt/qtj ambi-
  generato．．html。我们将简要地介绍本例中未涉及的那些特性，以便帮你了解都有哪些内容。‘
    影响生成器工作方式的关键是XML文件的内容。例如，对于C++中的多重继承，在Jambi中
    可以定义一个类作为“对象类型”或“值类型”，把其他的定义成“接口类型”一
    ．  可以提供更多的方法签名。例如，除了使用AnayList <QPointF>保存曲线上的点，1使用QPointF
    数组会更好一些。这包括隐藏原有的C++方法，使用Java方法替代，接收jQPoimP[]，以及在后台
    调用原始的C++方法等。可以通过修改jambiplotter.xml文件来做到达孚赢。起初，我们是利用类
    似于下面这样来定义C++的Plotter类型的：
我们将使用一个更复杂的版本来代替前面那行：
    <object-type name="Plotter">,
    <modify-function
    sigrIatu广e=‘’setCu广veData(int,const QVector＆lt;QPointF＆gt;＆amp;)“>
    <aCCeSS mOdifier=“口riVate”／>
・    <广ename to=“setcun,eData―p广iVate“／>
    <／modify―function>
    <inj ect―code>
    Dublic final Void setCu广VeData(int id,
    com.t广olltech.qt.co广e.QPointF points【】){
    setCurveData―p广j.vate(id,j aVa.utiLArrays.asList(points));
    '
    <／inj ect―code>
    (／obj ect―type>
    在(mod母・如1ction>元素中，我们把C++的setCunreData()方法重命名为setCur、，eData_pIiVate()，
  并修改其访问权限为私有，从而防止类以外方法的访问。值得注意的是，必须避免在signature属
  性中使用那些Ⅻ几的特殊字符“<”、“>”和“&，’。
    在<inject．code>元素中，在kra中实现了自定义的setCunreDa诅()方法。该方法接收QP衍n蚓：]
  参数，简卑地调用setCuⅣeDa吐皿vate()方法，把数组转换为C++的列表。
    现在，可以用更自然的方式来创建和保存QPoin小数组：
    QPointF[] points0=new
    QPointF[I pointsl=new
    for (int x=O；x<numP
    ,pointsOLxJ=new QPo
    pointsl[x]=new QPo
    }
余下的代码与以前的相同。
[numPo
[numPo
Math.
Math,
\n \n   -o o
IJ IJ   C C
c C   ro ro
._l rl    L L
tt .- x x
C C cn((
 _l .,-t IJ U- LL
o o C IJ IJ
01- 01- _1, C C
a o o .,-t rl
C++ GUI Qt4编程（第二版）
    有时，在打包类时，生成器会使用QNativePointer产生代码。该类型是C++“值类型”指针的打
包器，指针和数组都是可用的。文件mjb_nativepointer_api.log列举了那些使用QNativePointer生成的
代码。Qt J锄bi文档建议替换所有使用了QNatiyePointer的代码，并且提供了如何替换的具体步骤。
    有时需要在生成的.java文件中包含二些额外的；unpO/t声明。通过使用<extra-includes>．标签，
可以很轻松地实现这一点，并且在http：//doc．Golitech. com/qtjambl-4.3. 2_Ol/com/trolltech  7qU qtjambi-
typesystem. html中给出了完整的介绍。    ，：。
    Qt Jambi生成器是一个强大的通用工具，使Java程序员可以使用C++ tQt的类，可以在单一工
程中结合C++和Java的长处。  ．

